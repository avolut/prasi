"use strict";
(() => {
  var __create = Object.create;
  var __defProp = Object.defineProperty;
  var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
  var __getOwnPropNames = Object.getOwnPropertyNames;
  var __getProtoOf = Object.getPrototypeOf;
  var __hasOwnProp = Object.prototype.hasOwnProperty;
  var __require = /* @__PURE__ */ ((x) => typeof require !== "undefined" ? require : typeof Proxy !== "undefined" ? new Proxy(x, {
    get: (a, b) => (typeof require !== "undefined" ? require : a)[b]
  }) : x)(function(x) {
    if (typeof require !== "undefined")
      return require.apply(this, arguments);
    throw Error('Dynamic require of "' + x + '" is not supported');
  });
  var __esm = (fn, res) => function __init() {
    return fn && (res = (0, fn[__getOwnPropNames(fn)[0]])(fn = 0)), res;
  };
  var __commonJS = (cb, mod) => function __require2() {
    return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
  };
  var __export = (target, all) => {
    for (var name in all)
      __defProp(target, name, { get: all[name], enumerable: true });
  };
  var __copyProps = (to, from, except, desc) => {
    if (from && typeof from === "object" || typeof from === "function") {
      for (let key of __getOwnPropNames(from))
        if (!__hasOwnProp.call(to, key) && key !== except)
          __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
    }
    return to;
  };
  var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
    // If the importer is in node compatibility mode or this is not an ESM
    // file that has been converted to a CommonJS file using a Babel-
    // compatible transform (i.e. "__esModule" has not been set), then set
    // "default" to the CommonJS "module.exports" for node compatibility.
    isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
    mod
  ));

  // node_modules/.pnpm/command-exists@1.2.9/node_modules/command-exists/lib/command-exists.js
  var require_command_exists = __commonJS({
    "node_modules/.pnpm/command-exists@1.2.9/node_modules/command-exists/lib/command-exists.js"(exports2, module2) {
      "use strict";
      var exec = __require("child_process").exec;
      var execSync = __require("child_process").execSync;
      var fs2 = __require("fs");
      var path4 = __require("path");
      var access = fs2.access;
      var accessSync = fs2.accessSync;
      var constants3 = fs2.constants || fs2;
      var isUsingWindows = process.platform == "win32";
      var fileNotExists = function(commandName, callback) {
        access(
          commandName,
          constants3.F_OK,
          function(err2) {
            callback(!err2);
          }
        );
      };
      var fileNotExistsSync = function(commandName) {
        try {
          accessSync(commandName, constants3.F_OK);
          return false;
        } catch (e) {
          return true;
        }
      };
      var localExecutable = function(commandName, callback) {
        access(
          commandName,
          constants3.F_OK | constants3.X_OK,
          function(err2) {
            callback(null, !err2);
          }
        );
      };
      var localExecutableSync = function(commandName) {
        try {
          accessSync(commandName, constants3.F_OK | constants3.X_OK);
          return true;
        } catch (e) {
          return false;
        }
      };
      var commandExistsUnix = function(commandName, cleanedCommandName, callback) {
        fileNotExists(commandName, function(isFile) {
          if (!isFile) {
            var child = exec(
              "command -v " + cleanedCommandName + " 2>/dev/null && { echo >&1 " + cleanedCommandName + "; exit 0; }",
              function(error, stdout, stderr) {
                callback(null, !!stdout);
              }
            );
            return;
          }
          localExecutable(commandName, callback);
        });
      };
      var commandExistsWindows = function(commandName, cleanedCommandName, callback) {
        if (!/^(?!(?:.*\s|.*\.|\W+)$)(?:[a-zA-Z]:)?(?:(?:[^<>:"\|\?\*\n])+(?:\/\/|\/|\\\\|\\)?)+$/m.test(commandName)) {
          callback(null, false);
          return;
        }
        var child = exec(
          "where " + cleanedCommandName,
          function(error) {
            if (error !== null) {
              callback(null, false);
            } else {
              callback(null, true);
            }
          }
        );
      };
      var commandExistsUnixSync = function(commandName, cleanedCommandName) {
        if (fileNotExistsSync(commandName)) {
          try {
            var stdout = execSync(
              "command -v " + cleanedCommandName + " 2>/dev/null && { echo >&1 " + cleanedCommandName + "; exit 0; }"
            );
            return !!stdout;
          } catch (error) {
            return false;
          }
        }
        return localExecutableSync(commandName);
      };
      var commandExistsWindowsSync = function(commandName, cleanedCommandName, callback) {
        if (!/^(?!(?:.*\s|.*\.|\W+)$)(?:[a-zA-Z]:)?(?:(?:[^<>:"\|\?\*\n])+(?:\/\/|\/|\\\\|\\)?)+$/m.test(commandName)) {
          return false;
        }
        try {
          var stdout = execSync("where " + cleanedCommandName, { stdio: [] });
          return !!stdout;
        } catch (error) {
          return false;
        }
      };
      var cleanInput = function(s) {
        if (/[^A-Za-z0-9_\/:=-]/.test(s)) {
          s = "'" + s.replace(/'/g, "'\\''") + "'";
          s = s.replace(/^(?:'')+/g, "").replace(/\\'''/g, "\\'");
        }
        return s;
      };
      if (isUsingWindows) {
        cleanInput = function(s) {
          var isPathName = /[\\]/.test(s);
          if (isPathName) {
            var dirname8 = '"' + path4.dirname(s) + '"';
            var basename6 = '"' + path4.basename(s) + '"';
            return dirname8 + ":" + basename6;
          }
          return '"' + s + '"';
        };
      }
      module2.exports = function commandExists2(commandName, callback) {
        var cleanedCommandName = cleanInput(commandName);
        if (!callback && typeof Promise !== "undefined") {
          return new Promise(function(resolve, reject) {
            commandExists2(commandName, function(error, output) {
              if (output) {
                resolve(commandName);
              } else {
                reject(error);
              }
            });
          });
        }
        if (isUsingWindows) {
          commandExistsWindows(commandName, cleanedCommandName, callback);
        } else {
          commandExistsUnix(commandName, cleanedCommandName, callback);
        }
      };
      module2.exports.sync = function(commandName) {
        var cleanedCommandName = cleanInput(commandName);
        if (isUsingWindows) {
          return commandExistsWindowsSync(commandName, cleanedCommandName);
        } else {
          return commandExistsUnixSync(commandName, cleanedCommandName);
        }
      };
    }
  });

  // node_modules/.pnpm/command-exists@1.2.9/node_modules/command-exists/index.js
  var require_command_exists2 = __commonJS({
    "node_modules/.pnpm/command-exists@1.2.9/node_modules/command-exists/index.js"(exports2, module2) {
      module2.exports = require_command_exists();
    }
  });

  // pkgs/base/pkgs/dir/export.ts
  var import_fs2, import_path, import_process, globalize, dir;
  var init_export = __esm({
    "pkgs/base/pkgs/dir/export.ts"() {
      import_fs2 = __require("fs");
      import_path = __require("path");
      import_process = __require("process");
      globalize = (arg) => {
        const { name, init } = arg;
        const g4 = global;
        if (typeof g4[name] === "undefined") {
          g4[name] = arg.value;
        }
        g4[name].init = async () => {
          if (init) {
            await init(g4[name]);
          }
        };
        return g4[name];
      };
      dir = new Proxy(
        {},
        {
          get(_target, p) {
            if (p === "path") {
              return (arg = "") => {
                return (0, import_path.join)(process.cwd(), ...(arg || "").split("/"));
              };
            }
            if (p === "root") {
              return (arg = "") => {
                if ((0, import_fs2.existsSync)((0, import_path.join)((0, import_process.cwd)(), "base"))) {
                  return (0, import_path.join)(process.cwd(), ...arg.split("/"));
                }
                return (0, import_path.join)(process.cwd(), "..", "..", ...arg.split("/"));
              };
            }
          }
        }
      );
    }
  });

  // node_modules/.pnpm/fs-jetpack@5.1.0/node_modules/fs-jetpack/lib/utils/promisify.js
  var require_promisify = __commonJS({
    "node_modules/.pnpm/fs-jetpack@5.1.0/node_modules/fs-jetpack/lib/utils/promisify.js"(exports2, module2) {
      "use strict";
      module2.exports = (fn) => {
        return function() {
          const length = arguments.length;
          const args2 = new Array(length);
          for (let i = 0; i < length; i += 1) {
            args2[i] = arguments[i];
          }
          return new Promise((resolve, reject) => {
            args2.push((err2, data) => {
              if (err2) {
                reject(err2);
              } else {
                resolve(data);
              }
            });
            fn.apply(null, args2);
          });
        };
      };
    }
  });

  // node_modules/.pnpm/fs-jetpack@5.1.0/node_modules/fs-jetpack/lib/utils/fs.js
  var require_fs = __commonJS({
    "node_modules/.pnpm/fs-jetpack@5.1.0/node_modules/fs-jetpack/lib/utils/fs.js"(exports2, module2) {
      "use strict";
      var fs2 = __require("fs");
      var promisify = require_promisify();
      var isCallbackMethod = (key) => {
        return [
          typeof fs2[key] === "function",
          !key.match(/Sync$/),
          !key.match(/^[A-Z]/),
          !key.match(/^create/),
          !key.match(/^(un)?watch/)
        ].every(Boolean);
      };
      var adaptMethod = (name) => {
        const original = fs2[name];
        return promisify(original);
      };
      var adaptAllMethods = () => {
        const adapted = {};
        Object.keys(fs2).forEach((key) => {
          if (isCallbackMethod(key)) {
            if (key === "exists") {
              adapted.exists = () => {
                throw new Error("fs.exists() is deprecated");
              };
            } else {
              adapted[key] = adaptMethod(key);
            }
          } else {
            adapted[key] = fs2[key];
          }
        });
        return adapted;
      };
      module2.exports = adaptAllMethods();
    }
  });

  // node_modules/.pnpm/fs-jetpack@5.1.0/node_modules/fs-jetpack/lib/utils/validate.js
  var require_validate = __commonJS({
    "node_modules/.pnpm/fs-jetpack@5.1.0/node_modules/fs-jetpack/lib/utils/validate.js"(exports2, module2) {
      "use strict";
      var prettyPrintTypes = (types) => {
        const addArticle = (str) => {
          const vowels = ["a", "e", "i", "o", "u"];
          if (vowels.indexOf(str[0]) !== -1) {
            return `an ${str}`;
          }
          return `a ${str}`;
        };
        return types.map(addArticle).join(" or ");
      };
      var isArrayOfNotation = (typeDefinition) => {
        return /array of /.test(typeDefinition);
      };
      var extractTypeFromArrayOfNotation = (typeDefinition) => {
        return typeDefinition.split(" of ")[1];
      };
      var isValidTypeDefinition = (typeStr) => {
        if (isArrayOfNotation(typeStr)) {
          return isValidTypeDefinition(extractTypeFromArrayOfNotation(typeStr));
        }
        return [
          "string",
          "number",
          "boolean",
          "array",
          "object",
          "buffer",
          "null",
          "undefined",
          "function"
        ].some((validType) => {
          return validType === typeStr;
        });
      };
      var detectType = (value) => {
        if (value === null) {
          return "null";
        }
        if (Array.isArray(value)) {
          return "array";
        }
        if (Buffer.isBuffer(value)) {
          return "buffer";
        }
        return typeof value;
      };
      var onlyUniqueValuesInArrayFilter = (value, index, self2) => {
        return self2.indexOf(value) === index;
      };
      var detectTypeDeep = (value) => {
        let type = detectType(value);
        let typesInArray;
        if (type === "array") {
          typesInArray = value.map((element) => {
            return detectType(element);
          }).filter(onlyUniqueValuesInArrayFilter);
          type += ` of ${typesInArray.join(", ")}`;
        }
        return type;
      };
      var validateArray = (argumentValue, typeToCheck) => {
        const allowedTypeInArray = extractTypeFromArrayOfNotation(typeToCheck);
        if (detectType(argumentValue) !== "array") {
          return false;
        }
        return argumentValue.every((element) => {
          return detectType(element) === allowedTypeInArray;
        });
      };
      var validateArgument = (methodName, argumentName, argumentValue, argumentMustBe) => {
        const isOneOfAllowedTypes = argumentMustBe.some((type) => {
          if (!isValidTypeDefinition(type)) {
            throw new Error(`Unknown type "${type}"`);
          }
          if (isArrayOfNotation(type)) {
            return validateArray(argumentValue, type);
          }
          return type === detectType(argumentValue);
        });
        if (!isOneOfAllowedTypes) {
          throw new Error(
            `Argument "${argumentName}" passed to ${methodName} must be ${prettyPrintTypes(
              argumentMustBe
            )}. Received ${detectTypeDeep(argumentValue)}`
          );
        }
      };
      var validateOptions = (methodName, optionsObjName, obj, allowedOptions) => {
        if (obj !== void 0) {
          validateArgument(methodName, optionsObjName, obj, ["object"]);
          Object.keys(obj).forEach((key) => {
            const argName = `${optionsObjName}.${key}`;
            if (allowedOptions[key] !== void 0) {
              validateArgument(methodName, argName, obj[key], allowedOptions[key]);
            } else {
              throw new Error(
                `Unknown argument "${argName}" passed to ${methodName}`
              );
            }
          });
        }
      };
      module2.exports = {
        argument: validateArgument,
        options: validateOptions
      };
    }
  });

  // node_modules/.pnpm/fs-jetpack@5.1.0/node_modules/fs-jetpack/lib/utils/mode.js
  var require_mode = __commonJS({
    "node_modules/.pnpm/fs-jetpack@5.1.0/node_modules/fs-jetpack/lib/utils/mode.js"(exports2) {
      "use strict";
      exports2.normalizeFileMode = (mode) => {
        let modeAsString;
        if (typeof mode === "number") {
          modeAsString = mode.toString(8);
        } else {
          modeAsString = mode;
        }
        return modeAsString.substring(modeAsString.length - 3);
      };
    }
  });

  // node_modules/.pnpm/fs-jetpack@5.1.0/node_modules/fs-jetpack/lib/remove.js
  var require_remove = __commonJS({
    "node_modules/.pnpm/fs-jetpack@5.1.0/node_modules/fs-jetpack/lib/remove.js"(exports2) {
      "use strict";
      var fs2 = require_fs();
      var validate = require_validate();
      var validateInput = (methodName, path4) => {
        const methodSignature = `${methodName}([path])`;
        validate.argument(methodSignature, "path", path4, ["string", "undefined"]);
      };
      var removeSync = (path4) => {
        fs2.rmSync(path4, {
          recursive: true,
          force: true,
          maxRetries: 3
        });
      };
      var removeAsync11 = (path4) => {
        return fs2.rm(path4, {
          recursive: true,
          force: true,
          maxRetries: 3
        });
      };
      exports2.validateInput = validateInput;
      exports2.sync = removeSync;
      exports2.async = removeAsync11;
    }
  });

  // node_modules/.pnpm/fs-jetpack@5.1.0/node_modules/fs-jetpack/lib/dir.js
  var require_dir = __commonJS({
    "node_modules/.pnpm/fs-jetpack@5.1.0/node_modules/fs-jetpack/lib/dir.js"(exports2) {
      "use strict";
      var pathUtil = __require("path");
      var fs2 = require_fs();
      var modeUtil = require_mode();
      var validate = require_validate();
      var remove = require_remove();
      var validateInput = (methodName, path4, criteria) => {
        const methodSignature = `${methodName}(path, [criteria])`;
        validate.argument(methodSignature, "path", path4, ["string"]);
        validate.options(methodSignature, "criteria", criteria, {
          empty: ["boolean"],
          mode: ["string", "number"]
        });
      };
      var getCriteriaDefaults = (passedCriteria) => {
        const criteria = passedCriteria || {};
        if (typeof criteria.empty !== "boolean") {
          criteria.empty = false;
        }
        if (criteria.mode !== void 0) {
          criteria.mode = modeUtil.normalizeFileMode(criteria.mode);
        }
        return criteria;
      };
      var generatePathOccupiedByNotDirectoryError = (path4) => {
        return new Error(
          `Path ${path4} exists but is not a directory. Halting jetpack.dir() call for safety reasons.`
        );
      };
      var checkWhatAlreadyOccupiesPathSync = (path4) => {
        let stat6;
        try {
          stat6 = fs2.statSync(path4);
        } catch (err2) {
          if (err2.code !== "ENOENT") {
            throw err2;
          }
        }
        if (stat6 && !stat6.isDirectory()) {
          throw generatePathOccupiedByNotDirectoryError(path4);
        }
        return stat6;
      };
      var createBrandNewDirectorySync = (path4, opts) => {
        const options = opts || {};
        try {
          fs2.mkdirSync(path4, options.mode);
        } catch (err2) {
          if (err2.code === "ENOENT") {
            createBrandNewDirectorySync(pathUtil.dirname(path4), options);
            fs2.mkdirSync(path4, options.mode);
          } else if (err2.code === "EEXIST") {
          } else {
            throw err2;
          }
        }
      };
      var checkExistingDirectoryFulfillsCriteriaSync = (path4, stat6, criteria) => {
        const checkMode = () => {
          const mode = modeUtil.normalizeFileMode(stat6.mode);
          if (criteria.mode !== void 0 && criteria.mode !== mode) {
            fs2.chmodSync(path4, criteria.mode);
          }
        };
        const checkEmptiness = () => {
          if (criteria.empty) {
            const list = fs2.readdirSync(path4);
            list.forEach((filename) => {
              remove.sync(pathUtil.resolve(path4, filename));
            });
          }
        };
        checkMode();
        checkEmptiness();
      };
      var dirSync = (path4, passedCriteria) => {
        const criteria = getCriteriaDefaults(passedCriteria);
        const stat6 = checkWhatAlreadyOccupiesPathSync(path4);
        if (stat6) {
          checkExistingDirectoryFulfillsCriteriaSync(path4, stat6, criteria);
        } else {
          createBrandNewDirectorySync(path4, criteria);
        }
      };
      var checkWhatAlreadyOccupiesPathAsync = (path4) => {
        return new Promise((resolve, reject) => {
          fs2.stat(path4).then((stat6) => {
            if (stat6.isDirectory()) {
              resolve(stat6);
            } else {
              reject(generatePathOccupiedByNotDirectoryError(path4));
            }
          }).catch((err2) => {
            if (err2.code === "ENOENT") {
              resolve(void 0);
            } else {
              reject(err2);
            }
          });
        });
      };
      var emptyAsync = (path4) => {
        return new Promise((resolve, reject) => {
          fs2.readdir(path4).then((list) => {
            const doOne = (index) => {
              if (index === list.length) {
                resolve();
              } else {
                const subPath = pathUtil.resolve(path4, list[index]);
                remove.async(subPath).then(() => {
                  doOne(index + 1);
                });
              }
            };
            doOne(0);
          }).catch(reject);
        });
      };
      var checkExistingDirectoryFulfillsCriteriaAsync = (path4, stat6, criteria) => {
        return new Promise((resolve, reject) => {
          const checkMode = () => {
            const mode = modeUtil.normalizeFileMode(stat6.mode);
            if (criteria.mode !== void 0 && criteria.mode !== mode) {
              return fs2.chmod(path4, criteria.mode);
            }
            return Promise.resolve();
          };
          const checkEmptiness = () => {
            if (criteria.empty) {
              return emptyAsync(path4);
            }
            return Promise.resolve();
          };
          checkMode().then(checkEmptiness).then(resolve, reject);
        });
      };
      var createBrandNewDirectoryAsync = (path4, opts) => {
        const options = opts || {};
        return new Promise((resolve, reject) => {
          fs2.mkdir(path4, options.mode).then(resolve).catch((err2) => {
            if (err2.code === "ENOENT") {
              createBrandNewDirectoryAsync(pathUtil.dirname(path4), options).then(() => {
                return fs2.mkdir(path4, options.mode);
              }).then(resolve).catch((err22) => {
                if (err22.code === "EEXIST") {
                  resolve();
                } else {
                  reject(err22);
                }
              });
            } else if (err2.code === "EEXIST") {
              resolve();
            } else {
              reject(err2);
            }
          });
        });
      };
      var dirAsync4 = (path4, passedCriteria) => {
        return new Promise((resolve, reject) => {
          const criteria = getCriteriaDefaults(passedCriteria);
          checkWhatAlreadyOccupiesPathAsync(path4).then((stat6) => {
            if (stat6 !== void 0) {
              return checkExistingDirectoryFulfillsCriteriaAsync(
                path4,
                stat6,
                criteria
              );
            }
            return createBrandNewDirectoryAsync(path4, criteria);
          }).then(resolve, reject);
        });
      };
      exports2.validateInput = validateInput;
      exports2.sync = dirSync;
      exports2.createSync = createBrandNewDirectorySync;
      exports2.async = dirAsync4;
      exports2.createAsync = createBrandNewDirectoryAsync;
    }
  });

  // node_modules/.pnpm/fs-jetpack@5.1.0/node_modules/fs-jetpack/lib/write.js
  var require_write = __commonJS({
    "node_modules/.pnpm/fs-jetpack@5.1.0/node_modules/fs-jetpack/lib/write.js"(exports2) {
      "use strict";
      var pathUtil = __require("path");
      var fs2 = require_fs();
      var validate = require_validate();
      var dir2 = require_dir();
      var validateInput = (methodName, path4, data, options) => {
        const methodSignature = `${methodName}(path, data, [options])`;
        validate.argument(methodSignature, "path", path4, ["string"]);
        validate.argument(methodSignature, "data", data, [
          "string",
          "buffer",
          "object",
          "array"
        ]);
        validate.options(methodSignature, "options", options, {
          mode: ["string", "number"],
          atomic: ["boolean"],
          jsonIndent: ["number"]
        });
      };
      var newExt = ".__new__";
      var serializeToJsonMaybe = (data, jsonIndent) => {
        let indent = jsonIndent;
        if (typeof indent !== "number") {
          indent = 2;
        }
        if (typeof data === "object" && !Buffer.isBuffer(data) && data !== null) {
          return JSON.stringify(data, null, indent);
        }
        return data;
      };
      var writeFileSync2 = (path4, data, options) => {
        try {
          fs2.writeFileSync(path4, data, options);
        } catch (err2) {
          if (err2.code === "ENOENT") {
            dir2.createSync(pathUtil.dirname(path4));
            fs2.writeFileSync(path4, data, options);
          } else {
            throw err2;
          }
        }
      };
      var writeAtomicSync = (path4, data, options) => {
        writeFileSync2(path4 + newExt, data, options);
        fs2.renameSync(path4 + newExt, path4);
      };
      var writeSync = (path4, data, options) => {
        const opts = options || {};
        const processedData = serializeToJsonMaybe(data, opts.jsonIndent);
        let writeStrategy = writeFileSync2;
        if (opts.atomic) {
          writeStrategy = writeAtomicSync;
        }
        writeStrategy(path4, processedData, { mode: opts.mode });
      };
      var writeFileAsync = (path4, data, options) => {
        return new Promise((resolve, reject) => {
          fs2.writeFile(path4, data, options).then(resolve).catch((err2) => {
            if (err2.code === "ENOENT") {
              dir2.createAsync(pathUtil.dirname(path4)).then(() => {
                return fs2.writeFile(path4, data, options);
              }).then(resolve, reject);
            } else {
              reject(err2);
            }
          });
        });
      };
      var writeAtomicAsync = (path4, data, options) => {
        return new Promise((resolve, reject) => {
          writeFileAsync(path4 + newExt, data, options).then(() => {
            return fs2.rename(path4 + newExt, path4);
          }).then(resolve, reject);
        });
      };
      var writeAsync19 = (path4, data, options) => {
        const opts = options || {};
        const processedData = serializeToJsonMaybe(data, opts.jsonIndent);
        let writeStrategy = writeFileAsync;
        if (opts.atomic) {
          writeStrategy = writeAtomicAsync;
        }
        return writeStrategy(path4, processedData, { mode: opts.mode });
      };
      exports2.validateInput = validateInput;
      exports2.sync = writeSync;
      exports2.async = writeAsync19;
    }
  });

  // node_modules/.pnpm/fs-jetpack@5.1.0/node_modules/fs-jetpack/lib/append.js
  var require_append = __commonJS({
    "node_modules/.pnpm/fs-jetpack@5.1.0/node_modules/fs-jetpack/lib/append.js"(exports2) {
      "use strict";
      var fs2 = require_fs();
      var write = require_write();
      var validate = require_validate();
      var validateInput = (methodName, path4, data, options) => {
        const methodSignature = `${methodName}(path, data, [options])`;
        validate.argument(methodSignature, "path", path4, ["string"]);
        validate.argument(methodSignature, "data", data, ["string", "buffer"]);
        validate.options(methodSignature, "options", options, {
          mode: ["string", "number"]
        });
      };
      var appendSync = (path4, data, options) => {
        try {
          fs2.appendFileSync(path4, data, options);
        } catch (err2) {
          if (err2.code === "ENOENT") {
            write.sync(path4, data, options);
          } else {
            throw err2;
          }
        }
      };
      var appendAsync = (path4, data, options) => {
        return new Promise((resolve, reject) => {
          fs2.appendFile(path4, data, options).then(resolve).catch((err2) => {
            if (err2.code === "ENOENT") {
              write.async(path4, data, options).then(resolve, reject);
            } else {
              reject(err2);
            }
          });
        });
      };
      exports2.validateInput = validateInput;
      exports2.sync = appendSync;
      exports2.async = appendAsync;
    }
  });

  // node_modules/.pnpm/fs-jetpack@5.1.0/node_modules/fs-jetpack/lib/file.js
  var require_file = __commonJS({
    "node_modules/.pnpm/fs-jetpack@5.1.0/node_modules/fs-jetpack/lib/file.js"(exports2) {
      "use strict";
      var fs2 = require_fs();
      var modeUtil = require_mode();
      var validate = require_validate();
      var write = require_write();
      var validateInput = (methodName, path4, criteria) => {
        const methodSignature = `${methodName}(path, [criteria])`;
        validate.argument(methodSignature, "path", path4, ["string"]);
        validate.options(methodSignature, "criteria", criteria, {
          content: ["string", "buffer", "object", "array"],
          jsonIndent: ["number"],
          mode: ["string", "number"]
        });
      };
      var getCriteriaDefaults = (passedCriteria) => {
        const criteria = passedCriteria || {};
        if (criteria.mode !== void 0) {
          criteria.mode = modeUtil.normalizeFileMode(criteria.mode);
        }
        return criteria;
      };
      var generatePathOccupiedByNotFileError = (path4) => {
        return new Error(
          `Path ${path4} exists but is not a file. Halting jetpack.file() call for safety reasons.`
        );
      };
      var checkWhatAlreadyOccupiesPathSync = (path4) => {
        let stat6;
        try {
          stat6 = fs2.statSync(path4);
        } catch (err2) {
          if (err2.code !== "ENOENT") {
            throw err2;
          }
        }
        if (stat6 && !stat6.isFile()) {
          throw generatePathOccupiedByNotFileError(path4);
        }
        return stat6;
      };
      var checkExistingFileFulfillsCriteriaSync = (path4, stat6, criteria) => {
        const mode = modeUtil.normalizeFileMode(stat6.mode);
        const checkContent = () => {
          if (criteria.content !== void 0) {
            write.sync(path4, criteria.content, {
              mode,
              jsonIndent: criteria.jsonIndent
            });
            return true;
          }
          return false;
        };
        const checkMode = () => {
          if (criteria.mode !== void 0 && criteria.mode !== mode) {
            fs2.chmodSync(path4, criteria.mode);
          }
        };
        const contentReplaced = checkContent();
        if (!contentReplaced) {
          checkMode();
        }
      };
      var createBrandNewFileSync = (path4, criteria) => {
        let content = "";
        if (criteria.content !== void 0) {
          content = criteria.content;
        }
        write.sync(path4, content, {
          mode: criteria.mode,
          jsonIndent: criteria.jsonIndent
        });
      };
      var fileSync = (path4, passedCriteria) => {
        const criteria = getCriteriaDefaults(passedCriteria);
        const stat6 = checkWhatAlreadyOccupiesPathSync(path4);
        if (stat6 !== void 0) {
          checkExistingFileFulfillsCriteriaSync(path4, stat6, criteria);
        } else {
          createBrandNewFileSync(path4, criteria);
        }
      };
      var checkWhatAlreadyOccupiesPathAsync = (path4) => {
        return new Promise((resolve, reject) => {
          fs2.stat(path4).then((stat6) => {
            if (stat6.isFile()) {
              resolve(stat6);
            } else {
              reject(generatePathOccupiedByNotFileError(path4));
            }
          }).catch((err2) => {
            if (err2.code === "ENOENT") {
              resolve(void 0);
            } else {
              reject(err2);
            }
          });
        });
      };
      var checkExistingFileFulfillsCriteriaAsync = (path4, stat6, criteria) => {
        const mode = modeUtil.normalizeFileMode(stat6.mode);
        const checkContent = () => {
          return new Promise((resolve, reject) => {
            if (criteria.content !== void 0) {
              write.async(path4, criteria.content, {
                mode,
                jsonIndent: criteria.jsonIndent
              }).then(() => {
                resolve(true);
              }).catch(reject);
            } else {
              resolve(false);
            }
          });
        };
        const checkMode = () => {
          if (criteria.mode !== void 0 && criteria.mode !== mode) {
            return fs2.chmod(path4, criteria.mode);
          }
          return void 0;
        };
        return checkContent().then((contentReplaced) => {
          if (!contentReplaced) {
            return checkMode();
          }
          return void 0;
        });
      };
      var createBrandNewFileAsync = (path4, criteria) => {
        let content = "";
        if (criteria.content !== void 0) {
          content = criteria.content;
        }
        return write.async(path4, content, {
          mode: criteria.mode,
          jsonIndent: criteria.jsonIndent
        });
      };
      var fileAsync = (path4, passedCriteria) => {
        return new Promise((resolve, reject) => {
          const criteria = getCriteriaDefaults(passedCriteria);
          checkWhatAlreadyOccupiesPathAsync(path4).then((stat6) => {
            if (stat6 !== void 0) {
              return checkExistingFileFulfillsCriteriaAsync(path4, stat6, criteria);
            }
            return createBrandNewFileAsync(path4, criteria);
          }).then(resolve, reject);
        });
      };
      exports2.validateInput = validateInput;
      exports2.sync = fileSync;
      exports2.async = fileAsync;
    }
  });

  // node_modules/.pnpm/fs-jetpack@5.1.0/node_modules/fs-jetpack/lib/inspect.js
  var require_inspect = __commonJS({
    "node_modules/.pnpm/fs-jetpack@5.1.0/node_modules/fs-jetpack/lib/inspect.js"(exports2) {
      "use strict";
      var crypto = __require("crypto");
      var pathUtil = __require("path");
      var fs2 = require_fs();
      var validate = require_validate();
      var supportedChecksumAlgorithms = ["md5", "sha1", "sha256", "sha512"];
      var symlinkOptions = ["report", "follow"];
      var validateInput = (methodName, path4, options) => {
        const methodSignature = `${methodName}(path, [options])`;
        validate.argument(methodSignature, "path", path4, ["string"]);
        validate.options(methodSignature, "options", options, {
          checksum: ["string"],
          mode: ["boolean"],
          times: ["boolean"],
          absolutePath: ["boolean"],
          symlinks: ["string"]
        });
        if (options && options.checksum !== void 0 && supportedChecksumAlgorithms.indexOf(options.checksum) === -1) {
          throw new Error(
            `Argument "options.checksum" passed to ${methodSignature} must have one of values: ${supportedChecksumAlgorithms.join(
              ", "
            )}`
          );
        }
        if (options && options.symlinks !== void 0 && symlinkOptions.indexOf(options.symlinks) === -1) {
          throw new Error(
            `Argument "options.symlinks" passed to ${methodSignature} must have one of values: ${symlinkOptions.join(
              ", "
            )}`
          );
        }
      };
      var createInspectObj = (path4, options, stat6) => {
        const obj = {};
        obj.name = pathUtil.basename(path4);
        if (stat6.isFile()) {
          obj.type = "file";
          obj.size = stat6.size;
        } else if (stat6.isDirectory()) {
          obj.type = "dir";
        } else if (stat6.isSymbolicLink()) {
          obj.type = "symlink";
        } else {
          obj.type = "other";
        }
        if (options.mode) {
          obj.mode = stat6.mode;
        }
        if (options.times) {
          obj.accessTime = stat6.atime;
          obj.modifyTime = stat6.mtime;
          obj.changeTime = stat6.ctime;
          obj.birthTime = stat6.birthtime;
        }
        if (options.absolutePath) {
          obj.absolutePath = path4;
        }
        return obj;
      };
      var fileChecksum = (path4, algo) => {
        const hash = crypto.createHash(algo);
        const data = fs2.readFileSync(path4);
        hash.update(data);
        return hash.digest("hex");
      };
      var addExtraFieldsSync = (path4, inspectObj, options) => {
        if (inspectObj.type === "file" && options.checksum) {
          inspectObj[options.checksum] = fileChecksum(path4, options.checksum);
        } else if (inspectObj.type === "symlink") {
          inspectObj.pointsAt = fs2.readlinkSync(path4);
        }
      };
      var inspectSync = (path4, options) => {
        let statOperation = fs2.lstatSync;
        let stat6;
        const opts = options || {};
        if (opts.symlinks === "follow") {
          statOperation = fs2.statSync;
        }
        try {
          stat6 = statOperation(path4);
        } catch (err2) {
          if (err2.code === "ENOENT") {
            return void 0;
          }
          throw err2;
        }
        const inspectObj = createInspectObj(path4, opts, stat6);
        addExtraFieldsSync(path4, inspectObj, opts);
        return inspectObj;
      };
      var fileChecksumAsync = (path4, algo) => {
        return new Promise((resolve, reject) => {
          const hash = crypto.createHash(algo);
          const s = fs2.createReadStream(path4);
          s.on("data", (data) => {
            hash.update(data);
          });
          s.on("end", () => {
            resolve(hash.digest("hex"));
          });
          s.on("error", reject);
        });
      };
      var addExtraFieldsAsync = (path4, inspectObj, options) => {
        if (inspectObj.type === "file" && options.checksum) {
          return fileChecksumAsync(path4, options.checksum).then((checksum) => {
            inspectObj[options.checksum] = checksum;
            return inspectObj;
          });
        } else if (inspectObj.type === "symlink") {
          return fs2.readlink(path4).then((linkPath) => {
            inspectObj.pointsAt = linkPath;
            return inspectObj;
          });
        }
        return Promise.resolve(inspectObj);
      };
      var inspectAsync = (path4, options) => {
        return new Promise((resolve, reject) => {
          let statOperation = fs2.lstat;
          const opts = options || {};
          if (opts.symlinks === "follow") {
            statOperation = fs2.stat;
          }
          statOperation(path4).then((stat6) => {
            const inspectObj = createInspectObj(path4, opts, stat6);
            addExtraFieldsAsync(path4, inspectObj, opts).then(resolve, reject);
          }).catch((err2) => {
            if (err2.code === "ENOENT") {
              resolve(void 0);
            } else {
              reject(err2);
            }
          });
        });
      };
      exports2.supportedChecksumAlgorithms = supportedChecksumAlgorithms;
      exports2.symlinkOptions = symlinkOptions;
      exports2.validateInput = validateInput;
      exports2.sync = inspectSync;
      exports2.async = inspectAsync;
    }
  });

  // node_modules/.pnpm/fs-jetpack@5.1.0/node_modules/fs-jetpack/lib/list.js
  var require_list = __commonJS({
    "node_modules/.pnpm/fs-jetpack@5.1.0/node_modules/fs-jetpack/lib/list.js"(exports2) {
      "use strict";
      var fs2 = require_fs();
      var validate = require_validate();
      var validateInput = (methodName, path4) => {
        const methodSignature = `${methodName}(path)`;
        validate.argument(methodSignature, "path", path4, ["string", "undefined"]);
      };
      var listSync = (path4) => {
        try {
          return fs2.readdirSync(path4);
        } catch (err2) {
          if (err2.code === "ENOENT") {
            return void 0;
          }
          throw err2;
        }
      };
      var listAsync2 = (path4) => {
        return new Promise((resolve, reject) => {
          fs2.readdir(path4).then((list) => {
            resolve(list);
          }).catch((err2) => {
            if (err2.code === "ENOENT") {
              resolve(void 0);
            } else {
              reject(err2);
            }
          });
        });
      };
      exports2.validateInput = validateInput;
      exports2.sync = listSync;
      exports2.async = listAsync2;
    }
  });

  // node_modules/.pnpm/fs-jetpack@5.1.0/node_modules/fs-jetpack/lib/utils/tree_walker.js
  var require_tree_walker = __commonJS({
    "node_modules/.pnpm/fs-jetpack@5.1.0/node_modules/fs-jetpack/lib/utils/tree_walker.js"(exports2) {
      "use strict";
      var fs2 = __require("fs");
      var pathUtil = __require("path");
      var inspect2 = require_inspect();
      var list = require_list();
      var fileType = (dirent) => {
        if (dirent.isDirectory()) {
          return "dir";
        }
        if (dirent.isFile()) {
          return "file";
        }
        if (dirent.isSymbolicLink()) {
          return "symlink";
        }
        return "other";
      };
      var initialWalkSync = (path4, options, callback) => {
        if (options.maxLevelsDeep === void 0) {
          options.maxLevelsDeep = Infinity;
        }
        const performInspectOnEachNode = options.inspectOptions !== void 0;
        if (options.symlinks) {
          if (options.inspectOptions === void 0) {
            options.inspectOptions = { symlinks: options.symlinks };
          } else {
            options.inspectOptions.symlinks = options.symlinks;
          }
        }
        const walkSync = (path5, currentLevel) => {
          fs2.readdirSync(path5, { withFileTypes: true }).forEach((direntItem) => {
            const withFileTypesNotSupported = typeof direntItem === "string";
            let fileItemPath;
            if (withFileTypesNotSupported) {
              fileItemPath = pathUtil.join(path5, direntItem);
            } else {
              fileItemPath = pathUtil.join(path5, direntItem.name);
            }
            let fileItem;
            if (performInspectOnEachNode) {
              fileItem = inspect2.sync(fileItemPath, options.inspectOptions);
            } else if (withFileTypesNotSupported) {
              const inspectObject = inspect2.sync(
                fileItemPath,
                options.inspectOptions
              );
              fileItem = { name: inspectObject.name, type: inspectObject.type };
            } else {
              const type = fileType(direntItem);
              if (type === "symlink" && options.symlinks === "follow") {
                const symlinkPointsTo = fs2.statSync(fileItemPath);
                fileItem = { name: direntItem.name, type: fileType(symlinkPointsTo) };
              } else {
                fileItem = { name: direntItem.name, type };
              }
            }
            if (fileItem !== void 0) {
              callback(fileItemPath, fileItem);
              if (fileItem.type === "dir" && currentLevel < options.maxLevelsDeep) {
                walkSync(fileItemPath, currentLevel + 1);
              }
            }
          });
        };
        const item = inspect2.sync(path4, options.inspectOptions);
        if (item) {
          if (performInspectOnEachNode) {
            callback(path4, item);
          } else {
            callback(path4, { name: item.name, type: item.type });
          }
          if (item.type === "dir") {
            walkSync(path4, 1);
          }
        } else {
          callback(path4, void 0);
        }
      };
      var maxConcurrentOperations = 5;
      var initialWalkAsync = (path4, options, callback, doneCallback) => {
        if (options.maxLevelsDeep === void 0) {
          options.maxLevelsDeep = Infinity;
        }
        const performInspectOnEachNode = options.inspectOptions !== void 0;
        if (options.symlinks) {
          if (options.inspectOptions === void 0) {
            options.inspectOptions = { symlinks: options.symlinks };
          } else {
            options.inspectOptions.symlinks = options.symlinks;
          }
        }
        const concurrentOperationsQueue = [];
        let nowDoingConcurrentOperations = 0;
        const checkConcurrentOperations = () => {
          if (concurrentOperationsQueue.length === 0 && nowDoingConcurrentOperations === 0) {
            doneCallback();
          } else if (concurrentOperationsQueue.length > 0 && nowDoingConcurrentOperations < maxConcurrentOperations) {
            const operation = concurrentOperationsQueue.pop();
            nowDoingConcurrentOperations += 1;
            operation();
          }
        };
        const whenConcurrencySlotAvailable = (operation) => {
          concurrentOperationsQueue.push(operation);
          checkConcurrentOperations();
        };
        const concurrentOperationDone = () => {
          nowDoingConcurrentOperations -= 1;
          checkConcurrentOperations();
        };
        const walkAsync = (path5, currentLevel) => {
          const goDeeperIfDir = (fileItemPath, fileItem) => {
            if (fileItem.type === "dir" && currentLevel < options.maxLevelsDeep) {
              walkAsync(fileItemPath, currentLevel + 1);
            }
          };
          whenConcurrencySlotAvailable(() => {
            fs2.readdir(path5, { withFileTypes: true }, (err2, files) => {
              if (err2) {
                doneCallback(err2);
              } else {
                files.forEach((direntItem) => {
                  const withFileTypesNotSupported = typeof direntItem === "string";
                  let fileItemPath;
                  if (withFileTypesNotSupported) {
                    fileItemPath = pathUtil.join(path5, direntItem);
                  } else {
                    fileItemPath = pathUtil.join(path5, direntItem.name);
                  }
                  if (performInspectOnEachNode || withFileTypesNotSupported) {
                    whenConcurrencySlotAvailable(() => {
                      inspect2.async(fileItemPath, options.inspectOptions).then((fileItem) => {
                        if (fileItem !== void 0) {
                          if (performInspectOnEachNode) {
                            callback(fileItemPath, fileItem);
                          } else {
                            callback(fileItemPath, {
                              name: fileItem.name,
                              type: fileItem.type
                            });
                          }
                          goDeeperIfDir(fileItemPath, fileItem);
                        }
                        concurrentOperationDone();
                      }).catch((err3) => {
                        doneCallback(err3);
                      });
                    });
                  } else {
                    const type = fileType(direntItem);
                    if (type === "symlink" && options.symlinks === "follow") {
                      whenConcurrencySlotAvailable(() => {
                        fs2.stat(fileItemPath, (err3, symlinkPointsTo) => {
                          if (err3) {
                            doneCallback(err3);
                          } else {
                            const fileItem = {
                              name: direntItem.name,
                              type: fileType(symlinkPointsTo)
                            };
                            callback(fileItemPath, fileItem);
                            goDeeperIfDir(fileItemPath, fileItem);
                            concurrentOperationDone();
                          }
                        });
                      });
                    } else {
                      const fileItem = { name: direntItem.name, type };
                      callback(fileItemPath, fileItem);
                      goDeeperIfDir(fileItemPath, fileItem);
                    }
                  }
                });
                concurrentOperationDone();
              }
            });
          });
        };
        inspect2.async(path4, options.inspectOptions).then((item) => {
          if (item) {
            if (performInspectOnEachNode) {
              callback(path4, item);
            } else {
              callback(path4, { name: item.name, type: item.type });
            }
            if (item.type === "dir") {
              walkAsync(path4, 1);
            } else {
              doneCallback();
            }
          } else {
            callback(path4, void 0);
            doneCallback();
          }
        }).catch((err2) => {
          doneCallback(err2);
        });
      };
      exports2.sync = initialWalkSync;
      exports2.async = initialWalkAsync;
    }
  });

  // node_modules/.pnpm/minimatch@5.1.6/node_modules/minimatch/lib/path.js
  var require_path = __commonJS({
    "node_modules/.pnpm/minimatch@5.1.6/node_modules/minimatch/lib/path.js"(exports2, module2) {
      var isWindows = typeof process === "object" && process && process.platform === "win32";
      module2.exports = isWindows ? { sep: "\\" } : { sep: "/" };
    }
  });

  // node_modules/.pnpm/balanced-match@1.0.2/node_modules/balanced-match/index.js
  var require_balanced_match = __commonJS({
    "node_modules/.pnpm/balanced-match@1.0.2/node_modules/balanced-match/index.js"(exports2, module2) {
      "use strict";
      module2.exports = balanced;
      function balanced(a, b, str) {
        if (a instanceof RegExp)
          a = maybeMatch(a, str);
        if (b instanceof RegExp)
          b = maybeMatch(b, str);
        var r = range(a, b, str);
        return r && {
          start: r[0],
          end: r[1],
          pre: str.slice(0, r[0]),
          body: str.slice(r[0] + a.length, r[1]),
          post: str.slice(r[1] + b.length)
        };
      }
      function maybeMatch(reg, str) {
        var m = str.match(reg);
        return m ? m[0] : null;
      }
      balanced.range = range;
      function range(a, b, str) {
        var begs, beg, left, right, result;
        var ai = str.indexOf(a);
        var bi = str.indexOf(b, ai + 1);
        var i = ai;
        if (ai >= 0 && bi > 0) {
          if (a === b) {
            return [ai, bi];
          }
          begs = [];
          left = str.length;
          while (i >= 0 && !result) {
            if (i == ai) {
              begs.push(i);
              ai = str.indexOf(a, i + 1);
            } else if (begs.length == 1) {
              result = [begs.pop(), bi];
            } else {
              beg = begs.pop();
              if (beg < left) {
                left = beg;
                right = bi;
              }
              bi = str.indexOf(b, i + 1);
            }
            i = ai < bi && ai >= 0 ? ai : bi;
          }
          if (begs.length) {
            result = [left, right];
          }
        }
        return result;
      }
    }
  });

  // node_modules/.pnpm/brace-expansion@2.0.1/node_modules/brace-expansion/index.js
  var require_brace_expansion = __commonJS({
    "node_modules/.pnpm/brace-expansion@2.0.1/node_modules/brace-expansion/index.js"(exports2, module2) {
      var balanced = require_balanced_match();
      module2.exports = expandTop;
      var escSlash = "\0SLASH" + Math.random() + "\0";
      var escOpen = "\0OPEN" + Math.random() + "\0";
      var escClose = "\0CLOSE" + Math.random() + "\0";
      var escComma = "\0COMMA" + Math.random() + "\0";
      var escPeriod = "\0PERIOD" + Math.random() + "\0";
      function numeric(str) {
        return parseInt(str, 10) == str ? parseInt(str, 10) : str.charCodeAt(0);
      }
      function escapeBraces(str) {
        return str.split("\\\\").join(escSlash).split("\\{").join(escOpen).split("\\}").join(escClose).split("\\,").join(escComma).split("\\.").join(escPeriod);
      }
      function unescapeBraces(str) {
        return str.split(escSlash).join("\\").split(escOpen).join("{").split(escClose).join("}").split(escComma).join(",").split(escPeriod).join(".");
      }
      function parseCommaParts(str) {
        if (!str)
          return [""];
        var parts = [];
        var m = balanced("{", "}", str);
        if (!m)
          return str.split(",");
        var pre = m.pre;
        var body = m.body;
        var post = m.post;
        var p = pre.split(",");
        p[p.length - 1] += "{" + body + "}";
        var postParts = parseCommaParts(post);
        if (post.length) {
          p[p.length - 1] += postParts.shift();
          p.push.apply(p, postParts);
        }
        parts.push.apply(parts, p);
        return parts;
      }
      function expandTop(str) {
        if (!str)
          return [];
        if (str.substr(0, 2) === "{}") {
          str = "\\{\\}" + str.substr(2);
        }
        return expand(escapeBraces(str), true).map(unescapeBraces);
      }
      function embrace(str) {
        return "{" + str + "}";
      }
      function isPadded(el) {
        return /^-?0\d/.test(el);
      }
      function lte(i, y) {
        return i <= y;
      }
      function gte(i, y) {
        return i >= y;
      }
      function expand(str, isTop) {
        var expansions = [];
        var m = balanced("{", "}", str);
        if (!m)
          return [str];
        var pre = m.pre;
        var post = m.post.length ? expand(m.post, false) : [""];
        if (/\$$/.test(m.pre)) {
          for (var k = 0; k < post.length; k++) {
            var expansion = pre + "{" + m.body + "}" + post[k];
            expansions.push(expansion);
          }
        } else {
          var isNumericSequence = /^-?\d+\.\.-?\d+(?:\.\.-?\d+)?$/.test(m.body);
          var isAlphaSequence = /^[a-zA-Z]\.\.[a-zA-Z](?:\.\.-?\d+)?$/.test(m.body);
          var isSequence = isNumericSequence || isAlphaSequence;
          var isOptions = m.body.indexOf(",") >= 0;
          if (!isSequence && !isOptions) {
            if (m.post.match(/,.*\}/)) {
              str = m.pre + "{" + m.body + escClose + m.post;
              return expand(str);
            }
            return [str];
          }
          var n;
          if (isSequence) {
            n = m.body.split(/\.\./);
          } else {
            n = parseCommaParts(m.body);
            if (n.length === 1) {
              n = expand(n[0], false).map(embrace);
              if (n.length === 1) {
                return post.map(function(p) {
                  return m.pre + n[0] + p;
                });
              }
            }
          }
          var N;
          if (isSequence) {
            var x = numeric(n[0]);
            var y = numeric(n[1]);
            var width = Math.max(n[0].length, n[1].length);
            var incr = n.length == 3 ? Math.abs(numeric(n[2])) : 1;
            var test = lte;
            var reverse = y < x;
            if (reverse) {
              incr *= -1;
              test = gte;
            }
            var pad = n.some(isPadded);
            N = [];
            for (var i = x; test(i, y); i += incr) {
              var c;
              if (isAlphaSequence) {
                c = String.fromCharCode(i);
                if (c === "\\")
                  c = "";
              } else {
                c = String(i);
                if (pad) {
                  var need = width - c.length;
                  if (need > 0) {
                    var z = new Array(need + 1).join("0");
                    if (i < 0)
                      c = "-" + z + c.slice(1);
                    else
                      c = z + c;
                  }
                }
              }
              N.push(c);
            }
          } else {
            N = [];
            for (var j = 0; j < n.length; j++) {
              N.push.apply(N, expand(n[j], false));
            }
          }
          for (var j = 0; j < N.length; j++) {
            for (var k = 0; k < post.length; k++) {
              var expansion = pre + N[j] + post[k];
              if (!isTop || isSequence || expansion)
                expansions.push(expansion);
            }
          }
        }
        return expansions;
      }
    }
  });

  // node_modules/.pnpm/minimatch@5.1.6/node_modules/minimatch/minimatch.js
  var require_minimatch = __commonJS({
    "node_modules/.pnpm/minimatch@5.1.6/node_modules/minimatch/minimatch.js"(exports2, module2) {
      var minimatch = module2.exports = (p, pattern, options = {}) => {
        assertValidPattern(pattern);
        if (!options.nocomment && pattern.charAt(0) === "#") {
          return false;
        }
        return new Minimatch(pattern, options).match(p);
      };
      module2.exports = minimatch;
      var path4 = require_path();
      minimatch.sep = path4.sep;
      var GLOBSTAR = Symbol("globstar **");
      minimatch.GLOBSTAR = GLOBSTAR;
      var expand = require_brace_expansion();
      var plTypes = {
        "!": { open: "(?:(?!(?:", close: "))[^/]*?)" },
        "?": { open: "(?:", close: ")?" },
        "+": { open: "(?:", close: ")+" },
        "*": { open: "(?:", close: ")*" },
        "@": { open: "(?:", close: ")" }
      };
      var qmark = "[^/]";
      var star = qmark + "*?";
      var twoStarDot = "(?:(?!(?:\\/|^)(?:\\.{1,2})($|\\/)).)*?";
      var twoStarNoDot = "(?:(?!(?:\\/|^)\\.).)*?";
      var charSet = (s) => s.split("").reduce((set, c) => {
        set[c] = true;
        return set;
      }, {});
      var reSpecials = charSet("().*{}+?[]^$\\!");
      var addPatternStartSet = charSet("[.(");
      var slashSplit = /\/+/;
      minimatch.filter = (pattern, options = {}) => (p, i, list) => minimatch(p, pattern, options);
      var ext = (a, b = {}) => {
        const t = {};
        Object.keys(a).forEach((k) => t[k] = a[k]);
        Object.keys(b).forEach((k) => t[k] = b[k]);
        return t;
      };
      minimatch.defaults = (def) => {
        if (!def || typeof def !== "object" || !Object.keys(def).length) {
          return minimatch;
        }
        const orig = minimatch;
        const m = (p, pattern, options) => orig(p, pattern, ext(def, options));
        m.Minimatch = class Minimatch extends orig.Minimatch {
          constructor(pattern, options) {
            super(pattern, ext(def, options));
          }
        };
        m.Minimatch.defaults = (options) => orig.defaults(ext(def, options)).Minimatch;
        m.filter = (pattern, options) => orig.filter(pattern, ext(def, options));
        m.defaults = (options) => orig.defaults(ext(def, options));
        m.makeRe = (pattern, options) => orig.makeRe(pattern, ext(def, options));
        m.braceExpand = (pattern, options) => orig.braceExpand(pattern, ext(def, options));
        m.match = (list, pattern, options) => orig.match(list, pattern, ext(def, options));
        return m;
      };
      minimatch.braceExpand = (pattern, options) => braceExpand(pattern, options);
      var braceExpand = (pattern, options = {}) => {
        assertValidPattern(pattern);
        if (options.nobrace || !/\{(?:(?!\{).)*\}/.test(pattern)) {
          return [pattern];
        }
        return expand(pattern);
      };
      var MAX_PATTERN_LENGTH = 1024 * 64;
      var assertValidPattern = (pattern) => {
        if (typeof pattern !== "string") {
          throw new TypeError("invalid pattern");
        }
        if (pattern.length > MAX_PATTERN_LENGTH) {
          throw new TypeError("pattern is too long");
        }
      };
      var SUBPARSE = Symbol("subparse");
      minimatch.makeRe = (pattern, options) => new Minimatch(pattern, options || {}).makeRe();
      minimatch.match = (list, pattern, options = {}) => {
        const mm = new Minimatch(pattern, options);
        list = list.filter((f) => mm.match(f));
        if (mm.options.nonull && !list.length) {
          list.push(pattern);
        }
        return list;
      };
      var globUnescape = (s) => s.replace(/\\(.)/g, "$1");
      var charUnescape = (s) => s.replace(/\\([^-\]])/g, "$1");
      var regExpEscape = (s) => s.replace(/[-[\]{}()*+?.,\\^$|#\s]/g, "\\$&");
      var braExpEscape = (s) => s.replace(/[[\]\\]/g, "\\$&");
      var Minimatch = class {
        constructor(pattern, options) {
          assertValidPattern(pattern);
          if (!options)
            options = {};
          this.options = options;
          this.set = [];
          this.pattern = pattern;
          this.windowsPathsNoEscape = !!options.windowsPathsNoEscape || options.allowWindowsEscape === false;
          if (this.windowsPathsNoEscape) {
            this.pattern = this.pattern.replace(/\\/g, "/");
          }
          this.regexp = null;
          this.negate = false;
          this.comment = false;
          this.empty = false;
          this.partial = !!options.partial;
          this.make();
        }
        debug() {
        }
        make() {
          const pattern = this.pattern;
          const options = this.options;
          if (!options.nocomment && pattern.charAt(0) === "#") {
            this.comment = true;
            return;
          }
          if (!pattern) {
            this.empty = true;
            return;
          }
          this.parseNegate();
          let set = this.globSet = this.braceExpand();
          if (options.debug)
            this.debug = (...args2) => console.error(...args2);
          this.debug(this.pattern, set);
          set = this.globParts = set.map((s) => s.split(slashSplit));
          this.debug(this.pattern, set);
          set = set.map((s, si, set2) => s.map(this.parse, this));
          this.debug(this.pattern, set);
          set = set.filter((s) => s.indexOf(false) === -1);
          this.debug(this.pattern, set);
          this.set = set;
        }
        parseNegate() {
          if (this.options.nonegate)
            return;
          const pattern = this.pattern;
          let negate = false;
          let negateOffset = 0;
          for (let i = 0; i < pattern.length && pattern.charAt(i) === "!"; i++) {
            negate = !negate;
            negateOffset++;
          }
          if (negateOffset)
            this.pattern = pattern.slice(negateOffset);
          this.negate = negate;
        }
        // set partial to true to test if, for example,
        // "/a/b" matches the start of "/*/b/*/d"
        // Partial means, if you run out of file before you run
        // out of pattern, then that's fine, as long as all
        // the parts match.
        matchOne(file, pattern, partial) {
          var options = this.options;
          this.debug(
            "matchOne",
            { "this": this, file, pattern }
          );
          this.debug("matchOne", file.length, pattern.length);
          for (var fi = 0, pi = 0, fl2 = file.length, pl = pattern.length; fi < fl2 && pi < pl; fi++, pi++) {
            this.debug("matchOne loop");
            var p = pattern[pi];
            var f = file[fi];
            this.debug(pattern, p, f);
            if (p === false)
              return false;
            if (p === GLOBSTAR) {
              this.debug("GLOBSTAR", [pattern, p, f]);
              var fr = fi;
              var pr = pi + 1;
              if (pr === pl) {
                this.debug("** at the end");
                for (; fi < fl2; fi++) {
                  if (file[fi] === "." || file[fi] === ".." || !options.dot && file[fi].charAt(0) === ".")
                    return false;
                }
                return true;
              }
              while (fr < fl2) {
                var swallowee = file[fr];
                this.debug("\nglobstar while", file, fr, pattern, pr, swallowee);
                if (this.matchOne(file.slice(fr), pattern.slice(pr), partial)) {
                  this.debug("globstar found match!", fr, fl2, swallowee);
                  return true;
                } else {
                  if (swallowee === "." || swallowee === ".." || !options.dot && swallowee.charAt(0) === ".") {
                    this.debug("dot detected!", file, fr, pattern, pr);
                    break;
                  }
                  this.debug("globstar swallow a segment, and continue");
                  fr++;
                }
              }
              if (partial) {
                this.debug("\n>>> no match, partial?", file, fr, pattern, pr);
                if (fr === fl2)
                  return true;
              }
              return false;
            }
            var hit;
            if (typeof p === "string") {
              hit = f === p;
              this.debug("string match", p, f, hit);
            } else {
              hit = f.match(p);
              this.debug("pattern match", p, f, hit);
            }
            if (!hit)
              return false;
          }
          if (fi === fl2 && pi === pl) {
            return true;
          } else if (fi === fl2) {
            return partial;
          } else if (pi === pl) {
            return fi === fl2 - 1 && file[fi] === "";
          }
          throw new Error("wtf?");
        }
        braceExpand() {
          return braceExpand(this.pattern, this.options);
        }
        parse(pattern, isSub) {
          assertValidPattern(pattern);
          const options = this.options;
          if (pattern === "**") {
            if (!options.noglobstar)
              return GLOBSTAR;
            else
              pattern = "*";
          }
          if (pattern === "")
            return "";
          let re = "";
          let hasMagic = false;
          let escaping = false;
          const patternListStack = [];
          const negativeLists = [];
          let stateChar;
          let inClass = false;
          let reClassStart = -1;
          let classStart = -1;
          let cs;
          let pl;
          let sp;
          let dotTravAllowed = pattern.charAt(0) === ".";
          let dotFileAllowed = options.dot || dotTravAllowed;
          const patternStart = () => dotTravAllowed ? "" : dotFileAllowed ? "(?!(?:^|\\/)\\.{1,2}(?:$|\\/))" : "(?!\\.)";
          const subPatternStart = (p) => p.charAt(0) === "." ? "" : options.dot ? "(?!(?:^|\\/)\\.{1,2}(?:$|\\/))" : "(?!\\.)";
          const clearStateChar = () => {
            if (stateChar) {
              switch (stateChar) {
                case "*":
                  re += star;
                  hasMagic = true;
                  break;
                case "?":
                  re += qmark;
                  hasMagic = true;
                  break;
                default:
                  re += "\\" + stateChar;
                  break;
              }
              this.debug("clearStateChar %j %j", stateChar, re);
              stateChar = false;
            }
          };
          for (let i = 0, c; i < pattern.length && (c = pattern.charAt(i)); i++) {
            this.debug("%s	%s %s %j", pattern, i, re, c);
            if (escaping) {
              if (c === "/") {
                return false;
              }
              if (reSpecials[c]) {
                re += "\\";
              }
              re += c;
              escaping = false;
              continue;
            }
            switch (c) {
              case "/": {
                return false;
              }
              case "\\":
                if (inClass && pattern.charAt(i + 1) === "-") {
                  re += c;
                  continue;
                }
                clearStateChar();
                escaping = true;
                continue;
              case "?":
              case "*":
              case "+":
              case "@":
              case "!":
                this.debug("%s	%s %s %j <-- stateChar", pattern, i, re, c);
                if (inClass) {
                  this.debug("  in class");
                  if (c === "!" && i === classStart + 1)
                    c = "^";
                  re += c;
                  continue;
                }
                this.debug("call clearStateChar %j", stateChar);
                clearStateChar();
                stateChar = c;
                if (options.noext)
                  clearStateChar();
                continue;
              case "(": {
                if (inClass) {
                  re += "(";
                  continue;
                }
                if (!stateChar) {
                  re += "\\(";
                  continue;
                }
                const plEntry = {
                  type: stateChar,
                  start: i - 1,
                  reStart: re.length,
                  open: plTypes[stateChar].open,
                  close: plTypes[stateChar].close
                };
                this.debug(this.pattern, "	", plEntry);
                patternListStack.push(plEntry);
                re += plEntry.open;
                if (plEntry.start === 0 && plEntry.type !== "!") {
                  dotTravAllowed = true;
                  re += subPatternStart(pattern.slice(i + 1));
                }
                this.debug("plType %j %j", stateChar, re);
                stateChar = false;
                continue;
              }
              case ")": {
                const plEntry = patternListStack[patternListStack.length - 1];
                if (inClass || !plEntry) {
                  re += "\\)";
                  continue;
                }
                patternListStack.pop();
                clearStateChar();
                hasMagic = true;
                pl = plEntry;
                re += pl.close;
                if (pl.type === "!") {
                  negativeLists.push(Object.assign(pl, { reEnd: re.length }));
                }
                continue;
              }
              case "|": {
                const plEntry = patternListStack[patternListStack.length - 1];
                if (inClass || !plEntry) {
                  re += "\\|";
                  continue;
                }
                clearStateChar();
                re += "|";
                if (plEntry.start === 0 && plEntry.type !== "!") {
                  dotTravAllowed = true;
                  re += subPatternStart(pattern.slice(i + 1));
                }
                continue;
              }
              case "[":
                clearStateChar();
                if (inClass) {
                  re += "\\" + c;
                  continue;
                }
                inClass = true;
                classStart = i;
                reClassStart = re.length;
                re += c;
                continue;
              case "]":
                if (i === classStart + 1 || !inClass) {
                  re += "\\" + c;
                  continue;
                }
                cs = pattern.substring(classStart + 1, i);
                try {
                  RegExp("[" + braExpEscape(charUnescape(cs)) + "]");
                  re += c;
                } catch (er) {
                  re = re.substring(0, reClassStart) + "(?:$.)";
                }
                hasMagic = true;
                inClass = false;
                continue;
              default:
                clearStateChar();
                if (reSpecials[c] && !(c === "^" && inClass)) {
                  re += "\\";
                }
                re += c;
                break;
            }
          }
          if (inClass) {
            cs = pattern.slice(classStart + 1);
            sp = this.parse(cs, SUBPARSE);
            re = re.substring(0, reClassStart) + "\\[" + sp[0];
            hasMagic = hasMagic || sp[1];
          }
          for (pl = patternListStack.pop(); pl; pl = patternListStack.pop()) {
            let tail;
            tail = re.slice(pl.reStart + pl.open.length);
            this.debug("setting tail", re, pl);
            tail = tail.replace(/((?:\\{2}){0,64})(\\?)\|/g, (_, $1, $2) => {
              if (!$2) {
                $2 = "\\";
              }
              return $1 + $1 + $2 + "|";
            });
            this.debug("tail=%j\n   %s", tail, tail, pl, re);
            const t = pl.type === "*" ? star : pl.type === "?" ? qmark : "\\" + pl.type;
            hasMagic = true;
            re = re.slice(0, pl.reStart) + t + "\\(" + tail;
          }
          clearStateChar();
          if (escaping) {
            re += "\\\\";
          }
          const addPatternStart = addPatternStartSet[re.charAt(0)];
          for (let n = negativeLists.length - 1; n > -1; n--) {
            const nl = negativeLists[n];
            const nlBefore = re.slice(0, nl.reStart);
            const nlFirst = re.slice(nl.reStart, nl.reEnd - 8);
            let nlAfter = re.slice(nl.reEnd);
            const nlLast = re.slice(nl.reEnd - 8, nl.reEnd) + nlAfter;
            const closeParensBefore = nlBefore.split(")").length;
            const openParensBefore = nlBefore.split("(").length - closeParensBefore;
            let cleanAfter = nlAfter;
            for (let i = 0; i < openParensBefore; i++) {
              cleanAfter = cleanAfter.replace(/\)[+*?]?/, "");
            }
            nlAfter = cleanAfter;
            const dollar = nlAfter === "" && isSub !== SUBPARSE ? "(?:$|\\/)" : "";
            re = nlBefore + nlFirst + nlAfter + dollar + nlLast;
          }
          if (re !== "" && hasMagic) {
            re = "(?=.)" + re;
          }
          if (addPatternStart) {
            re = patternStart() + re;
          }
          if (isSub === SUBPARSE) {
            return [re, hasMagic];
          }
          if (options.nocase && !hasMagic) {
            hasMagic = pattern.toUpperCase() !== pattern.toLowerCase();
          }
          if (!hasMagic) {
            return globUnescape(pattern);
          }
          const flags = options.nocase ? "i" : "";
          try {
            return Object.assign(new RegExp("^" + re + "$", flags), {
              _glob: pattern,
              _src: re
            });
          } catch (er) {
            return new RegExp("$.");
          }
        }
        makeRe() {
          if (this.regexp || this.regexp === false)
            return this.regexp;
          const set = this.set;
          if (!set.length) {
            this.regexp = false;
            return this.regexp;
          }
          const options = this.options;
          const twoStar = options.noglobstar ? star : options.dot ? twoStarDot : twoStarNoDot;
          const flags = options.nocase ? "i" : "";
          let re = set.map((pattern) => {
            pattern = pattern.map(
              (p) => typeof p === "string" ? regExpEscape(p) : p === GLOBSTAR ? GLOBSTAR : p._src
            ).reduce((set2, p) => {
              if (!(set2[set2.length - 1] === GLOBSTAR && p === GLOBSTAR)) {
                set2.push(p);
              }
              return set2;
            }, []);
            pattern.forEach((p, i) => {
              if (p !== GLOBSTAR || pattern[i - 1] === GLOBSTAR) {
                return;
              }
              if (i === 0) {
                if (pattern.length > 1) {
                  pattern[i + 1] = "(?:\\/|" + twoStar + "\\/)?" + pattern[i + 1];
                } else {
                  pattern[i] = twoStar;
                }
              } else if (i === pattern.length - 1) {
                pattern[i - 1] += "(?:\\/|" + twoStar + ")?";
              } else {
                pattern[i - 1] += "(?:\\/|\\/" + twoStar + "\\/)" + pattern[i + 1];
                pattern[i + 1] = GLOBSTAR;
              }
            });
            return pattern.filter((p) => p !== GLOBSTAR).join("/");
          }).join("|");
          re = "^(?:" + re + ")$";
          if (this.negate)
            re = "^(?!" + re + ").*$";
          try {
            this.regexp = new RegExp(re, flags);
          } catch (ex) {
            this.regexp = false;
          }
          return this.regexp;
        }
        match(f, partial = this.partial) {
          this.debug("match", f, this.pattern);
          if (this.comment)
            return false;
          if (this.empty)
            return f === "";
          if (f === "/" && partial)
            return true;
          const options = this.options;
          if (path4.sep !== "/") {
            f = f.split(path4.sep).join("/");
          }
          f = f.split(slashSplit);
          this.debug(this.pattern, "split", f);
          const set = this.set;
          this.debug(this.pattern, "set", set);
          let filename;
          for (let i = f.length - 1; i >= 0; i--) {
            filename = f[i];
            if (filename)
              break;
          }
          for (let i = 0; i < set.length; i++) {
            const pattern = set[i];
            let file = f;
            if (options.matchBase && pattern.length === 1) {
              file = [filename];
            }
            const hit = this.matchOne(file, pattern, partial);
            if (hit) {
              if (options.flipNegate)
                return true;
              return !this.negate;
            }
          }
          if (options.flipNegate)
            return false;
          return this.negate;
        }
        static defaults(def) {
          return minimatch.defaults(def).Minimatch;
        }
      };
      minimatch.Minimatch = Minimatch;
    }
  });

  // node_modules/.pnpm/fs-jetpack@5.1.0/node_modules/fs-jetpack/lib/utils/matcher.js
  var require_matcher = __commonJS({
    "node_modules/.pnpm/fs-jetpack@5.1.0/node_modules/fs-jetpack/lib/utils/matcher.js"(exports2) {
      "use strict";
      var Minimatch = require_minimatch().Minimatch;
      var convertPatternToAbsolutePath = (basePath, pattern) => {
        const hasSlash = pattern.indexOf("/") !== -1;
        const isAbsolute = /^!?\//.test(pattern);
        const isNegated = /^!/.test(pattern);
        let separator;
        if (!isAbsolute && hasSlash) {
          const patternWithoutFirstCharacters = pattern.replace(/^!/, "").replace(/^\.\//, "");
          if (/\/$/.test(basePath)) {
            separator = "";
          } else {
            separator = "/";
          }
          if (isNegated) {
            return `!${basePath}${separator}${patternWithoutFirstCharacters}`;
          }
          return `${basePath}${separator}${patternWithoutFirstCharacters}`;
        }
        return pattern;
      };
      exports2.create = (basePath, patterns, ignoreCase) => {
        let normalizedPatterns;
        if (typeof patterns === "string") {
          normalizedPatterns = [patterns];
        } else {
          normalizedPatterns = patterns;
        }
        const matchers = normalizedPatterns.map((pattern) => {
          return convertPatternToAbsolutePath(basePath, pattern);
        }).map((pattern) => {
          return new Minimatch(pattern, {
            matchBase: true,
            nocomment: true,
            nocase: ignoreCase || false,
            dot: true,
            windowsPathsNoEscape: true
          });
        });
        const performMatch = (absolutePath) => {
          let mode = "matching";
          let weHaveMatch = false;
          let currentMatcher;
          let i;
          for (i = 0; i < matchers.length; i += 1) {
            currentMatcher = matchers[i];
            if (currentMatcher.negate) {
              mode = "negation";
              if (i === 0) {
                weHaveMatch = true;
              }
            }
            if (mode === "negation" && weHaveMatch && !currentMatcher.match(absolutePath)) {
              return false;
            }
            if (mode === "matching" && !weHaveMatch) {
              weHaveMatch = currentMatcher.match(absolutePath);
            }
          }
          return weHaveMatch;
        };
        return performMatch;
      };
    }
  });

  // node_modules/.pnpm/fs-jetpack@5.1.0/node_modules/fs-jetpack/lib/find.js
  var require_find = __commonJS({
    "node_modules/.pnpm/fs-jetpack@5.1.0/node_modules/fs-jetpack/lib/find.js"(exports2) {
      "use strict";
      var pathUtil = __require("path");
      var treeWalker = require_tree_walker();
      var inspect2 = require_inspect();
      var matcher = require_matcher();
      var validate = require_validate();
      var validateInput = (methodName, path4, options) => {
        const methodSignature = `${methodName}([path], options)`;
        validate.argument(methodSignature, "path", path4, ["string"]);
        validate.options(methodSignature, "options", options, {
          matching: ["string", "array of string"],
          filter: ["function"],
          files: ["boolean"],
          directories: ["boolean"],
          recursive: ["boolean"],
          ignoreCase: ["boolean"]
        });
      };
      var normalizeOptions = (options) => {
        const opts = options || {};
        if (opts.matching === void 0) {
          opts.matching = "*";
        }
        if (opts.files === void 0) {
          opts.files = true;
        }
        if (opts.ignoreCase === void 0) {
          opts.ignoreCase = false;
        }
        if (opts.directories === void 0) {
          opts.directories = false;
        }
        if (opts.recursive === void 0) {
          opts.recursive = true;
        }
        return opts;
      };
      var processFoundPaths = (foundPaths, cwd2) => {
        return foundPaths.map((path4) => {
          return pathUtil.relative(cwd2, path4);
        });
      };
      var generatePathDoesntExistError = (path4) => {
        const err2 = new Error(`Path you want to find stuff in doesn't exist ${path4}`);
        err2.code = "ENOENT";
        return err2;
      };
      var generatePathNotDirectoryError = (path4) => {
        const err2 = new Error(
          `Path you want to find stuff in must be a directory ${path4}`
        );
        err2.code = "ENOTDIR";
        return err2;
      };
      var findSync = (path4, options) => {
        const foundAbsolutePaths = [];
        const matchesAnyOfGlobs = matcher.create(
          path4,
          options.matching,
          options.ignoreCase
        );
        let maxLevelsDeep = Infinity;
        if (options.recursive === false) {
          maxLevelsDeep = 1;
        }
        treeWalker.sync(
          path4,
          {
            maxLevelsDeep,
            symlinks: "follow",
            inspectOptions: { times: true, absolutePath: true }
          },
          (itemPath, item) => {
            if (item && itemPath !== path4 && matchesAnyOfGlobs(itemPath)) {
              const weHaveMatch = item.type === "file" && options.files === true || item.type === "dir" && options.directories === true;
              if (weHaveMatch) {
                if (options.filter) {
                  const passedThroughFilter = options.filter(item);
                  if (passedThroughFilter) {
                    foundAbsolutePaths.push(itemPath);
                  }
                } else {
                  foundAbsolutePaths.push(itemPath);
                }
              }
            }
          }
        );
        foundAbsolutePaths.sort();
        return processFoundPaths(foundAbsolutePaths, options.cwd);
      };
      var findSyncInit = (path4, options) => {
        const entryPointInspect = inspect2.sync(path4, { symlinks: "follow" });
        if (entryPointInspect === void 0) {
          throw generatePathDoesntExistError(path4);
        } else if (entryPointInspect.type !== "dir") {
          throw generatePathNotDirectoryError(path4);
        }
        return findSync(path4, normalizeOptions(options));
      };
      var findAsync = (path4, options) => {
        return new Promise((resolve, reject) => {
          const foundAbsolutePaths = [];
          const matchesAnyOfGlobs = matcher.create(
            path4,
            options.matching,
            options.ignoreCase
          );
          let maxLevelsDeep = Infinity;
          if (options.recursive === false) {
            maxLevelsDeep = 1;
          }
          let waitingForFiltersToFinish = 0;
          let treeWalkerDone = false;
          const maybeDone = () => {
            if (treeWalkerDone && waitingForFiltersToFinish === 0) {
              foundAbsolutePaths.sort();
              resolve(processFoundPaths(foundAbsolutePaths, options.cwd));
            }
          };
          treeWalker.async(
            path4,
            {
              maxLevelsDeep,
              symlinks: "follow",
              inspectOptions: { times: true, absolutePath: true }
            },
            (itemPath, item) => {
              if (item && itemPath !== path4 && matchesAnyOfGlobs(itemPath)) {
                const weHaveMatch = item.type === "file" && options.files === true || item.type === "dir" && options.directories === true;
                if (weHaveMatch) {
                  if (options.filter) {
                    const passedThroughFilter = options.filter(item);
                    const isPromise = typeof passedThroughFilter.then === "function";
                    if (isPromise) {
                      waitingForFiltersToFinish += 1;
                      passedThroughFilter.then((passedThroughFilterResult) => {
                        if (passedThroughFilterResult) {
                          foundAbsolutePaths.push(itemPath);
                        }
                        waitingForFiltersToFinish -= 1;
                        maybeDone();
                      }).catch((err2) => {
                        reject(err2);
                      });
                    } else if (passedThroughFilter) {
                      foundAbsolutePaths.push(itemPath);
                    }
                  } else {
                    foundAbsolutePaths.push(itemPath);
                  }
                }
              }
            },
            (err2) => {
              if (err2) {
                reject(err2);
              } else {
                treeWalkerDone = true;
                maybeDone();
              }
            }
          );
        });
      };
      var findAsyncInit = (path4, options) => {
        return inspect2.async(path4, { symlinks: "follow" }).then((entryPointInspect) => {
          if (entryPointInspect === void 0) {
            throw generatePathDoesntExistError(path4);
          } else if (entryPointInspect.type !== "dir") {
            throw generatePathNotDirectoryError(path4);
          }
          return findAsync(path4, normalizeOptions(options));
        });
      };
      exports2.validateInput = validateInput;
      exports2.sync = findSyncInit;
      exports2.async = findAsyncInit;
    }
  });

  // node_modules/.pnpm/fs-jetpack@5.1.0/node_modules/fs-jetpack/lib/inspect_tree.js
  var require_inspect_tree = __commonJS({
    "node_modules/.pnpm/fs-jetpack@5.1.0/node_modules/fs-jetpack/lib/inspect_tree.js"(exports2) {
      "use strict";
      var crypto = __require("crypto");
      var pathUtil = __require("path");
      var inspect2 = require_inspect();
      var list = require_list();
      var validate = require_validate();
      var treeWalker = require_tree_walker();
      var validateInput = (methodName, path4, options) => {
        const methodSignature = `${methodName}(path, [options])`;
        validate.argument(methodSignature, "path", path4, ["string"]);
        validate.options(methodSignature, "options", options, {
          checksum: ["string"],
          relativePath: ["boolean"],
          times: ["boolean"],
          symlinks: ["string"]
        });
        if (options && options.checksum !== void 0 && inspect2.supportedChecksumAlgorithms.indexOf(options.checksum) === -1) {
          throw new Error(
            `Argument "options.checksum" passed to ${methodSignature} must have one of values: ${inspect2.supportedChecksumAlgorithms.join(
              ", "
            )}`
          );
        }
        if (options && options.symlinks !== void 0 && inspect2.symlinkOptions.indexOf(options.symlinks) === -1) {
          throw new Error(
            `Argument "options.symlinks" passed to ${methodSignature} must have one of values: ${inspect2.symlinkOptions.join(
              ", "
            )}`
          );
        }
      };
      var relativePathInTree = (parentInspectObj, inspectObj) => {
        if (parentInspectObj === void 0) {
          return ".";
        }
        return parentInspectObj.relativePath + "/" + inspectObj.name;
      };
      var checksumOfDir = (inspectList, algo) => {
        const hash = crypto.createHash(algo);
        inspectList.forEach((inspectObj) => {
          hash.update(inspectObj.name + inspectObj[algo]);
        });
        return hash.digest("hex");
      };
      var calculateTreeDependentProperties = (parentInspectObj, inspectObj, options) => {
        if (options.relativePath) {
          inspectObj.relativePath = relativePathInTree(parentInspectObj, inspectObj);
        }
        if (inspectObj.type === "dir") {
          inspectObj.children.forEach((childInspectObj) => {
            calculateTreeDependentProperties(inspectObj, childInspectObj, options);
          });
          inspectObj.size = 0;
          inspectObj.children.sort((a, b) => {
            if (a.type === "dir" && b.type === "file") {
              return -1;
            }
            if (a.type === "file" && b.type === "dir") {
              return 1;
            }
            return a.name.localeCompare(b.name);
          });
          inspectObj.children.forEach((child) => {
            inspectObj.size += child.size || 0;
          });
          if (options.checksum) {
            inspectObj[options.checksum] = checksumOfDir(
              inspectObj.children,
              options.checksum
            );
          }
        }
      };
      var findParentInTree = (treeNode, pathChain, item) => {
        const name = pathChain[0];
        if (pathChain.length > 1) {
          const itemInTreeForPathChain = treeNode.children.find((child) => {
            return child.name === name;
          });
          return findParentInTree(itemInTreeForPathChain, pathChain.slice(1), item);
        }
        return treeNode;
      };
      var inspectTreeSync = (path4, opts) => {
        const options = opts || {};
        let tree;
        treeWalker.sync(path4, { inspectOptions: options }, (itemPath, item) => {
          if (item) {
            if (item.type === "dir") {
              item.children = [];
            }
            const relativePath = pathUtil.relative(path4, itemPath);
            if (relativePath === "") {
              tree = item;
            } else {
              const parentItem = findParentInTree(
                tree,
                relativePath.split(pathUtil.sep),
                item
              );
              parentItem.children.push(item);
            }
          }
        });
        if (tree) {
          calculateTreeDependentProperties(void 0, tree, options);
        }
        return tree;
      };
      var inspectTreeAsync = (path4, opts) => {
        const options = opts || {};
        let tree;
        return new Promise((resolve, reject) => {
          treeWalker.async(
            path4,
            { inspectOptions: options },
            (itemPath, item) => {
              if (item) {
                if (item.type === "dir") {
                  item.children = [];
                }
                const relativePath = pathUtil.relative(path4, itemPath);
                if (relativePath === "") {
                  tree = item;
                } else {
                  const parentItem = findParentInTree(
                    tree,
                    relativePath.split(pathUtil.sep),
                    item
                  );
                  parentItem.children.push(item);
                }
              }
            },
            (err2) => {
              if (err2) {
                reject(err2);
              } else {
                if (tree) {
                  calculateTreeDependentProperties(void 0, tree, options);
                }
                resolve(tree);
              }
            }
          );
        });
      };
      exports2.validateInput = validateInput;
      exports2.sync = inspectTreeSync;
      exports2.async = inspectTreeAsync;
    }
  });

  // node_modules/.pnpm/fs-jetpack@5.1.0/node_modules/fs-jetpack/lib/exists.js
  var require_exists = __commonJS({
    "node_modules/.pnpm/fs-jetpack@5.1.0/node_modules/fs-jetpack/lib/exists.js"(exports2) {
      "use strict";
      var fs2 = require_fs();
      var validate = require_validate();
      var validateInput = (methodName, path4) => {
        const methodSignature = `${methodName}(path)`;
        validate.argument(methodSignature, "path", path4, ["string"]);
      };
      var existsSync5 = (path4) => {
        try {
          const stat6 = fs2.statSync(path4);
          if (stat6.isDirectory()) {
            return "dir";
          } else if (stat6.isFile()) {
            return "file";
          }
          return "other";
        } catch (err2) {
          if (err2.code !== "ENOENT") {
            throw err2;
          }
        }
        return false;
      };
      var existsAsync13 = (path4) => {
        return new Promise((resolve, reject) => {
          fs2.stat(path4).then((stat6) => {
            if (stat6.isDirectory()) {
              resolve("dir");
            } else if (stat6.isFile()) {
              resolve("file");
            } else {
              resolve("other");
            }
          }).catch((err2) => {
            if (err2.code === "ENOENT") {
              resolve(false);
            } else {
              reject(err2);
            }
          });
        });
      };
      exports2.validateInput = validateInput;
      exports2.sync = existsSync5;
      exports2.async = existsAsync13;
    }
  });

  // node_modules/.pnpm/fs-jetpack@5.1.0/node_modules/fs-jetpack/lib/copy.js
  var require_copy = __commonJS({
    "node_modules/.pnpm/fs-jetpack@5.1.0/node_modules/fs-jetpack/lib/copy.js"(exports2) {
      "use strict";
      var pathUtil = __require("path");
      var fs2 = require_fs();
      var dir2 = require_dir();
      var exists = require_exists();
      var inspect2 = require_inspect();
      var write = require_write();
      var matcher = require_matcher();
      var fileMode = require_mode();
      var treeWalker = require_tree_walker();
      var validate = require_validate();
      var validateInput = (methodName, from, to, options) => {
        const methodSignature = `${methodName}(from, to, [options])`;
        validate.argument(methodSignature, "from", from, ["string"]);
        validate.argument(methodSignature, "to", to, ["string"]);
        validate.options(methodSignature, "options", options, {
          overwrite: ["boolean", "function"],
          matching: ["string", "array of string"],
          ignoreCase: ["boolean"]
        });
      };
      var parseOptions = (options, from) => {
        const opts = options || {};
        const parsedOptions = {};
        if (opts.ignoreCase === void 0) {
          opts.ignoreCase = false;
        }
        parsedOptions.overwrite = opts.overwrite;
        if (opts.matching) {
          parsedOptions.allowedToCopy = matcher.create(
            from,
            opts.matching,
            opts.ignoreCase
          );
        } else {
          parsedOptions.allowedToCopy = () => {
            return true;
          };
        }
        return parsedOptions;
      };
      var generateNoSourceError = (path4) => {
        const err2 = new Error(`Path to copy doesn't exist ${path4}`);
        err2.code = "ENOENT";
        return err2;
      };
      var generateDestinationExistsError = (path4) => {
        const err2 = new Error(`Destination path already exists ${path4}`);
        err2.code = "EEXIST";
        return err2;
      };
      var inspectOptions = {
        mode: true,
        symlinks: "report",
        times: true,
        absolutePath: true
      };
      var shouldThrowDestinationExistsError = (context2) => {
        return typeof context2.opts.overwrite !== "function" && context2.opts.overwrite !== true;
      };
      var checksBeforeCopyingSync = (from, to, opts) => {
        if (!exists.sync(from)) {
          throw generateNoSourceError(from);
        }
        if (exists.sync(to) && !opts.overwrite) {
          throw generateDestinationExistsError(to);
        }
      };
      var canOverwriteItSync = (context2) => {
        if (typeof context2.opts.overwrite === "function") {
          const destInspectData = inspect2.sync(context2.destPath, inspectOptions);
          return context2.opts.overwrite(context2.srcInspectData, destInspectData);
        }
        return context2.opts.overwrite === true;
      };
      var copyFileSync = (srcPath, destPath, mode, context2) => {
        const data = fs2.readFileSync(srcPath);
        try {
          fs2.writeFileSync(destPath, data, { mode, flag: "wx" });
        } catch (err2) {
          if (err2.code === "ENOENT") {
            write.sync(destPath, data, { mode });
          } else if (err2.code === "EEXIST") {
            if (canOverwriteItSync(context2)) {
              fs2.writeFileSync(destPath, data, { mode });
            } else if (shouldThrowDestinationExistsError(context2)) {
              throw generateDestinationExistsError(context2.destPath);
            }
          } else {
            throw err2;
          }
        }
      };
      var copySymlinkSync = (from, to) => {
        const symlinkPointsAt = fs2.readlinkSync(from);
        try {
          fs2.symlinkSync(symlinkPointsAt, to);
        } catch (err2) {
          if (err2.code === "EEXIST") {
            fs2.unlinkSync(to);
            fs2.symlinkSync(symlinkPointsAt, to);
          } else {
            throw err2;
          }
        }
      };
      var copyItemSync = (srcPath, srcInspectData, destPath, opts) => {
        const context2 = { srcPath, destPath, srcInspectData, opts };
        const mode = fileMode.normalizeFileMode(srcInspectData.mode);
        if (srcInspectData.type === "dir") {
          dir2.createSync(destPath, { mode });
        } else if (srcInspectData.type === "file") {
          copyFileSync(srcPath, destPath, mode, context2);
        } else if (srcInspectData.type === "symlink") {
          copySymlinkSync(srcPath, destPath);
        }
      };
      var copySync = (from, to, options) => {
        const opts = parseOptions(options, from);
        checksBeforeCopyingSync(from, to, opts);
        treeWalker.sync(from, { inspectOptions }, (srcPath, srcInspectData) => {
          const rel = pathUtil.relative(from, srcPath);
          const destPath = pathUtil.resolve(to, rel);
          if (opts.allowedToCopy(srcPath, destPath, srcInspectData)) {
            copyItemSync(srcPath, srcInspectData, destPath, opts);
          }
        });
      };
      var checksBeforeCopyingAsync = (from, to, opts) => {
        return exists.async(from).then((srcPathExists) => {
          if (!srcPathExists) {
            throw generateNoSourceError(from);
          } else {
            return exists.async(to);
          }
        }).then((destPathExists) => {
          if (destPathExists && !opts.overwrite) {
            throw generateDestinationExistsError(to);
          }
        });
      };
      var canOverwriteItAsync = (context2) => {
        return new Promise((resolve, reject) => {
          if (typeof context2.opts.overwrite === "function") {
            inspect2.async(context2.destPath, inspectOptions).then((destInspectData) => {
              resolve(
                context2.opts.overwrite(context2.srcInspectData, destInspectData)
              );
            }).catch(reject);
          } else {
            resolve(context2.opts.overwrite === true);
          }
        });
      };
      var copyFileAsync = (srcPath, destPath, mode, context2, runOptions) => {
        return new Promise((resolve, reject) => {
          const runOpts = runOptions || {};
          let flags = "wx";
          if (runOpts.overwrite) {
            flags = "w";
          }
          const readStream = fs2.createReadStream(srcPath);
          const writeStream = fs2.createWriteStream(destPath, { mode, flags });
          readStream.on("error", reject);
          writeStream.on("error", (err2) => {
            readStream.resume();
            if (err2.code === "ENOENT") {
              dir2.createAsync(pathUtil.dirname(destPath)).then(() => {
                copyFileAsync(srcPath, destPath, mode, context2).then(
                  resolve,
                  reject
                );
              }).catch(reject);
            } else if (err2.code === "EEXIST") {
              canOverwriteItAsync(context2).then((canOverwite) => {
                if (canOverwite) {
                  copyFileAsync(srcPath, destPath, mode, context2, {
                    overwrite: true
                  }).then(resolve, reject);
                } else if (shouldThrowDestinationExistsError(context2)) {
                  reject(generateDestinationExistsError(destPath));
                } else {
                  resolve();
                }
              }).catch(reject);
            } else {
              reject(err2);
            }
          });
          writeStream.on("finish", resolve);
          readStream.pipe(writeStream);
        });
      };
      var copySymlinkAsync = (from, to) => {
        return fs2.readlink(from).then((symlinkPointsAt) => {
          return new Promise((resolve, reject) => {
            fs2.symlink(symlinkPointsAt, to).then(resolve).catch((err2) => {
              if (err2.code === "EEXIST") {
                fs2.unlink(to).then(() => {
                  return fs2.symlink(symlinkPointsAt, to);
                }).then(resolve, reject);
              } else {
                reject(err2);
              }
            });
          });
        });
      };
      var copyItemAsync = (srcPath, srcInspectData, destPath, opts) => {
        const context2 = { srcPath, destPath, srcInspectData, opts };
        const mode = fileMode.normalizeFileMode(srcInspectData.mode);
        if (srcInspectData.type === "dir") {
          return dir2.createAsync(destPath, { mode });
        } else if (srcInspectData.type === "file") {
          return copyFileAsync(srcPath, destPath, mode, context2);
        } else if (srcInspectData.type === "symlink") {
          return copySymlinkAsync(srcPath, destPath);
        }
        return Promise.resolve();
      };
      var copyAsync5 = (from, to, options) => {
        return new Promise((resolve, reject) => {
          const opts = parseOptions(options, from);
          checksBeforeCopyingAsync(from, to, opts).then(() => {
            let allFilesDelivered = false;
            let filesInProgress = 0;
            treeWalker.async(
              from,
              { inspectOptions },
              (srcPath, item) => {
                if (item) {
                  const rel = pathUtil.relative(from, srcPath);
                  const destPath = pathUtil.resolve(to, rel);
                  if (opts.allowedToCopy(srcPath, item, destPath)) {
                    filesInProgress += 1;
                    copyItemAsync(srcPath, item, destPath, opts).then(() => {
                      filesInProgress -= 1;
                      if (allFilesDelivered && filesInProgress === 0) {
                        resolve();
                      }
                    }).catch(reject);
                  }
                }
              },
              (err2) => {
                if (err2) {
                  reject(err2);
                } else {
                  allFilesDelivered = true;
                  if (allFilesDelivered && filesInProgress === 0) {
                    resolve();
                  }
                }
              }
            );
          }).catch(reject);
        });
      };
      exports2.validateInput = validateInput;
      exports2.sync = copySync;
      exports2.async = copyAsync5;
    }
  });

  // node_modules/.pnpm/fs-jetpack@5.1.0/node_modules/fs-jetpack/lib/move.js
  var require_move = __commonJS({
    "node_modules/.pnpm/fs-jetpack@5.1.0/node_modules/fs-jetpack/lib/move.js"(exports2) {
      "use strict";
      var pathUtil = __require("path");
      var fs2 = require_fs();
      var validate = require_validate();
      var copy = require_copy();
      var dir2 = require_dir();
      var exists = require_exists();
      var remove = require_remove();
      var validateInput = (methodName, from, to, options) => {
        const methodSignature = `${methodName}(from, to, [options])`;
        validate.argument(methodSignature, "from", from, ["string"]);
        validate.argument(methodSignature, "to", to, ["string"]);
        validate.options(methodSignature, "options", options, {
          overwrite: ["boolean"]
        });
      };
      var parseOptions = (options) => {
        const opts = options || {};
        return opts;
      };
      var generateDestinationExistsError = (path4) => {
        const err2 = new Error(`Destination path already exists ${path4}`);
        err2.code = "EEXIST";
        return err2;
      };
      var generateSourceDoesntExistError = (path4) => {
        const err2 = new Error(`Path to move doesn't exist ${path4}`);
        err2.code = "ENOENT";
        return err2;
      };
      var moveSync = (from, to, options) => {
        const opts = parseOptions(options);
        if (exists.sync(to) !== false && opts.overwrite !== true) {
          throw generateDestinationExistsError(to);
        }
        try {
          fs2.renameSync(from, to);
        } catch (err2) {
          if (err2.code === "EISDIR" || err2.code === "EPERM") {
            remove.sync(to);
            fs2.renameSync(from, to);
          } else if (err2.code === "EXDEV") {
            copy.sync(from, to, { overwrite: true });
            remove.sync(from);
          } else if (err2.code === "ENOENT") {
            if (!exists.sync(from)) {
              throw generateSourceDoesntExistError(from);
            }
            dir2.createSync(pathUtil.dirname(to));
            fs2.renameSync(from, to);
          } else {
            throw err2;
          }
        }
      };
      var ensureDestinationPathExistsAsync = (to) => {
        return new Promise((resolve, reject) => {
          const destDir = pathUtil.dirname(to);
          exists.async(destDir).then((dstExists) => {
            if (!dstExists) {
              dir2.createAsync(destDir).then(resolve, reject);
            } else {
              reject();
            }
          }).catch(reject);
        });
      };
      var moveAsync2 = (from, to, options) => {
        const opts = parseOptions(options);
        return new Promise((resolve, reject) => {
          exists.async(to).then((destinationExists) => {
            if (destinationExists !== false && opts.overwrite !== true) {
              reject(generateDestinationExistsError(to));
            } else {
              fs2.rename(from, to).then(resolve).catch((err2) => {
                if (err2.code === "EISDIR" || err2.code === "EPERM") {
                  remove.async(to).then(() => fs2.rename(from, to)).then(resolve, reject);
                } else if (err2.code === "EXDEV") {
                  copy.async(from, to, { overwrite: true }).then(() => remove.async(from)).then(resolve, reject);
                } else if (err2.code === "ENOENT") {
                  exists.async(from).then((srcExists) => {
                    if (!srcExists) {
                      reject(generateSourceDoesntExistError(from));
                    } else {
                      ensureDestinationPathExistsAsync(to).then(() => {
                        return fs2.rename(from, to);
                      }).then(resolve, reject);
                    }
                  }).catch(reject);
                } else {
                  reject(err2);
                }
              });
            }
          });
        });
      };
      exports2.validateInput = validateInput;
      exports2.sync = moveSync;
      exports2.async = moveAsync2;
    }
  });

  // node_modules/.pnpm/fs-jetpack@5.1.0/node_modules/fs-jetpack/lib/read.js
  var require_read = __commonJS({
    "node_modules/.pnpm/fs-jetpack@5.1.0/node_modules/fs-jetpack/lib/read.js"(exports2) {
      "use strict";
      var fs2 = require_fs();
      var validate = require_validate();
      var supportedReturnAs = ["utf8", "buffer", "json", "jsonWithDates"];
      var validateInput = (methodName, path4, returnAs) => {
        const methodSignature = `${methodName}(path, returnAs)`;
        validate.argument(methodSignature, "path", path4, ["string"]);
        validate.argument(methodSignature, "returnAs", returnAs, [
          "string",
          "undefined"
        ]);
        if (returnAs && supportedReturnAs.indexOf(returnAs) === -1) {
          throw new Error(
            `Argument "returnAs" passed to ${methodSignature} must have one of values: ${supportedReturnAs.join(
              ", "
            )}`
          );
        }
      };
      var jsonDateParser = (key, value) => {
        const reISO = /^(\d{4})-(\d{2})-(\d{2})T(\d{2}):(\d{2}):(\d{2}(?:\.\d*))(?:Z|(\+|-)([\d|:]*))?$/;
        if (typeof value === "string") {
          if (reISO.exec(value)) {
            return new Date(value);
          }
        }
        return value;
      };
      var makeNicerJsonParsingError = (path4, err2) => {
        const nicerError = new Error(
          `JSON parsing failed while reading ${path4} [${err2}]`
        );
        nicerError.originalError = err2;
        return nicerError;
      };
      var readSync = (path4, returnAs) => {
        const retAs = returnAs || "utf8";
        let data;
        let encoding = "utf8";
        if (retAs === "buffer") {
          encoding = null;
        }
        try {
          data = fs2.readFileSync(path4, { encoding });
        } catch (err2) {
          if (err2.code === "ENOENT") {
            return void 0;
          }
          throw err2;
        }
        try {
          if (retAs === "json") {
            data = JSON.parse(data);
          } else if (retAs === "jsonWithDates") {
            data = JSON.parse(data, jsonDateParser);
          }
        } catch (err2) {
          throw makeNicerJsonParsingError(path4, err2);
        }
        return data;
      };
      var readAsync15 = (path4, returnAs) => {
        return new Promise((resolve, reject) => {
          const retAs = returnAs || "utf8";
          let encoding = "utf8";
          if (retAs === "buffer") {
            encoding = null;
          }
          fs2.readFile(path4, { encoding }).then((data) => {
            try {
              if (retAs === "json") {
                resolve(JSON.parse(data));
              } else if (retAs === "jsonWithDates") {
                resolve(JSON.parse(data, jsonDateParser));
              } else {
                resolve(data);
              }
            } catch (err2) {
              reject(makeNicerJsonParsingError(path4, err2));
            }
          }).catch((err2) => {
            if (err2.code === "ENOENT") {
              resolve(void 0);
            } else {
              reject(err2);
            }
          });
        });
      };
      exports2.validateInput = validateInput;
      exports2.sync = readSync;
      exports2.async = readAsync15;
    }
  });

  // node_modules/.pnpm/fs-jetpack@5.1.0/node_modules/fs-jetpack/lib/rename.js
  var require_rename = __commonJS({
    "node_modules/.pnpm/fs-jetpack@5.1.0/node_modules/fs-jetpack/lib/rename.js"(exports2) {
      "use strict";
      var pathUtil = __require("path");
      var move = require_move();
      var validate = require_validate();
      var validateInput = (methodName, path4, newName, options) => {
        const methodSignature = `${methodName}(path, newName, [options])`;
        validate.argument(methodSignature, "path", path4, ["string"]);
        validate.argument(methodSignature, "newName", newName, ["string"]);
        validate.options(methodSignature, "options", options, {
          overwrite: ["boolean"]
        });
        if (pathUtil.basename(newName) !== newName) {
          throw new Error(
            `Argument "newName" passed to ${methodSignature} should be a filename, not a path. Received "${newName}"`
          );
        }
      };
      var renameSync = (path4, newName, options) => {
        const newPath = pathUtil.join(pathUtil.dirname(path4), newName);
        move.sync(path4, newPath, options);
      };
      var renameAsync = (path4, newName, options) => {
        const newPath = pathUtil.join(pathUtil.dirname(path4), newName);
        return move.async(path4, newPath, options);
      };
      exports2.validateInput = validateInput;
      exports2.sync = renameSync;
      exports2.async = renameAsync;
    }
  });

  // node_modules/.pnpm/fs-jetpack@5.1.0/node_modules/fs-jetpack/lib/symlink.js
  var require_symlink = __commonJS({
    "node_modules/.pnpm/fs-jetpack@5.1.0/node_modules/fs-jetpack/lib/symlink.js"(exports2) {
      "use strict";
      var pathUtil = __require("path");
      var fs2 = require_fs();
      var validate = require_validate();
      var dir2 = require_dir();
      var validateInput = (methodName, symlinkValue, path4) => {
        const methodSignature = `${methodName}(symlinkValue, path)`;
        validate.argument(methodSignature, "symlinkValue", symlinkValue, ["string"]);
        validate.argument(methodSignature, "path", path4, ["string"]);
      };
      var symlinkSync = (symlinkValue, path4) => {
        try {
          fs2.symlinkSync(symlinkValue, path4);
        } catch (err2) {
          if (err2.code === "ENOENT") {
            dir2.createSync(pathUtil.dirname(path4));
            fs2.symlinkSync(symlinkValue, path4);
          } else {
            throw err2;
          }
        }
      };
      var symlinkAsync = (symlinkValue, path4) => {
        return new Promise((resolve, reject) => {
          fs2.symlink(symlinkValue, path4).then(resolve).catch((err2) => {
            if (err2.code === "ENOENT") {
              dir2.createAsync(pathUtil.dirname(path4)).then(() => {
                return fs2.symlink(symlinkValue, path4);
              }).then(resolve, reject);
            } else {
              reject(err2);
            }
          });
        });
      };
      exports2.validateInput = validateInput;
      exports2.sync = symlinkSync;
      exports2.async = symlinkAsync;
    }
  });

  // node_modules/.pnpm/fs-jetpack@5.1.0/node_modules/fs-jetpack/lib/streams.js
  var require_streams = __commonJS({
    "node_modules/.pnpm/fs-jetpack@5.1.0/node_modules/fs-jetpack/lib/streams.js"(exports2) {
      "use strict";
      var fs2 = __require("fs");
      exports2.createWriteStream = fs2.createWriteStream;
      exports2.createReadStream = fs2.createReadStream;
    }
  });

  // node_modules/.pnpm/fs-jetpack@5.1.0/node_modules/fs-jetpack/lib/tmp_dir.js
  var require_tmp_dir = __commonJS({
    "node_modules/.pnpm/fs-jetpack@5.1.0/node_modules/fs-jetpack/lib/tmp_dir.js"(exports2) {
      "use strict";
      var pathUtil = __require("path");
      var os5 = __require("os");
      var crypto = __require("crypto");
      var dir2 = require_dir();
      var fs2 = require_fs();
      var validate = require_validate();
      var validateInput = (methodName, options) => {
        const methodSignature = `${methodName}([options])`;
        validate.options(methodSignature, "options", options, {
          prefix: ["string"],
          basePath: ["string"]
        });
      };
      var getOptionsDefaults = (passedOptions, cwdPath) => {
        passedOptions = passedOptions || {};
        const options = {};
        if (typeof passedOptions.prefix !== "string") {
          options.prefix = "";
        } else {
          options.prefix = passedOptions.prefix;
        }
        if (typeof passedOptions.basePath === "string") {
          options.basePath = pathUtil.resolve(cwdPath, passedOptions.basePath);
        } else {
          options.basePath = os5.tmpdir();
        }
        return options;
      };
      var randomStringLength = 32;
      var tmpDirSync = (cwdPath, passedOptions) => {
        const options = getOptionsDefaults(passedOptions, cwdPath);
        const randomString = crypto.randomBytes(randomStringLength / 2).toString("hex");
        const dirPath = pathUtil.join(
          options.basePath,
          options.prefix + randomString
        );
        try {
          fs2.mkdirSync(dirPath);
        } catch (err2) {
          if (err2.code === "ENOENT") {
            dir2.sync(dirPath);
          } else {
            throw err2;
          }
        }
        return dirPath;
      };
      var tmpDirAsync = (cwdPath, passedOptions) => {
        return new Promise((resolve, reject) => {
          const options = getOptionsDefaults(passedOptions, cwdPath);
          crypto.randomBytes(randomStringLength / 2, (err2, bytes) => {
            if (err2) {
              reject(err2);
            } else {
              const randomString = bytes.toString("hex");
              const dirPath = pathUtil.join(
                options.basePath,
                options.prefix + randomString
              );
              fs2.mkdir(dirPath, (err3) => {
                if (err3) {
                  if (err3.code === "ENOENT") {
                    dir2.async(dirPath).then(() => {
                      resolve(dirPath);
                    }, reject);
                  } else {
                    reject(err3);
                  }
                } else {
                  resolve(dirPath);
                }
              });
            }
          });
        });
      };
      exports2.validateInput = validateInput;
      exports2.sync = tmpDirSync;
      exports2.async = tmpDirAsync;
    }
  });

  // node_modules/.pnpm/fs-jetpack@5.1.0/node_modules/fs-jetpack/lib/jetpack.js
  var require_jetpack = __commonJS({
    "node_modules/.pnpm/fs-jetpack@5.1.0/node_modules/fs-jetpack/lib/jetpack.js"(exports2, module2) {
      "use strict";
      var util = __require("util");
      var pathUtil = __require("path");
      var append = require_append();
      var dir2 = require_dir();
      var file = require_file();
      var find = require_find();
      var inspect2 = require_inspect();
      var inspectTree = require_inspect_tree();
      var copy = require_copy();
      var exists = require_exists();
      var list = require_list();
      var move = require_move();
      var read = require_read();
      var remove = require_remove();
      var rename = require_rename();
      var symlink = require_symlink();
      var streams = require_streams();
      var tmpDir = require_tmp_dir();
      var write = require_write();
      var jetpackContext = (cwdPath) => {
        const getCwdPath = () => {
          return cwdPath || process.cwd();
        };
        const cwd2 = function() {
          if (arguments.length === 0) {
            return getCwdPath();
          }
          const args2 = Array.prototype.slice.call(arguments);
          const pathParts = [getCwdPath()].concat(args2);
          return jetpackContext(pathUtil.resolve.apply(null, pathParts));
        };
        const resolvePath = (path4) => {
          return pathUtil.resolve(getCwdPath(), path4);
        };
        const getPath = function() {
          Array.prototype.unshift.call(arguments, getCwdPath());
          return pathUtil.resolve.apply(null, arguments);
        };
        const normalizeOptions = (options) => {
          const opts = options || {};
          opts.cwd = getCwdPath();
          return opts;
        };
        const api = {
          cwd: cwd2,
          path: getPath,
          append: (path4, data, options) => {
            append.validateInput("append", path4, data, options);
            append.sync(resolvePath(path4), data, options);
          },
          appendAsync: (path4, data, options) => {
            append.validateInput("appendAsync", path4, data, options);
            return append.async(resolvePath(path4), data, options);
          },
          copy: (from, to, options) => {
            copy.validateInput("copy", from, to, options);
            copy.sync(resolvePath(from), resolvePath(to), options);
          },
          copyAsync: (from, to, options) => {
            copy.validateInput("copyAsync", from, to, options);
            return copy.async(resolvePath(from), resolvePath(to), options);
          },
          createWriteStream: (path4, options) => {
            return streams.createWriteStream(resolvePath(path4), options);
          },
          createReadStream: (path4, options) => {
            return streams.createReadStream(resolvePath(path4), options);
          },
          dir: (path4, criteria) => {
            dir2.validateInput("dir", path4, criteria);
            const normalizedPath = resolvePath(path4);
            dir2.sync(normalizedPath, criteria);
            return cwd2(normalizedPath);
          },
          dirAsync: (path4, criteria) => {
            dir2.validateInput("dirAsync", path4, criteria);
            return new Promise((resolve, reject) => {
              const normalizedPath = resolvePath(path4);
              dir2.async(normalizedPath, criteria).then(() => {
                resolve(cwd2(normalizedPath));
              }, reject);
            });
          },
          exists: (path4) => {
            exists.validateInput("exists", path4);
            return exists.sync(resolvePath(path4));
          },
          existsAsync: (path4) => {
            exists.validateInput("existsAsync", path4);
            return exists.async(resolvePath(path4));
          },
          file: (path4, criteria) => {
            file.validateInput("file", path4, criteria);
            file.sync(resolvePath(path4), criteria);
            return api;
          },
          fileAsync: (path4, criteria) => {
            file.validateInput("fileAsync", path4, criteria);
            return new Promise((resolve, reject) => {
              file.async(resolvePath(path4), criteria).then(() => {
                resolve(api);
              }, reject);
            });
          },
          find: (startPath, options) => {
            if (typeof options === "undefined" && typeof startPath === "object") {
              options = startPath;
              startPath = ".";
            }
            find.validateInput("find", startPath, options);
            return find.sync(resolvePath(startPath), normalizeOptions(options));
          },
          findAsync: (startPath, options) => {
            if (typeof options === "undefined" && typeof startPath === "object") {
              options = startPath;
              startPath = ".";
            }
            find.validateInput("findAsync", startPath, options);
            return find.async(resolvePath(startPath), normalizeOptions(options));
          },
          inspect: (path4, fieldsToInclude) => {
            inspect2.validateInput("inspect", path4, fieldsToInclude);
            return inspect2.sync(resolvePath(path4), fieldsToInclude);
          },
          inspectAsync: (path4, fieldsToInclude) => {
            inspect2.validateInput("inspectAsync", path4, fieldsToInclude);
            return inspect2.async(resolvePath(path4), fieldsToInclude);
          },
          inspectTree: (path4, options) => {
            inspectTree.validateInput("inspectTree", path4, options);
            return inspectTree.sync(resolvePath(path4), options);
          },
          inspectTreeAsync: (path4, options) => {
            inspectTree.validateInput("inspectTreeAsync", path4, options);
            return inspectTree.async(resolvePath(path4), options);
          },
          list: (path4) => {
            list.validateInput("list", path4);
            return list.sync(resolvePath(path4 || "."));
          },
          listAsync: (path4) => {
            list.validateInput("listAsync", path4);
            return list.async(resolvePath(path4 || "."));
          },
          move: (from, to, options) => {
            move.validateInput("move", from, to, options);
            move.sync(resolvePath(from), resolvePath(to), options);
          },
          moveAsync: (from, to, options) => {
            move.validateInput("moveAsync", from, to, options);
            return move.async(resolvePath(from), resolvePath(to), options);
          },
          read: (path4, returnAs) => {
            read.validateInput("read", path4, returnAs);
            return read.sync(resolvePath(path4), returnAs);
          },
          readAsync: (path4, returnAs) => {
            read.validateInput("readAsync", path4, returnAs);
            return read.async(resolvePath(path4), returnAs);
          },
          remove: (path4) => {
            remove.validateInput("remove", path4);
            remove.sync(resolvePath(path4 || "."));
          },
          removeAsync: (path4) => {
            remove.validateInput("removeAsync", path4);
            return remove.async(resolvePath(path4 || "."));
          },
          rename: (path4, newName, options) => {
            rename.validateInput("rename", path4, newName, options);
            rename.sync(resolvePath(path4), newName, options);
          },
          renameAsync: (path4, newName, options) => {
            rename.validateInput("renameAsync", path4, newName, options);
            return rename.async(resolvePath(path4), newName, options);
          },
          symlink: (symlinkValue, path4) => {
            symlink.validateInput("symlink", symlinkValue, path4);
            symlink.sync(symlinkValue, resolvePath(path4));
          },
          symlinkAsync: (symlinkValue, path4) => {
            symlink.validateInput("symlinkAsync", symlinkValue, path4);
            return symlink.async(symlinkValue, resolvePath(path4));
          },
          tmpDir: (options) => {
            tmpDir.validateInput("tmpDir", options);
            const pathOfCreatedDirectory = tmpDir.sync(getCwdPath(), options);
            return cwd2(pathOfCreatedDirectory);
          },
          tmpDirAsync: (options) => {
            tmpDir.validateInput("tmpDirAsync", options);
            return new Promise((resolve, reject) => {
              tmpDir.async(getCwdPath(), options).then((pathOfCreatedDirectory) => {
                resolve(cwd2(pathOfCreatedDirectory));
              }, reject);
            });
          },
          write: (path4, data, options) => {
            write.validateInput("write", path4, data, options);
            write.sync(resolvePath(path4), data, options);
          },
          writeAsync: (path4, data, options) => {
            write.validateInput("writeAsync", path4, data, options);
            return write.async(resolvePath(path4), data, options);
          }
        };
        if (util.inspect.custom !== void 0) {
          api[util.inspect.custom] = () => {
            return `[fs-jetpack CWD: ${getCwdPath()}]`;
          };
        }
        return api;
      };
      module2.exports = jetpackContext;
    }
  });

  // node_modules/.pnpm/fs-jetpack@5.1.0/node_modules/fs-jetpack/main.js
  var require_main = __commonJS({
    "node_modules/.pnpm/fs-jetpack@5.1.0/node_modules/fs-jetpack/main.js"(exports2, module2) {
      "use strict";
      var jetpack = require_jetpack();
      module2.exports = jetpack();
    }
  });

  // node_modules/.pnpm/lodash.padend@4.6.1/node_modules/lodash.padend/index.js
  var require_lodash = __commonJS({
    "node_modules/.pnpm/lodash.padend@4.6.1/node_modules/lodash.padend/index.js"(exports2, module2) {
      var INFINITY = 1 / 0;
      var MAX_SAFE_INTEGER = 9007199254740991;
      var MAX_INTEGER = 17976931348623157e292;
      var NAN = 0 / 0;
      var symbolTag = "[object Symbol]";
      var reTrim = /^\s+|\s+$/g;
      var reIsBadHex = /^[-+]0x[0-9a-f]+$/i;
      var reIsBinary = /^0b[01]+$/i;
      var reIsOctal = /^0o[0-7]+$/i;
      var rsAstralRange = "\\ud800-\\udfff";
      var rsComboMarksRange = "\\u0300-\\u036f\\ufe20-\\ufe23";
      var rsComboSymbolsRange = "\\u20d0-\\u20f0";
      var rsVarRange = "\\ufe0e\\ufe0f";
      var rsAstral = "[" + rsAstralRange + "]";
      var rsCombo = "[" + rsComboMarksRange + rsComboSymbolsRange + "]";
      var rsFitz = "\\ud83c[\\udffb-\\udfff]";
      var rsModifier = "(?:" + rsCombo + "|" + rsFitz + ")";
      var rsNonAstral = "[^" + rsAstralRange + "]";
      var rsRegional = "(?:\\ud83c[\\udde6-\\uddff]){2}";
      var rsSurrPair = "[\\ud800-\\udbff][\\udc00-\\udfff]";
      var rsZWJ = "\\u200d";
      var reOptMod = rsModifier + "?";
      var rsOptVar = "[" + rsVarRange + "]?";
      var rsOptJoin = "(?:" + rsZWJ + "(?:" + [rsNonAstral, rsRegional, rsSurrPair].join("|") + ")" + rsOptVar + reOptMod + ")*";
      var rsSeq = rsOptVar + reOptMod + rsOptJoin;
      var rsSymbol = "(?:" + [rsNonAstral + rsCombo + "?", rsCombo, rsRegional, rsSurrPair, rsAstral].join("|") + ")";
      var reUnicode = RegExp(rsFitz + "(?=" + rsFitz + ")|" + rsSymbol + rsSeq, "g");
      var reHasUnicode = RegExp("[" + rsZWJ + rsAstralRange + rsComboMarksRange + rsComboSymbolsRange + rsVarRange + "]");
      var freeParseInt = parseInt;
      var freeGlobal = typeof global == "object" && global && global.Object === Object && global;
      var freeSelf = typeof self == "object" && self && self.Object === Object && self;
      var root = freeGlobal || freeSelf || Function("return this")();
      var asciiSize = baseProperty("length");
      function asciiToArray(string) {
        return string.split("");
      }
      function baseProperty(key) {
        return function(object) {
          return object == null ? void 0 : object[key];
        };
      }
      function hasUnicode(string) {
        return reHasUnicode.test(string);
      }
      function stringSize(string) {
        return hasUnicode(string) ? unicodeSize(string) : asciiSize(string);
      }
      function stringToArray(string) {
        return hasUnicode(string) ? unicodeToArray(string) : asciiToArray(string);
      }
      function unicodeSize(string) {
        var result = reUnicode.lastIndex = 0;
        while (reUnicode.test(string)) {
          result++;
        }
        return result;
      }
      function unicodeToArray(string) {
        return string.match(reUnicode) || [];
      }
      var objectProto = Object.prototype;
      var objectToString = objectProto.toString;
      var Symbol2 = root.Symbol;
      var nativeCeil = Math.ceil;
      var nativeFloor = Math.floor;
      var symbolProto = Symbol2 ? Symbol2.prototype : void 0;
      var symbolToString = symbolProto ? symbolProto.toString : void 0;
      function baseRepeat(string, n) {
        var result = "";
        if (!string || n < 1 || n > MAX_SAFE_INTEGER) {
          return result;
        }
        do {
          if (n % 2) {
            result += string;
          }
          n = nativeFloor(n / 2);
          if (n) {
            string += string;
          }
        } while (n);
        return result;
      }
      function baseSlice(array, start, end) {
        var index = -1, length = array.length;
        if (start < 0) {
          start = -start > length ? 0 : length + start;
        }
        end = end > length ? length : end;
        if (end < 0) {
          end += length;
        }
        length = start > end ? 0 : end - start >>> 0;
        start >>>= 0;
        var result = Array(length);
        while (++index < length) {
          result[index] = array[index + start];
        }
        return result;
      }
      function baseToString(value) {
        if (typeof value == "string") {
          return value;
        }
        if (isSymbol(value)) {
          return symbolToString ? symbolToString.call(value) : "";
        }
        var result = value + "";
        return result == "0" && 1 / value == -INFINITY ? "-0" : result;
      }
      function castSlice(array, start, end) {
        var length = array.length;
        end = end === void 0 ? length : end;
        return !start && end >= length ? array : baseSlice(array, start, end);
      }
      function createPadding(length, chars) {
        chars = chars === void 0 ? " " : baseToString(chars);
        var charsLength = chars.length;
        if (charsLength < 2) {
          return charsLength ? baseRepeat(chars, length) : chars;
        }
        var result = baseRepeat(chars, nativeCeil(length / stringSize(chars)));
        return hasUnicode(chars) ? castSlice(stringToArray(result), 0, length).join("") : result.slice(0, length);
      }
      function isObject(value) {
        var type = typeof value;
        return !!value && (type == "object" || type == "function");
      }
      function isObjectLike(value) {
        return !!value && typeof value == "object";
      }
      function isSymbol(value) {
        return typeof value == "symbol" || isObjectLike(value) && objectToString.call(value) == symbolTag;
      }
      function toFinite(value) {
        if (!value) {
          return value === 0 ? value : 0;
        }
        value = toNumber(value);
        if (value === INFINITY || value === -INFINITY) {
          var sign = value < 0 ? -1 : 1;
          return sign * MAX_INTEGER;
        }
        return value === value ? value : 0;
      }
      function toInteger(value) {
        var result = toFinite(value), remainder = result % 1;
        return result === result ? remainder ? result - remainder : result : 0;
      }
      function toNumber(value) {
        if (typeof value == "number") {
          return value;
        }
        if (isSymbol(value)) {
          return NAN;
        }
        if (isObject(value)) {
          var other = typeof value.valueOf == "function" ? value.valueOf() : value;
          value = isObject(other) ? other + "" : other;
        }
        if (typeof value != "string") {
          return value === 0 ? value : +value;
        }
        value = value.replace(reTrim, "");
        var isBinary = reIsBinary.test(value);
        return isBinary || reIsOctal.test(value) ? freeParseInt(value.slice(2), isBinary ? 2 : 8) : reIsBadHex.test(value) ? NAN : +value;
      }
      function toString(value) {
        return value == null ? "" : baseToString(value);
      }
      function padEnd4(string, length, chars) {
        string = toString(string);
        length = toInteger(length);
        var strLength = length ? stringSize(string) : 0;
        return length && strLength < length ? string + createPadding(length - strLength, chars) : string;
      }
      module2.exports = padEnd4;
    }
  });

  // node_modules/.pnpm/color-name@1.1.4/node_modules/color-name/index.js
  var require_color_name = __commonJS({
    "node_modules/.pnpm/color-name@1.1.4/node_modules/color-name/index.js"(exports2, module2) {
      "use strict";
      module2.exports = {
        "aliceblue": [240, 248, 255],
        "antiquewhite": [250, 235, 215],
        "aqua": [0, 255, 255],
        "aquamarine": [127, 255, 212],
        "azure": [240, 255, 255],
        "beige": [245, 245, 220],
        "bisque": [255, 228, 196],
        "black": [0, 0, 0],
        "blanchedalmond": [255, 235, 205],
        "blue": [0, 0, 255],
        "blueviolet": [138, 43, 226],
        "brown": [165, 42, 42],
        "burlywood": [222, 184, 135],
        "cadetblue": [95, 158, 160],
        "chartreuse": [127, 255, 0],
        "chocolate": [210, 105, 30],
        "coral": [255, 127, 80],
        "cornflowerblue": [100, 149, 237],
        "cornsilk": [255, 248, 220],
        "crimson": [220, 20, 60],
        "cyan": [0, 255, 255],
        "darkblue": [0, 0, 139],
        "darkcyan": [0, 139, 139],
        "darkgoldenrod": [184, 134, 11],
        "darkgray": [169, 169, 169],
        "darkgreen": [0, 100, 0],
        "darkgrey": [169, 169, 169],
        "darkkhaki": [189, 183, 107],
        "darkmagenta": [139, 0, 139],
        "darkolivegreen": [85, 107, 47],
        "darkorange": [255, 140, 0],
        "darkorchid": [153, 50, 204],
        "darkred": [139, 0, 0],
        "darksalmon": [233, 150, 122],
        "darkseagreen": [143, 188, 143],
        "darkslateblue": [72, 61, 139],
        "darkslategray": [47, 79, 79],
        "darkslategrey": [47, 79, 79],
        "darkturquoise": [0, 206, 209],
        "darkviolet": [148, 0, 211],
        "deeppink": [255, 20, 147],
        "deepskyblue": [0, 191, 255],
        "dimgray": [105, 105, 105],
        "dimgrey": [105, 105, 105],
        "dodgerblue": [30, 144, 255],
        "firebrick": [178, 34, 34],
        "floralwhite": [255, 250, 240],
        "forestgreen": [34, 139, 34],
        "fuchsia": [255, 0, 255],
        "gainsboro": [220, 220, 220],
        "ghostwhite": [248, 248, 255],
        "gold": [255, 215, 0],
        "goldenrod": [218, 165, 32],
        "gray": [128, 128, 128],
        "green": [0, 128, 0],
        "greenyellow": [173, 255, 47],
        "grey": [128, 128, 128],
        "honeydew": [240, 255, 240],
        "hotpink": [255, 105, 180],
        "indianred": [205, 92, 92],
        "indigo": [75, 0, 130],
        "ivory": [255, 255, 240],
        "khaki": [240, 230, 140],
        "lavender": [230, 230, 250],
        "lavenderblush": [255, 240, 245],
        "lawngreen": [124, 252, 0],
        "lemonchiffon": [255, 250, 205],
        "lightblue": [173, 216, 230],
        "lightcoral": [240, 128, 128],
        "lightcyan": [224, 255, 255],
        "lightgoldenrodyellow": [250, 250, 210],
        "lightgray": [211, 211, 211],
        "lightgreen": [144, 238, 144],
        "lightgrey": [211, 211, 211],
        "lightpink": [255, 182, 193],
        "lightsalmon": [255, 160, 122],
        "lightseagreen": [32, 178, 170],
        "lightskyblue": [135, 206, 250],
        "lightslategray": [119, 136, 153],
        "lightslategrey": [119, 136, 153],
        "lightsteelblue": [176, 196, 222],
        "lightyellow": [255, 255, 224],
        "lime": [0, 255, 0],
        "limegreen": [50, 205, 50],
        "linen": [250, 240, 230],
        "magenta": [255, 0, 255],
        "maroon": [128, 0, 0],
        "mediumaquamarine": [102, 205, 170],
        "mediumblue": [0, 0, 205],
        "mediumorchid": [186, 85, 211],
        "mediumpurple": [147, 112, 219],
        "mediumseagreen": [60, 179, 113],
        "mediumslateblue": [123, 104, 238],
        "mediumspringgreen": [0, 250, 154],
        "mediumturquoise": [72, 209, 204],
        "mediumvioletred": [199, 21, 133],
        "midnightblue": [25, 25, 112],
        "mintcream": [245, 255, 250],
        "mistyrose": [255, 228, 225],
        "moccasin": [255, 228, 181],
        "navajowhite": [255, 222, 173],
        "navy": [0, 0, 128],
        "oldlace": [253, 245, 230],
        "olive": [128, 128, 0],
        "olivedrab": [107, 142, 35],
        "orange": [255, 165, 0],
        "orangered": [255, 69, 0],
        "orchid": [218, 112, 214],
        "palegoldenrod": [238, 232, 170],
        "palegreen": [152, 251, 152],
        "paleturquoise": [175, 238, 238],
        "palevioletred": [219, 112, 147],
        "papayawhip": [255, 239, 213],
        "peachpuff": [255, 218, 185],
        "peru": [205, 133, 63],
        "pink": [255, 192, 203],
        "plum": [221, 160, 221],
        "powderblue": [176, 224, 230],
        "purple": [128, 0, 128],
        "rebeccapurple": [102, 51, 153],
        "red": [255, 0, 0],
        "rosybrown": [188, 143, 143],
        "royalblue": [65, 105, 225],
        "saddlebrown": [139, 69, 19],
        "salmon": [250, 128, 114],
        "sandybrown": [244, 164, 96],
        "seagreen": [46, 139, 87],
        "seashell": [255, 245, 238],
        "sienna": [160, 82, 45],
        "silver": [192, 192, 192],
        "skyblue": [135, 206, 235],
        "slateblue": [106, 90, 205],
        "slategray": [112, 128, 144],
        "slategrey": [112, 128, 144],
        "snow": [255, 250, 250],
        "springgreen": [0, 255, 127],
        "steelblue": [70, 130, 180],
        "tan": [210, 180, 140],
        "teal": [0, 128, 128],
        "thistle": [216, 191, 216],
        "tomato": [255, 99, 71],
        "turquoise": [64, 224, 208],
        "violet": [238, 130, 238],
        "wheat": [245, 222, 179],
        "white": [255, 255, 255],
        "whitesmoke": [245, 245, 245],
        "yellow": [255, 255, 0],
        "yellowgreen": [154, 205, 50]
      };
    }
  });

  // node_modules/.pnpm/color-convert@2.0.1/node_modules/color-convert/conversions.js
  var require_conversions = __commonJS({
    "node_modules/.pnpm/color-convert@2.0.1/node_modules/color-convert/conversions.js"(exports2, module2) {
      var cssKeywords = require_color_name();
      var reverseKeywords = {};
      for (const key of Object.keys(cssKeywords)) {
        reverseKeywords[cssKeywords[key]] = key;
      }
      var convert = {
        rgb: { channels: 3, labels: "rgb" },
        hsl: { channels: 3, labels: "hsl" },
        hsv: { channels: 3, labels: "hsv" },
        hwb: { channels: 3, labels: "hwb" },
        cmyk: { channels: 4, labels: "cmyk" },
        xyz: { channels: 3, labels: "xyz" },
        lab: { channels: 3, labels: "lab" },
        lch: { channels: 3, labels: "lch" },
        hex: { channels: 1, labels: ["hex"] },
        keyword: { channels: 1, labels: ["keyword"] },
        ansi16: { channels: 1, labels: ["ansi16"] },
        ansi256: { channels: 1, labels: ["ansi256"] },
        hcg: { channels: 3, labels: ["h", "c", "g"] },
        apple: { channels: 3, labels: ["r16", "g16", "b16"] },
        gray: { channels: 1, labels: ["gray"] }
      };
      module2.exports = convert;
      for (const model of Object.keys(convert)) {
        if (!("channels" in convert[model])) {
          throw new Error("missing channels property: " + model);
        }
        if (!("labels" in convert[model])) {
          throw new Error("missing channel labels property: " + model);
        }
        if (convert[model].labels.length !== convert[model].channels) {
          throw new Error("channel and label counts mismatch: " + model);
        }
        const { channels, labels } = convert[model];
        delete convert[model].channels;
        delete convert[model].labels;
        Object.defineProperty(convert[model], "channels", { value: channels });
        Object.defineProperty(convert[model], "labels", { value: labels });
      }
      convert.rgb.hsl = function(rgb) {
        const r = rgb[0] / 255;
        const g4 = rgb[1] / 255;
        const b = rgb[2] / 255;
        const min = Math.min(r, g4, b);
        const max2 = Math.max(r, g4, b);
        const delta = max2 - min;
        let h;
        let s;
        if (max2 === min) {
          h = 0;
        } else if (r === max2) {
          h = (g4 - b) / delta;
        } else if (g4 === max2) {
          h = 2 + (b - r) / delta;
        } else if (b === max2) {
          h = 4 + (r - g4) / delta;
        }
        h = Math.min(h * 60, 360);
        if (h < 0) {
          h += 360;
        }
        const l = (min + max2) / 2;
        if (max2 === min) {
          s = 0;
        } else if (l <= 0.5) {
          s = delta / (max2 + min);
        } else {
          s = delta / (2 - max2 - min);
        }
        return [h, s * 100, l * 100];
      };
      convert.rgb.hsv = function(rgb) {
        let rdif;
        let gdif;
        let bdif;
        let h;
        let s;
        const r = rgb[0] / 255;
        const g4 = rgb[1] / 255;
        const b = rgb[2] / 255;
        const v = Math.max(r, g4, b);
        const diff = v - Math.min(r, g4, b);
        const diffc = function(c) {
          return (v - c) / 6 / diff + 1 / 2;
        };
        if (diff === 0) {
          h = 0;
          s = 0;
        } else {
          s = diff / v;
          rdif = diffc(r);
          gdif = diffc(g4);
          bdif = diffc(b);
          if (r === v) {
            h = bdif - gdif;
          } else if (g4 === v) {
            h = 1 / 3 + rdif - bdif;
          } else if (b === v) {
            h = 2 / 3 + gdif - rdif;
          }
          if (h < 0) {
            h += 1;
          } else if (h > 1) {
            h -= 1;
          }
        }
        return [
          h * 360,
          s * 100,
          v * 100
        ];
      };
      convert.rgb.hwb = function(rgb) {
        const r = rgb[0];
        const g4 = rgb[1];
        let b = rgb[2];
        const h = convert.rgb.hsl(rgb)[0];
        const w = 1 / 255 * Math.min(r, Math.min(g4, b));
        b = 1 - 1 / 255 * Math.max(r, Math.max(g4, b));
        return [h, w * 100, b * 100];
      };
      convert.rgb.cmyk = function(rgb) {
        const r = rgb[0] / 255;
        const g4 = rgb[1] / 255;
        const b = rgb[2] / 255;
        const k = Math.min(1 - r, 1 - g4, 1 - b);
        const c = (1 - r - k) / (1 - k) || 0;
        const m = (1 - g4 - k) / (1 - k) || 0;
        const y = (1 - b - k) / (1 - k) || 0;
        return [c * 100, m * 100, y * 100, k * 100];
      };
      function comparativeDistance(x, y) {
        return (x[0] - y[0]) ** 2 + (x[1] - y[1]) ** 2 + (x[2] - y[2]) ** 2;
      }
      convert.rgb.keyword = function(rgb) {
        const reversed = reverseKeywords[rgb];
        if (reversed) {
          return reversed;
        }
        let currentClosestDistance = Infinity;
        let currentClosestKeyword;
        for (const keyword of Object.keys(cssKeywords)) {
          const value = cssKeywords[keyword];
          const distance = comparativeDistance(rgb, value);
          if (distance < currentClosestDistance) {
            currentClosestDistance = distance;
            currentClosestKeyword = keyword;
          }
        }
        return currentClosestKeyword;
      };
      convert.keyword.rgb = function(keyword) {
        return cssKeywords[keyword];
      };
      convert.rgb.xyz = function(rgb) {
        let r = rgb[0] / 255;
        let g4 = rgb[1] / 255;
        let b = rgb[2] / 255;
        r = r > 0.04045 ? ((r + 0.055) / 1.055) ** 2.4 : r / 12.92;
        g4 = g4 > 0.04045 ? ((g4 + 0.055) / 1.055) ** 2.4 : g4 / 12.92;
        b = b > 0.04045 ? ((b + 0.055) / 1.055) ** 2.4 : b / 12.92;
        const x = r * 0.4124 + g4 * 0.3576 + b * 0.1805;
        const y = r * 0.2126 + g4 * 0.7152 + b * 0.0722;
        const z = r * 0.0193 + g4 * 0.1192 + b * 0.9505;
        return [x * 100, y * 100, z * 100];
      };
      convert.rgb.lab = function(rgb) {
        const xyz = convert.rgb.xyz(rgb);
        let x = xyz[0];
        let y = xyz[1];
        let z = xyz[2];
        x /= 95.047;
        y /= 100;
        z /= 108.883;
        x = x > 8856e-6 ? x ** (1 / 3) : 7.787 * x + 16 / 116;
        y = y > 8856e-6 ? y ** (1 / 3) : 7.787 * y + 16 / 116;
        z = z > 8856e-6 ? z ** (1 / 3) : 7.787 * z + 16 / 116;
        const l = 116 * y - 16;
        const a = 500 * (x - y);
        const b = 200 * (y - z);
        return [l, a, b];
      };
      convert.hsl.rgb = function(hsl) {
        const h = hsl[0] / 360;
        const s = hsl[1] / 100;
        const l = hsl[2] / 100;
        let t2;
        let t3;
        let val;
        if (s === 0) {
          val = l * 255;
          return [val, val, val];
        }
        if (l < 0.5) {
          t2 = l * (1 + s);
        } else {
          t2 = l + s - l * s;
        }
        const t1 = 2 * l - t2;
        const rgb = [0, 0, 0];
        for (let i = 0; i < 3; i++) {
          t3 = h + 1 / 3 * -(i - 1);
          if (t3 < 0) {
            t3++;
          }
          if (t3 > 1) {
            t3--;
          }
          if (6 * t3 < 1) {
            val = t1 + (t2 - t1) * 6 * t3;
          } else if (2 * t3 < 1) {
            val = t2;
          } else if (3 * t3 < 2) {
            val = t1 + (t2 - t1) * (2 / 3 - t3) * 6;
          } else {
            val = t1;
          }
          rgb[i] = val * 255;
        }
        return rgb;
      };
      convert.hsl.hsv = function(hsl) {
        const h = hsl[0];
        let s = hsl[1] / 100;
        let l = hsl[2] / 100;
        let smin = s;
        const lmin = Math.max(l, 0.01);
        l *= 2;
        s *= l <= 1 ? l : 2 - l;
        smin *= lmin <= 1 ? lmin : 2 - lmin;
        const v = (l + s) / 2;
        const sv = l === 0 ? 2 * smin / (lmin + smin) : 2 * s / (l + s);
        return [h, sv * 100, v * 100];
      };
      convert.hsv.rgb = function(hsv) {
        const h = hsv[0] / 60;
        const s = hsv[1] / 100;
        let v = hsv[2] / 100;
        const hi = Math.floor(h) % 6;
        const f = h - Math.floor(h);
        const p = 255 * v * (1 - s);
        const q = 255 * v * (1 - s * f);
        const t = 255 * v * (1 - s * (1 - f));
        v *= 255;
        switch (hi) {
          case 0:
            return [v, t, p];
          case 1:
            return [q, v, p];
          case 2:
            return [p, v, t];
          case 3:
            return [p, q, v];
          case 4:
            return [t, p, v];
          case 5:
            return [v, p, q];
        }
      };
      convert.hsv.hsl = function(hsv) {
        const h = hsv[0];
        const s = hsv[1] / 100;
        const v = hsv[2] / 100;
        const vmin = Math.max(v, 0.01);
        let sl;
        let l;
        l = (2 - s) * v;
        const lmin = (2 - s) * vmin;
        sl = s * vmin;
        sl /= lmin <= 1 ? lmin : 2 - lmin;
        sl = sl || 0;
        l /= 2;
        return [h, sl * 100, l * 100];
      };
      convert.hwb.rgb = function(hwb) {
        const h = hwb[0] / 360;
        let wh = hwb[1] / 100;
        let bl = hwb[2] / 100;
        const ratio = wh + bl;
        let f;
        if (ratio > 1) {
          wh /= ratio;
          bl /= ratio;
        }
        const i = Math.floor(6 * h);
        const v = 1 - bl;
        f = 6 * h - i;
        if ((i & 1) !== 0) {
          f = 1 - f;
        }
        const n = wh + f * (v - wh);
        let r;
        let g4;
        let b;
        switch (i) {
          default:
          case 6:
          case 0:
            r = v;
            g4 = n;
            b = wh;
            break;
          case 1:
            r = n;
            g4 = v;
            b = wh;
            break;
          case 2:
            r = wh;
            g4 = v;
            b = n;
            break;
          case 3:
            r = wh;
            g4 = n;
            b = v;
            break;
          case 4:
            r = n;
            g4 = wh;
            b = v;
            break;
          case 5:
            r = v;
            g4 = wh;
            b = n;
            break;
        }
        return [r * 255, g4 * 255, b * 255];
      };
      convert.cmyk.rgb = function(cmyk) {
        const c = cmyk[0] / 100;
        const m = cmyk[1] / 100;
        const y = cmyk[2] / 100;
        const k = cmyk[3] / 100;
        const r = 1 - Math.min(1, c * (1 - k) + k);
        const g4 = 1 - Math.min(1, m * (1 - k) + k);
        const b = 1 - Math.min(1, y * (1 - k) + k);
        return [r * 255, g4 * 255, b * 255];
      };
      convert.xyz.rgb = function(xyz) {
        const x = xyz[0] / 100;
        const y = xyz[1] / 100;
        const z = xyz[2] / 100;
        let r;
        let g4;
        let b;
        r = x * 3.2406 + y * -1.5372 + z * -0.4986;
        g4 = x * -0.9689 + y * 1.8758 + z * 0.0415;
        b = x * 0.0557 + y * -0.204 + z * 1.057;
        r = r > 31308e-7 ? 1.055 * r ** (1 / 2.4) - 0.055 : r * 12.92;
        g4 = g4 > 31308e-7 ? 1.055 * g4 ** (1 / 2.4) - 0.055 : g4 * 12.92;
        b = b > 31308e-7 ? 1.055 * b ** (1 / 2.4) - 0.055 : b * 12.92;
        r = Math.min(Math.max(0, r), 1);
        g4 = Math.min(Math.max(0, g4), 1);
        b = Math.min(Math.max(0, b), 1);
        return [r * 255, g4 * 255, b * 255];
      };
      convert.xyz.lab = function(xyz) {
        let x = xyz[0];
        let y = xyz[1];
        let z = xyz[2];
        x /= 95.047;
        y /= 100;
        z /= 108.883;
        x = x > 8856e-6 ? x ** (1 / 3) : 7.787 * x + 16 / 116;
        y = y > 8856e-6 ? y ** (1 / 3) : 7.787 * y + 16 / 116;
        z = z > 8856e-6 ? z ** (1 / 3) : 7.787 * z + 16 / 116;
        const l = 116 * y - 16;
        const a = 500 * (x - y);
        const b = 200 * (y - z);
        return [l, a, b];
      };
      convert.lab.xyz = function(lab) {
        const l = lab[0];
        const a = lab[1];
        const b = lab[2];
        let x;
        let y;
        let z;
        y = (l + 16) / 116;
        x = a / 500 + y;
        z = y - b / 200;
        const y2 = y ** 3;
        const x2 = x ** 3;
        const z2 = z ** 3;
        y = y2 > 8856e-6 ? y2 : (y - 16 / 116) / 7.787;
        x = x2 > 8856e-6 ? x2 : (x - 16 / 116) / 7.787;
        z = z2 > 8856e-6 ? z2 : (z - 16 / 116) / 7.787;
        x *= 95.047;
        y *= 100;
        z *= 108.883;
        return [x, y, z];
      };
      convert.lab.lch = function(lab) {
        const l = lab[0];
        const a = lab[1];
        const b = lab[2];
        let h;
        const hr = Math.atan2(b, a);
        h = hr * 360 / 2 / Math.PI;
        if (h < 0) {
          h += 360;
        }
        const c = Math.sqrt(a * a + b * b);
        return [l, c, h];
      };
      convert.lch.lab = function(lch) {
        const l = lch[0];
        const c = lch[1];
        const h = lch[2];
        const hr = h / 360 * 2 * Math.PI;
        const a = c * Math.cos(hr);
        const b = c * Math.sin(hr);
        return [l, a, b];
      };
      convert.rgb.ansi16 = function(args2, saturation = null) {
        const [r, g4, b] = args2;
        let value = saturation === null ? convert.rgb.hsv(args2)[2] : saturation;
        value = Math.round(value / 50);
        if (value === 0) {
          return 30;
        }
        let ansi = 30 + (Math.round(b / 255) << 2 | Math.round(g4 / 255) << 1 | Math.round(r / 255));
        if (value === 2) {
          ansi += 60;
        }
        return ansi;
      };
      convert.hsv.ansi16 = function(args2) {
        return convert.rgb.ansi16(convert.hsv.rgb(args2), args2[2]);
      };
      convert.rgb.ansi256 = function(args2) {
        const r = args2[0];
        const g4 = args2[1];
        const b = args2[2];
        if (r === g4 && g4 === b) {
          if (r < 8) {
            return 16;
          }
          if (r > 248) {
            return 231;
          }
          return Math.round((r - 8) / 247 * 24) + 232;
        }
        const ansi = 16 + 36 * Math.round(r / 255 * 5) + 6 * Math.round(g4 / 255 * 5) + Math.round(b / 255 * 5);
        return ansi;
      };
      convert.ansi16.rgb = function(args2) {
        let color = args2 % 10;
        if (color === 0 || color === 7) {
          if (args2 > 50) {
            color += 3.5;
          }
          color = color / 10.5 * 255;
          return [color, color, color];
        }
        const mult = (~~(args2 > 50) + 1) * 0.5;
        const r = (color & 1) * mult * 255;
        const g4 = (color >> 1 & 1) * mult * 255;
        const b = (color >> 2 & 1) * mult * 255;
        return [r, g4, b];
      };
      convert.ansi256.rgb = function(args2) {
        if (args2 >= 232) {
          const c = (args2 - 232) * 10 + 8;
          return [c, c, c];
        }
        args2 -= 16;
        let rem;
        const r = Math.floor(args2 / 36) / 5 * 255;
        const g4 = Math.floor((rem = args2 % 36) / 6) / 5 * 255;
        const b = rem % 6 / 5 * 255;
        return [r, g4, b];
      };
      convert.rgb.hex = function(args2) {
        const integer = ((Math.round(args2[0]) & 255) << 16) + ((Math.round(args2[1]) & 255) << 8) + (Math.round(args2[2]) & 255);
        const string = integer.toString(16).toUpperCase();
        return "000000".substring(string.length) + string;
      };
      convert.hex.rgb = function(args2) {
        const match = args2.toString(16).match(/[a-f0-9]{6}|[a-f0-9]{3}/i);
        if (!match) {
          return [0, 0, 0];
        }
        let colorString = match[0];
        if (match[0].length === 3) {
          colorString = colorString.split("").map((char) => {
            return char + char;
          }).join("");
        }
        const integer = parseInt(colorString, 16);
        const r = integer >> 16 & 255;
        const g4 = integer >> 8 & 255;
        const b = integer & 255;
        return [r, g4, b];
      };
      convert.rgb.hcg = function(rgb) {
        const r = rgb[0] / 255;
        const g4 = rgb[1] / 255;
        const b = rgb[2] / 255;
        const max2 = Math.max(Math.max(r, g4), b);
        const min = Math.min(Math.min(r, g4), b);
        const chroma = max2 - min;
        let grayscale;
        let hue;
        if (chroma < 1) {
          grayscale = min / (1 - chroma);
        } else {
          grayscale = 0;
        }
        if (chroma <= 0) {
          hue = 0;
        } else if (max2 === r) {
          hue = (g4 - b) / chroma % 6;
        } else if (max2 === g4) {
          hue = 2 + (b - r) / chroma;
        } else {
          hue = 4 + (r - g4) / chroma;
        }
        hue /= 6;
        hue %= 1;
        return [hue * 360, chroma * 100, grayscale * 100];
      };
      convert.hsl.hcg = function(hsl) {
        const s = hsl[1] / 100;
        const l = hsl[2] / 100;
        const c = l < 0.5 ? 2 * s * l : 2 * s * (1 - l);
        let f = 0;
        if (c < 1) {
          f = (l - 0.5 * c) / (1 - c);
        }
        return [hsl[0], c * 100, f * 100];
      };
      convert.hsv.hcg = function(hsv) {
        const s = hsv[1] / 100;
        const v = hsv[2] / 100;
        const c = s * v;
        let f = 0;
        if (c < 1) {
          f = (v - c) / (1 - c);
        }
        return [hsv[0], c * 100, f * 100];
      };
      convert.hcg.rgb = function(hcg) {
        const h = hcg[0] / 360;
        const c = hcg[1] / 100;
        const g4 = hcg[2] / 100;
        if (c === 0) {
          return [g4 * 255, g4 * 255, g4 * 255];
        }
        const pure = [0, 0, 0];
        const hi = h % 1 * 6;
        const v = hi % 1;
        const w = 1 - v;
        let mg = 0;
        switch (Math.floor(hi)) {
          case 0:
            pure[0] = 1;
            pure[1] = v;
            pure[2] = 0;
            break;
          case 1:
            pure[0] = w;
            pure[1] = 1;
            pure[2] = 0;
            break;
          case 2:
            pure[0] = 0;
            pure[1] = 1;
            pure[2] = v;
            break;
          case 3:
            pure[0] = 0;
            pure[1] = w;
            pure[2] = 1;
            break;
          case 4:
            pure[0] = v;
            pure[1] = 0;
            pure[2] = 1;
            break;
          default:
            pure[0] = 1;
            pure[1] = 0;
            pure[2] = w;
        }
        mg = (1 - c) * g4;
        return [
          (c * pure[0] + mg) * 255,
          (c * pure[1] + mg) * 255,
          (c * pure[2] + mg) * 255
        ];
      };
      convert.hcg.hsv = function(hcg) {
        const c = hcg[1] / 100;
        const g4 = hcg[2] / 100;
        const v = c + g4 * (1 - c);
        let f = 0;
        if (v > 0) {
          f = c / v;
        }
        return [hcg[0], f * 100, v * 100];
      };
      convert.hcg.hsl = function(hcg) {
        const c = hcg[1] / 100;
        const g4 = hcg[2] / 100;
        const l = g4 * (1 - c) + 0.5 * c;
        let s = 0;
        if (l > 0 && l < 0.5) {
          s = c / (2 * l);
        } else if (l >= 0.5 && l < 1) {
          s = c / (2 * (1 - l));
        }
        return [hcg[0], s * 100, l * 100];
      };
      convert.hcg.hwb = function(hcg) {
        const c = hcg[1] / 100;
        const g4 = hcg[2] / 100;
        const v = c + g4 * (1 - c);
        return [hcg[0], (v - c) * 100, (1 - v) * 100];
      };
      convert.hwb.hcg = function(hwb) {
        const w = hwb[1] / 100;
        const b = hwb[2] / 100;
        const v = 1 - b;
        const c = v - w;
        let g4 = 0;
        if (c < 1) {
          g4 = (v - c) / (1 - c);
        }
        return [hwb[0], c * 100, g4 * 100];
      };
      convert.apple.rgb = function(apple) {
        return [apple[0] / 65535 * 255, apple[1] / 65535 * 255, apple[2] / 65535 * 255];
      };
      convert.rgb.apple = function(rgb) {
        return [rgb[0] / 255 * 65535, rgb[1] / 255 * 65535, rgb[2] / 255 * 65535];
      };
      convert.gray.rgb = function(args2) {
        return [args2[0] / 100 * 255, args2[0] / 100 * 255, args2[0] / 100 * 255];
      };
      convert.gray.hsl = function(args2) {
        return [0, 0, args2[0]];
      };
      convert.gray.hsv = convert.gray.hsl;
      convert.gray.hwb = function(gray) {
        return [0, 100, gray[0]];
      };
      convert.gray.cmyk = function(gray) {
        return [0, 0, 0, gray[0]];
      };
      convert.gray.lab = function(gray) {
        return [gray[0], 0, 0];
      };
      convert.gray.hex = function(gray) {
        const val = Math.round(gray[0] / 100 * 255) & 255;
        const integer = (val << 16) + (val << 8) + val;
        const string = integer.toString(16).toUpperCase();
        return "000000".substring(string.length) + string;
      };
      convert.rgb.gray = function(rgb) {
        const val = (rgb[0] + rgb[1] + rgb[2]) / 3;
        return [val / 255 * 100];
      };
    }
  });

  // node_modules/.pnpm/color-convert@2.0.1/node_modules/color-convert/route.js
  var require_route = __commonJS({
    "node_modules/.pnpm/color-convert@2.0.1/node_modules/color-convert/route.js"(exports2, module2) {
      var conversions = require_conversions();
      function buildGraph() {
        const graph = {};
        const models = Object.keys(conversions);
        for (let len = models.length, i = 0; i < len; i++) {
          graph[models[i]] = {
            // http://jsperf.com/1-vs-infinity
            // micro-opt, but this is simple.
            distance: -1,
            parent: null
          };
        }
        return graph;
      }
      function deriveBFS(fromModel) {
        const graph = buildGraph();
        const queue = [fromModel];
        graph[fromModel].distance = 0;
        while (queue.length) {
          const current = queue.pop();
          const adjacents = Object.keys(conversions[current]);
          for (let len = adjacents.length, i = 0; i < len; i++) {
            const adjacent = adjacents[i];
            const node = graph[adjacent];
            if (node.distance === -1) {
              node.distance = graph[current].distance + 1;
              node.parent = current;
              queue.unshift(adjacent);
            }
          }
        }
        return graph;
      }
      function link(from, to) {
        return function(args2) {
          return to(from(args2));
        };
      }
      function wrapConversion(toModel, graph) {
        const path4 = [graph[toModel].parent, toModel];
        let fn = conversions[graph[toModel].parent][toModel];
        let cur = graph[toModel].parent;
        while (graph[cur].parent) {
          path4.unshift(graph[cur].parent);
          fn = link(conversions[graph[cur].parent][cur], fn);
          cur = graph[cur].parent;
        }
        fn.conversion = path4;
        return fn;
      }
      module2.exports = function(fromModel) {
        const graph = deriveBFS(fromModel);
        const conversion = {};
        const models = Object.keys(graph);
        for (let len = models.length, i = 0; i < len; i++) {
          const toModel = models[i];
          const node = graph[toModel];
          if (node.parent === null) {
            continue;
          }
          conversion[toModel] = wrapConversion(toModel, graph);
        }
        return conversion;
      };
    }
  });

  // node_modules/.pnpm/color-convert@2.0.1/node_modules/color-convert/index.js
  var require_color_convert = __commonJS({
    "node_modules/.pnpm/color-convert@2.0.1/node_modules/color-convert/index.js"(exports2, module2) {
      var conversions = require_conversions();
      var route = require_route();
      var convert = {};
      var models = Object.keys(conversions);
      function wrapRaw(fn) {
        const wrappedFn = function(...args2) {
          const arg0 = args2[0];
          if (arg0 === void 0 || arg0 === null) {
            return arg0;
          }
          if (arg0.length > 1) {
            args2 = arg0;
          }
          return fn(args2);
        };
        if ("conversion" in fn) {
          wrappedFn.conversion = fn.conversion;
        }
        return wrappedFn;
      }
      function wrapRounded(fn) {
        const wrappedFn = function(...args2) {
          const arg0 = args2[0];
          if (arg0 === void 0 || arg0 === null) {
            return arg0;
          }
          if (arg0.length > 1) {
            args2 = arg0;
          }
          const result = fn(args2);
          if (typeof result === "object") {
            for (let len = result.length, i = 0; i < len; i++) {
              result[i] = Math.round(result[i]);
            }
          }
          return result;
        };
        if ("conversion" in fn) {
          wrappedFn.conversion = fn.conversion;
        }
        return wrappedFn;
      }
      models.forEach((fromModel) => {
        convert[fromModel] = {};
        Object.defineProperty(convert[fromModel], "channels", { value: conversions[fromModel].channels });
        Object.defineProperty(convert[fromModel], "labels", { value: conversions[fromModel].labels });
        const routes = route(fromModel);
        const routeModels = Object.keys(routes);
        routeModels.forEach((toModel) => {
          const fn = routes[toModel];
          convert[fromModel][toModel] = wrapRounded(fn);
          convert[fromModel][toModel].raw = wrapRaw(fn);
        });
      });
      module2.exports = convert;
    }
  });

  // node_modules/.pnpm/ansi-styles@4.3.0/node_modules/ansi-styles/index.js
  var require_ansi_styles = __commonJS({
    "node_modules/.pnpm/ansi-styles@4.3.0/node_modules/ansi-styles/index.js"(exports2, module2) {
      "use strict";
      var wrapAnsi163 = (fn, offset) => (...args2) => {
        const code = fn(...args2);
        return `\x1B[${code + offset}m`;
      };
      var wrapAnsi2563 = (fn, offset) => (...args2) => {
        const code = fn(...args2);
        return `\x1B[${38 + offset};5;${code}m`;
      };
      var wrapAnsi16m3 = (fn, offset) => (...args2) => {
        const rgb = fn(...args2);
        return `\x1B[${38 + offset};2;${rgb[0]};${rgb[1]};${rgb[2]}m`;
      };
      var ansi2ansi = (n) => n;
      var rgb2rgb = (r, g4, b) => [r, g4, b];
      var setLazyProperty = (object, property, get4) => {
        Object.defineProperty(object, property, {
          get: () => {
            const value = get4();
            Object.defineProperty(object, property, {
              value,
              enumerable: true,
              configurable: true
            });
            return value;
          },
          enumerable: true,
          configurable: true
        });
      };
      var colorConvert;
      var makeDynamicStyles = (wrap, targetSpace, identity, isBackground) => {
        if (colorConvert === void 0) {
          colorConvert = require_color_convert();
        }
        const offset = isBackground ? 10 : 0;
        const styles5 = {};
        for (const [sourceSpace, suite] of Object.entries(colorConvert)) {
          const name = sourceSpace === "ansi16" ? "ansi" : sourceSpace;
          if (sourceSpace === targetSpace) {
            styles5[name] = wrap(identity, offset);
          } else if (typeof suite === "object") {
            styles5[name] = wrap(suite[targetSpace], offset);
          }
        }
        return styles5;
      };
      function assembleStyles3() {
        const codes = /* @__PURE__ */ new Map();
        const styles5 = {
          modifier: {
            reset: [0, 0],
            // 21 isn't widely supported and 22 does the same thing
            bold: [1, 22],
            dim: [2, 22],
            italic: [3, 23],
            underline: [4, 24],
            inverse: [7, 27],
            hidden: [8, 28],
            strikethrough: [9, 29]
          },
          color: {
            black: [30, 39],
            red: [31, 39],
            green: [32, 39],
            yellow: [33, 39],
            blue: [34, 39],
            magenta: [35, 39],
            cyan: [36, 39],
            white: [37, 39],
            // Bright color
            blackBright: [90, 39],
            redBright: [91, 39],
            greenBright: [92, 39],
            yellowBright: [93, 39],
            blueBright: [94, 39],
            magentaBright: [95, 39],
            cyanBright: [96, 39],
            whiteBright: [97, 39]
          },
          bgColor: {
            bgBlack: [40, 49],
            bgRed: [41, 49],
            bgGreen: [42, 49],
            bgYellow: [43, 49],
            bgBlue: [44, 49],
            bgMagenta: [45, 49],
            bgCyan: [46, 49],
            bgWhite: [47, 49],
            // Bright color
            bgBlackBright: [100, 49],
            bgRedBright: [101, 49],
            bgGreenBright: [102, 49],
            bgYellowBright: [103, 49],
            bgBlueBright: [104, 49],
            bgMagentaBright: [105, 49],
            bgCyanBright: [106, 49],
            bgWhiteBright: [107, 49]
          }
        };
        styles5.color.gray = styles5.color.blackBright;
        styles5.bgColor.bgGray = styles5.bgColor.bgBlackBright;
        styles5.color.grey = styles5.color.blackBright;
        styles5.bgColor.bgGrey = styles5.bgColor.bgBlackBright;
        for (const [groupName, group] of Object.entries(styles5)) {
          for (const [styleName, style] of Object.entries(group)) {
            styles5[styleName] = {
              open: `\x1B[${style[0]}m`,
              close: `\x1B[${style[1]}m`
            };
            group[styleName] = styles5[styleName];
            codes.set(style[0], style[1]);
          }
          Object.defineProperty(styles5, groupName, {
            value: group,
            enumerable: false
          });
        }
        Object.defineProperty(styles5, "codes", {
          value: codes,
          enumerable: false
        });
        styles5.color.close = "\x1B[39m";
        styles5.bgColor.close = "\x1B[49m";
        setLazyProperty(styles5.color, "ansi", () => makeDynamicStyles(wrapAnsi163, "ansi16", ansi2ansi, false));
        setLazyProperty(styles5.color, "ansi256", () => makeDynamicStyles(wrapAnsi2563, "ansi256", ansi2ansi, false));
        setLazyProperty(styles5.color, "ansi16m", () => makeDynamicStyles(wrapAnsi16m3, "rgb", rgb2rgb, false));
        setLazyProperty(styles5.bgColor, "ansi", () => makeDynamicStyles(wrapAnsi163, "ansi16", ansi2ansi, true));
        setLazyProperty(styles5.bgColor, "ansi256", () => makeDynamicStyles(wrapAnsi2563, "ansi256", ansi2ansi, true));
        setLazyProperty(styles5.bgColor, "ansi16m", () => makeDynamicStyles(wrapAnsi16m3, "rgb", rgb2rgb, true));
        return styles5;
      }
      Object.defineProperty(module2, "exports", {
        enumerable: true,
        get: assembleStyles3
      });
    }
  });

  // node_modules/.pnpm/has-flag@4.0.0/node_modules/has-flag/index.js
  var require_has_flag = __commonJS({
    "node_modules/.pnpm/has-flag@4.0.0/node_modules/has-flag/index.js"(exports2, module2) {
      "use strict";
      module2.exports = (flag, argv = process.argv) => {
        const prefix = flag.startsWith("-") ? "" : flag.length === 1 ? "-" : "--";
        const position = argv.indexOf(prefix + flag);
        const terminatorPosition = argv.indexOf("--");
        return position !== -1 && (terminatorPosition === -1 || position < terminatorPosition);
      };
    }
  });

  // node_modules/.pnpm/supports-color@7.2.0/node_modules/supports-color/index.js
  var require_supports_color = __commonJS({
    "node_modules/.pnpm/supports-color@7.2.0/node_modules/supports-color/index.js"(exports2, module2) {
      "use strict";
      var os5 = __require("os");
      var tty3 = __require("tty");
      var hasFlag3 = require_has_flag();
      var { env: env3 } = process;
      var forceColor;
      if (hasFlag3("no-color") || hasFlag3("no-colors") || hasFlag3("color=false") || hasFlag3("color=never")) {
        forceColor = 0;
      } else if (hasFlag3("color") || hasFlag3("colors") || hasFlag3("color=true") || hasFlag3("color=always")) {
        forceColor = 1;
      }
      if ("FORCE_COLOR" in env3) {
        if (env3.FORCE_COLOR === "true") {
          forceColor = 1;
        } else if (env3.FORCE_COLOR === "false") {
          forceColor = 0;
        } else {
          forceColor = env3.FORCE_COLOR.length === 0 ? 1 : Math.min(parseInt(env3.FORCE_COLOR, 10), 3);
        }
      }
      function translateLevel3(level) {
        if (level === 0) {
          return false;
        }
        return {
          level,
          hasBasic: true,
          has256: level >= 2,
          has16m: level >= 3
        };
      }
      function supportsColor3(haveStream, streamIsTTY) {
        if (forceColor === 0) {
          return 0;
        }
        if (hasFlag3("color=16m") || hasFlag3("color=full") || hasFlag3("color=truecolor")) {
          return 3;
        }
        if (hasFlag3("color=256")) {
          return 2;
        }
        if (haveStream && !streamIsTTY && forceColor === void 0) {
          return 0;
        }
        const min = forceColor || 0;
        if (env3.TERM === "dumb") {
          return min;
        }
        if (process.platform === "win32") {
          const osRelease = os5.release().split(".");
          if (Number(osRelease[0]) >= 10 && Number(osRelease[2]) >= 10586) {
            return Number(osRelease[2]) >= 14931 ? 3 : 2;
          }
          return 1;
        }
        if ("CI" in env3) {
          if (["TRAVIS", "CIRCLECI", "APPVEYOR", "GITLAB_CI", "GITHUB_ACTIONS", "BUILDKITE"].some((sign) => sign in env3) || env3.CI_NAME === "codeship") {
            return 1;
          }
          return min;
        }
        if ("TEAMCITY_VERSION" in env3) {
          return /^(9\.(0*[1-9]\d*)\.|\d{2,}\.)/.test(env3.TEAMCITY_VERSION) ? 1 : 0;
        }
        if (env3.COLORTERM === "truecolor") {
          return 3;
        }
        if ("TERM_PROGRAM" in env3) {
          const version = parseInt((env3.TERM_PROGRAM_VERSION || "").split(".")[0], 10);
          switch (env3.TERM_PROGRAM) {
            case "iTerm.app":
              return version >= 3 ? 3 : 2;
            case "Apple_Terminal":
              return 2;
          }
        }
        if (/-256(color)?$/i.test(env3.TERM)) {
          return 2;
        }
        if (/^screen|^xterm|^vt100|^vt220|^rxvt|color|ansi|cygwin|linux/i.test(env3.TERM)) {
          return 1;
        }
        if ("COLORTERM" in env3) {
          return 1;
        }
        return min;
      }
      function getSupportLevel(stream) {
        const level = supportsColor3(stream, stream && stream.isTTY);
        return translateLevel3(level);
      }
      module2.exports = {
        supportsColor: getSupportLevel,
        stdout: translateLevel3(supportsColor3(true, tty3.isatty(1))),
        stderr: translateLevel3(supportsColor3(true, tty3.isatty(2)))
      };
    }
  });

  // node_modules/.pnpm/chalk@4.0.0/node_modules/chalk/source/util.js
  var require_util = __commonJS({
    "node_modules/.pnpm/chalk@4.0.0/node_modules/chalk/source/util.js"(exports2, module2) {
      "use strict";
      var stringReplaceAll3 = (string, substring, replacer) => {
        let index = string.indexOf(substring);
        if (index === -1) {
          return string;
        }
        const substringLength = substring.length;
        let endIndex = 0;
        let returnValue = "";
        do {
          returnValue += string.substr(endIndex, index - endIndex) + substring + replacer;
          endIndex = index + substringLength;
          index = string.indexOf(substring, endIndex);
        } while (index !== -1);
        returnValue += string.substr(endIndex);
        return returnValue;
      };
      var stringEncaseCRLFWithFirstIndex3 = (string, prefix, postfix, index) => {
        let endIndex = 0;
        let returnValue = "";
        do {
          const gotCR = string[index - 1] === "\r";
          returnValue += string.substr(endIndex, (gotCR ? index - 1 : index) - endIndex) + prefix + (gotCR ? "\r\n" : "\n") + postfix;
          endIndex = index + 1;
          index = string.indexOf("\n", endIndex);
        } while (index !== -1);
        returnValue += string.substr(endIndex);
        return returnValue;
      };
      module2.exports = {
        stringReplaceAll: stringReplaceAll3,
        stringEncaseCRLFWithFirstIndex: stringEncaseCRLFWithFirstIndex3
      };
    }
  });

  // node_modules/.pnpm/chalk@4.0.0/node_modules/chalk/source/templates.js
  var require_templates = __commonJS({
    "node_modules/.pnpm/chalk@4.0.0/node_modules/chalk/source/templates.js"(exports2, module2) {
      "use strict";
      var TEMPLATE_REGEX = /(?:\\(u(?:[a-f\d]{4}|\{[a-f\d]{1,6}\})|x[a-f\d]{2}|.))|(?:\{(~)?(\w+(?:\([^)]*\))?(?:\.\w+(?:\([^)]*\))?)*)(?:[ \t]|(?=\r?\n)))|(\})|((?:.|[\r\n\f])+?)/gi;
      var STYLE_REGEX = /(?:^|\.)(\w+)(?:\(([^)]*)\))?/g;
      var STRING_REGEX = /^(['"])((?:\\.|(?!\1)[^\\])*)\1$/;
      var ESCAPE_REGEX = /\\(u(?:[a-f\d]{4}|{[a-f\d]{1,6}})|x[a-f\d]{2}|.)|([^\\])/gi;
      var ESCAPES = /* @__PURE__ */ new Map([
        ["n", "\n"],
        ["r", "\r"],
        ["t", "	"],
        ["b", "\b"],
        ["f", "\f"],
        ["v", "\v"],
        ["0", "\0"],
        ["\\", "\\"],
        ["e", "\x1B"],
        ["a", "\x07"]
      ]);
      function unescape(c) {
        const u = c[0] === "u";
        const bracket = c[1] === "{";
        if (u && !bracket && c.length === 5 || c[0] === "x" && c.length === 3) {
          return String.fromCharCode(parseInt(c.slice(1), 16));
        }
        if (u && bracket) {
          return String.fromCodePoint(parseInt(c.slice(2, -1), 16));
        }
        return ESCAPES.get(c) || c;
      }
      function parseArguments(name, arguments_) {
        const results = [];
        const chunks = arguments_.trim().split(/\s*,\s*/g);
        let matches;
        for (const chunk of chunks) {
          const number = Number(chunk);
          if (!Number.isNaN(number)) {
            results.push(number);
          } else if (matches = chunk.match(STRING_REGEX)) {
            results.push(matches[2].replace(ESCAPE_REGEX, (m, escape, character) => escape ? unescape(escape) : character));
          } else {
            throw new Error(`Invalid Chalk template style argument: ${chunk} (in style '${name}')`);
          }
        }
        return results;
      }
      function parseStyle(style) {
        STYLE_REGEX.lastIndex = 0;
        const results = [];
        let matches;
        while ((matches = STYLE_REGEX.exec(style)) !== null) {
          const name = matches[1];
          if (matches[2]) {
            const args2 = parseArguments(name, matches[2]);
            results.push([name].concat(args2));
          } else {
            results.push([name]);
          }
        }
        return results;
      }
      function buildStyle(chalk5, styles5) {
        const enabled = {};
        for (const layer of styles5) {
          for (const style of layer.styles) {
            enabled[style[0]] = layer.inverse ? null : style.slice(1);
          }
        }
        let current = chalk5;
        for (const [styleName, styles6] of Object.entries(enabled)) {
          if (!Array.isArray(styles6)) {
            continue;
          }
          if (!(styleName in current)) {
            throw new Error(`Unknown Chalk style: ${styleName}`);
          }
          current = styles6.length > 0 ? current[styleName](...styles6) : current[styleName];
        }
        return current;
      }
      module2.exports = (chalk5, temporary) => {
        const styles5 = [];
        const chunks = [];
        let chunk = [];
        temporary.replace(TEMPLATE_REGEX, (m, escapeCharacter, inverse, style, close, character) => {
          if (escapeCharacter) {
            chunk.push(unescape(escapeCharacter));
          } else if (style) {
            const string = chunk.join("");
            chunk = [];
            chunks.push(styles5.length === 0 ? string : buildStyle(chalk5, styles5)(string));
            styles5.push({ inverse, styles: parseStyle(style) });
          } else if (close) {
            if (styles5.length === 0) {
              throw new Error("Found extraneous } in Chalk template literal");
            }
            chunks.push(buildStyle(chalk5, styles5)(chunk.join("")));
            chunk = [];
            styles5.pop();
          } else {
            chunk.push(character);
          }
        });
        chunks.push(chunk.join(""));
        if (styles5.length > 0) {
          const errMessage = `Chalk template literal is missing ${styles5.length} closing bracket${styles5.length === 1 ? "" : "s"} (\`}\`)`;
          throw new Error(errMessage);
        }
        return chunks.join("");
      };
    }
  });

  // node_modules/.pnpm/chalk@4.0.0/node_modules/chalk/source/index.js
  var require_source = __commonJS({
    "node_modules/.pnpm/chalk@4.0.0/node_modules/chalk/source/index.js"(exports2, module2) {
      "use strict";
      var ansiStyles3 = require_ansi_styles();
      var { stdout: stdoutColor3, stderr: stderrColor3 } = require_supports_color();
      var {
        stringReplaceAll: stringReplaceAll3,
        stringEncaseCRLFWithFirstIndex: stringEncaseCRLFWithFirstIndex3
      } = require_util();
      var levelMapping3 = [
        "ansi",
        "ansi",
        "ansi256",
        "ansi16m"
      ];
      var styles5 = /* @__PURE__ */ Object.create(null);
      var applyOptions3 = (object, options = {}) => {
        if (options.level && !(Number.isInteger(options.level) && options.level >= 0 && options.level <= 3)) {
          throw new Error("The `level` option should be an integer from 0 to 3");
        }
        const colorLevel = stdoutColor3 ? stdoutColor3.level : 0;
        object.level = options.level === void 0 ? colorLevel : options.level;
      };
      var ChalkClass = class {
        constructor(options) {
          return chalkFactory3(options);
        }
      };
      var chalkFactory3 = (options) => {
        const chalk6 = {};
        applyOptions3(chalk6, options);
        chalk6.template = (...arguments_) => chalkTag(chalk6.template, ...arguments_);
        Object.setPrototypeOf(chalk6, Chalk.prototype);
        Object.setPrototypeOf(chalk6.template, chalk6);
        chalk6.template.constructor = () => {
          throw new Error("`chalk.constructor()` is deprecated. Use `new chalk.Instance()` instead.");
        };
        chalk6.template.Instance = ChalkClass;
        return chalk6.template;
      };
      function Chalk(options) {
        return chalkFactory3(options);
      }
      for (const [styleName, style] of Object.entries(ansiStyles3)) {
        styles5[styleName] = {
          get() {
            const builder = createBuilder3(this, createStyler3(style.open, style.close, this._styler), this._isEmpty);
            Object.defineProperty(this, styleName, { value: builder });
            return builder;
          }
        };
      }
      styles5.visible = {
        get() {
          const builder = createBuilder3(this, this._styler, true);
          Object.defineProperty(this, "visible", { value: builder });
          return builder;
        }
      };
      var usedModels3 = ["rgb", "hex", "keyword", "hsl", "hsv", "hwb", "ansi", "ansi256"];
      for (const model of usedModels3) {
        styles5[model] = {
          get() {
            const { level } = this;
            return function(...arguments_) {
              const styler = createStyler3(ansiStyles3.color[levelMapping3[level]][model](...arguments_), ansiStyles3.color.close, this._styler);
              return createBuilder3(this, styler, this._isEmpty);
            };
          }
        };
      }
      for (const model of usedModels3) {
        const bgModel = "bg" + model[0].toUpperCase() + model.slice(1);
        styles5[bgModel] = {
          get() {
            const { level } = this;
            return function(...arguments_) {
              const styler = createStyler3(ansiStyles3.bgColor[levelMapping3[level]][model](...arguments_), ansiStyles3.bgColor.close, this._styler);
              return createBuilder3(this, styler, this._isEmpty);
            };
          }
        };
      }
      var proto3 = Object.defineProperties(() => {
      }, {
        ...styles5,
        level: {
          enumerable: true,
          get() {
            return this._generator.level;
          },
          set(level) {
            this._generator.level = level;
          }
        }
      });
      var createStyler3 = (open, close, parent) => {
        let openAll;
        let closeAll;
        if (parent === void 0) {
          openAll = open;
          closeAll = close;
        } else {
          openAll = parent.openAll + open;
          closeAll = close + parent.closeAll;
        }
        return {
          open,
          close,
          openAll,
          closeAll,
          parent
        };
      };
      var createBuilder3 = (self2, _styler, _isEmpty) => {
        const builder = (...arguments_) => {
          return applyStyle3(builder, arguments_.length === 1 ? "" + arguments_[0] : arguments_.join(" "));
        };
        Object.setPrototypeOf(builder, proto3);
        builder._generator = self2;
        builder._styler = _styler;
        builder._isEmpty = _isEmpty;
        return builder;
      };
      var applyStyle3 = (self2, string) => {
        if (self2.level <= 0 || !string) {
          return self2._isEmpty ? "" : string;
        }
        let styler = self2._styler;
        if (styler === void 0) {
          return string;
        }
        const { openAll, closeAll } = styler;
        if (string.indexOf("\x1B") !== -1) {
          while (styler !== void 0) {
            string = stringReplaceAll3(string, styler.close, styler.open);
            styler = styler.parent;
          }
        }
        const lfIndex = string.indexOf("\n");
        if (lfIndex !== -1) {
          string = stringEncaseCRLFWithFirstIndex3(string, closeAll, openAll, lfIndex);
        }
        return openAll + string + closeAll;
      };
      var template;
      var chalkTag = (chalk6, ...strings) => {
        const [firstString] = strings;
        if (!Array.isArray(firstString)) {
          return strings.join(" ");
        }
        const arguments_ = strings.slice(1);
        const parts = [firstString.raw[0]];
        for (let i = 1; i < firstString.length; i++) {
          parts.push(
            String(arguments_[i - 1]).replace(/[{}\\]/g, "\\$&"),
            String(firstString.raw[i])
          );
        }
        if (template === void 0) {
          template = require_templates();
        }
        return template(chalk6, parts.join(""));
      };
      Object.defineProperties(Chalk.prototype, styles5);
      var chalk5 = Chalk();
      chalk5.supportsColor = stdoutColor3;
      chalk5.stderr = Chalk({ level: stderrColor3 ? stderrColor3.level : 0 });
      chalk5.stderr.supportsColor = stderrColor3;
      module2.exports = chalk5;
    }
  });

  // node_modules/.pnpm/@noble+hashes@1.3.1/node_modules/@noble/hashes/_assert.js
  var require_assert = __commonJS({
    "node_modules/.pnpm/@noble+hashes@1.3.1/node_modules/@noble/hashes/_assert.js"(exports2) {
      "use strict";
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.output = exports2.exists = exports2.hash = exports2.bytes = exports2.bool = exports2.number = void 0;
      function number(n) {
        if (!Number.isSafeInteger(n) || n < 0)
          throw new Error(`Wrong positive integer: ${n}`);
      }
      exports2.number = number;
      function bool(b) {
        if (typeof b !== "boolean")
          throw new Error(`Expected boolean, not ${b}`);
      }
      exports2.bool = bool;
      function bytes(b, ...lengths) {
        if (!(b instanceof Uint8Array))
          throw new Error("Expected Uint8Array");
        if (lengths.length > 0 && !lengths.includes(b.length))
          throw new Error(`Expected Uint8Array of length ${lengths}, not of length=${b.length}`);
      }
      exports2.bytes = bytes;
      function hash(hash2) {
        if (typeof hash2 !== "function" || typeof hash2.create !== "function")
          throw new Error("Hash should be wrapped by utils.wrapConstructor");
        number(hash2.outputLen);
        number(hash2.blockLen);
      }
      exports2.hash = hash;
      function exists(instance, checkFinished = true) {
        if (instance.destroyed)
          throw new Error("Hash instance has been destroyed");
        if (checkFinished && instance.finished)
          throw new Error("Hash#digest() has already been called");
      }
      exports2.exists = exists;
      function output(out, instance) {
        bytes(out);
        const min = instance.outputLen;
        if (out.length < min) {
          throw new Error(`digestInto() expects output buffer of length at least ${min}`);
        }
      }
      exports2.output = output;
      var assert = {
        number,
        bool,
        bytes,
        hash,
        exists,
        output
      };
      exports2.default = assert;
    }
  });

  // node_modules/.pnpm/@noble+hashes@1.3.1/node_modules/@noble/hashes/_u64.js
  var require_u64 = __commonJS({
    "node_modules/.pnpm/@noble+hashes@1.3.1/node_modules/@noble/hashes/_u64.js"(exports2) {
      "use strict";
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.add = exports2.toBig = exports2.split = exports2.fromBig = void 0;
      var U32_MASK64 = BigInt(2 ** 32 - 1);
      var _32n = BigInt(32);
      function fromBig(n, le = false) {
        if (le)
          return { h: Number(n & U32_MASK64), l: Number(n >> _32n & U32_MASK64) };
        return { h: Number(n >> _32n & U32_MASK64) | 0, l: Number(n & U32_MASK64) | 0 };
      }
      exports2.fromBig = fromBig;
      function split(lst, le = false) {
        let Ah = new Uint32Array(lst.length);
        let Al = new Uint32Array(lst.length);
        for (let i = 0; i < lst.length; i++) {
          const { h, l } = fromBig(lst[i], le);
          [Ah[i], Al[i]] = [h, l];
        }
        return [Ah, Al];
      }
      exports2.split = split;
      var toBig = (h, l) => BigInt(h >>> 0) << _32n | BigInt(l >>> 0);
      exports2.toBig = toBig;
      var shrSH = (h, l, s) => h >>> s;
      var shrSL = (h, l, s) => h << 32 - s | l >>> s;
      var rotrSH = (h, l, s) => h >>> s | l << 32 - s;
      var rotrSL = (h, l, s) => h << 32 - s | l >>> s;
      var rotrBH = (h, l, s) => h << 64 - s | l >>> s - 32;
      var rotrBL = (h, l, s) => h >>> s - 32 | l << 64 - s;
      var rotr32H = (h, l) => l;
      var rotr32L = (h, l) => h;
      var rotlSH = (h, l, s) => h << s | l >>> 32 - s;
      var rotlSL = (h, l, s) => l << s | h >>> 32 - s;
      var rotlBH = (h, l, s) => l << s - 32 | h >>> 64 - s;
      var rotlBL = (h, l, s) => h << s - 32 | l >>> 64 - s;
      function add(Ah, Al, Bh, Bl) {
        const l = (Al >>> 0) + (Bl >>> 0);
        return { h: Ah + Bh + (l / 2 ** 32 | 0) | 0, l: l | 0 };
      }
      exports2.add = add;
      var add3L = (Al, Bl, Cl) => (Al >>> 0) + (Bl >>> 0) + (Cl >>> 0);
      var add3H = (low, Ah, Bh, Ch) => Ah + Bh + Ch + (low / 2 ** 32 | 0) | 0;
      var add4L = (Al, Bl, Cl, Dl) => (Al >>> 0) + (Bl >>> 0) + (Cl >>> 0) + (Dl >>> 0);
      var add4H = (low, Ah, Bh, Ch, Dh) => Ah + Bh + Ch + Dh + (low / 2 ** 32 | 0) | 0;
      var add5L = (Al, Bl, Cl, Dl, El) => (Al >>> 0) + (Bl >>> 0) + (Cl >>> 0) + (Dl >>> 0) + (El >>> 0);
      var add5H = (low, Ah, Bh, Ch, Dh, Eh) => Ah + Bh + Ch + Dh + Eh + (low / 2 ** 32 | 0) | 0;
      var u64 = {
        fromBig,
        split,
        toBig: exports2.toBig,
        shrSH,
        shrSL,
        rotrSH,
        rotrSL,
        rotrBH,
        rotrBL,
        rotr32H,
        rotr32L,
        rotlSH,
        rotlSL,
        rotlBH,
        rotlBL,
        add,
        add3L,
        add3H,
        add4L,
        add4H,
        add5H,
        add5L
      };
      exports2.default = u64;
    }
  });

  // node_modules/.pnpm/@noble+hashes@1.3.1/node_modules/@noble/hashes/cryptoNode.js
  var require_cryptoNode = __commonJS({
    "node_modules/.pnpm/@noble+hashes@1.3.1/node_modules/@noble/hashes/cryptoNode.js"(exports2) {
      "use strict";
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.crypto = void 0;
      var nc = __require("node:crypto");
      exports2.crypto = nc && typeof nc === "object" && "webcrypto" in nc ? nc.webcrypto : void 0;
    }
  });

  // node_modules/.pnpm/@noble+hashes@1.3.1/node_modules/@noble/hashes/utils.js
  var require_utils = __commonJS({
    "node_modules/.pnpm/@noble+hashes@1.3.1/node_modules/@noble/hashes/utils.js"(exports2) {
      "use strict";
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.randomBytes = exports2.wrapXOFConstructorWithOpts = exports2.wrapConstructorWithOpts = exports2.wrapConstructor = exports2.checkOpts = exports2.Hash = exports2.concatBytes = exports2.toBytes = exports2.utf8ToBytes = exports2.asyncLoop = exports2.nextTick = exports2.hexToBytes = exports2.bytesToHex = exports2.isLE = exports2.rotr = exports2.createView = exports2.u32 = exports2.u8 = void 0;
      var crypto_1 = require_cryptoNode();
      var u8a = (a) => a instanceof Uint8Array;
      var u82 = (arr) => new Uint8Array(arr.buffer, arr.byteOffset, arr.byteLength);
      exports2.u8 = u82;
      var u32 = (arr) => new Uint32Array(arr.buffer, arr.byteOffset, Math.floor(arr.byteLength / 4));
      exports2.u32 = u32;
      var createView = (arr) => new DataView(arr.buffer, arr.byteOffset, arr.byteLength);
      exports2.createView = createView;
      var rotr = (word, shift) => word << 32 - shift | word >>> shift;
      exports2.rotr = rotr;
      exports2.isLE = new Uint8Array(new Uint32Array([287454020]).buffer)[0] === 68;
      if (!exports2.isLE)
        throw new Error("Non little-endian hardware is not supported");
      var hexes = Array.from({ length: 256 }, (v, i) => i.toString(16).padStart(2, "0"));
      function bytesToHex(bytes) {
        if (!u8a(bytes))
          throw new Error("Uint8Array expected");
        let hex = "";
        for (let i = 0; i < bytes.length; i++) {
          hex += hexes[bytes[i]];
        }
        return hex;
      }
      exports2.bytesToHex = bytesToHex;
      function hexToBytes(hex) {
        if (typeof hex !== "string")
          throw new Error("hex string expected, got " + typeof hex);
        const len = hex.length;
        if (len % 2)
          throw new Error("padded hex string expected, got unpadded hex of length " + len);
        const array = new Uint8Array(len / 2);
        for (let i = 0; i < array.length; i++) {
          const j = i * 2;
          const hexByte = hex.slice(j, j + 2);
          const byte = Number.parseInt(hexByte, 16);
          if (Number.isNaN(byte) || byte < 0)
            throw new Error("Invalid byte sequence");
          array[i] = byte;
        }
        return array;
      }
      exports2.hexToBytes = hexToBytes;
      var nextTick = async () => {
      };
      exports2.nextTick = nextTick;
      async function asyncLoop(iters, tick, cb) {
        let ts = Date.now();
        for (let i = 0; i < iters; i++) {
          cb(i);
          const diff = Date.now() - ts;
          if (diff >= 0 && diff < tick)
            continue;
          await (0, exports2.nextTick)();
          ts += diff;
        }
      }
      exports2.asyncLoop = asyncLoop;
      function utf8ToBytes(str) {
        if (typeof str !== "string")
          throw new Error(`utf8ToBytes expected string, got ${typeof str}`);
        return new Uint8Array(new TextEncoder().encode(str));
      }
      exports2.utf8ToBytes = utf8ToBytes;
      function toBytes(data) {
        if (typeof data === "string")
          data = utf8ToBytes(data);
        if (!u8a(data))
          throw new Error(`expected Uint8Array, got ${typeof data}`);
        return data;
      }
      exports2.toBytes = toBytes;
      function concatBytes(...arrays) {
        const r = new Uint8Array(arrays.reduce((sum, a) => sum + a.length, 0));
        let pad = 0;
        arrays.forEach((a) => {
          if (!u8a(a))
            throw new Error("Uint8Array expected");
          r.set(a, pad);
          pad += a.length;
        });
        return r;
      }
      exports2.concatBytes = concatBytes;
      var Hash = class {
        // Safe version that clones internal state
        clone() {
          return this._cloneInto();
        }
      };
      exports2.Hash = Hash;
      var isPlainObject = (obj) => Object.prototype.toString.call(obj) === "[object Object]" && obj.constructor === Object;
      function checkOpts(defaults, opts) {
        if (opts !== void 0 && (typeof opts !== "object" || !isPlainObject(opts)))
          throw new Error("Options should be object or undefined");
        const merged = Object.assign(defaults, opts);
        return merged;
      }
      exports2.checkOpts = checkOpts;
      function wrapConstructor(hashCons) {
        const hashC = (msg) => hashCons().update(toBytes(msg)).digest();
        const tmp = hashCons();
        hashC.outputLen = tmp.outputLen;
        hashC.blockLen = tmp.blockLen;
        hashC.create = () => hashCons();
        return hashC;
      }
      exports2.wrapConstructor = wrapConstructor;
      function wrapConstructorWithOpts(hashCons) {
        const hashC = (msg, opts) => hashCons(opts).update(toBytes(msg)).digest();
        const tmp = hashCons({});
        hashC.outputLen = tmp.outputLen;
        hashC.blockLen = tmp.blockLen;
        hashC.create = (opts) => hashCons(opts);
        return hashC;
      }
      exports2.wrapConstructorWithOpts = wrapConstructorWithOpts;
      function wrapXOFConstructorWithOpts(hashCons) {
        const hashC = (msg, opts) => hashCons(opts).update(toBytes(msg)).digest();
        const tmp = hashCons({});
        hashC.outputLen = tmp.outputLen;
        hashC.blockLen = tmp.blockLen;
        hashC.create = (opts) => hashCons(opts);
        return hashC;
      }
      exports2.wrapXOFConstructorWithOpts = wrapXOFConstructorWithOpts;
      function randomBytes(bytesLength = 32) {
        if (crypto_1.crypto && typeof crypto_1.crypto.getRandomValues === "function") {
          return crypto_1.crypto.getRandomValues(new Uint8Array(bytesLength));
        }
        throw new Error("crypto.getRandomValues must be defined");
      }
      exports2.randomBytes = randomBytes;
    }
  });

  // node_modules/.pnpm/@noble+hashes@1.3.1/node_modules/@noble/hashes/sha3.js
  var require_sha3 = __commonJS({
    "node_modules/.pnpm/@noble+hashes@1.3.1/node_modules/@noble/hashes/sha3.js"(exports2) {
      "use strict";
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.shake256 = exports2.shake128 = exports2.keccak_512 = exports2.keccak_384 = exports2.keccak_256 = exports2.keccak_224 = exports2.sha3_512 = exports2.sha3_384 = exports2.sha3_256 = exports2.sha3_224 = exports2.Keccak = exports2.keccakP = void 0;
      var _assert_js_1 = require_assert();
      var _u64_js_1 = require_u64();
      var utils_js_1 = require_utils();
      var [SHA3_PI, SHA3_ROTL, _SHA3_IOTA] = [[], [], []];
      var _0n = BigInt(0);
      var _1n = BigInt(1);
      var _2n = BigInt(2);
      var _7n = BigInt(7);
      var _256n = BigInt(256);
      var _0x71n = BigInt(113);
      for (let round = 0, R = _1n, x = 1, y = 0; round < 24; round++) {
        [x, y] = [y, (2 * x + 3 * y) % 5];
        SHA3_PI.push(2 * (5 * y + x));
        SHA3_ROTL.push((round + 1) * (round + 2) / 2 % 64);
        let t = _0n;
        for (let j = 0; j < 7; j++) {
          R = (R << _1n ^ (R >> _7n) * _0x71n) % _256n;
          if (R & _2n)
            t ^= _1n << (_1n << BigInt(j)) - _1n;
        }
        _SHA3_IOTA.push(t);
      }
      var [SHA3_IOTA_H, SHA3_IOTA_L] = _u64_js_1.default.split(_SHA3_IOTA, true);
      var rotlH = (h, l, s) => s > 32 ? _u64_js_1.default.rotlBH(h, l, s) : _u64_js_1.default.rotlSH(h, l, s);
      var rotlL = (h, l, s) => s > 32 ? _u64_js_1.default.rotlBL(h, l, s) : _u64_js_1.default.rotlSL(h, l, s);
      function keccakP(s, rounds = 24) {
        const B = new Uint32Array(5 * 2);
        for (let round = 24 - rounds; round < 24; round++) {
          for (let x = 0; x < 10; x++)
            B[x] = s[x] ^ s[x + 10] ^ s[x + 20] ^ s[x + 30] ^ s[x + 40];
          for (let x = 0; x < 10; x += 2) {
            const idx1 = (x + 8) % 10;
            const idx0 = (x + 2) % 10;
            const B0 = B[idx0];
            const B1 = B[idx0 + 1];
            const Th = rotlH(B0, B1, 1) ^ B[idx1];
            const Tl = rotlL(B0, B1, 1) ^ B[idx1 + 1];
            for (let y = 0; y < 50; y += 10) {
              s[x + y] ^= Th;
              s[x + y + 1] ^= Tl;
            }
          }
          let curH = s[2];
          let curL = s[3];
          for (let t = 0; t < 24; t++) {
            const shift = SHA3_ROTL[t];
            const Th = rotlH(curH, curL, shift);
            const Tl = rotlL(curH, curL, shift);
            const PI = SHA3_PI[t];
            curH = s[PI];
            curL = s[PI + 1];
            s[PI] = Th;
            s[PI + 1] = Tl;
          }
          for (let y = 0; y < 50; y += 10) {
            for (let x = 0; x < 10; x++)
              B[x] = s[y + x];
            for (let x = 0; x < 10; x++)
              s[y + x] ^= ~B[(x + 2) % 10] & B[(x + 4) % 10];
          }
          s[0] ^= SHA3_IOTA_H[round];
          s[1] ^= SHA3_IOTA_L[round];
        }
        B.fill(0);
      }
      exports2.keccakP = keccakP;
      var Keccak = class _Keccak extends utils_js_1.Hash {
        // NOTE: we accept arguments in bytes instead of bits here.
        constructor(blockLen, suffix, outputLen, enableXOF = false, rounds = 24) {
          super();
          this.blockLen = blockLen;
          this.suffix = suffix;
          this.outputLen = outputLen;
          this.enableXOF = enableXOF;
          this.rounds = rounds;
          this.pos = 0;
          this.posOut = 0;
          this.finished = false;
          this.destroyed = false;
          _assert_js_1.default.number(outputLen);
          if (0 >= this.blockLen || this.blockLen >= 200)
            throw new Error("Sha3 supports only keccak-f1600 function");
          this.state = new Uint8Array(200);
          this.state32 = (0, utils_js_1.u32)(this.state);
        }
        keccak() {
          keccakP(this.state32, this.rounds);
          this.posOut = 0;
          this.pos = 0;
        }
        update(data) {
          _assert_js_1.default.exists(this);
          const { blockLen, state } = this;
          data = (0, utils_js_1.toBytes)(data);
          const len = data.length;
          for (let pos = 0; pos < len; ) {
            const take = Math.min(blockLen - this.pos, len - pos);
            for (let i = 0; i < take; i++)
              state[this.pos++] ^= data[pos++];
            if (this.pos === blockLen)
              this.keccak();
          }
          return this;
        }
        finish() {
          if (this.finished)
            return;
          this.finished = true;
          const { state, suffix, pos, blockLen } = this;
          state[pos] ^= suffix;
          if ((suffix & 128) !== 0 && pos === blockLen - 1)
            this.keccak();
          state[blockLen - 1] ^= 128;
          this.keccak();
        }
        writeInto(out) {
          _assert_js_1.default.exists(this, false);
          _assert_js_1.default.bytes(out);
          this.finish();
          const bufferOut = this.state;
          const { blockLen } = this;
          for (let pos = 0, len = out.length; pos < len; ) {
            if (this.posOut >= blockLen)
              this.keccak();
            const take = Math.min(blockLen - this.posOut, len - pos);
            out.set(bufferOut.subarray(this.posOut, this.posOut + take), pos);
            this.posOut += take;
            pos += take;
          }
          return out;
        }
        xofInto(out) {
          if (!this.enableXOF)
            throw new Error("XOF is not possible for this instance");
          return this.writeInto(out);
        }
        xof(bytes) {
          _assert_js_1.default.number(bytes);
          return this.xofInto(new Uint8Array(bytes));
        }
        digestInto(out) {
          _assert_js_1.default.output(out, this);
          if (this.finished)
            throw new Error("digest() was already called");
          this.writeInto(out);
          this.destroy();
          return out;
        }
        digest() {
          return this.digestInto(new Uint8Array(this.outputLen));
        }
        destroy() {
          this.destroyed = true;
          this.state.fill(0);
        }
        _cloneInto(to) {
          const { blockLen, suffix, outputLen, rounds, enableXOF } = this;
          to || (to = new _Keccak(blockLen, suffix, outputLen, enableXOF, rounds));
          to.state32.set(this.state32);
          to.pos = this.pos;
          to.posOut = this.posOut;
          to.finished = this.finished;
          to.rounds = rounds;
          to.suffix = suffix;
          to.outputLen = outputLen;
          to.enableXOF = enableXOF;
          to.destroyed = this.destroyed;
          return to;
        }
      };
      exports2.Keccak = Keccak;
      var gen = (suffix, blockLen, outputLen) => (0, utils_js_1.wrapConstructor)(() => new Keccak(blockLen, suffix, outputLen));
      exports2.sha3_224 = gen(6, 144, 224 / 8);
      exports2.sha3_256 = gen(6, 136, 256 / 8);
      exports2.sha3_384 = gen(6, 104, 384 / 8);
      exports2.sha3_512 = gen(6, 72, 512 / 8);
      exports2.keccak_224 = gen(1, 144, 224 / 8);
      exports2.keccak_256 = gen(1, 136, 256 / 8);
      exports2.keccak_384 = gen(1, 104, 384 / 8);
      exports2.keccak_512 = gen(1, 72, 512 / 8);
      var genShake = (suffix, blockLen, outputLen) => (0, utils_js_1.wrapXOFConstructorWithOpts)((opts = {}) => new Keccak(blockLen, suffix, opts.dkLen === void 0 ? outputLen : opts.dkLen, true));
      exports2.shake128 = genShake(31, 168, 128 / 8);
      exports2.shake256 = genShake(31, 136, 256 / 8);
    }
  });

  // node_modules/.pnpm/@paralleldrive+cuid2@2.0.1/node_modules/@paralleldrive/cuid2/src/index.js
  var require_src = __commonJS({
    "node_modules/.pnpm/@paralleldrive+cuid2@2.0.1/node_modules/@paralleldrive/cuid2/src/index.js"(exports2, module2) {
      var { sha3_512: sha3 } = require_sha3();
      var defaultLength = 24;
      var bigLength = 32;
      var globalObj = typeof global !== "undefined" ? global : typeof window !== "undefined" ? window : [];
      var primes = [
        109717,
        109721,
        109741,
        109751,
        109789,
        109793,
        109807,
        109819,
        109829,
        109831
      ];
      var createEntropy = (length = 4, random = Math.random) => {
        let entropy = "";
        while (entropy.length < length) {
          const randomPrime = primes[Math.floor(random() * primes.length)];
          entropy = entropy + Math.floor(random() * randomPrime).toString(36);
        }
        return entropy.slice(0, length);
      };
      function bufToBigInt(buf) {
        let bits2 = 8n;
        let value = 0n;
        for (const i of buf.values()) {
          const bi = BigInt(i);
          value = (value << bits2) + bi;
        }
        return value;
      }
      var hash = (input = "", length = bigLength) => {
        const salt = createEntropy(length);
        const text = input + salt;
        return bufToBigInt(sha3(text)).toString(36).slice(1);
      };
      var alphabet = Array.from(
        { length: 26 },
        (x, i) => String.fromCharCode(i + 97)
      );
      var randomLetter = (random) => alphabet[Math.floor(random() * alphabet.length)];
      var createFingerprint = (random) => hash(Math.floor((random() + 1) * 2063) + Object.keys(globalObj).toString());
      var createCounter = (count) => () => {
        return count++;
      };
      var init = ({
        random = Math.random,
        counter = createCounter(Math.floor(random() * 2057)),
        length = defaultLength,
        fingerprint = createFingerprint(random)
      } = {}) => {
        return function cuid2() {
          const time = Date.now().toString(36);
          const randomEntropy = createEntropy(length, random);
          const count = counter().toString(36);
          const firstLetter = randomLetter(random);
          const hashInput = `${time + randomEntropy + count + fingerprint}`;
          return `${firstLetter + hash(hashInput, length).substring(1, length)}`;
        };
      };
      var createId4 = init();
      module2.exports.getConstants = () => ({ defaultLength, bigLength });
      module2.exports.init = init;
      module2.exports.createId = createId4;
      module2.exports.bufToBigInt = bufToBigInt;
      module2.exports.createCounter = createCounter;
    }
  });

  // node_modules/.pnpm/@paralleldrive+cuid2@2.0.1/node_modules/@paralleldrive/cuid2/index.js
  var require_cuid2 = __commonJS({
    "node_modules/.pnpm/@paralleldrive+cuid2@2.0.1/node_modules/@paralleldrive/cuid2/index.js"(exports2, module2) {
      var { createId: createId4, init, getConstants } = require_src();
      module2.exports.createId = createId4;
      module2.exports.init = init;
      module2.exports.getConstants = getConstants;
    }
  });

  // node_modules/.pnpm/lodash.get@4.4.2/node_modules/lodash.get/index.js
  var require_lodash2 = __commonJS({
    "node_modules/.pnpm/lodash.get@4.4.2/node_modules/lodash.get/index.js"(exports2, module2) {
      var FUNC_ERROR_TEXT = "Expected a function";
      var HASH_UNDEFINED = "__lodash_hash_undefined__";
      var INFINITY = 1 / 0;
      var funcTag = "[object Function]";
      var genTag = "[object GeneratorFunction]";
      var symbolTag = "[object Symbol]";
      var reIsDeepProp = /\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/;
      var reIsPlainProp = /^\w*$/;
      var reLeadingDot = /^\./;
      var rePropName = /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g;
      var reRegExpChar = /[\\^$.*+?()[\]{}|]/g;
      var reEscapeChar = /\\(\\)?/g;
      var reIsHostCtor = /^\[object .+?Constructor\]$/;
      var freeGlobal = typeof global == "object" && global && global.Object === Object && global;
      var freeSelf = typeof self == "object" && self && self.Object === Object && self;
      var root = freeGlobal || freeSelf || Function("return this")();
      function getValue(object, key) {
        return object == null ? void 0 : object[key];
      }
      function isHostObject(value) {
        var result = false;
        if (value != null && typeof value.toString != "function") {
          try {
            result = !!(value + "");
          } catch (e) {
          }
        }
        return result;
      }
      var arrayProto = Array.prototype;
      var funcProto = Function.prototype;
      var objectProto = Object.prototype;
      var coreJsData = root["__core-js_shared__"];
      var maskSrcKey = function() {
        var uid = /[^.]+$/.exec(coreJsData && coreJsData.keys && coreJsData.keys.IE_PROTO || "");
        return uid ? "Symbol(src)_1." + uid : "";
      }();
      var funcToString = funcProto.toString;
      var hasOwnProperty = objectProto.hasOwnProperty;
      var objectToString = objectProto.toString;
      var reIsNative = RegExp(
        "^" + funcToString.call(hasOwnProperty).replace(reRegExpChar, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$"
      );
      var Symbol2 = root.Symbol;
      var splice = arrayProto.splice;
      var Map2 = getNative(root, "Map");
      var nativeCreate = getNative(Object, "create");
      var symbolProto = Symbol2 ? Symbol2.prototype : void 0;
      var symbolToString = symbolProto ? symbolProto.toString : void 0;
      function Hash(entries) {
        var index = -1, length = entries ? entries.length : 0;
        this.clear();
        while (++index < length) {
          var entry = entries[index];
          this.set(entry[0], entry[1]);
        }
      }
      function hashClear() {
        this.__data__ = nativeCreate ? nativeCreate(null) : {};
      }
      function hashDelete(key) {
        return this.has(key) && delete this.__data__[key];
      }
      function hashGet(key) {
        var data = this.__data__;
        if (nativeCreate) {
          var result = data[key];
          return result === HASH_UNDEFINED ? void 0 : result;
        }
        return hasOwnProperty.call(data, key) ? data[key] : void 0;
      }
      function hashHas(key) {
        var data = this.__data__;
        return nativeCreate ? data[key] !== void 0 : hasOwnProperty.call(data, key);
      }
      function hashSet(key, value) {
        var data = this.__data__;
        data[key] = nativeCreate && value === void 0 ? HASH_UNDEFINED : value;
        return this;
      }
      Hash.prototype.clear = hashClear;
      Hash.prototype["delete"] = hashDelete;
      Hash.prototype.get = hashGet;
      Hash.prototype.has = hashHas;
      Hash.prototype.set = hashSet;
      function ListCache(entries) {
        var index = -1, length = entries ? entries.length : 0;
        this.clear();
        while (++index < length) {
          var entry = entries[index];
          this.set(entry[0], entry[1]);
        }
      }
      function listCacheClear() {
        this.__data__ = [];
      }
      function listCacheDelete(key) {
        var data = this.__data__, index = assocIndexOf(data, key);
        if (index < 0) {
          return false;
        }
        var lastIndex = data.length - 1;
        if (index == lastIndex) {
          data.pop();
        } else {
          splice.call(data, index, 1);
        }
        return true;
      }
      function listCacheGet(key) {
        var data = this.__data__, index = assocIndexOf(data, key);
        return index < 0 ? void 0 : data[index][1];
      }
      function listCacheHas(key) {
        return assocIndexOf(this.__data__, key) > -1;
      }
      function listCacheSet(key, value) {
        var data = this.__data__, index = assocIndexOf(data, key);
        if (index < 0) {
          data.push([key, value]);
        } else {
          data[index][1] = value;
        }
        return this;
      }
      ListCache.prototype.clear = listCacheClear;
      ListCache.prototype["delete"] = listCacheDelete;
      ListCache.prototype.get = listCacheGet;
      ListCache.prototype.has = listCacheHas;
      ListCache.prototype.set = listCacheSet;
      function MapCache(entries) {
        var index = -1, length = entries ? entries.length : 0;
        this.clear();
        while (++index < length) {
          var entry = entries[index];
          this.set(entry[0], entry[1]);
        }
      }
      function mapCacheClear() {
        this.__data__ = {
          "hash": new Hash(),
          "map": new (Map2 || ListCache)(),
          "string": new Hash()
        };
      }
      function mapCacheDelete(key) {
        return getMapData(this, key)["delete"](key);
      }
      function mapCacheGet(key) {
        return getMapData(this, key).get(key);
      }
      function mapCacheHas(key) {
        return getMapData(this, key).has(key);
      }
      function mapCacheSet(key, value) {
        getMapData(this, key).set(key, value);
        return this;
      }
      MapCache.prototype.clear = mapCacheClear;
      MapCache.prototype["delete"] = mapCacheDelete;
      MapCache.prototype.get = mapCacheGet;
      MapCache.prototype.has = mapCacheHas;
      MapCache.prototype.set = mapCacheSet;
      function assocIndexOf(array, key) {
        var length = array.length;
        while (length--) {
          if (eq(array[length][0], key)) {
            return length;
          }
        }
        return -1;
      }
      function baseGet(object, path4) {
        path4 = isKey(path4, object) ? [path4] : castPath(path4);
        var index = 0, length = path4.length;
        while (object != null && index < length) {
          object = object[toKey(path4[index++])];
        }
        return index && index == length ? object : void 0;
      }
      function baseIsNative(value) {
        if (!isObject(value) || isMasked(value)) {
          return false;
        }
        var pattern = isFunction(value) || isHostObject(value) ? reIsNative : reIsHostCtor;
        return pattern.test(toSource(value));
      }
      function baseToString(value) {
        if (typeof value == "string") {
          return value;
        }
        if (isSymbol(value)) {
          return symbolToString ? symbolToString.call(value) : "";
        }
        var result = value + "";
        return result == "0" && 1 / value == -INFINITY ? "-0" : result;
      }
      function castPath(value) {
        return isArray(value) ? value : stringToPath(value);
      }
      function getMapData(map, key) {
        var data = map.__data__;
        return isKeyable(key) ? data[typeof key == "string" ? "string" : "hash"] : data.map;
      }
      function getNative(object, key) {
        var value = getValue(object, key);
        return baseIsNative(value) ? value : void 0;
      }
      function isKey(value, object) {
        if (isArray(value)) {
          return false;
        }
        var type = typeof value;
        if (type == "number" || type == "symbol" || type == "boolean" || value == null || isSymbol(value)) {
          return true;
        }
        return reIsPlainProp.test(value) || !reIsDeepProp.test(value) || object != null && value in Object(object);
      }
      function isKeyable(value) {
        var type = typeof value;
        return type == "string" || type == "number" || type == "symbol" || type == "boolean" ? value !== "__proto__" : value === null;
      }
      function isMasked(func) {
        return !!maskSrcKey && maskSrcKey in func;
      }
      var stringToPath = memoize(function(string) {
        string = toString(string);
        var result = [];
        if (reLeadingDot.test(string)) {
          result.push("");
        }
        string.replace(rePropName, function(match, number, quote, string2) {
          result.push(quote ? string2.replace(reEscapeChar, "$1") : number || match);
        });
        return result;
      });
      function toKey(value) {
        if (typeof value == "string" || isSymbol(value)) {
          return value;
        }
        var result = value + "";
        return result == "0" && 1 / value == -INFINITY ? "-0" : result;
      }
      function toSource(func) {
        if (func != null) {
          try {
            return funcToString.call(func);
          } catch (e) {
          }
          try {
            return func + "";
          } catch (e) {
          }
        }
        return "";
      }
      function memoize(func, resolver) {
        if (typeof func != "function" || resolver && typeof resolver != "function") {
          throw new TypeError(FUNC_ERROR_TEXT);
        }
        var memoized = function() {
          var args2 = arguments, key = resolver ? resolver.apply(this, args2) : args2[0], cache2 = memoized.cache;
          if (cache2.has(key)) {
            return cache2.get(key);
          }
          var result = func.apply(this, args2);
          memoized.cache = cache2.set(key, result);
          return result;
        };
        memoized.cache = new (memoize.Cache || MapCache)();
        return memoized;
      }
      memoize.Cache = MapCache;
      function eq(value, other) {
        return value === other || value !== value && other !== other;
      }
      var isArray = Array.isArray;
      function isFunction(value) {
        var tag = isObject(value) ? objectToString.call(value) : "";
        return tag == funcTag || tag == genTag;
      }
      function isObject(value) {
        var type = typeof value;
        return !!value && (type == "object" || type == "function");
      }
      function isObjectLike(value) {
        return !!value && typeof value == "object";
      }
      function isSymbol(value) {
        return typeof value == "symbol" || isObjectLike(value) && objectToString.call(value) == symbolTag;
      }
      function toString(value) {
        return value == null ? "" : baseToString(value);
      }
      function get4(object, path4, defaultValue) {
        var result = object == null ? void 0 : baseGet(object, path4);
        return result === void 0 ? defaultValue : result;
      }
      module2.exports = get4;
    }
  });

  // node_modules/.pnpm/ws@8.12.1/node_modules/ws/lib/stream.js
  var require_stream = __commonJS({
    "node_modules/.pnpm/ws@8.12.1/node_modules/ws/lib/stream.js"(exports2, module2) {
      "use strict";
      var { Duplex } = __require("stream");
      function emitClose(stream) {
        stream.emit("close");
      }
      function duplexOnEnd() {
        if (!this.destroyed && this._writableState.finished) {
          this.destroy();
        }
      }
      function duplexOnError(err2) {
        this.removeListener("error", duplexOnError);
        this.destroy();
        if (this.listenerCount("error") === 0) {
          this.emit("error", err2);
        }
      }
      function createWebSocketStream2(ws, options) {
        let terminateOnDestroy = true;
        const duplex = new Duplex({
          ...options,
          autoDestroy: false,
          emitClose: false,
          objectMode: false,
          writableObjectMode: false
        });
        ws.on("message", function message(msg, isBinary) {
          const data = !isBinary && duplex._readableState.objectMode ? msg.toString() : msg;
          if (!duplex.push(data))
            ws.pause();
        });
        ws.once("error", function error(err2) {
          if (duplex.destroyed)
            return;
          terminateOnDestroy = false;
          duplex.destroy(err2);
        });
        ws.once("close", function close() {
          if (duplex.destroyed)
            return;
          duplex.push(null);
        });
        duplex._destroy = function(err2, callback) {
          if (ws.readyState === ws.CLOSED) {
            callback(err2);
            process.nextTick(emitClose, duplex);
            return;
          }
          let called = false;
          ws.once("error", function error(err3) {
            called = true;
            callback(err3);
          });
          ws.once("close", function close() {
            if (!called)
              callback(err2);
            process.nextTick(emitClose, duplex);
          });
          if (terminateOnDestroy)
            ws.terminate();
        };
        duplex._final = function(callback) {
          if (ws.readyState === ws.CONNECTING) {
            ws.once("open", function open() {
              duplex._final(callback);
            });
            return;
          }
          if (ws._socket === null)
            return;
          if (ws._socket._writableState.finished) {
            callback();
            if (duplex._readableState.endEmitted)
              duplex.destroy();
          } else {
            ws._socket.once("finish", function finish() {
              callback();
            });
            ws.close();
          }
        };
        duplex._read = function() {
          if (ws.isPaused)
            ws.resume();
        };
        duplex._write = function(chunk, encoding, callback) {
          if (ws.readyState === ws.CONNECTING) {
            ws.once("open", function open() {
              duplex._write(chunk, encoding, callback);
            });
            return;
          }
          ws.send(chunk, callback);
        };
        duplex.on("end", duplexOnEnd);
        duplex.on("error", duplexOnError);
        return duplex;
      }
      module2.exports = createWebSocketStream2;
    }
  });

  // node_modules/.pnpm/ws@8.12.1/node_modules/ws/lib/constants.js
  var require_constants = __commonJS({
    "node_modules/.pnpm/ws@8.12.1/node_modules/ws/lib/constants.js"(exports2, module2) {
      "use strict";
      module2.exports = {
        BINARY_TYPES: ["nodebuffer", "arraybuffer", "fragments"],
        EMPTY_BUFFER: Buffer.alloc(0),
        GUID: "258EAFA5-E914-47DA-95CA-C5AB0DC85B11",
        kForOnEventAttribute: Symbol("kIsForOnEventAttribute"),
        kListener: Symbol("kListener"),
        kStatusCode: Symbol("status-code"),
        kWebSocket: Symbol("websocket"),
        NOOP: () => {
        }
      };
    }
  });

  // node_modules/.pnpm/ws@8.12.1/node_modules/ws/lib/buffer-util.js
  var require_buffer_util = __commonJS({
    "node_modules/.pnpm/ws@8.12.1/node_modules/ws/lib/buffer-util.js"(exports2, module2) {
      "use strict";
      var { EMPTY_BUFFER } = require_constants();
      var FastBuffer = Buffer[Symbol.species];
      function concat(list, totalLength) {
        if (list.length === 0)
          return EMPTY_BUFFER;
        if (list.length === 1)
          return list[0];
        const target = Buffer.allocUnsafe(totalLength);
        let offset = 0;
        for (let i = 0; i < list.length; i++) {
          const buf = list[i];
          target.set(buf, offset);
          offset += buf.length;
        }
        if (offset < totalLength) {
          return new FastBuffer(target.buffer, target.byteOffset, offset);
        }
        return target;
      }
      function _mask(source, mask, output, offset, length) {
        for (let i = 0; i < length; i++) {
          output[offset + i] = source[i] ^ mask[i & 3];
        }
      }
      function _unmask(buffer, mask) {
        for (let i = 0; i < buffer.length; i++) {
          buffer[i] ^= mask[i & 3];
        }
      }
      function toArrayBuffer(buf) {
        if (buf.length === buf.buffer.byteLength) {
          return buf.buffer;
        }
        return buf.buffer.slice(buf.byteOffset, buf.byteOffset + buf.length);
      }
      function toBuffer(data) {
        toBuffer.readOnly = true;
        if (Buffer.isBuffer(data))
          return data;
        let buf;
        if (data instanceof ArrayBuffer) {
          buf = new FastBuffer(data);
        } else if (ArrayBuffer.isView(data)) {
          buf = new FastBuffer(data.buffer, data.byteOffset, data.byteLength);
        } else {
          buf = Buffer.from(data);
          toBuffer.readOnly = false;
        }
        return buf;
      }
      module2.exports = {
        concat,
        mask: _mask,
        toArrayBuffer,
        toBuffer,
        unmask: _unmask
      };
      if (!process.env.WS_NO_BUFFER_UTIL) {
        try {
          const bufferUtil = __require("bufferutil");
          module2.exports.mask = function(source, mask, output, offset, length) {
            if (length < 48)
              _mask(source, mask, output, offset, length);
            else
              bufferUtil.mask(source, mask, output, offset, length);
          };
          module2.exports.unmask = function(buffer, mask) {
            if (buffer.length < 32)
              _unmask(buffer, mask);
            else
              bufferUtil.unmask(buffer, mask);
          };
        } catch (e) {
        }
      }
    }
  });

  // node_modules/.pnpm/ws@8.12.1/node_modules/ws/lib/limiter.js
  var require_limiter = __commonJS({
    "node_modules/.pnpm/ws@8.12.1/node_modules/ws/lib/limiter.js"(exports2, module2) {
      "use strict";
      var kDone = Symbol("kDone");
      var kRun = Symbol("kRun");
      var Limiter = class {
        /**
         * Creates a new `Limiter`.
         *
         * @param {Number} [concurrency=Infinity] The maximum number of jobs allowed
         *     to run concurrently
         */
        constructor(concurrency) {
          this[kDone] = () => {
            this.pending--;
            this[kRun]();
          };
          this.concurrency = concurrency || Infinity;
          this.jobs = [];
          this.pending = 0;
        }
        /**
         * Adds a job to the queue.
         *
         * @param {Function} job The job to run
         * @public
         */
        add(job) {
          this.jobs.push(job);
          this[kRun]();
        }
        /**
         * Removes a job from the queue and runs it if possible.
         *
         * @private
         */
        [kRun]() {
          if (this.pending === this.concurrency)
            return;
          if (this.jobs.length) {
            const job = this.jobs.shift();
            this.pending++;
            job(this[kDone]);
          }
        }
      };
      module2.exports = Limiter;
    }
  });

  // node_modules/.pnpm/ws@8.12.1/node_modules/ws/lib/permessage-deflate.js
  var require_permessage_deflate = __commonJS({
    "node_modules/.pnpm/ws@8.12.1/node_modules/ws/lib/permessage-deflate.js"(exports2, module2) {
      "use strict";
      var zlib = __require("zlib");
      var bufferUtil = require_buffer_util();
      var Limiter = require_limiter();
      var { kStatusCode } = require_constants();
      var FastBuffer = Buffer[Symbol.species];
      var TRAILER = Buffer.from([0, 0, 255, 255]);
      var kPerMessageDeflate = Symbol("permessage-deflate");
      var kTotalLength = Symbol("total-length");
      var kCallback = Symbol("callback");
      var kBuffers = Symbol("buffers");
      var kError = Symbol("error");
      var zlibLimiter;
      var PerMessageDeflate = class {
        /**
         * Creates a PerMessageDeflate instance.
         *
         * @param {Object} [options] Configuration options
         * @param {(Boolean|Number)} [options.clientMaxWindowBits] Advertise support
         *     for, or request, a custom client window size
         * @param {Boolean} [options.clientNoContextTakeover=false] Advertise/
         *     acknowledge disabling of client context takeover
         * @param {Number} [options.concurrencyLimit=10] The number of concurrent
         *     calls to zlib
         * @param {(Boolean|Number)} [options.serverMaxWindowBits] Request/confirm the
         *     use of a custom server window size
         * @param {Boolean} [options.serverNoContextTakeover=false] Request/accept
         *     disabling of server context takeover
         * @param {Number} [options.threshold=1024] Size (in bytes) below which
         *     messages should not be compressed if context takeover is disabled
         * @param {Object} [options.zlibDeflateOptions] Options to pass to zlib on
         *     deflate
         * @param {Object} [options.zlibInflateOptions] Options to pass to zlib on
         *     inflate
         * @param {Boolean} [isServer=false] Create the instance in either server or
         *     client mode
         * @param {Number} [maxPayload=0] The maximum allowed message length
         */
        constructor(options, isServer, maxPayload) {
          this._maxPayload = maxPayload | 0;
          this._options = options || {};
          this._threshold = this._options.threshold !== void 0 ? this._options.threshold : 1024;
          this._isServer = !!isServer;
          this._deflate = null;
          this._inflate = null;
          this.params = null;
          if (!zlibLimiter) {
            const concurrency = this._options.concurrencyLimit !== void 0 ? this._options.concurrencyLimit : 10;
            zlibLimiter = new Limiter(concurrency);
          }
        }
        /**
         * @type {String}
         */
        static get extensionName() {
          return "permessage-deflate";
        }
        /**
         * Create an extension negotiation offer.
         *
         * @return {Object} Extension parameters
         * @public
         */
        offer() {
          const params = {};
          if (this._options.serverNoContextTakeover) {
            params.server_no_context_takeover = true;
          }
          if (this._options.clientNoContextTakeover) {
            params.client_no_context_takeover = true;
          }
          if (this._options.serverMaxWindowBits) {
            params.server_max_window_bits = this._options.serverMaxWindowBits;
          }
          if (this._options.clientMaxWindowBits) {
            params.client_max_window_bits = this._options.clientMaxWindowBits;
          } else if (this._options.clientMaxWindowBits == null) {
            params.client_max_window_bits = true;
          }
          return params;
        }
        /**
         * Accept an extension negotiation offer/response.
         *
         * @param {Array} configurations The extension negotiation offers/reponse
         * @return {Object} Accepted configuration
         * @public
         */
        accept(configurations) {
          configurations = this.normalizeParams(configurations);
          this.params = this._isServer ? this.acceptAsServer(configurations) : this.acceptAsClient(configurations);
          return this.params;
        }
        /**
         * Releases all resources used by the extension.
         *
         * @public
         */
        cleanup() {
          if (this._inflate) {
            this._inflate.close();
            this._inflate = null;
          }
          if (this._deflate) {
            const callback = this._deflate[kCallback];
            this._deflate.close();
            this._deflate = null;
            if (callback) {
              callback(
                new Error(
                  "The deflate stream was closed while data was being processed"
                )
              );
            }
          }
        }
        /**
         *  Accept an extension negotiation offer.
         *
         * @param {Array} offers The extension negotiation offers
         * @return {Object} Accepted configuration
         * @private
         */
        acceptAsServer(offers) {
          const opts = this._options;
          const accepted = offers.find((params) => {
            if (opts.serverNoContextTakeover === false && params.server_no_context_takeover || params.server_max_window_bits && (opts.serverMaxWindowBits === false || typeof opts.serverMaxWindowBits === "number" && opts.serverMaxWindowBits > params.server_max_window_bits) || typeof opts.clientMaxWindowBits === "number" && !params.client_max_window_bits) {
              return false;
            }
            return true;
          });
          if (!accepted) {
            throw new Error("None of the extension offers can be accepted");
          }
          if (opts.serverNoContextTakeover) {
            accepted.server_no_context_takeover = true;
          }
          if (opts.clientNoContextTakeover) {
            accepted.client_no_context_takeover = true;
          }
          if (typeof opts.serverMaxWindowBits === "number") {
            accepted.server_max_window_bits = opts.serverMaxWindowBits;
          }
          if (typeof opts.clientMaxWindowBits === "number") {
            accepted.client_max_window_bits = opts.clientMaxWindowBits;
          } else if (accepted.client_max_window_bits === true || opts.clientMaxWindowBits === false) {
            delete accepted.client_max_window_bits;
          }
          return accepted;
        }
        /**
         * Accept the extension negotiation response.
         *
         * @param {Array} response The extension negotiation response
         * @return {Object} Accepted configuration
         * @private
         */
        acceptAsClient(response) {
          const params = response[0];
          if (this._options.clientNoContextTakeover === false && params.client_no_context_takeover) {
            throw new Error('Unexpected parameter "client_no_context_takeover"');
          }
          if (!params.client_max_window_bits) {
            if (typeof this._options.clientMaxWindowBits === "number") {
              params.client_max_window_bits = this._options.clientMaxWindowBits;
            }
          } else if (this._options.clientMaxWindowBits === false || typeof this._options.clientMaxWindowBits === "number" && params.client_max_window_bits > this._options.clientMaxWindowBits) {
            throw new Error(
              'Unexpected or invalid parameter "client_max_window_bits"'
            );
          }
          return params;
        }
        /**
         * Normalize parameters.
         *
         * @param {Array} configurations The extension negotiation offers/reponse
         * @return {Array} The offers/response with normalized parameters
         * @private
         */
        normalizeParams(configurations) {
          configurations.forEach((params) => {
            Object.keys(params).forEach((key) => {
              let value = params[key];
              if (value.length > 1) {
                throw new Error(`Parameter "${key}" must have only a single value`);
              }
              value = value[0];
              if (key === "client_max_window_bits") {
                if (value !== true) {
                  const num = +value;
                  if (!Number.isInteger(num) || num < 8 || num > 15) {
                    throw new TypeError(
                      `Invalid value for parameter "${key}": ${value}`
                    );
                  }
                  value = num;
                } else if (!this._isServer) {
                  throw new TypeError(
                    `Invalid value for parameter "${key}": ${value}`
                  );
                }
              } else if (key === "server_max_window_bits") {
                const num = +value;
                if (!Number.isInteger(num) || num < 8 || num > 15) {
                  throw new TypeError(
                    `Invalid value for parameter "${key}": ${value}`
                  );
                }
                value = num;
              } else if (key === "client_no_context_takeover" || key === "server_no_context_takeover") {
                if (value !== true) {
                  throw new TypeError(
                    `Invalid value for parameter "${key}": ${value}`
                  );
                }
              } else {
                throw new Error(`Unknown parameter "${key}"`);
              }
              params[key] = value;
            });
          });
          return configurations;
        }
        /**
         * Decompress data. Concurrency limited.
         *
         * @param {Buffer} data Compressed data
         * @param {Boolean} fin Specifies whether or not this is the last fragment
         * @param {Function} callback Callback
         * @public
         */
        decompress(data, fin, callback) {
          zlibLimiter.add((done) => {
            this._decompress(data, fin, (err2, result) => {
              done();
              callback(err2, result);
            });
          });
        }
        /**
         * Compress data. Concurrency limited.
         *
         * @param {(Buffer|String)} data Data to compress
         * @param {Boolean} fin Specifies whether or not this is the last fragment
         * @param {Function} callback Callback
         * @public
         */
        compress(data, fin, callback) {
          zlibLimiter.add((done) => {
            this._compress(data, fin, (err2, result) => {
              done();
              callback(err2, result);
            });
          });
        }
        /**
         * Decompress data.
         *
         * @param {Buffer} data Compressed data
         * @param {Boolean} fin Specifies whether or not this is the last fragment
         * @param {Function} callback Callback
         * @private
         */
        _decompress(data, fin, callback) {
          const endpoint = this._isServer ? "client" : "server";
          if (!this._inflate) {
            const key = `${endpoint}_max_window_bits`;
            const windowBits = typeof this.params[key] !== "number" ? zlib.Z_DEFAULT_WINDOWBITS : this.params[key];
            this._inflate = zlib.createInflateRaw({
              ...this._options.zlibInflateOptions,
              windowBits
            });
            this._inflate[kPerMessageDeflate] = this;
            this._inflate[kTotalLength] = 0;
            this._inflate[kBuffers] = [];
            this._inflate.on("error", inflateOnError);
            this._inflate.on("data", inflateOnData);
          }
          this._inflate[kCallback] = callback;
          this._inflate.write(data);
          if (fin)
            this._inflate.write(TRAILER);
          this._inflate.flush(() => {
            const err2 = this._inflate[kError];
            if (err2) {
              this._inflate.close();
              this._inflate = null;
              callback(err2);
              return;
            }
            const data2 = bufferUtil.concat(
              this._inflate[kBuffers],
              this._inflate[kTotalLength]
            );
            if (this._inflate._readableState.endEmitted) {
              this._inflate.close();
              this._inflate = null;
            } else {
              this._inflate[kTotalLength] = 0;
              this._inflate[kBuffers] = [];
              if (fin && this.params[`${endpoint}_no_context_takeover`]) {
                this._inflate.reset();
              }
            }
            callback(null, data2);
          });
        }
        /**
         * Compress data.
         *
         * @param {(Buffer|String)} data Data to compress
         * @param {Boolean} fin Specifies whether or not this is the last fragment
         * @param {Function} callback Callback
         * @private
         */
        _compress(data, fin, callback) {
          const endpoint = this._isServer ? "server" : "client";
          if (!this._deflate) {
            const key = `${endpoint}_max_window_bits`;
            const windowBits = typeof this.params[key] !== "number" ? zlib.Z_DEFAULT_WINDOWBITS : this.params[key];
            this._deflate = zlib.createDeflateRaw({
              ...this._options.zlibDeflateOptions,
              windowBits
            });
            this._deflate[kTotalLength] = 0;
            this._deflate[kBuffers] = [];
            this._deflate.on("data", deflateOnData);
          }
          this._deflate[kCallback] = callback;
          this._deflate.write(data);
          this._deflate.flush(zlib.Z_SYNC_FLUSH, () => {
            if (!this._deflate) {
              return;
            }
            let data2 = bufferUtil.concat(
              this._deflate[kBuffers],
              this._deflate[kTotalLength]
            );
            if (fin) {
              data2 = new FastBuffer(data2.buffer, data2.byteOffset, data2.length - 4);
            }
            this._deflate[kCallback] = null;
            this._deflate[kTotalLength] = 0;
            this._deflate[kBuffers] = [];
            if (fin && this.params[`${endpoint}_no_context_takeover`]) {
              this._deflate.reset();
            }
            callback(null, data2);
          });
        }
      };
      module2.exports = PerMessageDeflate;
      function deflateOnData(chunk) {
        this[kBuffers].push(chunk);
        this[kTotalLength] += chunk.length;
      }
      function inflateOnData(chunk) {
        this[kTotalLength] += chunk.length;
        if (this[kPerMessageDeflate]._maxPayload < 1 || this[kTotalLength] <= this[kPerMessageDeflate]._maxPayload) {
          this[kBuffers].push(chunk);
          return;
        }
        this[kError] = new RangeError("Max payload size exceeded");
        this[kError].code = "WS_ERR_UNSUPPORTED_MESSAGE_LENGTH";
        this[kError][kStatusCode] = 1009;
        this.removeListener("data", inflateOnData);
        this.reset();
      }
      function inflateOnError(err2) {
        this[kPerMessageDeflate]._inflate = null;
        err2[kStatusCode] = 1007;
        this[kCallback](err2);
      }
    }
  });

  // node_modules/.pnpm/ws@8.12.1/node_modules/ws/lib/validation.js
  var require_validation = __commonJS({
    "node_modules/.pnpm/ws@8.12.1/node_modules/ws/lib/validation.js"(exports2, module2) {
      "use strict";
      var { isUtf8 } = __require("buffer");
      var tokenChars = [
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        // 0 - 15
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        // 16 - 31
        0,
        1,
        0,
        1,
        1,
        1,
        1,
        1,
        0,
        0,
        1,
        1,
        0,
        1,
        1,
        0,
        // 32 - 47
        1,
        1,
        1,
        1,
        1,
        1,
        1,
        1,
        1,
        1,
        0,
        0,
        0,
        0,
        0,
        0,
        // 48 - 63
        0,
        1,
        1,
        1,
        1,
        1,
        1,
        1,
        1,
        1,
        1,
        1,
        1,
        1,
        1,
        1,
        // 64 - 79
        1,
        1,
        1,
        1,
        1,
        1,
        1,
        1,
        1,
        1,
        1,
        0,
        0,
        0,
        1,
        1,
        // 80 - 95
        1,
        1,
        1,
        1,
        1,
        1,
        1,
        1,
        1,
        1,
        1,
        1,
        1,
        1,
        1,
        1,
        // 96 - 111
        1,
        1,
        1,
        1,
        1,
        1,
        1,
        1,
        1,
        1,
        1,
        0,
        1,
        0,
        1,
        0
        // 112 - 127
      ];
      function isValidStatusCode(code) {
        return code >= 1e3 && code <= 1014 && code !== 1004 && code !== 1005 && code !== 1006 || code >= 3e3 && code <= 4999;
      }
      function _isValidUTF8(buf) {
        const len = buf.length;
        let i = 0;
        while (i < len) {
          if ((buf[i] & 128) === 0) {
            i++;
          } else if ((buf[i] & 224) === 192) {
            if (i + 1 === len || (buf[i + 1] & 192) !== 128 || (buf[i] & 254) === 192) {
              return false;
            }
            i += 2;
          } else if ((buf[i] & 240) === 224) {
            if (i + 2 >= len || (buf[i + 1] & 192) !== 128 || (buf[i + 2] & 192) !== 128 || buf[i] === 224 && (buf[i + 1] & 224) === 128 || // Overlong
            buf[i] === 237 && (buf[i + 1] & 224) === 160) {
              return false;
            }
            i += 3;
          } else if ((buf[i] & 248) === 240) {
            if (i + 3 >= len || (buf[i + 1] & 192) !== 128 || (buf[i + 2] & 192) !== 128 || (buf[i + 3] & 192) !== 128 || buf[i] === 240 && (buf[i + 1] & 240) === 128 || // Overlong
            buf[i] === 244 && buf[i + 1] > 143 || buf[i] > 244) {
              return false;
            }
            i += 4;
          } else {
            return false;
          }
        }
        return true;
      }
      module2.exports = {
        isValidStatusCode,
        isValidUTF8: _isValidUTF8,
        tokenChars
      };
      if (isUtf8) {
        module2.exports.isValidUTF8 = function(buf) {
          return buf.length < 24 ? _isValidUTF8(buf) : isUtf8(buf);
        };
      } else if (!process.env.WS_NO_UTF_8_VALIDATE) {
        try {
          const isValidUTF8 = __require("utf-8-validate");
          module2.exports.isValidUTF8 = function(buf) {
            return buf.length < 32 ? _isValidUTF8(buf) : isValidUTF8(buf);
          };
        } catch (e) {
        }
      }
    }
  });

  // node_modules/.pnpm/ws@8.12.1/node_modules/ws/lib/receiver.js
  var require_receiver = __commonJS({
    "node_modules/.pnpm/ws@8.12.1/node_modules/ws/lib/receiver.js"(exports2, module2) {
      "use strict";
      var { Writable } = __require("stream");
      var PerMessageDeflate = require_permessage_deflate();
      var {
        BINARY_TYPES,
        EMPTY_BUFFER,
        kStatusCode,
        kWebSocket
      } = require_constants();
      var { concat, toArrayBuffer, unmask } = require_buffer_util();
      var { isValidStatusCode, isValidUTF8 } = require_validation();
      var FastBuffer = Buffer[Symbol.species];
      var GET_INFO = 0;
      var GET_PAYLOAD_LENGTH_16 = 1;
      var GET_PAYLOAD_LENGTH_64 = 2;
      var GET_MASK = 3;
      var GET_DATA = 4;
      var INFLATING = 5;
      var Receiver2 = class extends Writable {
        /**
         * Creates a Receiver instance.
         *
         * @param {Object} [options] Options object
         * @param {String} [options.binaryType=nodebuffer] The type for binary data
         * @param {Object} [options.extensions] An object containing the negotiated
         *     extensions
         * @param {Boolean} [options.isServer=false] Specifies whether to operate in
         *     client or server mode
         * @param {Number} [options.maxPayload=0] The maximum allowed message length
         * @param {Boolean} [options.skipUTF8Validation=false] Specifies whether or
         *     not to skip UTF-8 validation for text and close messages
         */
        constructor(options = {}) {
          super();
          this._binaryType = options.binaryType || BINARY_TYPES[0];
          this._extensions = options.extensions || {};
          this._isServer = !!options.isServer;
          this._maxPayload = options.maxPayload | 0;
          this._skipUTF8Validation = !!options.skipUTF8Validation;
          this[kWebSocket] = void 0;
          this._bufferedBytes = 0;
          this._buffers = [];
          this._compressed = false;
          this._payloadLength = 0;
          this._mask = void 0;
          this._fragmented = 0;
          this._masked = false;
          this._fin = false;
          this._opcode = 0;
          this._totalPayloadLength = 0;
          this._messageLength = 0;
          this._fragments = [];
          this._state = GET_INFO;
          this._loop = false;
        }
        /**
         * Implements `Writable.prototype._write()`.
         *
         * @param {Buffer} chunk The chunk of data to write
         * @param {String} encoding The character encoding of `chunk`
         * @param {Function} cb Callback
         * @private
         */
        _write(chunk, encoding, cb) {
          if (this._opcode === 8 && this._state == GET_INFO)
            return cb();
          this._bufferedBytes += chunk.length;
          this._buffers.push(chunk);
          this.startLoop(cb);
        }
        /**
         * Consumes `n` bytes from the buffered data.
         *
         * @param {Number} n The number of bytes to consume
         * @return {Buffer} The consumed bytes
         * @private
         */
        consume(n) {
          this._bufferedBytes -= n;
          if (n === this._buffers[0].length)
            return this._buffers.shift();
          if (n < this._buffers[0].length) {
            const buf = this._buffers[0];
            this._buffers[0] = new FastBuffer(
              buf.buffer,
              buf.byteOffset + n,
              buf.length - n
            );
            return new FastBuffer(buf.buffer, buf.byteOffset, n);
          }
          const dst = Buffer.allocUnsafe(n);
          do {
            const buf = this._buffers[0];
            const offset = dst.length - n;
            if (n >= buf.length) {
              dst.set(this._buffers.shift(), offset);
            } else {
              dst.set(new Uint8Array(buf.buffer, buf.byteOffset, n), offset);
              this._buffers[0] = new FastBuffer(
                buf.buffer,
                buf.byteOffset + n,
                buf.length - n
              );
            }
            n -= buf.length;
          } while (n > 0);
          return dst;
        }
        /**
         * Starts the parsing loop.
         *
         * @param {Function} cb Callback
         * @private
         */
        startLoop(cb) {
          let err2;
          this._loop = true;
          do {
            switch (this._state) {
              case GET_INFO:
                err2 = this.getInfo();
                break;
              case GET_PAYLOAD_LENGTH_16:
                err2 = this.getPayloadLength16();
                break;
              case GET_PAYLOAD_LENGTH_64:
                err2 = this.getPayloadLength64();
                break;
              case GET_MASK:
                this.getMask();
                break;
              case GET_DATA:
                err2 = this.getData(cb);
                break;
              default:
                this._loop = false;
                return;
            }
          } while (this._loop);
          cb(err2);
        }
        /**
         * Reads the first two bytes of a frame.
         *
         * @return {(RangeError|undefined)} A possible error
         * @private
         */
        getInfo() {
          if (this._bufferedBytes < 2) {
            this._loop = false;
            return;
          }
          const buf = this.consume(2);
          if ((buf[0] & 48) !== 0) {
            this._loop = false;
            return error(
              RangeError,
              "RSV2 and RSV3 must be clear",
              true,
              1002,
              "WS_ERR_UNEXPECTED_RSV_2_3"
            );
          }
          const compressed = (buf[0] & 64) === 64;
          if (compressed && !this._extensions[PerMessageDeflate.extensionName]) {
            this._loop = false;
            return error(
              RangeError,
              "RSV1 must be clear",
              true,
              1002,
              "WS_ERR_UNEXPECTED_RSV_1"
            );
          }
          this._fin = (buf[0] & 128) === 128;
          this._opcode = buf[0] & 15;
          this._payloadLength = buf[1] & 127;
          if (this._opcode === 0) {
            if (compressed) {
              this._loop = false;
              return error(
                RangeError,
                "RSV1 must be clear",
                true,
                1002,
                "WS_ERR_UNEXPECTED_RSV_1"
              );
            }
            if (!this._fragmented) {
              this._loop = false;
              return error(
                RangeError,
                "invalid opcode 0",
                true,
                1002,
                "WS_ERR_INVALID_OPCODE"
              );
            }
            this._opcode = this._fragmented;
          } else if (this._opcode === 1 || this._opcode === 2) {
            if (this._fragmented) {
              this._loop = false;
              return error(
                RangeError,
                `invalid opcode ${this._opcode}`,
                true,
                1002,
                "WS_ERR_INVALID_OPCODE"
              );
            }
            this._compressed = compressed;
          } else if (this._opcode > 7 && this._opcode < 11) {
            if (!this._fin) {
              this._loop = false;
              return error(
                RangeError,
                "FIN must be set",
                true,
                1002,
                "WS_ERR_EXPECTED_FIN"
              );
            }
            if (compressed) {
              this._loop = false;
              return error(
                RangeError,
                "RSV1 must be clear",
                true,
                1002,
                "WS_ERR_UNEXPECTED_RSV_1"
              );
            }
            if (this._payloadLength > 125 || this._opcode === 8 && this._payloadLength === 1) {
              this._loop = false;
              return error(
                RangeError,
                `invalid payload length ${this._payloadLength}`,
                true,
                1002,
                "WS_ERR_INVALID_CONTROL_PAYLOAD_LENGTH"
              );
            }
          } else {
            this._loop = false;
            return error(
              RangeError,
              `invalid opcode ${this._opcode}`,
              true,
              1002,
              "WS_ERR_INVALID_OPCODE"
            );
          }
          if (!this._fin && !this._fragmented)
            this._fragmented = this._opcode;
          this._masked = (buf[1] & 128) === 128;
          if (this._isServer) {
            if (!this._masked) {
              this._loop = false;
              return error(
                RangeError,
                "MASK must be set",
                true,
                1002,
                "WS_ERR_EXPECTED_MASK"
              );
            }
          } else if (this._masked) {
            this._loop = false;
            return error(
              RangeError,
              "MASK must be clear",
              true,
              1002,
              "WS_ERR_UNEXPECTED_MASK"
            );
          }
          if (this._payloadLength === 126)
            this._state = GET_PAYLOAD_LENGTH_16;
          else if (this._payloadLength === 127)
            this._state = GET_PAYLOAD_LENGTH_64;
          else
            return this.haveLength();
        }
        /**
         * Gets extended payload length (7+16).
         *
         * @return {(RangeError|undefined)} A possible error
         * @private
         */
        getPayloadLength16() {
          if (this._bufferedBytes < 2) {
            this._loop = false;
            return;
          }
          this._payloadLength = this.consume(2).readUInt16BE(0);
          return this.haveLength();
        }
        /**
         * Gets extended payload length (7+64).
         *
         * @return {(RangeError|undefined)} A possible error
         * @private
         */
        getPayloadLength64() {
          if (this._bufferedBytes < 8) {
            this._loop = false;
            return;
          }
          const buf = this.consume(8);
          const num = buf.readUInt32BE(0);
          if (num > Math.pow(2, 53 - 32) - 1) {
            this._loop = false;
            return error(
              RangeError,
              "Unsupported WebSocket frame: payload length > 2^53 - 1",
              false,
              1009,
              "WS_ERR_UNSUPPORTED_DATA_PAYLOAD_LENGTH"
            );
          }
          this._payloadLength = num * Math.pow(2, 32) + buf.readUInt32BE(4);
          return this.haveLength();
        }
        /**
         * Payload length has been read.
         *
         * @return {(RangeError|undefined)} A possible error
         * @private
         */
        haveLength() {
          if (this._payloadLength && this._opcode < 8) {
            this._totalPayloadLength += this._payloadLength;
            if (this._totalPayloadLength > this._maxPayload && this._maxPayload > 0) {
              this._loop = false;
              return error(
                RangeError,
                "Max payload size exceeded",
                false,
                1009,
                "WS_ERR_UNSUPPORTED_MESSAGE_LENGTH"
              );
            }
          }
          if (this._masked)
            this._state = GET_MASK;
          else
            this._state = GET_DATA;
        }
        /**
         * Reads mask bytes.
         *
         * @private
         */
        getMask() {
          if (this._bufferedBytes < 4) {
            this._loop = false;
            return;
          }
          this._mask = this.consume(4);
          this._state = GET_DATA;
        }
        /**
         * Reads data bytes.
         *
         * @param {Function} cb Callback
         * @return {(Error|RangeError|undefined)} A possible error
         * @private
         */
        getData(cb) {
          let data = EMPTY_BUFFER;
          if (this._payloadLength) {
            if (this._bufferedBytes < this._payloadLength) {
              this._loop = false;
              return;
            }
            data = this.consume(this._payloadLength);
            if (this._masked && (this._mask[0] | this._mask[1] | this._mask[2] | this._mask[3]) !== 0) {
              unmask(data, this._mask);
            }
          }
          if (this._opcode > 7)
            return this.controlMessage(data);
          if (this._compressed) {
            this._state = INFLATING;
            this.decompress(data, cb);
            return;
          }
          if (data.length) {
            this._messageLength = this._totalPayloadLength;
            this._fragments.push(data);
          }
          return this.dataMessage();
        }
        /**
         * Decompresses data.
         *
         * @param {Buffer} data Compressed data
         * @param {Function} cb Callback
         * @private
         */
        decompress(data, cb) {
          const perMessageDeflate = this._extensions[PerMessageDeflate.extensionName];
          perMessageDeflate.decompress(data, this._fin, (err2, buf) => {
            if (err2)
              return cb(err2);
            if (buf.length) {
              this._messageLength += buf.length;
              if (this._messageLength > this._maxPayload && this._maxPayload > 0) {
                return cb(
                  error(
                    RangeError,
                    "Max payload size exceeded",
                    false,
                    1009,
                    "WS_ERR_UNSUPPORTED_MESSAGE_LENGTH"
                  )
                );
              }
              this._fragments.push(buf);
            }
            const er = this.dataMessage();
            if (er)
              return cb(er);
            this.startLoop(cb);
          });
        }
        /**
         * Handles a data message.
         *
         * @return {(Error|undefined)} A possible error
         * @private
         */
        dataMessage() {
          if (this._fin) {
            const messageLength = this._messageLength;
            const fragments = this._fragments;
            this._totalPayloadLength = 0;
            this._messageLength = 0;
            this._fragmented = 0;
            this._fragments = [];
            if (this._opcode === 2) {
              let data;
              if (this._binaryType === "nodebuffer") {
                data = concat(fragments, messageLength);
              } else if (this._binaryType === "arraybuffer") {
                data = toArrayBuffer(concat(fragments, messageLength));
              } else {
                data = fragments;
              }
              this.emit("message", data, true);
            } else {
              const buf = concat(fragments, messageLength);
              if (!this._skipUTF8Validation && !isValidUTF8(buf)) {
                this._loop = false;
                return error(
                  Error,
                  "invalid UTF-8 sequence",
                  true,
                  1007,
                  "WS_ERR_INVALID_UTF8"
                );
              }
              this.emit("message", buf, false);
            }
          }
          this._state = GET_INFO;
        }
        /**
         * Handles a control message.
         *
         * @param {Buffer} data Data to handle
         * @return {(Error|RangeError|undefined)} A possible error
         * @private
         */
        controlMessage(data) {
          if (this._opcode === 8) {
            this._loop = false;
            if (data.length === 0) {
              this.emit("conclude", 1005, EMPTY_BUFFER);
              this.end();
            } else {
              const code = data.readUInt16BE(0);
              if (!isValidStatusCode(code)) {
                return error(
                  RangeError,
                  `invalid status code ${code}`,
                  true,
                  1002,
                  "WS_ERR_INVALID_CLOSE_CODE"
                );
              }
              const buf = new FastBuffer(
                data.buffer,
                data.byteOffset + 2,
                data.length - 2
              );
              if (!this._skipUTF8Validation && !isValidUTF8(buf)) {
                return error(
                  Error,
                  "invalid UTF-8 sequence",
                  true,
                  1007,
                  "WS_ERR_INVALID_UTF8"
                );
              }
              this.emit("conclude", code, buf);
              this.end();
            }
          } else if (this._opcode === 9) {
            this.emit("ping", data);
          } else {
            this.emit("pong", data);
          }
          this._state = GET_INFO;
        }
      };
      module2.exports = Receiver2;
      function error(ErrorCtor, message, prefix, statusCode, errorCode) {
        const err2 = new ErrorCtor(
          prefix ? `Invalid WebSocket frame: ${message}` : message
        );
        Error.captureStackTrace(err2, error);
        err2.code = errorCode;
        err2[kStatusCode] = statusCode;
        return err2;
      }
    }
  });

  // node_modules/.pnpm/ws@8.12.1/node_modules/ws/lib/sender.js
  var require_sender = __commonJS({
    "node_modules/.pnpm/ws@8.12.1/node_modules/ws/lib/sender.js"(exports2, module2) {
      "use strict";
      var net2 = __require("net");
      var tls = __require("tls");
      var { randomFillSync } = __require("crypto");
      var PerMessageDeflate = require_permessage_deflate();
      var { EMPTY_BUFFER } = require_constants();
      var { isValidStatusCode } = require_validation();
      var { mask: applyMask, toBuffer } = require_buffer_util();
      var kByteLength = Symbol("kByteLength");
      var maskBuffer = Buffer.alloc(4);
      var Sender2 = class _Sender {
        /**
         * Creates a Sender instance.
         *
         * @param {(net.Socket|tls.Socket)} socket The connection socket
         * @param {Object} [extensions] An object containing the negotiated extensions
         * @param {Function} [generateMask] The function used to generate the masking
         *     key
         */
        constructor(socket, extensions, generateMask) {
          this._extensions = extensions || {};
          if (generateMask) {
            this._generateMask = generateMask;
            this._maskBuffer = Buffer.alloc(4);
          }
          this._socket = socket;
          this._firstFragment = true;
          this._compress = false;
          this._bufferedBytes = 0;
          this._deflating = false;
          this._queue = [];
        }
        /**
         * Frames a piece of data according to the HyBi WebSocket protocol.
         *
         * @param {(Buffer|String)} data The data to frame
         * @param {Object} options Options object
         * @param {Boolean} [options.fin=false] Specifies whether or not to set the
         *     FIN bit
         * @param {Function} [options.generateMask] The function used to generate the
         *     masking key
         * @param {Boolean} [options.mask=false] Specifies whether or not to mask
         *     `data`
         * @param {Buffer} [options.maskBuffer] The buffer used to store the masking
         *     key
         * @param {Number} options.opcode The opcode
         * @param {Boolean} [options.readOnly=false] Specifies whether `data` can be
         *     modified
         * @param {Boolean} [options.rsv1=false] Specifies whether or not to set the
         *     RSV1 bit
         * @return {(Buffer|String)[]} The framed data
         * @public
         */
        static frame(data, options) {
          let mask;
          let merge = false;
          let offset = 2;
          let skipMasking = false;
          if (options.mask) {
            mask = options.maskBuffer || maskBuffer;
            if (options.generateMask) {
              options.generateMask(mask);
            } else {
              randomFillSync(mask, 0, 4);
            }
            skipMasking = (mask[0] | mask[1] | mask[2] | mask[3]) === 0;
            offset = 6;
          }
          let dataLength;
          if (typeof data === "string") {
            if ((!options.mask || skipMasking) && options[kByteLength] !== void 0) {
              dataLength = options[kByteLength];
            } else {
              data = Buffer.from(data);
              dataLength = data.length;
            }
          } else {
            dataLength = data.length;
            merge = options.mask && options.readOnly && !skipMasking;
          }
          let payloadLength = dataLength;
          if (dataLength >= 65536) {
            offset += 8;
            payloadLength = 127;
          } else if (dataLength > 125) {
            offset += 2;
            payloadLength = 126;
          }
          const target = Buffer.allocUnsafe(merge ? dataLength + offset : offset);
          target[0] = options.fin ? options.opcode | 128 : options.opcode;
          if (options.rsv1)
            target[0] |= 64;
          target[1] = payloadLength;
          if (payloadLength === 126) {
            target.writeUInt16BE(dataLength, 2);
          } else if (payloadLength === 127) {
            target[2] = target[3] = 0;
            target.writeUIntBE(dataLength, 4, 6);
          }
          if (!options.mask)
            return [target, data];
          target[1] |= 128;
          target[offset - 4] = mask[0];
          target[offset - 3] = mask[1];
          target[offset - 2] = mask[2];
          target[offset - 1] = mask[3];
          if (skipMasking)
            return [target, data];
          if (merge) {
            applyMask(data, mask, target, offset, dataLength);
            return [target];
          }
          applyMask(data, mask, data, 0, dataLength);
          return [target, data];
        }
        /**
         * Sends a close message to the other peer.
         *
         * @param {Number} [code] The status code component of the body
         * @param {(String|Buffer)} [data] The message component of the body
         * @param {Boolean} [mask=false] Specifies whether or not to mask the message
         * @param {Function} [cb] Callback
         * @public
         */
        close(code, data, mask, cb) {
          let buf;
          if (code === void 0) {
            buf = EMPTY_BUFFER;
          } else if (typeof code !== "number" || !isValidStatusCode(code)) {
            throw new TypeError("First argument must be a valid error code number");
          } else if (data === void 0 || !data.length) {
            buf = Buffer.allocUnsafe(2);
            buf.writeUInt16BE(code, 0);
          } else {
            const length = Buffer.byteLength(data);
            if (length > 123) {
              throw new RangeError("The message must not be greater than 123 bytes");
            }
            buf = Buffer.allocUnsafe(2 + length);
            buf.writeUInt16BE(code, 0);
            if (typeof data === "string") {
              buf.write(data, 2);
            } else {
              buf.set(data, 2);
            }
          }
          const options = {
            [kByteLength]: buf.length,
            fin: true,
            generateMask: this._generateMask,
            mask,
            maskBuffer: this._maskBuffer,
            opcode: 8,
            readOnly: false,
            rsv1: false
          };
          if (this._deflating) {
            this.enqueue([this.dispatch, buf, false, options, cb]);
          } else {
            this.sendFrame(_Sender.frame(buf, options), cb);
          }
        }
        /**
         * Sends a ping message to the other peer.
         *
         * @param {*} data The message to send
         * @param {Boolean} [mask=false] Specifies whether or not to mask `data`
         * @param {Function} [cb] Callback
         * @public
         */
        ping(data, mask, cb) {
          let byteLength;
          let readOnly;
          if (typeof data === "string") {
            byteLength = Buffer.byteLength(data);
            readOnly = false;
          } else {
            data = toBuffer(data);
            byteLength = data.length;
            readOnly = toBuffer.readOnly;
          }
          if (byteLength > 125) {
            throw new RangeError("The data size must not be greater than 125 bytes");
          }
          const options = {
            [kByteLength]: byteLength,
            fin: true,
            generateMask: this._generateMask,
            mask,
            maskBuffer: this._maskBuffer,
            opcode: 9,
            readOnly,
            rsv1: false
          };
          if (this._deflating) {
            this.enqueue([this.dispatch, data, false, options, cb]);
          } else {
            this.sendFrame(_Sender.frame(data, options), cb);
          }
        }
        /**
         * Sends a pong message to the other peer.
         *
         * @param {*} data The message to send
         * @param {Boolean} [mask=false] Specifies whether or not to mask `data`
         * @param {Function} [cb] Callback
         * @public
         */
        pong(data, mask, cb) {
          let byteLength;
          let readOnly;
          if (typeof data === "string") {
            byteLength = Buffer.byteLength(data);
            readOnly = false;
          } else {
            data = toBuffer(data);
            byteLength = data.length;
            readOnly = toBuffer.readOnly;
          }
          if (byteLength > 125) {
            throw new RangeError("The data size must not be greater than 125 bytes");
          }
          const options = {
            [kByteLength]: byteLength,
            fin: true,
            generateMask: this._generateMask,
            mask,
            maskBuffer: this._maskBuffer,
            opcode: 10,
            readOnly,
            rsv1: false
          };
          if (this._deflating) {
            this.enqueue([this.dispatch, data, false, options, cb]);
          } else {
            this.sendFrame(_Sender.frame(data, options), cb);
          }
        }
        /**
         * Sends a data message to the other peer.
         *
         * @param {*} data The message to send
         * @param {Object} options Options object
         * @param {Boolean} [options.binary=false] Specifies whether `data` is binary
         *     or text
         * @param {Boolean} [options.compress=false] Specifies whether or not to
         *     compress `data`
         * @param {Boolean} [options.fin=false] Specifies whether the fragment is the
         *     last one
         * @param {Boolean} [options.mask=false] Specifies whether or not to mask
         *     `data`
         * @param {Function} [cb] Callback
         * @public
         */
        send(data, options, cb) {
          const perMessageDeflate = this._extensions[PerMessageDeflate.extensionName];
          let opcode = options.binary ? 2 : 1;
          let rsv1 = options.compress;
          let byteLength;
          let readOnly;
          if (typeof data === "string") {
            byteLength = Buffer.byteLength(data);
            readOnly = false;
          } else {
            data = toBuffer(data);
            byteLength = data.length;
            readOnly = toBuffer.readOnly;
          }
          if (this._firstFragment) {
            this._firstFragment = false;
            if (rsv1 && perMessageDeflate && perMessageDeflate.params[perMessageDeflate._isServer ? "server_no_context_takeover" : "client_no_context_takeover"]) {
              rsv1 = byteLength >= perMessageDeflate._threshold;
            }
            this._compress = rsv1;
          } else {
            rsv1 = false;
            opcode = 0;
          }
          if (options.fin)
            this._firstFragment = true;
          if (perMessageDeflate) {
            const opts = {
              [kByteLength]: byteLength,
              fin: options.fin,
              generateMask: this._generateMask,
              mask: options.mask,
              maskBuffer: this._maskBuffer,
              opcode,
              readOnly,
              rsv1
            };
            if (this._deflating) {
              this.enqueue([this.dispatch, data, this._compress, opts, cb]);
            } else {
              this.dispatch(data, this._compress, opts, cb);
            }
          } else {
            this.sendFrame(
              _Sender.frame(data, {
                [kByteLength]: byteLength,
                fin: options.fin,
                generateMask: this._generateMask,
                mask: options.mask,
                maskBuffer: this._maskBuffer,
                opcode,
                readOnly,
                rsv1: false
              }),
              cb
            );
          }
        }
        /**
         * Dispatches a message.
         *
         * @param {(Buffer|String)} data The message to send
         * @param {Boolean} [compress=false] Specifies whether or not to compress
         *     `data`
         * @param {Object} options Options object
         * @param {Boolean} [options.fin=false] Specifies whether or not to set the
         *     FIN bit
         * @param {Function} [options.generateMask] The function used to generate the
         *     masking key
         * @param {Boolean} [options.mask=false] Specifies whether or not to mask
         *     `data`
         * @param {Buffer} [options.maskBuffer] The buffer used to store the masking
         *     key
         * @param {Number} options.opcode The opcode
         * @param {Boolean} [options.readOnly=false] Specifies whether `data` can be
         *     modified
         * @param {Boolean} [options.rsv1=false] Specifies whether or not to set the
         *     RSV1 bit
         * @param {Function} [cb] Callback
         * @private
         */
        dispatch(data, compress, options, cb) {
          if (!compress) {
            this.sendFrame(_Sender.frame(data, options), cb);
            return;
          }
          const perMessageDeflate = this._extensions[PerMessageDeflate.extensionName];
          this._bufferedBytes += options[kByteLength];
          this._deflating = true;
          perMessageDeflate.compress(data, options.fin, (_, buf) => {
            if (this._socket.destroyed) {
              const err2 = new Error(
                "The socket was closed while data was being compressed"
              );
              if (typeof cb === "function")
                cb(err2);
              for (let i = 0; i < this._queue.length; i++) {
                const params = this._queue[i];
                const callback = params[params.length - 1];
                if (typeof callback === "function")
                  callback(err2);
              }
              return;
            }
            this._bufferedBytes -= options[kByteLength];
            this._deflating = false;
            options.readOnly = false;
            this.sendFrame(_Sender.frame(buf, options), cb);
            this.dequeue();
          });
        }
        /**
         * Executes queued send operations.
         *
         * @private
         */
        dequeue() {
          while (!this._deflating && this._queue.length) {
            const params = this._queue.shift();
            this._bufferedBytes -= params[3][kByteLength];
            Reflect.apply(params[0], this, params.slice(1));
          }
        }
        /**
         * Enqueues a send operation.
         *
         * @param {Array} params Send operation parameters.
         * @private
         */
        enqueue(params) {
          this._bufferedBytes += params[3][kByteLength];
          this._queue.push(params);
        }
        /**
         * Sends a frame.
         *
         * @param {Buffer[]} list The frame to send
         * @param {Function} [cb] Callback
         * @private
         */
        sendFrame(list, cb) {
          if (list.length === 2) {
            this._socket.cork();
            this._socket.write(list[0]);
            this._socket.write(list[1], cb);
            this._socket.uncork();
          } else {
            this._socket.write(list[0], cb);
          }
        }
      };
      module2.exports = Sender2;
    }
  });

  // node_modules/.pnpm/ws@8.12.1/node_modules/ws/lib/event-target.js
  var require_event_target = __commonJS({
    "node_modules/.pnpm/ws@8.12.1/node_modules/ws/lib/event-target.js"(exports2, module2) {
      "use strict";
      var { kForOnEventAttribute, kListener } = require_constants();
      var kCode = Symbol("kCode");
      var kData = Symbol("kData");
      var kError = Symbol("kError");
      var kMessage = Symbol("kMessage");
      var kReason = Symbol("kReason");
      var kTarget = Symbol("kTarget");
      var kType = Symbol("kType");
      var kWasClean = Symbol("kWasClean");
      var Event = class {
        /**
         * Create a new `Event`.
         *
         * @param {String} type The name of the event
         * @throws {TypeError} If the `type` argument is not specified
         */
        constructor(type) {
          this[kTarget] = null;
          this[kType] = type;
        }
        /**
         * @type {*}
         */
        get target() {
          return this[kTarget];
        }
        /**
         * @type {String}
         */
        get type() {
          return this[kType];
        }
      };
      Object.defineProperty(Event.prototype, "target", { enumerable: true });
      Object.defineProperty(Event.prototype, "type", { enumerable: true });
      var CloseEvent = class extends Event {
        /**
         * Create a new `CloseEvent`.
         *
         * @param {String} type The name of the event
         * @param {Object} [options] A dictionary object that allows for setting
         *     attributes via object members of the same name
         * @param {Number} [options.code=0] The status code explaining why the
         *     connection was closed
         * @param {String} [options.reason=''] A human-readable string explaining why
         *     the connection was closed
         * @param {Boolean} [options.wasClean=false] Indicates whether or not the
         *     connection was cleanly closed
         */
        constructor(type, options = {}) {
          super(type);
          this[kCode] = options.code === void 0 ? 0 : options.code;
          this[kReason] = options.reason === void 0 ? "" : options.reason;
          this[kWasClean] = options.wasClean === void 0 ? false : options.wasClean;
        }
        /**
         * @type {Number}
         */
        get code() {
          return this[kCode];
        }
        /**
         * @type {String}
         */
        get reason() {
          return this[kReason];
        }
        /**
         * @type {Boolean}
         */
        get wasClean() {
          return this[kWasClean];
        }
      };
      Object.defineProperty(CloseEvent.prototype, "code", { enumerable: true });
      Object.defineProperty(CloseEvent.prototype, "reason", { enumerable: true });
      Object.defineProperty(CloseEvent.prototype, "wasClean", { enumerable: true });
      var ErrorEvent = class extends Event {
        /**
         * Create a new `ErrorEvent`.
         *
         * @param {String} type The name of the event
         * @param {Object} [options] A dictionary object that allows for setting
         *     attributes via object members of the same name
         * @param {*} [options.error=null] The error that generated this event
         * @param {String} [options.message=''] The error message
         */
        constructor(type, options = {}) {
          super(type);
          this[kError] = options.error === void 0 ? null : options.error;
          this[kMessage] = options.message === void 0 ? "" : options.message;
        }
        /**
         * @type {*}
         */
        get error() {
          return this[kError];
        }
        /**
         * @type {String}
         */
        get message() {
          return this[kMessage];
        }
      };
      Object.defineProperty(ErrorEvent.prototype, "error", { enumerable: true });
      Object.defineProperty(ErrorEvent.prototype, "message", { enumerable: true });
      var MessageEvent = class extends Event {
        /**
         * Create a new `MessageEvent`.
         *
         * @param {String} type The name of the event
         * @param {Object} [options] A dictionary object that allows for setting
         *     attributes via object members of the same name
         * @param {*} [options.data=null] The message content
         */
        constructor(type, options = {}) {
          super(type);
          this[kData] = options.data === void 0 ? null : options.data;
        }
        /**
         * @type {*}
         */
        get data() {
          return this[kData];
        }
      };
      Object.defineProperty(MessageEvent.prototype, "data", { enumerable: true });
      var EventTarget = {
        /**
         * Register an event listener.
         *
         * @param {String} type A string representing the event type to listen for
         * @param {(Function|Object)} handler The listener to add
         * @param {Object} [options] An options object specifies characteristics about
         *     the event listener
         * @param {Boolean} [options.once=false] A `Boolean` indicating that the
         *     listener should be invoked at most once after being added. If `true`,
         *     the listener would be automatically removed when invoked.
         * @public
         */
        addEventListener(type, handler, options = {}) {
          for (const listener of this.listeners(type)) {
            if (!options[kForOnEventAttribute] && listener[kListener] === handler && !listener[kForOnEventAttribute]) {
              return;
            }
          }
          let wrapper;
          if (type === "message") {
            wrapper = function onMessage(data, isBinary) {
              const event = new MessageEvent("message", {
                data: isBinary ? data : data.toString()
              });
              event[kTarget] = this;
              callListener(handler, this, event);
            };
          } else if (type === "close") {
            wrapper = function onClose(code, message) {
              const event = new CloseEvent("close", {
                code,
                reason: message.toString(),
                wasClean: this._closeFrameReceived && this._closeFrameSent
              });
              event[kTarget] = this;
              callListener(handler, this, event);
            };
          } else if (type === "error") {
            wrapper = function onError(error) {
              const event = new ErrorEvent("error", {
                error,
                message: error.message
              });
              event[kTarget] = this;
              callListener(handler, this, event);
            };
          } else if (type === "open") {
            wrapper = function onOpen() {
              const event = new Event("open");
              event[kTarget] = this;
              callListener(handler, this, event);
            };
          } else {
            return;
          }
          wrapper[kForOnEventAttribute] = !!options[kForOnEventAttribute];
          wrapper[kListener] = handler;
          if (options.once) {
            this.once(type, wrapper);
          } else {
            this.on(type, wrapper);
          }
        },
        /**
         * Remove an event listener.
         *
         * @param {String} type A string representing the event type to remove
         * @param {(Function|Object)} handler The listener to remove
         * @public
         */
        removeEventListener(type, handler) {
          for (const listener of this.listeners(type)) {
            if (listener[kListener] === handler && !listener[kForOnEventAttribute]) {
              this.removeListener(type, listener);
              break;
            }
          }
        }
      };
      module2.exports = {
        CloseEvent,
        ErrorEvent,
        Event,
        EventTarget,
        MessageEvent
      };
      function callListener(listener, thisArg, event) {
        if (typeof listener === "object" && listener.handleEvent) {
          listener.handleEvent.call(listener, event);
        } else {
          listener.call(thisArg, event);
        }
      }
    }
  });

  // node_modules/.pnpm/ws@8.12.1/node_modules/ws/lib/extension.js
  var require_extension = __commonJS({
    "node_modules/.pnpm/ws@8.12.1/node_modules/ws/lib/extension.js"(exports2, module2) {
      "use strict";
      var { tokenChars } = require_validation();
      function push(dest, name, elem) {
        if (dest[name] === void 0)
          dest[name] = [elem];
        else
          dest[name].push(elem);
      }
      function parse4(header) {
        const offers = /* @__PURE__ */ Object.create(null);
        let params = /* @__PURE__ */ Object.create(null);
        let mustUnescape = false;
        let isEscaping = false;
        let inQuotes = false;
        let extensionName;
        let paramName;
        let start = -1;
        let code = -1;
        let end = -1;
        let i = 0;
        for (; i < header.length; i++) {
          code = header.charCodeAt(i);
          if (extensionName === void 0) {
            if (end === -1 && tokenChars[code] === 1) {
              if (start === -1)
                start = i;
            } else if (i !== 0 && (code === 32 || code === 9)) {
              if (end === -1 && start !== -1)
                end = i;
            } else if (code === 59 || code === 44) {
              if (start === -1) {
                throw new SyntaxError(`Unexpected character at index ${i}`);
              }
              if (end === -1)
                end = i;
              const name = header.slice(start, end);
              if (code === 44) {
                push(offers, name, params);
                params = /* @__PURE__ */ Object.create(null);
              } else {
                extensionName = name;
              }
              start = end = -1;
            } else {
              throw new SyntaxError(`Unexpected character at index ${i}`);
            }
          } else if (paramName === void 0) {
            if (end === -1 && tokenChars[code] === 1) {
              if (start === -1)
                start = i;
            } else if (code === 32 || code === 9) {
              if (end === -1 && start !== -1)
                end = i;
            } else if (code === 59 || code === 44) {
              if (start === -1) {
                throw new SyntaxError(`Unexpected character at index ${i}`);
              }
              if (end === -1)
                end = i;
              push(params, header.slice(start, end), true);
              if (code === 44) {
                push(offers, extensionName, params);
                params = /* @__PURE__ */ Object.create(null);
                extensionName = void 0;
              }
              start = end = -1;
            } else if (code === 61 && start !== -1 && end === -1) {
              paramName = header.slice(start, i);
              start = end = -1;
            } else {
              throw new SyntaxError(`Unexpected character at index ${i}`);
            }
          } else {
            if (isEscaping) {
              if (tokenChars[code] !== 1) {
                throw new SyntaxError(`Unexpected character at index ${i}`);
              }
              if (start === -1)
                start = i;
              else if (!mustUnescape)
                mustUnescape = true;
              isEscaping = false;
            } else if (inQuotes) {
              if (tokenChars[code] === 1) {
                if (start === -1)
                  start = i;
              } else if (code === 34 && start !== -1) {
                inQuotes = false;
                end = i;
              } else if (code === 92) {
                isEscaping = true;
              } else {
                throw new SyntaxError(`Unexpected character at index ${i}`);
              }
            } else if (code === 34 && header.charCodeAt(i - 1) === 61) {
              inQuotes = true;
            } else if (end === -1 && tokenChars[code] === 1) {
              if (start === -1)
                start = i;
            } else if (start !== -1 && (code === 32 || code === 9)) {
              if (end === -1)
                end = i;
            } else if (code === 59 || code === 44) {
              if (start === -1) {
                throw new SyntaxError(`Unexpected character at index ${i}`);
              }
              if (end === -1)
                end = i;
              let value = header.slice(start, end);
              if (mustUnescape) {
                value = value.replace(/\\/g, "");
                mustUnescape = false;
              }
              push(params, paramName, value);
              if (code === 44) {
                push(offers, extensionName, params);
                params = /* @__PURE__ */ Object.create(null);
                extensionName = void 0;
              }
              paramName = void 0;
              start = end = -1;
            } else {
              throw new SyntaxError(`Unexpected character at index ${i}`);
            }
          }
        }
        if (start === -1 || inQuotes || code === 32 || code === 9) {
          throw new SyntaxError("Unexpected end of input");
        }
        if (end === -1)
          end = i;
        const token = header.slice(start, end);
        if (extensionName === void 0) {
          push(offers, token, params);
        } else {
          if (paramName === void 0) {
            push(params, token, true);
          } else if (mustUnescape) {
            push(params, paramName, token.replace(/\\/g, ""));
          } else {
            push(params, paramName, token);
          }
          push(offers, extensionName, params);
        }
        return offers;
      }
      function format(extensions) {
        return Object.keys(extensions).map((extension) => {
          let configurations = extensions[extension];
          if (!Array.isArray(configurations))
            configurations = [configurations];
          return configurations.map((params) => {
            return [extension].concat(
              Object.keys(params).map((k) => {
                let values = params[k];
                if (!Array.isArray(values))
                  values = [values];
                return values.map((v) => v === true ? k : `${k}=${v}`).join("; ");
              })
            ).join("; ");
          }).join(", ");
        }).join(", ");
      }
      module2.exports = { format, parse: parse4 };
    }
  });

  // node_modules/.pnpm/ws@8.12.1/node_modules/ws/lib/websocket.js
  var require_websocket = __commonJS({
    "node_modules/.pnpm/ws@8.12.1/node_modules/ws/lib/websocket.js"(exports2, module2) {
      "use strict";
      var EventEmitter = __require("events");
      var https = __require("https");
      var http = __require("http");
      var net2 = __require("net");
      var tls = __require("tls");
      var { randomBytes, createHash } = __require("crypto");
      var { Readable } = __require("stream");
      var { URL: URL2 } = __require("url");
      var PerMessageDeflate = require_permessage_deflate();
      var Receiver2 = require_receiver();
      var Sender2 = require_sender();
      var {
        BINARY_TYPES,
        EMPTY_BUFFER,
        GUID,
        kForOnEventAttribute,
        kListener,
        kStatusCode,
        kWebSocket,
        NOOP
      } = require_constants();
      var {
        EventTarget: { addEventListener, removeEventListener }
      } = require_event_target();
      var { format, parse: parse4 } = require_extension();
      var { toBuffer } = require_buffer_util();
      var closeTimeout = 30 * 1e3;
      var kAborted = Symbol("kAborted");
      var protocolVersions = [8, 13];
      var readyStates = ["CONNECTING", "OPEN", "CLOSING", "CLOSED"];
      var subprotocolRegex = /^[!#$%&'*+\-.0-9A-Z^_`|a-z~]+$/;
      var WebSocket2 = class _WebSocket extends EventEmitter {
        /**
         * Create a new `WebSocket`.
         *
         * @param {(String|URL)} address The URL to which to connect
         * @param {(String|String[])} [protocols] The subprotocols
         * @param {Object} [options] Connection options
         */
        constructor(address, protocols, options) {
          super();
          this._binaryType = BINARY_TYPES[0];
          this._closeCode = 1006;
          this._closeFrameReceived = false;
          this._closeFrameSent = false;
          this._closeMessage = EMPTY_BUFFER;
          this._closeTimer = null;
          this._extensions = {};
          this._paused = false;
          this._protocol = "";
          this._readyState = _WebSocket.CONNECTING;
          this._receiver = null;
          this._sender = null;
          this._socket = null;
          if (address !== null) {
            this._bufferedAmount = 0;
            this._isServer = false;
            this._redirects = 0;
            if (protocols === void 0) {
              protocols = [];
            } else if (!Array.isArray(protocols)) {
              if (typeof protocols === "object" && protocols !== null) {
                options = protocols;
                protocols = [];
              } else {
                protocols = [protocols];
              }
            }
            initAsClient(this, address, protocols, options);
          } else {
            this._isServer = true;
          }
        }
        /**
         * This deviates from the WHATWG interface since ws doesn't support the
         * required default "blob" type (instead we define a custom "nodebuffer"
         * type).
         *
         * @type {String}
         */
        get binaryType() {
          return this._binaryType;
        }
        set binaryType(type) {
          if (!BINARY_TYPES.includes(type))
            return;
          this._binaryType = type;
          if (this._receiver)
            this._receiver._binaryType = type;
        }
        /**
         * @type {Number}
         */
        get bufferedAmount() {
          if (!this._socket)
            return this._bufferedAmount;
          return this._socket._writableState.length + this._sender._bufferedBytes;
        }
        /**
         * @type {String}
         */
        get extensions() {
          return Object.keys(this._extensions).join();
        }
        /**
         * @type {Boolean}
         */
        get isPaused() {
          return this._paused;
        }
        /**
         * @type {Function}
         */
        /* istanbul ignore next */
        get onclose() {
          return null;
        }
        /**
         * @type {Function}
         */
        /* istanbul ignore next */
        get onerror() {
          return null;
        }
        /**
         * @type {Function}
         */
        /* istanbul ignore next */
        get onopen() {
          return null;
        }
        /**
         * @type {Function}
         */
        /* istanbul ignore next */
        get onmessage() {
          return null;
        }
        /**
         * @type {String}
         */
        get protocol() {
          return this._protocol;
        }
        /**
         * @type {Number}
         */
        get readyState() {
          return this._readyState;
        }
        /**
         * @type {String}
         */
        get url() {
          return this._url;
        }
        /**
         * Set up the socket and the internal resources.
         *
         * @param {(net.Socket|tls.Socket)} socket The network socket between the
         *     server and client
         * @param {Buffer} head The first packet of the upgraded stream
         * @param {Object} options Options object
         * @param {Function} [options.generateMask] The function used to generate the
         *     masking key
         * @param {Number} [options.maxPayload=0] The maximum allowed message size
         * @param {Boolean} [options.skipUTF8Validation=false] Specifies whether or
         *     not to skip UTF-8 validation for text and close messages
         * @private
         */
        setSocket(socket, head, options) {
          const receiver = new Receiver2({
            binaryType: this.binaryType,
            extensions: this._extensions,
            isServer: this._isServer,
            maxPayload: options.maxPayload,
            skipUTF8Validation: options.skipUTF8Validation
          });
          this._sender = new Sender2(socket, this._extensions, options.generateMask);
          this._receiver = receiver;
          this._socket = socket;
          receiver[kWebSocket] = this;
          socket[kWebSocket] = this;
          receiver.on("conclude", receiverOnConclude);
          receiver.on("drain", receiverOnDrain);
          receiver.on("error", receiverOnError);
          receiver.on("message", receiverOnMessage);
          receiver.on("ping", receiverOnPing);
          receiver.on("pong", receiverOnPong);
          socket.setTimeout(0);
          socket.setNoDelay();
          if (head.length > 0)
            socket.unshift(head);
          socket.on("close", socketOnClose);
          socket.on("data", socketOnData);
          socket.on("end", socketOnEnd);
          socket.on("error", socketOnError);
          this._readyState = _WebSocket.OPEN;
          this.emit("open");
        }
        /**
         * Emit the `'close'` event.
         *
         * @private
         */
        emitClose() {
          if (!this._socket) {
            this._readyState = _WebSocket.CLOSED;
            this.emit("close", this._closeCode, this._closeMessage);
            return;
          }
          if (this._extensions[PerMessageDeflate.extensionName]) {
            this._extensions[PerMessageDeflate.extensionName].cleanup();
          }
          this._receiver.removeAllListeners();
          this._readyState = _WebSocket.CLOSED;
          this.emit("close", this._closeCode, this._closeMessage);
        }
        /**
         * Start a closing handshake.
         *
         *          +----------+   +-----------+   +----------+
         *     - - -|ws.close()|-->|close frame|-->|ws.close()|- - -
         *    |     +----------+   +-----------+   +----------+     |
         *          +----------+   +-----------+         |
         * CLOSING  |ws.close()|<--|close frame|<--+-----+       CLOSING
         *          +----------+   +-----------+   |
         *    |           |                        |   +---+        |
         *                +------------------------+-->|fin| - - - -
         *    |         +---+                      |   +---+
         *     - - - - -|fin|<---------------------+
         *              +---+
         *
         * @param {Number} [code] Status code explaining why the connection is closing
         * @param {(String|Buffer)} [data] The reason why the connection is
         *     closing
         * @public
         */
        close(code, data) {
          if (this.readyState === _WebSocket.CLOSED)
            return;
          if (this.readyState === _WebSocket.CONNECTING) {
            const msg = "WebSocket was closed before the connection was established";
            abortHandshake(this, this._req, msg);
            return;
          }
          if (this.readyState === _WebSocket.CLOSING) {
            if (this._closeFrameSent && (this._closeFrameReceived || this._receiver._writableState.errorEmitted)) {
              this._socket.end();
            }
            return;
          }
          this._readyState = _WebSocket.CLOSING;
          this._sender.close(code, data, !this._isServer, (err2) => {
            if (err2)
              return;
            this._closeFrameSent = true;
            if (this._closeFrameReceived || this._receiver._writableState.errorEmitted) {
              this._socket.end();
            }
          });
          this._closeTimer = setTimeout(
            this._socket.destroy.bind(this._socket),
            closeTimeout
          );
        }
        /**
         * Pause the socket.
         *
         * @public
         */
        pause() {
          if (this.readyState === _WebSocket.CONNECTING || this.readyState === _WebSocket.CLOSED) {
            return;
          }
          this._paused = true;
          this._socket.pause();
        }
        /**
         * Send a ping.
         *
         * @param {*} [data] The data to send
         * @param {Boolean} [mask] Indicates whether or not to mask `data`
         * @param {Function} [cb] Callback which is executed when the ping is sent
         * @public
         */
        ping(data, mask, cb) {
          if (this.readyState === _WebSocket.CONNECTING) {
            throw new Error("WebSocket is not open: readyState 0 (CONNECTING)");
          }
          if (typeof data === "function") {
            cb = data;
            data = mask = void 0;
          } else if (typeof mask === "function") {
            cb = mask;
            mask = void 0;
          }
          if (typeof data === "number")
            data = data.toString();
          if (this.readyState !== _WebSocket.OPEN) {
            sendAfterClose(this, data, cb);
            return;
          }
          if (mask === void 0)
            mask = !this._isServer;
          this._sender.ping(data || EMPTY_BUFFER, mask, cb);
        }
        /**
         * Send a pong.
         *
         * @param {*} [data] The data to send
         * @param {Boolean} [mask] Indicates whether or not to mask `data`
         * @param {Function} [cb] Callback which is executed when the pong is sent
         * @public
         */
        pong(data, mask, cb) {
          if (this.readyState === _WebSocket.CONNECTING) {
            throw new Error("WebSocket is not open: readyState 0 (CONNECTING)");
          }
          if (typeof data === "function") {
            cb = data;
            data = mask = void 0;
          } else if (typeof mask === "function") {
            cb = mask;
            mask = void 0;
          }
          if (typeof data === "number")
            data = data.toString();
          if (this.readyState !== _WebSocket.OPEN) {
            sendAfterClose(this, data, cb);
            return;
          }
          if (mask === void 0)
            mask = !this._isServer;
          this._sender.pong(data || EMPTY_BUFFER, mask, cb);
        }
        /**
         * Resume the socket.
         *
         * @public
         */
        resume() {
          if (this.readyState === _WebSocket.CONNECTING || this.readyState === _WebSocket.CLOSED) {
            return;
          }
          this._paused = false;
          if (!this._receiver._writableState.needDrain)
            this._socket.resume();
        }
        /**
         * Send a data message.
         *
         * @param {*} data The message to send
         * @param {Object} [options] Options object
         * @param {Boolean} [options.binary] Specifies whether `data` is binary or
         *     text
         * @param {Boolean} [options.compress] Specifies whether or not to compress
         *     `data`
         * @param {Boolean} [options.fin=true] Specifies whether the fragment is the
         *     last one
         * @param {Boolean} [options.mask] Specifies whether or not to mask `data`
         * @param {Function} [cb] Callback which is executed when data is written out
         * @public
         */
        send(data, options, cb) {
          if (this.readyState === _WebSocket.CONNECTING) {
            throw new Error("WebSocket is not open: readyState 0 (CONNECTING)");
          }
          if (typeof options === "function") {
            cb = options;
            options = {};
          }
          if (typeof data === "number")
            data = data.toString();
          if (this.readyState !== _WebSocket.OPEN) {
            sendAfterClose(this, data, cb);
            return;
          }
          const opts = {
            binary: typeof data !== "string",
            mask: !this._isServer,
            compress: true,
            fin: true,
            ...options
          };
          if (!this._extensions[PerMessageDeflate.extensionName]) {
            opts.compress = false;
          }
          this._sender.send(data || EMPTY_BUFFER, opts, cb);
        }
        /**
         * Forcibly close the connection.
         *
         * @public
         */
        terminate() {
          if (this.readyState === _WebSocket.CLOSED)
            return;
          if (this.readyState === _WebSocket.CONNECTING) {
            const msg = "WebSocket was closed before the connection was established";
            abortHandshake(this, this._req, msg);
            return;
          }
          if (this._socket) {
            this._readyState = _WebSocket.CLOSING;
            this._socket.destroy();
          }
        }
      };
      Object.defineProperty(WebSocket2, "CONNECTING", {
        enumerable: true,
        value: readyStates.indexOf("CONNECTING")
      });
      Object.defineProperty(WebSocket2.prototype, "CONNECTING", {
        enumerable: true,
        value: readyStates.indexOf("CONNECTING")
      });
      Object.defineProperty(WebSocket2, "OPEN", {
        enumerable: true,
        value: readyStates.indexOf("OPEN")
      });
      Object.defineProperty(WebSocket2.prototype, "OPEN", {
        enumerable: true,
        value: readyStates.indexOf("OPEN")
      });
      Object.defineProperty(WebSocket2, "CLOSING", {
        enumerable: true,
        value: readyStates.indexOf("CLOSING")
      });
      Object.defineProperty(WebSocket2.prototype, "CLOSING", {
        enumerable: true,
        value: readyStates.indexOf("CLOSING")
      });
      Object.defineProperty(WebSocket2, "CLOSED", {
        enumerable: true,
        value: readyStates.indexOf("CLOSED")
      });
      Object.defineProperty(WebSocket2.prototype, "CLOSED", {
        enumerable: true,
        value: readyStates.indexOf("CLOSED")
      });
      [
        "binaryType",
        "bufferedAmount",
        "extensions",
        "isPaused",
        "protocol",
        "readyState",
        "url"
      ].forEach((property) => {
        Object.defineProperty(WebSocket2.prototype, property, { enumerable: true });
      });
      ["open", "error", "close", "message"].forEach((method) => {
        Object.defineProperty(WebSocket2.prototype, `on${method}`, {
          enumerable: true,
          get() {
            for (const listener of this.listeners(method)) {
              if (listener[kForOnEventAttribute])
                return listener[kListener];
            }
            return null;
          },
          set(handler) {
            for (const listener of this.listeners(method)) {
              if (listener[kForOnEventAttribute]) {
                this.removeListener(method, listener);
                break;
              }
            }
            if (typeof handler !== "function")
              return;
            this.addEventListener(method, handler, {
              [kForOnEventAttribute]: true
            });
          }
        });
      });
      WebSocket2.prototype.addEventListener = addEventListener;
      WebSocket2.prototype.removeEventListener = removeEventListener;
      module2.exports = WebSocket2;
      function initAsClient(websocket, address, protocols, options) {
        const opts = {
          protocolVersion: protocolVersions[1],
          maxPayload: 100 * 1024 * 1024,
          skipUTF8Validation: false,
          perMessageDeflate: true,
          followRedirects: false,
          maxRedirects: 10,
          ...options,
          createConnection: void 0,
          socketPath: void 0,
          hostname: void 0,
          protocol: void 0,
          timeout: void 0,
          method: "GET",
          host: void 0,
          path: void 0,
          port: void 0
        };
        if (!protocolVersions.includes(opts.protocolVersion)) {
          throw new RangeError(
            `Unsupported protocol version: ${opts.protocolVersion} (supported versions: ${protocolVersions.join(", ")})`
          );
        }
        let parsedUrl;
        if (address instanceof URL2) {
          parsedUrl = address;
          websocket._url = address.href;
        } else {
          try {
            parsedUrl = new URL2(address);
          } catch (e) {
            throw new SyntaxError(`Invalid URL: ${address}`);
          }
          websocket._url = address;
        }
        const isSecure = parsedUrl.protocol === "wss:";
        const isIpcUrl = parsedUrl.protocol === "ws+unix:";
        let invalidUrlMessage;
        if (parsedUrl.protocol !== "ws:" && !isSecure && !isIpcUrl) {
          invalidUrlMessage = `The URL's protocol must be one of "ws:", "wss:", or "ws+unix:"`;
        } else if (isIpcUrl && !parsedUrl.pathname) {
          invalidUrlMessage = "The URL's pathname is empty";
        } else if (parsedUrl.hash) {
          invalidUrlMessage = "The URL contains a fragment identifier";
        }
        if (invalidUrlMessage) {
          const err2 = new SyntaxError(invalidUrlMessage);
          if (websocket._redirects === 0) {
            throw err2;
          } else {
            emitErrorAndClose(websocket, err2);
            return;
          }
        }
        const defaultPort = isSecure ? 443 : 80;
        const key = randomBytes(16).toString("base64");
        const request = isSecure ? https.request : http.request;
        const protocolSet = /* @__PURE__ */ new Set();
        let perMessageDeflate;
        opts.createConnection = isSecure ? tlsConnect : netConnect;
        opts.defaultPort = opts.defaultPort || defaultPort;
        opts.port = parsedUrl.port || defaultPort;
        opts.host = parsedUrl.hostname.startsWith("[") ? parsedUrl.hostname.slice(1, -1) : parsedUrl.hostname;
        opts.headers = {
          ...opts.headers,
          "Sec-WebSocket-Version": opts.protocolVersion,
          "Sec-WebSocket-Key": key,
          Connection: "Upgrade",
          Upgrade: "websocket"
        };
        opts.path = parsedUrl.pathname + parsedUrl.search;
        opts.timeout = opts.handshakeTimeout;
        if (opts.perMessageDeflate) {
          perMessageDeflate = new PerMessageDeflate(
            opts.perMessageDeflate !== true ? opts.perMessageDeflate : {},
            false,
            opts.maxPayload
          );
          opts.headers["Sec-WebSocket-Extensions"] = format({
            [PerMessageDeflate.extensionName]: perMessageDeflate.offer()
          });
        }
        if (protocols.length) {
          for (const protocol of protocols) {
            if (typeof protocol !== "string" || !subprotocolRegex.test(protocol) || protocolSet.has(protocol)) {
              throw new SyntaxError(
                "An invalid or duplicated subprotocol was specified"
              );
            }
            protocolSet.add(protocol);
          }
          opts.headers["Sec-WebSocket-Protocol"] = protocols.join(",");
        }
        if (opts.origin) {
          if (opts.protocolVersion < 13) {
            opts.headers["Sec-WebSocket-Origin"] = opts.origin;
          } else {
            opts.headers.Origin = opts.origin;
          }
        }
        if (parsedUrl.username || parsedUrl.password) {
          opts.auth = `${parsedUrl.username}:${parsedUrl.password}`;
        }
        if (isIpcUrl) {
          const parts = opts.path.split(":");
          opts.socketPath = parts[0];
          opts.path = parts[1];
        }
        let req;
        if (opts.followRedirects) {
          if (websocket._redirects === 0) {
            websocket._originalIpc = isIpcUrl;
            websocket._originalSecure = isSecure;
            websocket._originalHostOrSocketPath = isIpcUrl ? opts.socketPath : parsedUrl.host;
            const headers = options && options.headers;
            options = { ...options, headers: {} };
            if (headers) {
              for (const [key2, value] of Object.entries(headers)) {
                options.headers[key2.toLowerCase()] = value;
              }
            }
          } else if (websocket.listenerCount("redirect") === 0) {
            const isSameHost = isIpcUrl ? websocket._originalIpc ? opts.socketPath === websocket._originalHostOrSocketPath : false : websocket._originalIpc ? false : parsedUrl.host === websocket._originalHostOrSocketPath;
            if (!isSameHost || websocket._originalSecure && !isSecure) {
              delete opts.headers.authorization;
              delete opts.headers.cookie;
              if (!isSameHost)
                delete opts.headers.host;
              opts.auth = void 0;
            }
          }
          if (opts.auth && !options.headers.authorization) {
            options.headers.authorization = "Basic " + Buffer.from(opts.auth).toString("base64");
          }
          req = websocket._req = request(opts);
          if (websocket._redirects) {
            websocket.emit("redirect", websocket.url, req);
          }
        } else {
          req = websocket._req = request(opts);
        }
        if (opts.timeout) {
          req.on("timeout", () => {
            abortHandshake(websocket, req, "Opening handshake has timed out");
          });
        }
        req.on("error", (err2) => {
          if (req === null || req[kAborted])
            return;
          req = websocket._req = null;
          emitErrorAndClose(websocket, err2);
        });
        req.on("response", (res) => {
          const location = res.headers.location;
          const statusCode = res.statusCode;
          if (location && opts.followRedirects && statusCode >= 300 && statusCode < 400) {
            if (++websocket._redirects > opts.maxRedirects) {
              abortHandshake(websocket, req, "Maximum redirects exceeded");
              return;
            }
            req.abort();
            let addr;
            try {
              addr = new URL2(location, address);
            } catch (e) {
              const err2 = new SyntaxError(`Invalid URL: ${location}`);
              emitErrorAndClose(websocket, err2);
              return;
            }
            initAsClient(websocket, addr, protocols, options);
          } else if (!websocket.emit("unexpected-response", req, res)) {
            abortHandshake(
              websocket,
              req,
              `Unexpected server response: ${res.statusCode}`
            );
          }
        });
        req.on("upgrade", (res, socket, head) => {
          websocket.emit("upgrade", res);
          if (websocket.readyState !== WebSocket2.CONNECTING)
            return;
          req = websocket._req = null;
          if (res.headers.upgrade.toLowerCase() !== "websocket") {
            abortHandshake(websocket, socket, "Invalid Upgrade header");
            return;
          }
          const digest = createHash("sha1").update(key + GUID).digest("base64");
          if (res.headers["sec-websocket-accept"] !== digest) {
            abortHandshake(websocket, socket, "Invalid Sec-WebSocket-Accept header");
            return;
          }
          const serverProt = res.headers["sec-websocket-protocol"];
          let protError;
          if (serverProt !== void 0) {
            if (!protocolSet.size) {
              protError = "Server sent a subprotocol but none was requested";
            } else if (!protocolSet.has(serverProt)) {
              protError = "Server sent an invalid subprotocol";
            }
          } else if (protocolSet.size) {
            protError = "Server sent no subprotocol";
          }
          if (protError) {
            abortHandshake(websocket, socket, protError);
            return;
          }
          if (serverProt)
            websocket._protocol = serverProt;
          const secWebSocketExtensions = res.headers["sec-websocket-extensions"];
          if (secWebSocketExtensions !== void 0) {
            if (!perMessageDeflate) {
              const message = "Server sent a Sec-WebSocket-Extensions header but no extension was requested";
              abortHandshake(websocket, socket, message);
              return;
            }
            let extensions;
            try {
              extensions = parse4(secWebSocketExtensions);
            } catch (err2) {
              const message = "Invalid Sec-WebSocket-Extensions header";
              abortHandshake(websocket, socket, message);
              return;
            }
            const extensionNames = Object.keys(extensions);
            if (extensionNames.length !== 1 || extensionNames[0] !== PerMessageDeflate.extensionName) {
              const message = "Server indicated an extension that was not requested";
              abortHandshake(websocket, socket, message);
              return;
            }
            try {
              perMessageDeflate.accept(extensions[PerMessageDeflate.extensionName]);
            } catch (err2) {
              const message = "Invalid Sec-WebSocket-Extensions header";
              abortHandshake(websocket, socket, message);
              return;
            }
            websocket._extensions[PerMessageDeflate.extensionName] = perMessageDeflate;
          }
          websocket.setSocket(socket, head, {
            generateMask: opts.generateMask,
            maxPayload: opts.maxPayload,
            skipUTF8Validation: opts.skipUTF8Validation
          });
        });
        req.end();
      }
      function emitErrorAndClose(websocket, err2) {
        websocket._readyState = WebSocket2.CLOSING;
        websocket.emit("error", err2);
        websocket.emitClose();
      }
      function netConnect(options) {
        options.path = options.socketPath;
        return net2.connect(options);
      }
      function tlsConnect(options) {
        options.path = void 0;
        if (!options.servername && options.servername !== "") {
          options.servername = net2.isIP(options.host) ? "" : options.host;
        }
        return tls.connect(options);
      }
      function abortHandshake(websocket, stream, message) {
        websocket._readyState = WebSocket2.CLOSING;
        const err2 = new Error(message);
        Error.captureStackTrace(err2, abortHandshake);
        if (stream.setHeader) {
          stream[kAborted] = true;
          stream.abort();
          if (stream.socket && !stream.socket.destroyed) {
            stream.socket.destroy();
          }
          process.nextTick(emitErrorAndClose, websocket, err2);
        } else {
          stream.destroy(err2);
          stream.once("error", websocket.emit.bind(websocket, "error"));
          stream.once("close", websocket.emitClose.bind(websocket));
        }
      }
      function sendAfterClose(websocket, data, cb) {
        if (data) {
          const length = toBuffer(data).length;
          if (websocket._socket)
            websocket._sender._bufferedBytes += length;
          else
            websocket._bufferedAmount += length;
        }
        if (cb) {
          const err2 = new Error(
            `WebSocket is not open: readyState ${websocket.readyState} (${readyStates[websocket.readyState]})`
          );
          process.nextTick(cb, err2);
        }
      }
      function receiverOnConclude(code, reason) {
        const websocket = this[kWebSocket];
        websocket._closeFrameReceived = true;
        websocket._closeMessage = reason;
        websocket._closeCode = code;
        if (websocket._socket[kWebSocket] === void 0)
          return;
        websocket._socket.removeListener("data", socketOnData);
        process.nextTick(resume, websocket._socket);
        if (code === 1005)
          websocket.close();
        else
          websocket.close(code, reason);
      }
      function receiverOnDrain() {
        const websocket = this[kWebSocket];
        if (!websocket.isPaused)
          websocket._socket.resume();
      }
      function receiverOnError(err2) {
        const websocket = this[kWebSocket];
        if (websocket._socket[kWebSocket] !== void 0) {
          websocket._socket.removeListener("data", socketOnData);
          process.nextTick(resume, websocket._socket);
          websocket.close(err2[kStatusCode]);
        }
        websocket.emit("error", err2);
      }
      function receiverOnFinish() {
        this[kWebSocket].emitClose();
      }
      function receiverOnMessage(data, isBinary) {
        this[kWebSocket].emit("message", data, isBinary);
      }
      function receiverOnPing(data) {
        const websocket = this[kWebSocket];
        websocket.pong(data, !websocket._isServer, NOOP);
        websocket.emit("ping", data);
      }
      function receiverOnPong(data) {
        this[kWebSocket].emit("pong", data);
      }
      function resume(stream) {
        stream.resume();
      }
      function socketOnClose() {
        const websocket = this[kWebSocket];
        this.removeListener("close", socketOnClose);
        this.removeListener("data", socketOnData);
        this.removeListener("end", socketOnEnd);
        websocket._readyState = WebSocket2.CLOSING;
        let chunk;
        if (!this._readableState.endEmitted && !websocket._closeFrameReceived && !websocket._receiver._writableState.errorEmitted && (chunk = websocket._socket.read()) !== null) {
          websocket._receiver.write(chunk);
        }
        websocket._receiver.end();
        this[kWebSocket] = void 0;
        clearTimeout(websocket._closeTimer);
        if (websocket._receiver._writableState.finished || websocket._receiver._writableState.errorEmitted) {
          websocket.emitClose();
        } else {
          websocket._receiver.on("error", receiverOnFinish);
          websocket._receiver.on("finish", receiverOnFinish);
        }
      }
      function socketOnData(chunk) {
        if (!this[kWebSocket]._receiver.write(chunk)) {
          this.pause();
        }
      }
      function socketOnEnd() {
        const websocket = this[kWebSocket];
        websocket._readyState = WebSocket2.CLOSING;
        websocket._receiver.end();
        this.end();
      }
      function socketOnError() {
        const websocket = this[kWebSocket];
        this.removeListener("error", socketOnError);
        this.on("error", NOOP);
        if (websocket) {
          websocket._readyState = WebSocket2.CLOSING;
          this.destroy();
        }
      }
    }
  });

  // node_modules/.pnpm/ws@8.12.1/node_modules/ws/lib/subprotocol.js
  var require_subprotocol = __commonJS({
    "node_modules/.pnpm/ws@8.12.1/node_modules/ws/lib/subprotocol.js"(exports2, module2) {
      "use strict";
      var { tokenChars } = require_validation();
      function parse4(header) {
        const protocols = /* @__PURE__ */ new Set();
        let start = -1;
        let end = -1;
        let i = 0;
        for (i; i < header.length; i++) {
          const code = header.charCodeAt(i);
          if (end === -1 && tokenChars[code] === 1) {
            if (start === -1)
              start = i;
          } else if (i !== 0 && (code === 32 || code === 9)) {
            if (end === -1 && start !== -1)
              end = i;
          } else if (code === 44) {
            if (start === -1) {
              throw new SyntaxError(`Unexpected character at index ${i}`);
            }
            if (end === -1)
              end = i;
            const protocol2 = header.slice(start, end);
            if (protocols.has(protocol2)) {
              throw new SyntaxError(`The "${protocol2}" subprotocol is duplicated`);
            }
            protocols.add(protocol2);
            start = end = -1;
          } else {
            throw new SyntaxError(`Unexpected character at index ${i}`);
          }
        }
        if (start === -1 || end !== -1) {
          throw new SyntaxError("Unexpected end of input");
        }
        const protocol = header.slice(start, i);
        if (protocols.has(protocol)) {
          throw new SyntaxError(`The "${protocol}" subprotocol is duplicated`);
        }
        protocols.add(protocol);
        return protocols;
      }
      module2.exports = { parse: parse4 };
    }
  });

  // node_modules/.pnpm/ws@8.12.1/node_modules/ws/lib/websocket-server.js
  var require_websocket_server = __commonJS({
    "node_modules/.pnpm/ws@8.12.1/node_modules/ws/lib/websocket-server.js"(exports2, module2) {
      "use strict";
      var EventEmitter = __require("events");
      var http = __require("http");
      var https = __require("https");
      var net2 = __require("net");
      var tls = __require("tls");
      var { createHash } = __require("crypto");
      var extension = require_extension();
      var PerMessageDeflate = require_permessage_deflate();
      var subprotocol = require_subprotocol();
      var WebSocket2 = require_websocket();
      var { GUID, kWebSocket } = require_constants();
      var keyRegex = /^[+/0-9A-Za-z]{22}==$/;
      var RUNNING = 0;
      var CLOSING = 1;
      var CLOSED = 2;
      var WebSocketServer2 = class extends EventEmitter {
        /**
         * Create a `WebSocketServer` instance.
         *
         * @param {Object} options Configuration options
         * @param {Number} [options.backlog=511] The maximum length of the queue of
         *     pending connections
         * @param {Boolean} [options.clientTracking=true] Specifies whether or not to
         *     track clients
         * @param {Function} [options.handleProtocols] A hook to handle protocols
         * @param {String} [options.host] The hostname where to bind the server
         * @param {Number} [options.maxPayload=104857600] The maximum allowed message
         *     size
         * @param {Boolean} [options.noServer=false] Enable no server mode
         * @param {String} [options.path] Accept only connections matching this path
         * @param {(Boolean|Object)} [options.perMessageDeflate=false] Enable/disable
         *     permessage-deflate
         * @param {Number} [options.port] The port where to bind the server
         * @param {(http.Server|https.Server)} [options.server] A pre-created HTTP/S
         *     server to use
         * @param {Boolean} [options.skipUTF8Validation=false] Specifies whether or
         *     not to skip UTF-8 validation for text and close messages
         * @param {Function} [options.verifyClient] A hook to reject connections
         * @param {Function} [options.WebSocket=WebSocket] Specifies the `WebSocket`
         *     class to use. It must be the `WebSocket` class or class that extends it
         * @param {Function} [callback] A listener for the `listening` event
         */
        constructor(options, callback) {
          super();
          options = {
            maxPayload: 100 * 1024 * 1024,
            skipUTF8Validation: false,
            perMessageDeflate: false,
            handleProtocols: null,
            clientTracking: true,
            verifyClient: null,
            noServer: false,
            backlog: null,
            // use default (511 as implemented in net.js)
            server: null,
            host: null,
            path: null,
            port: null,
            WebSocket: WebSocket2,
            ...options
          };
          if (options.port == null && !options.server && !options.noServer || options.port != null && (options.server || options.noServer) || options.server && options.noServer) {
            throw new TypeError(
              'One and only one of the "port", "server", or "noServer" options must be specified'
            );
          }
          if (options.port != null) {
            this._server = http.createServer((req, res) => {
              const body = http.STATUS_CODES[426];
              res.writeHead(426, {
                "Content-Length": body.length,
                "Content-Type": "text/plain"
              });
              res.end(body);
            });
            this._server.listen(
              options.port,
              options.host,
              options.backlog,
              callback
            );
          } else if (options.server) {
            this._server = options.server;
          }
          if (this._server) {
            const emitConnection = this.emit.bind(this, "connection");
            this._removeListeners = addListeners(this._server, {
              listening: this.emit.bind(this, "listening"),
              error: this.emit.bind(this, "error"),
              upgrade: (req, socket, head) => {
                this.handleUpgrade(req, socket, head, emitConnection);
              }
            });
          }
          if (options.perMessageDeflate === true)
            options.perMessageDeflate = {};
          if (options.clientTracking) {
            this.clients = /* @__PURE__ */ new Set();
            this._shouldEmitClose = false;
          }
          this.options = options;
          this._state = RUNNING;
        }
        /**
         * Returns the bound address, the address family name, and port of the server
         * as reported by the operating system if listening on an IP socket.
         * If the server is listening on a pipe or UNIX domain socket, the name is
         * returned as a string.
         *
         * @return {(Object|String|null)} The address of the server
         * @public
         */
        address() {
          if (this.options.noServer) {
            throw new Error('The server is operating in "noServer" mode');
          }
          if (!this._server)
            return null;
          return this._server.address();
        }
        /**
         * Stop the server from accepting new connections and emit the `'close'` event
         * when all existing connections are closed.
         *
         * @param {Function} [cb] A one-time listener for the `'close'` event
         * @public
         */
        close(cb) {
          if (this._state === CLOSED) {
            if (cb) {
              this.once("close", () => {
                cb(new Error("The server is not running"));
              });
            }
            process.nextTick(emitClose, this);
            return;
          }
          if (cb)
            this.once("close", cb);
          if (this._state === CLOSING)
            return;
          this._state = CLOSING;
          if (this.options.noServer || this.options.server) {
            if (this._server) {
              this._removeListeners();
              this._removeListeners = this._server = null;
            }
            if (this.clients) {
              if (!this.clients.size) {
                process.nextTick(emitClose, this);
              } else {
                this._shouldEmitClose = true;
              }
            } else {
              process.nextTick(emitClose, this);
            }
          } else {
            const server = this._server;
            this._removeListeners();
            this._removeListeners = this._server = null;
            server.close(() => {
              emitClose(this);
            });
          }
        }
        /**
         * See if a given request should be handled by this server instance.
         *
         * @param {http.IncomingMessage} req Request object to inspect
         * @return {Boolean} `true` if the request is valid, else `false`
         * @public
         */
        shouldHandle(req) {
          if (this.options.path) {
            const index = req.url.indexOf("?");
            const pathname = index !== -1 ? req.url.slice(0, index) : req.url;
            if (pathname !== this.options.path)
              return false;
          }
          return true;
        }
        /**
         * Handle a HTTP Upgrade request.
         *
         * @param {http.IncomingMessage} req The request object
         * @param {(net.Socket|tls.Socket)} socket The network socket between the
         *     server and client
         * @param {Buffer} head The first packet of the upgraded stream
         * @param {Function} cb Callback
         * @public
         */
        handleUpgrade(req, socket, head, cb) {
          socket.on("error", socketOnError);
          const key = req.headers["sec-websocket-key"];
          const version = +req.headers["sec-websocket-version"];
          if (req.method !== "GET") {
            const message = "Invalid HTTP method";
            abortHandshakeOrEmitwsClientError(this, req, socket, 405, message);
            return;
          }
          if (req.headers.upgrade.toLowerCase() !== "websocket") {
            const message = "Invalid Upgrade header";
            abortHandshakeOrEmitwsClientError(this, req, socket, 400, message);
            return;
          }
          if (!key || !keyRegex.test(key)) {
            const message = "Missing or invalid Sec-WebSocket-Key header";
            abortHandshakeOrEmitwsClientError(this, req, socket, 400, message);
            return;
          }
          if (version !== 8 && version !== 13) {
            const message = "Missing or invalid Sec-WebSocket-Version header";
            abortHandshakeOrEmitwsClientError(this, req, socket, 400, message);
            return;
          }
          if (!this.shouldHandle(req)) {
            abortHandshake(socket, 400);
            return;
          }
          const secWebSocketProtocol = req.headers["sec-websocket-protocol"];
          let protocols = /* @__PURE__ */ new Set();
          if (secWebSocketProtocol !== void 0) {
            try {
              protocols = subprotocol.parse(secWebSocketProtocol);
            } catch (err2) {
              const message = "Invalid Sec-WebSocket-Protocol header";
              abortHandshakeOrEmitwsClientError(this, req, socket, 400, message);
              return;
            }
          }
          const secWebSocketExtensions = req.headers["sec-websocket-extensions"];
          const extensions = {};
          if (this.options.perMessageDeflate && secWebSocketExtensions !== void 0) {
            const perMessageDeflate = new PerMessageDeflate(
              this.options.perMessageDeflate,
              true,
              this.options.maxPayload
            );
            try {
              const offers = extension.parse(secWebSocketExtensions);
              if (offers[PerMessageDeflate.extensionName]) {
                perMessageDeflate.accept(offers[PerMessageDeflate.extensionName]);
                extensions[PerMessageDeflate.extensionName] = perMessageDeflate;
              }
            } catch (err2) {
              const message = "Invalid or unacceptable Sec-WebSocket-Extensions header";
              abortHandshakeOrEmitwsClientError(this, req, socket, 400, message);
              return;
            }
          }
          if (this.options.verifyClient) {
            const info = {
              origin: req.headers[`${version === 8 ? "sec-websocket-origin" : "origin"}`],
              secure: !!(req.socket.authorized || req.socket.encrypted),
              req
            };
            if (this.options.verifyClient.length === 2) {
              this.options.verifyClient(info, (verified, code, message, headers) => {
                if (!verified) {
                  return abortHandshake(socket, code || 401, message, headers);
                }
                this.completeUpgrade(
                  extensions,
                  key,
                  protocols,
                  req,
                  socket,
                  head,
                  cb
                );
              });
              return;
            }
            if (!this.options.verifyClient(info))
              return abortHandshake(socket, 401);
          }
          this.completeUpgrade(extensions, key, protocols, req, socket, head, cb);
        }
        /**
         * Upgrade the connection to WebSocket.
         *
         * @param {Object} extensions The accepted extensions
         * @param {String} key The value of the `Sec-WebSocket-Key` header
         * @param {Set} protocols The subprotocols
         * @param {http.IncomingMessage} req The request object
         * @param {(net.Socket|tls.Socket)} socket The network socket between the
         *     server and client
         * @param {Buffer} head The first packet of the upgraded stream
         * @param {Function} cb Callback
         * @throws {Error} If called more than once with the same socket
         * @private
         */
        completeUpgrade(extensions, key, protocols, req, socket, head, cb) {
          if (!socket.readable || !socket.writable)
            return socket.destroy();
          if (socket[kWebSocket]) {
            throw new Error(
              "server.handleUpgrade() was called more than once with the same socket, possibly due to a misconfiguration"
            );
          }
          if (this._state > RUNNING)
            return abortHandshake(socket, 503);
          const digest = createHash("sha1").update(key + GUID).digest("base64");
          const headers = [
            "HTTP/1.1 101 Switching Protocols",
            "Upgrade: websocket",
            "Connection: Upgrade",
            `Sec-WebSocket-Accept: ${digest}`
          ];
          const ws = new this.options.WebSocket(null);
          if (protocols.size) {
            const protocol = this.options.handleProtocols ? this.options.handleProtocols(protocols, req) : protocols.values().next().value;
            if (protocol) {
              headers.push(`Sec-WebSocket-Protocol: ${protocol}`);
              ws._protocol = protocol;
            }
          }
          if (extensions[PerMessageDeflate.extensionName]) {
            const params = extensions[PerMessageDeflate.extensionName].params;
            const value = extension.format({
              [PerMessageDeflate.extensionName]: [params]
            });
            headers.push(`Sec-WebSocket-Extensions: ${value}`);
            ws._extensions = extensions;
          }
          this.emit("headers", headers, req);
          socket.write(headers.concat("\r\n").join("\r\n"));
          socket.removeListener("error", socketOnError);
          ws.setSocket(socket, head, {
            maxPayload: this.options.maxPayload,
            skipUTF8Validation: this.options.skipUTF8Validation
          });
          if (this.clients) {
            this.clients.add(ws);
            ws.on("close", () => {
              this.clients.delete(ws);
              if (this._shouldEmitClose && !this.clients.size) {
                process.nextTick(emitClose, this);
              }
            });
          }
          cb(ws, req);
        }
      };
      module2.exports = WebSocketServer2;
      function addListeners(server, map) {
        for (const event of Object.keys(map))
          server.on(event, map[event]);
        return function removeListeners() {
          for (const event of Object.keys(map)) {
            server.removeListener(event, map[event]);
          }
        };
      }
      function emitClose(server) {
        server._state = CLOSED;
        server.emit("close");
      }
      function socketOnError() {
        this.destroy();
      }
      function abortHandshake(socket, code, message, headers) {
        message = message || http.STATUS_CODES[code];
        headers = {
          Connection: "close",
          "Content-Type": "text/html",
          "Content-Length": Buffer.byteLength(message),
          ...headers
        };
        socket.once("finish", socket.destroy);
        socket.end(
          `HTTP/1.1 ${code} ${http.STATUS_CODES[code]}\r
` + Object.keys(headers).map((h) => `${h}: ${headers[h]}`).join("\r\n") + "\r\n\r\n" + message
        );
      }
      function abortHandshakeOrEmitwsClientError(server, req, socket, code, message) {
        if (server.listenerCount("wsClientError")) {
          const err2 = new Error(message);
          Error.captureStackTrace(err2, abortHandshakeOrEmitwsClientError);
          server.emit("wsClientError", err2, socket, req);
        } else {
          abortHandshake(socket, code, message);
        }
      }
    }
  });

  // node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_freeGlobal.js
  var require_freeGlobal = __commonJS({
    "node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_freeGlobal.js"(exports2, module2) {
      var freeGlobal = typeof global == "object" && global && global.Object === Object && global;
      module2.exports = freeGlobal;
    }
  });

  // node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_root.js
  var require_root = __commonJS({
    "node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_root.js"(exports2, module2) {
      var freeGlobal = require_freeGlobal();
      var freeSelf = typeof self == "object" && self && self.Object === Object && self;
      var root = freeGlobal || freeSelf || Function("return this")();
      module2.exports = root;
    }
  });

  // node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_Symbol.js
  var require_Symbol = __commonJS({
    "node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_Symbol.js"(exports2, module2) {
      var root = require_root();
      var Symbol2 = root.Symbol;
      module2.exports = Symbol2;
    }
  });

  // node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_getRawTag.js
  var require_getRawTag = __commonJS({
    "node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_getRawTag.js"(exports2, module2) {
      var Symbol2 = require_Symbol();
      var objectProto = Object.prototype;
      var hasOwnProperty = objectProto.hasOwnProperty;
      var nativeObjectToString = objectProto.toString;
      var symToStringTag = Symbol2 ? Symbol2.toStringTag : void 0;
      function getRawTag(value) {
        var isOwn = hasOwnProperty.call(value, symToStringTag), tag = value[symToStringTag];
        try {
          value[symToStringTag] = void 0;
          var unmasked = true;
        } catch (e) {
        }
        var result = nativeObjectToString.call(value);
        if (unmasked) {
          if (isOwn) {
            value[symToStringTag] = tag;
          } else {
            delete value[symToStringTag];
          }
        }
        return result;
      }
      module2.exports = getRawTag;
    }
  });

  // node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_objectToString.js
  var require_objectToString = __commonJS({
    "node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_objectToString.js"(exports2, module2) {
      var objectProto = Object.prototype;
      var nativeObjectToString = objectProto.toString;
      function objectToString(value) {
        return nativeObjectToString.call(value);
      }
      module2.exports = objectToString;
    }
  });

  // node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_baseGetTag.js
  var require_baseGetTag = __commonJS({
    "node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_baseGetTag.js"(exports2, module2) {
      var Symbol2 = require_Symbol();
      var getRawTag = require_getRawTag();
      var objectToString = require_objectToString();
      var nullTag = "[object Null]";
      var undefinedTag = "[object Undefined]";
      var symToStringTag = Symbol2 ? Symbol2.toStringTag : void 0;
      function baseGetTag(value) {
        if (value == null) {
          return value === void 0 ? undefinedTag : nullTag;
        }
        return symToStringTag && symToStringTag in Object(value) ? getRawTag(value) : objectToString(value);
      }
      module2.exports = baseGetTag;
    }
  });

  // node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_overArg.js
  var require_overArg = __commonJS({
    "node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_overArg.js"(exports2, module2) {
      function overArg(func, transform) {
        return function(arg) {
          return func(transform(arg));
        };
      }
      module2.exports = overArg;
    }
  });

  // node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_getPrototype.js
  var require_getPrototype = __commonJS({
    "node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_getPrototype.js"(exports2, module2) {
      var overArg = require_overArg();
      var getPrototype = overArg(Object.getPrototypeOf, Object);
      module2.exports = getPrototype;
    }
  });

  // node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/isObjectLike.js
  var require_isObjectLike = __commonJS({
    "node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/isObjectLike.js"(exports2, module2) {
      function isObjectLike(value) {
        return value != null && typeof value == "object";
      }
      module2.exports = isObjectLike;
    }
  });

  // node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/isPlainObject.js
  var require_isPlainObject = __commonJS({
    "node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/isPlainObject.js"(exports2, module2) {
      var baseGetTag = require_baseGetTag();
      var getPrototype = require_getPrototype();
      var isObjectLike = require_isObjectLike();
      var objectTag = "[object Object]";
      var funcProto = Function.prototype;
      var objectProto = Object.prototype;
      var funcToString = funcProto.toString;
      var hasOwnProperty = objectProto.hasOwnProperty;
      var objectCtorString = funcToString.call(Object);
      function isPlainObject(value) {
        if (!isObjectLike(value) || baseGetTag(value) != objectTag) {
          return false;
        }
        var proto3 = getPrototype(value);
        if (proto3 === null) {
          return true;
        }
        var Ctor = hasOwnProperty.call(proto3, "constructor") && proto3.constructor;
        return typeof Ctor == "function" && Ctor instanceof Ctor && funcToString.call(Ctor) == objectCtorString;
      }
      module2.exports = isPlainObject;
    }
  });

  // node_modules/.pnpm/pretty-error@4.0.0/node_modules/pretty-error/lib/defaultStyle.js
  var require_defaultStyle = __commonJS({
    "node_modules/.pnpm/pretty-error@4.0.0/node_modules/pretty-error/lib/defaultStyle.js"(exports2, module2) {
      module2.exports = function() {
        return {
          "pretty-error": {
            display: "block",
            marginLeft: "2"
          },
          "pretty-error > header": {
            display: "block"
          },
          "pretty-error > header > title > kind": {
            background: "red",
            color: "bright-white"
          },
          "pretty-error > header > title > wrapper": {
            marginRight: "1",
            color: "grey"
          },
          "pretty-error > header > colon": {
            color: "grey",
            marginRight: 1
          },
          "pretty-error > header > message": {
            color: "bright-white"
          },
          "pretty-error > trace": {
            display: "block",
            marginTop: 1
          },
          "pretty-error > trace > item": {
            display: "block",
            marginBottom: 1,
            marginLeft: 2,
            bullet: '"<grey>-</grey>"'
          },
          "pretty-error > trace > item > header": {
            display: "block"
          },
          "pretty-error > trace > item > header > pointer > file": {
            color: "bright-yellow"
          },
          "pretty-error > trace > item > header > pointer > colon": {
            color: "grey"
          },
          "pretty-error > trace > item > header > pointer > line": {
            color: "bright-yellow",
            marginRight: 1
          },
          "pretty-error > trace > item > header > what": {
            color: "white"
          },
          "pretty-error > trace > item > footer": {
            display: "block"
          },
          "pretty-error > trace > item > footer > addr": {
            display: "block",
            color: "grey"
          },
          "pretty-error > trace > item > footer > extra": {
            display: "block",
            color: "grey"
          }
        };
      };
    }
  });

  // node_modules/.pnpm/pretty-error@4.0.0/node_modules/pretty-error/lib/ParsedError.js
  var require_ParsedError = __commonJS({
    "node_modules/.pnpm/pretty-error@4.0.0/node_modules/pretty-error/lib/ParsedError.js"(exports2, module2) {
      var ParsedError;
      var prop;
      var sysPath;
      var _fn;
      var _i;
      var _len;
      var _ref;
      sysPath = __require("path");
      module2.exports = ParsedError = function() {
        function ParsedError2(error) {
          this.error = error;
          this._parse();
        }
        ParsedError2.prototype._parse = function() {
          var m;
          this._trace = [];
          this._kind = "Error";
          this._wrapper = "";
          if (this.error.wrapper != null) {
            this._wrapper = String(this.error.wrapper);
          }
          if (typeof this.error !== "object") {
            this._message = String(this.error);
          } else {
            this._stack = this.error.stack;
            if (this.error.kind != null) {
              this._kind = String(this.error.kind);
            } else if (typeof this._stack === "string") {
              if (m = this._stack.match(/^([a-zA-Z0-9\_\$]+):\ /)) {
                this._kind = m[1];
              }
            }
            this._message = this.error.message != null && String(this.error.message) || "";
            if (typeof this._stack === "string") {
              this._parseStack();
            }
          }
        };
        ParsedError2.prototype._parseStack = function() {
          var line, message, messageLines, reachedTrace, _i2, _len2, _ref2;
          messageLines = [];
          reachedTrace = false;
          _ref2 = this._stack.split("\n");
          for (_i2 = 0, _len2 = _ref2.length; _i2 < _len2; _i2++) {
            line = _ref2[_i2];
            if (line.trim() === "") {
              continue;
            }
            if (reachedTrace) {
              this._trace.push(this._parseTraceItem(line));
            } else {
              if (line.match(/^\s*at\s.+/)) {
                reachedTrace = true;
                this._trace.push(this._parseTraceItem(line));
              } else if (!this._message.split("\n".indexOf(line))) {
                messageLines.push(line);
              }
            }
          }
          message = messageLines.join("\n");
          if (message.substr(0, this._kind.length) === this._kind) {
            message = message.substr(this._kind.length, message.length).replace(/^\:\s+/, "");
          }
          if (message.length) {
            this._message = this._message.length ? [this._message, message].join("\n") : message;
          }
        };
        ParsedError2.prototype._parseTraceItem = function(text) {
          var addr, col, d, dir2, file, jsCol, jsLine, line, m, original, packageName, packages, path4, r, remaining, shortenedAddr, shortenedPath, what;
          text = text.trim();
          if (text === "") {
            return;
          }
          if (!text.match(/^at\ /)) {
            return text;
          }
          text = text.replace(/^at /, "");
          if (text === "Error (<anonymous>)" || text === "Error (<anonymous>:null:null)") {
            return;
          }
          original = text;
          what = null;
          addr = null;
          path4 = null;
          dir2 = null;
          file = null;
          line = null;
          col = null;
          jsLine = null;
          jsCol = null;
          shortenedPath = null;
          shortenedAddr = null;
          packageName = "[current]";
          if (m = text.match(/\(([^\)]+)\)$/)) {
            addr = m[1].trim();
          }
          if (addr != null) {
            what = text.substr(0, text.length - addr.length - 2);
            what = what.trim();
          }
          if (addr == null) {
            addr = text.trim();
          }
          addr = this._fixPath(addr);
          remaining = addr;
          if (m = remaining.match(/\,\ <js>:(\d+):(\d+)$/)) {
            jsLine = m[1];
            jsCol = m[2];
            remaining = remaining.substr(0, remaining.length - m[0].length);
          }
          if (m = remaining.match(/:(\d+):(\d+)$/)) {
            line = m[1];
            col = m[2];
            remaining = remaining.substr(0, remaining.length - m[0].length);
            path4 = remaining;
          }
          if (path4 != null) {
            file = sysPath.basename(path4);
            dir2 = sysPath.dirname(path4);
            if (dir2 === ".") {
              dir2 = "";
            }
            path4 = this._fixPath(path4);
            file = this._fixPath(file);
            dir2 = this._fixPath(dir2);
          }
          if (dir2 != null) {
            d = dir2.replace(/[\\]{1,2}/g, "/");
            if (m = d.match(/node_modules\/([^\/]+)(?!.*node_modules.*)/)) {
              packageName = m[1];
            }
          }
          if (jsLine == null) {
            jsLine = line;
            jsCol = col;
          }
          if (path4 != null) {
            r = this._rectifyPath(path4);
            shortenedPath = r.path;
            shortenedAddr = shortenedPath + addr.substr(path4.length, addr.length);
            packages = r.packages;
          }
          return {
            original,
            what,
            addr,
            path: path4,
            dir: dir2,
            file,
            line: parseInt(line),
            col: parseInt(col),
            jsLine: parseInt(jsLine),
            jsCol: parseInt(jsCol),
            packageName,
            shortenedPath,
            shortenedAddr,
            packages: packages || []
          };
        };
        ParsedError2.prototype._getMessage = function() {
          return this._message;
        };
        ParsedError2.prototype._getKind = function() {
          return this._kind;
        };
        ParsedError2.prototype._getWrapper = function() {
          return this._wrapper;
        };
        ParsedError2.prototype._getStack = function() {
          return this._stack;
        };
        ParsedError2.prototype._getArguments = function() {
          return this.error["arguments"];
        };
        ParsedError2.prototype._getType = function() {
          return this.error.type;
        };
        ParsedError2.prototype._getTrace = function() {
          return this._trace;
        };
        ParsedError2.prototype._fixPath = function(path4) {
          return path4.replace(/[\\]{1,2}/g, "/");
        };
        ParsedError2.prototype._rectifyPath = function(path4, nameForCurrentPackage) {
          var m, packages, parts, remaining, rest;
          path4 = String(path4);
          remaining = path4;
          if (!(m = path4.match(/^(.+?)\/node_modules\/(.+)$/))) {
            return {
              path: path4,
              packages: []
            };
          }
          parts = [];
          packages = [];
          if (typeof nameForCurrentPackage === "string") {
            parts.push("[" + nameForCurrentPackage + "]");
            packages.push("[" + nameForCurrentPackage + "]");
          } else {
            parts.push("[" + m[1].match(/([^\/]+)$/)[1] + "]");
            packages.push(m[1].match(/([^\/]+)$/)[1]);
          }
          rest = m[2];
          while (m = rest.match(/([^\/]+)\/node_modules\/(.+)$/)) {
            parts.push("[" + m[1] + "]");
            packages.push(m[1]);
            rest = m[2];
          }
          if (m = rest.match(/([^\/]+)\/(.+)$/)) {
            parts.push("[" + m[1] + "]");
            packages.push(m[1]);
            rest = m[2];
          }
          parts.push(rest);
          return {
            path: parts.join("/"),
            packages
          };
        };
        return ParsedError2;
      }();
      _ref = ["message", "kind", "arguments", "type", "stack", "trace", "wrapper"];
      _fn = function() {
        var methodName;
        methodName = "_get" + prop[0].toUpperCase() + prop.substr(1, prop.length);
        return Object.defineProperty(ParsedError.prototype, prop, {
          get: function() {
            return this[methodName]();
          }
        });
      };
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        prop = _ref[_i];
        _fn();
      }
    }
  });

  // node_modules/.pnpm/pretty-error@4.0.0/node_modules/pretty-error/lib/nodePaths.js
  var require_nodePaths = __commonJS({
    "node_modules/.pnpm/pretty-error@4.0.0/node_modules/pretty-error/lib/nodePaths.js"(exports2, module2) {
      module2.exports = ["_debugger.js", "_http_agent.js", "_http_client.js", "_http_common.js", "_http_incoming.js", "_http_outgoing.js", "_http_server.js", "_linklist.js", "_stream_duplex.js", "_stream_passthrough.js", "_stream_readable.js", "_stream_transform.js", "_stream_writable.js", "_tls_legacy.js", "_tls_wrap.js", "assert.js", "buffer.js", "child_process.js", "cluster.js", "console.js", "constants.js", "crypto.js", "dgram.js", "dns.js", "domain.js", "events.js", "freelist.js", "fs.js", "http.js", "https.js", "module.js", "net.js", "os.js", "path.js", "punycode.js", "querystring.js", "readline.js", "repl.js", "smalloc.js", "stream.js", "string_decoder.js", "sys.js", "timers.js", "tls.js", "tty.js", "url.js", "util.js", "vm.js", "zlib.js", "node.js"];
    }
  });

  // node_modules/.pnpm/entities@2.2.0/node_modules/entities/lib/maps/decode.json
  var require_decode = __commonJS({
    "node_modules/.pnpm/entities@2.2.0/node_modules/entities/lib/maps/decode.json"(exports2, module2) {
      module2.exports = { "0": 65533, "128": 8364, "130": 8218, "131": 402, "132": 8222, "133": 8230, "134": 8224, "135": 8225, "136": 710, "137": 8240, "138": 352, "139": 8249, "140": 338, "142": 381, "145": 8216, "146": 8217, "147": 8220, "148": 8221, "149": 8226, "150": 8211, "151": 8212, "152": 732, "153": 8482, "154": 353, "155": 8250, "156": 339, "158": 382, "159": 376 };
    }
  });

  // node_modules/.pnpm/entities@2.2.0/node_modules/entities/lib/decode_codepoint.js
  var require_decode_codepoint = __commonJS({
    "node_modules/.pnpm/entities@2.2.0/node_modules/entities/lib/decode_codepoint.js"(exports2) {
      "use strict";
      var __importDefault = exports2 && exports2.__importDefault || function(mod) {
        return mod && mod.__esModule ? mod : { "default": mod };
      };
      Object.defineProperty(exports2, "__esModule", { value: true });
      var decode_json_1 = __importDefault(require_decode());
      var fromCodePoint = (
        // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition
        String.fromCodePoint || function(codePoint) {
          var output = "";
          if (codePoint > 65535) {
            codePoint -= 65536;
            output += String.fromCharCode(codePoint >>> 10 & 1023 | 55296);
            codePoint = 56320 | codePoint & 1023;
          }
          output += String.fromCharCode(codePoint);
          return output;
        }
      );
      function decodeCodePoint(codePoint) {
        if (codePoint >= 55296 && codePoint <= 57343 || codePoint > 1114111) {
          return "\uFFFD";
        }
        if (codePoint in decode_json_1.default) {
          codePoint = decode_json_1.default[codePoint];
        }
        return fromCodePoint(codePoint);
      }
      exports2.default = decodeCodePoint;
    }
  });

  // node_modules/.pnpm/entities@2.2.0/node_modules/entities/lib/maps/entities.json
  var require_entities = __commonJS({
    "node_modules/.pnpm/entities@2.2.0/node_modules/entities/lib/maps/entities.json"(exports2, module2) {
      module2.exports = { Aacute: "\xC1", aacute: "\xE1", Abreve: "\u0102", abreve: "\u0103", ac: "\u223E", acd: "\u223F", acE: "\u223E\u0333", Acirc: "\xC2", acirc: "\xE2", acute: "\xB4", Acy: "\u0410", acy: "\u0430", AElig: "\xC6", aelig: "\xE6", af: "\u2061", Afr: "\u{1D504}", afr: "\u{1D51E}", Agrave: "\xC0", agrave: "\xE0", alefsym: "\u2135", aleph: "\u2135", Alpha: "\u0391", alpha: "\u03B1", Amacr: "\u0100", amacr: "\u0101", amalg: "\u2A3F", amp: "&", AMP: "&", andand: "\u2A55", And: "\u2A53", and: "\u2227", andd: "\u2A5C", andslope: "\u2A58", andv: "\u2A5A", ang: "\u2220", ange: "\u29A4", angle: "\u2220", angmsdaa: "\u29A8", angmsdab: "\u29A9", angmsdac: "\u29AA", angmsdad: "\u29AB", angmsdae: "\u29AC", angmsdaf: "\u29AD", angmsdag: "\u29AE", angmsdah: "\u29AF", angmsd: "\u2221", angrt: "\u221F", angrtvb: "\u22BE", angrtvbd: "\u299D", angsph: "\u2222", angst: "\xC5", angzarr: "\u237C", Aogon: "\u0104", aogon: "\u0105", Aopf: "\u{1D538}", aopf: "\u{1D552}", apacir: "\u2A6F", ap: "\u2248", apE: "\u2A70", ape: "\u224A", apid: "\u224B", apos: "'", ApplyFunction: "\u2061", approx: "\u2248", approxeq: "\u224A", Aring: "\xC5", aring: "\xE5", Ascr: "\u{1D49C}", ascr: "\u{1D4B6}", Assign: "\u2254", ast: "*", asymp: "\u2248", asympeq: "\u224D", Atilde: "\xC3", atilde: "\xE3", Auml: "\xC4", auml: "\xE4", awconint: "\u2233", awint: "\u2A11", backcong: "\u224C", backepsilon: "\u03F6", backprime: "\u2035", backsim: "\u223D", backsimeq: "\u22CD", Backslash: "\u2216", Barv: "\u2AE7", barvee: "\u22BD", barwed: "\u2305", Barwed: "\u2306", barwedge: "\u2305", bbrk: "\u23B5", bbrktbrk: "\u23B6", bcong: "\u224C", Bcy: "\u0411", bcy: "\u0431", bdquo: "\u201E", becaus: "\u2235", because: "\u2235", Because: "\u2235", bemptyv: "\u29B0", bepsi: "\u03F6", bernou: "\u212C", Bernoullis: "\u212C", Beta: "\u0392", beta: "\u03B2", beth: "\u2136", between: "\u226C", Bfr: "\u{1D505}", bfr: "\u{1D51F}", bigcap: "\u22C2", bigcirc: "\u25EF", bigcup: "\u22C3", bigodot: "\u2A00", bigoplus: "\u2A01", bigotimes: "\u2A02", bigsqcup: "\u2A06", bigstar: "\u2605", bigtriangledown: "\u25BD", bigtriangleup: "\u25B3", biguplus: "\u2A04", bigvee: "\u22C1", bigwedge: "\u22C0", bkarow: "\u290D", blacklozenge: "\u29EB", blacksquare: "\u25AA", blacktriangle: "\u25B4", blacktriangledown: "\u25BE", blacktriangleleft: "\u25C2", blacktriangleright: "\u25B8", blank: "\u2423", blk12: "\u2592", blk14: "\u2591", blk34: "\u2593", block: "\u2588", bne: "=\u20E5", bnequiv: "\u2261\u20E5", bNot: "\u2AED", bnot: "\u2310", Bopf: "\u{1D539}", bopf: "\u{1D553}", bot: "\u22A5", bottom: "\u22A5", bowtie: "\u22C8", boxbox: "\u29C9", boxdl: "\u2510", boxdL: "\u2555", boxDl: "\u2556", boxDL: "\u2557", boxdr: "\u250C", boxdR: "\u2552", boxDr: "\u2553", boxDR: "\u2554", boxh: "\u2500", boxH: "\u2550", boxhd: "\u252C", boxHd: "\u2564", boxhD: "\u2565", boxHD: "\u2566", boxhu: "\u2534", boxHu: "\u2567", boxhU: "\u2568", boxHU: "\u2569", boxminus: "\u229F", boxplus: "\u229E", boxtimes: "\u22A0", boxul: "\u2518", boxuL: "\u255B", boxUl: "\u255C", boxUL: "\u255D", boxur: "\u2514", boxuR: "\u2558", boxUr: "\u2559", boxUR: "\u255A", boxv: "\u2502", boxV: "\u2551", boxvh: "\u253C", boxvH: "\u256A", boxVh: "\u256B", boxVH: "\u256C", boxvl: "\u2524", boxvL: "\u2561", boxVl: "\u2562", boxVL: "\u2563", boxvr: "\u251C", boxvR: "\u255E", boxVr: "\u255F", boxVR: "\u2560", bprime: "\u2035", breve: "\u02D8", Breve: "\u02D8", brvbar: "\xA6", bscr: "\u{1D4B7}", Bscr: "\u212C", bsemi: "\u204F", bsim: "\u223D", bsime: "\u22CD", bsolb: "\u29C5", bsol: "\\", bsolhsub: "\u27C8", bull: "\u2022", bullet: "\u2022", bump: "\u224E", bumpE: "\u2AAE", bumpe: "\u224F", Bumpeq: "\u224E", bumpeq: "\u224F", Cacute: "\u0106", cacute: "\u0107", capand: "\u2A44", capbrcup: "\u2A49", capcap: "\u2A4B", cap: "\u2229", Cap: "\u22D2", capcup: "\u2A47", capdot: "\u2A40", CapitalDifferentialD: "\u2145", caps: "\u2229\uFE00", caret: "\u2041", caron: "\u02C7", Cayleys: "\u212D", ccaps: "\u2A4D", Ccaron: "\u010C", ccaron: "\u010D", Ccedil: "\xC7", ccedil: "\xE7", Ccirc: "\u0108", ccirc: "\u0109", Cconint: "\u2230", ccups: "\u2A4C", ccupssm: "\u2A50", Cdot: "\u010A", cdot: "\u010B", cedil: "\xB8", Cedilla: "\xB8", cemptyv: "\u29B2", cent: "\xA2", centerdot: "\xB7", CenterDot: "\xB7", cfr: "\u{1D520}", Cfr: "\u212D", CHcy: "\u0427", chcy: "\u0447", check: "\u2713", checkmark: "\u2713", Chi: "\u03A7", chi: "\u03C7", circ: "\u02C6", circeq: "\u2257", circlearrowleft: "\u21BA", circlearrowright: "\u21BB", circledast: "\u229B", circledcirc: "\u229A", circleddash: "\u229D", CircleDot: "\u2299", circledR: "\xAE", circledS: "\u24C8", CircleMinus: "\u2296", CirclePlus: "\u2295", CircleTimes: "\u2297", cir: "\u25CB", cirE: "\u29C3", cire: "\u2257", cirfnint: "\u2A10", cirmid: "\u2AEF", cirscir: "\u29C2", ClockwiseContourIntegral: "\u2232", CloseCurlyDoubleQuote: "\u201D", CloseCurlyQuote: "\u2019", clubs: "\u2663", clubsuit: "\u2663", colon: ":", Colon: "\u2237", Colone: "\u2A74", colone: "\u2254", coloneq: "\u2254", comma: ",", commat: "@", comp: "\u2201", compfn: "\u2218", complement: "\u2201", complexes: "\u2102", cong: "\u2245", congdot: "\u2A6D", Congruent: "\u2261", conint: "\u222E", Conint: "\u222F", ContourIntegral: "\u222E", copf: "\u{1D554}", Copf: "\u2102", coprod: "\u2210", Coproduct: "\u2210", copy: "\xA9", COPY: "\xA9", copysr: "\u2117", CounterClockwiseContourIntegral: "\u2233", crarr: "\u21B5", cross: "\u2717", Cross: "\u2A2F", Cscr: "\u{1D49E}", cscr: "\u{1D4B8}", csub: "\u2ACF", csube: "\u2AD1", csup: "\u2AD0", csupe: "\u2AD2", ctdot: "\u22EF", cudarrl: "\u2938", cudarrr: "\u2935", cuepr: "\u22DE", cuesc: "\u22DF", cularr: "\u21B6", cularrp: "\u293D", cupbrcap: "\u2A48", cupcap: "\u2A46", CupCap: "\u224D", cup: "\u222A", Cup: "\u22D3", cupcup: "\u2A4A", cupdot: "\u228D", cupor: "\u2A45", cups: "\u222A\uFE00", curarr: "\u21B7", curarrm: "\u293C", curlyeqprec: "\u22DE", curlyeqsucc: "\u22DF", curlyvee: "\u22CE", curlywedge: "\u22CF", curren: "\xA4", curvearrowleft: "\u21B6", curvearrowright: "\u21B7", cuvee: "\u22CE", cuwed: "\u22CF", cwconint: "\u2232", cwint: "\u2231", cylcty: "\u232D", dagger: "\u2020", Dagger: "\u2021", daleth: "\u2138", darr: "\u2193", Darr: "\u21A1", dArr: "\u21D3", dash: "\u2010", Dashv: "\u2AE4", dashv: "\u22A3", dbkarow: "\u290F", dblac: "\u02DD", Dcaron: "\u010E", dcaron: "\u010F", Dcy: "\u0414", dcy: "\u0434", ddagger: "\u2021", ddarr: "\u21CA", DD: "\u2145", dd: "\u2146", DDotrahd: "\u2911", ddotseq: "\u2A77", deg: "\xB0", Del: "\u2207", Delta: "\u0394", delta: "\u03B4", demptyv: "\u29B1", dfisht: "\u297F", Dfr: "\u{1D507}", dfr: "\u{1D521}", dHar: "\u2965", dharl: "\u21C3", dharr: "\u21C2", DiacriticalAcute: "\xB4", DiacriticalDot: "\u02D9", DiacriticalDoubleAcute: "\u02DD", DiacriticalGrave: "`", DiacriticalTilde: "\u02DC", diam: "\u22C4", diamond: "\u22C4", Diamond: "\u22C4", diamondsuit: "\u2666", diams: "\u2666", die: "\xA8", DifferentialD: "\u2146", digamma: "\u03DD", disin: "\u22F2", div: "\xF7", divide: "\xF7", divideontimes: "\u22C7", divonx: "\u22C7", DJcy: "\u0402", djcy: "\u0452", dlcorn: "\u231E", dlcrop: "\u230D", dollar: "$", Dopf: "\u{1D53B}", dopf: "\u{1D555}", Dot: "\xA8", dot: "\u02D9", DotDot: "\u20DC", doteq: "\u2250", doteqdot: "\u2251", DotEqual: "\u2250", dotminus: "\u2238", dotplus: "\u2214", dotsquare: "\u22A1", doublebarwedge: "\u2306", DoubleContourIntegral: "\u222F", DoubleDot: "\xA8", DoubleDownArrow: "\u21D3", DoubleLeftArrow: "\u21D0", DoubleLeftRightArrow: "\u21D4", DoubleLeftTee: "\u2AE4", DoubleLongLeftArrow: "\u27F8", DoubleLongLeftRightArrow: "\u27FA", DoubleLongRightArrow: "\u27F9", DoubleRightArrow: "\u21D2", DoubleRightTee: "\u22A8", DoubleUpArrow: "\u21D1", DoubleUpDownArrow: "\u21D5", DoubleVerticalBar: "\u2225", DownArrowBar: "\u2913", downarrow: "\u2193", DownArrow: "\u2193", Downarrow: "\u21D3", DownArrowUpArrow: "\u21F5", DownBreve: "\u0311", downdownarrows: "\u21CA", downharpoonleft: "\u21C3", downharpoonright: "\u21C2", DownLeftRightVector: "\u2950", DownLeftTeeVector: "\u295E", DownLeftVectorBar: "\u2956", DownLeftVector: "\u21BD", DownRightTeeVector: "\u295F", DownRightVectorBar: "\u2957", DownRightVector: "\u21C1", DownTeeArrow: "\u21A7", DownTee: "\u22A4", drbkarow: "\u2910", drcorn: "\u231F", drcrop: "\u230C", Dscr: "\u{1D49F}", dscr: "\u{1D4B9}", DScy: "\u0405", dscy: "\u0455", dsol: "\u29F6", Dstrok: "\u0110", dstrok: "\u0111", dtdot: "\u22F1", dtri: "\u25BF", dtrif: "\u25BE", duarr: "\u21F5", duhar: "\u296F", dwangle: "\u29A6", DZcy: "\u040F", dzcy: "\u045F", dzigrarr: "\u27FF", Eacute: "\xC9", eacute: "\xE9", easter: "\u2A6E", Ecaron: "\u011A", ecaron: "\u011B", Ecirc: "\xCA", ecirc: "\xEA", ecir: "\u2256", ecolon: "\u2255", Ecy: "\u042D", ecy: "\u044D", eDDot: "\u2A77", Edot: "\u0116", edot: "\u0117", eDot: "\u2251", ee: "\u2147", efDot: "\u2252", Efr: "\u{1D508}", efr: "\u{1D522}", eg: "\u2A9A", Egrave: "\xC8", egrave: "\xE8", egs: "\u2A96", egsdot: "\u2A98", el: "\u2A99", Element: "\u2208", elinters: "\u23E7", ell: "\u2113", els: "\u2A95", elsdot: "\u2A97", Emacr: "\u0112", emacr: "\u0113", empty: "\u2205", emptyset: "\u2205", EmptySmallSquare: "\u25FB", emptyv: "\u2205", EmptyVerySmallSquare: "\u25AB", emsp13: "\u2004", emsp14: "\u2005", emsp: "\u2003", ENG: "\u014A", eng: "\u014B", ensp: "\u2002", Eogon: "\u0118", eogon: "\u0119", Eopf: "\u{1D53C}", eopf: "\u{1D556}", epar: "\u22D5", eparsl: "\u29E3", eplus: "\u2A71", epsi: "\u03B5", Epsilon: "\u0395", epsilon: "\u03B5", epsiv: "\u03F5", eqcirc: "\u2256", eqcolon: "\u2255", eqsim: "\u2242", eqslantgtr: "\u2A96", eqslantless: "\u2A95", Equal: "\u2A75", equals: "=", EqualTilde: "\u2242", equest: "\u225F", Equilibrium: "\u21CC", equiv: "\u2261", equivDD: "\u2A78", eqvparsl: "\u29E5", erarr: "\u2971", erDot: "\u2253", escr: "\u212F", Escr: "\u2130", esdot: "\u2250", Esim: "\u2A73", esim: "\u2242", Eta: "\u0397", eta: "\u03B7", ETH: "\xD0", eth: "\xF0", Euml: "\xCB", euml: "\xEB", euro: "\u20AC", excl: "!", exist: "\u2203", Exists: "\u2203", expectation: "\u2130", exponentiale: "\u2147", ExponentialE: "\u2147", fallingdotseq: "\u2252", Fcy: "\u0424", fcy: "\u0444", female: "\u2640", ffilig: "\uFB03", fflig: "\uFB00", ffllig: "\uFB04", Ffr: "\u{1D509}", ffr: "\u{1D523}", filig: "\uFB01", FilledSmallSquare: "\u25FC", FilledVerySmallSquare: "\u25AA", fjlig: "fj", flat: "\u266D", fllig: "\uFB02", fltns: "\u25B1", fnof: "\u0192", Fopf: "\u{1D53D}", fopf: "\u{1D557}", forall: "\u2200", ForAll: "\u2200", fork: "\u22D4", forkv: "\u2AD9", Fouriertrf: "\u2131", fpartint: "\u2A0D", frac12: "\xBD", frac13: "\u2153", frac14: "\xBC", frac15: "\u2155", frac16: "\u2159", frac18: "\u215B", frac23: "\u2154", frac25: "\u2156", frac34: "\xBE", frac35: "\u2157", frac38: "\u215C", frac45: "\u2158", frac56: "\u215A", frac58: "\u215D", frac78: "\u215E", frasl: "\u2044", frown: "\u2322", fscr: "\u{1D4BB}", Fscr: "\u2131", gacute: "\u01F5", Gamma: "\u0393", gamma: "\u03B3", Gammad: "\u03DC", gammad: "\u03DD", gap: "\u2A86", Gbreve: "\u011E", gbreve: "\u011F", Gcedil: "\u0122", Gcirc: "\u011C", gcirc: "\u011D", Gcy: "\u0413", gcy: "\u0433", Gdot: "\u0120", gdot: "\u0121", ge: "\u2265", gE: "\u2267", gEl: "\u2A8C", gel: "\u22DB", geq: "\u2265", geqq: "\u2267", geqslant: "\u2A7E", gescc: "\u2AA9", ges: "\u2A7E", gesdot: "\u2A80", gesdoto: "\u2A82", gesdotol: "\u2A84", gesl: "\u22DB\uFE00", gesles: "\u2A94", Gfr: "\u{1D50A}", gfr: "\u{1D524}", gg: "\u226B", Gg: "\u22D9", ggg: "\u22D9", gimel: "\u2137", GJcy: "\u0403", gjcy: "\u0453", gla: "\u2AA5", gl: "\u2277", glE: "\u2A92", glj: "\u2AA4", gnap: "\u2A8A", gnapprox: "\u2A8A", gne: "\u2A88", gnE: "\u2269", gneq: "\u2A88", gneqq: "\u2269", gnsim: "\u22E7", Gopf: "\u{1D53E}", gopf: "\u{1D558}", grave: "`", GreaterEqual: "\u2265", GreaterEqualLess: "\u22DB", GreaterFullEqual: "\u2267", GreaterGreater: "\u2AA2", GreaterLess: "\u2277", GreaterSlantEqual: "\u2A7E", GreaterTilde: "\u2273", Gscr: "\u{1D4A2}", gscr: "\u210A", gsim: "\u2273", gsime: "\u2A8E", gsiml: "\u2A90", gtcc: "\u2AA7", gtcir: "\u2A7A", gt: ">", GT: ">", Gt: "\u226B", gtdot: "\u22D7", gtlPar: "\u2995", gtquest: "\u2A7C", gtrapprox: "\u2A86", gtrarr: "\u2978", gtrdot: "\u22D7", gtreqless: "\u22DB", gtreqqless: "\u2A8C", gtrless: "\u2277", gtrsim: "\u2273", gvertneqq: "\u2269\uFE00", gvnE: "\u2269\uFE00", Hacek: "\u02C7", hairsp: "\u200A", half: "\xBD", hamilt: "\u210B", HARDcy: "\u042A", hardcy: "\u044A", harrcir: "\u2948", harr: "\u2194", hArr: "\u21D4", harrw: "\u21AD", Hat: "^", hbar: "\u210F", Hcirc: "\u0124", hcirc: "\u0125", hearts: "\u2665", heartsuit: "\u2665", hellip: "\u2026", hercon: "\u22B9", hfr: "\u{1D525}", Hfr: "\u210C", HilbertSpace: "\u210B", hksearow: "\u2925", hkswarow: "\u2926", hoarr: "\u21FF", homtht: "\u223B", hookleftarrow: "\u21A9", hookrightarrow: "\u21AA", hopf: "\u{1D559}", Hopf: "\u210D", horbar: "\u2015", HorizontalLine: "\u2500", hscr: "\u{1D4BD}", Hscr: "\u210B", hslash: "\u210F", Hstrok: "\u0126", hstrok: "\u0127", HumpDownHump: "\u224E", HumpEqual: "\u224F", hybull: "\u2043", hyphen: "\u2010", Iacute: "\xCD", iacute: "\xED", ic: "\u2063", Icirc: "\xCE", icirc: "\xEE", Icy: "\u0418", icy: "\u0438", Idot: "\u0130", IEcy: "\u0415", iecy: "\u0435", iexcl: "\xA1", iff: "\u21D4", ifr: "\u{1D526}", Ifr: "\u2111", Igrave: "\xCC", igrave: "\xEC", ii: "\u2148", iiiint: "\u2A0C", iiint: "\u222D", iinfin: "\u29DC", iiota: "\u2129", IJlig: "\u0132", ijlig: "\u0133", Imacr: "\u012A", imacr: "\u012B", image: "\u2111", ImaginaryI: "\u2148", imagline: "\u2110", imagpart: "\u2111", imath: "\u0131", Im: "\u2111", imof: "\u22B7", imped: "\u01B5", Implies: "\u21D2", incare: "\u2105", in: "\u2208", infin: "\u221E", infintie: "\u29DD", inodot: "\u0131", intcal: "\u22BA", int: "\u222B", Int: "\u222C", integers: "\u2124", Integral: "\u222B", intercal: "\u22BA", Intersection: "\u22C2", intlarhk: "\u2A17", intprod: "\u2A3C", InvisibleComma: "\u2063", InvisibleTimes: "\u2062", IOcy: "\u0401", iocy: "\u0451", Iogon: "\u012E", iogon: "\u012F", Iopf: "\u{1D540}", iopf: "\u{1D55A}", Iota: "\u0399", iota: "\u03B9", iprod: "\u2A3C", iquest: "\xBF", iscr: "\u{1D4BE}", Iscr: "\u2110", isin: "\u2208", isindot: "\u22F5", isinE: "\u22F9", isins: "\u22F4", isinsv: "\u22F3", isinv: "\u2208", it: "\u2062", Itilde: "\u0128", itilde: "\u0129", Iukcy: "\u0406", iukcy: "\u0456", Iuml: "\xCF", iuml: "\xEF", Jcirc: "\u0134", jcirc: "\u0135", Jcy: "\u0419", jcy: "\u0439", Jfr: "\u{1D50D}", jfr: "\u{1D527}", jmath: "\u0237", Jopf: "\u{1D541}", jopf: "\u{1D55B}", Jscr: "\u{1D4A5}", jscr: "\u{1D4BF}", Jsercy: "\u0408", jsercy: "\u0458", Jukcy: "\u0404", jukcy: "\u0454", Kappa: "\u039A", kappa: "\u03BA", kappav: "\u03F0", Kcedil: "\u0136", kcedil: "\u0137", Kcy: "\u041A", kcy: "\u043A", Kfr: "\u{1D50E}", kfr: "\u{1D528}", kgreen: "\u0138", KHcy: "\u0425", khcy: "\u0445", KJcy: "\u040C", kjcy: "\u045C", Kopf: "\u{1D542}", kopf: "\u{1D55C}", Kscr: "\u{1D4A6}", kscr: "\u{1D4C0}", lAarr: "\u21DA", Lacute: "\u0139", lacute: "\u013A", laemptyv: "\u29B4", lagran: "\u2112", Lambda: "\u039B", lambda: "\u03BB", lang: "\u27E8", Lang: "\u27EA", langd: "\u2991", langle: "\u27E8", lap: "\u2A85", Laplacetrf: "\u2112", laquo: "\xAB", larrb: "\u21E4", larrbfs: "\u291F", larr: "\u2190", Larr: "\u219E", lArr: "\u21D0", larrfs: "\u291D", larrhk: "\u21A9", larrlp: "\u21AB", larrpl: "\u2939", larrsim: "\u2973", larrtl: "\u21A2", latail: "\u2919", lAtail: "\u291B", lat: "\u2AAB", late: "\u2AAD", lates: "\u2AAD\uFE00", lbarr: "\u290C", lBarr: "\u290E", lbbrk: "\u2772", lbrace: "{", lbrack: "[", lbrke: "\u298B", lbrksld: "\u298F", lbrkslu: "\u298D", Lcaron: "\u013D", lcaron: "\u013E", Lcedil: "\u013B", lcedil: "\u013C", lceil: "\u2308", lcub: "{", Lcy: "\u041B", lcy: "\u043B", ldca: "\u2936", ldquo: "\u201C", ldquor: "\u201E", ldrdhar: "\u2967", ldrushar: "\u294B", ldsh: "\u21B2", le: "\u2264", lE: "\u2266", LeftAngleBracket: "\u27E8", LeftArrowBar: "\u21E4", leftarrow: "\u2190", LeftArrow: "\u2190", Leftarrow: "\u21D0", LeftArrowRightArrow: "\u21C6", leftarrowtail: "\u21A2", LeftCeiling: "\u2308", LeftDoubleBracket: "\u27E6", LeftDownTeeVector: "\u2961", LeftDownVectorBar: "\u2959", LeftDownVector: "\u21C3", LeftFloor: "\u230A", leftharpoondown: "\u21BD", leftharpoonup: "\u21BC", leftleftarrows: "\u21C7", leftrightarrow: "\u2194", LeftRightArrow: "\u2194", Leftrightarrow: "\u21D4", leftrightarrows: "\u21C6", leftrightharpoons: "\u21CB", leftrightsquigarrow: "\u21AD", LeftRightVector: "\u294E", LeftTeeArrow: "\u21A4", LeftTee: "\u22A3", LeftTeeVector: "\u295A", leftthreetimes: "\u22CB", LeftTriangleBar: "\u29CF", LeftTriangle: "\u22B2", LeftTriangleEqual: "\u22B4", LeftUpDownVector: "\u2951", LeftUpTeeVector: "\u2960", LeftUpVectorBar: "\u2958", LeftUpVector: "\u21BF", LeftVectorBar: "\u2952", LeftVector: "\u21BC", lEg: "\u2A8B", leg: "\u22DA", leq: "\u2264", leqq: "\u2266", leqslant: "\u2A7D", lescc: "\u2AA8", les: "\u2A7D", lesdot: "\u2A7F", lesdoto: "\u2A81", lesdotor: "\u2A83", lesg: "\u22DA\uFE00", lesges: "\u2A93", lessapprox: "\u2A85", lessdot: "\u22D6", lesseqgtr: "\u22DA", lesseqqgtr: "\u2A8B", LessEqualGreater: "\u22DA", LessFullEqual: "\u2266", LessGreater: "\u2276", lessgtr: "\u2276", LessLess: "\u2AA1", lesssim: "\u2272", LessSlantEqual: "\u2A7D", LessTilde: "\u2272", lfisht: "\u297C", lfloor: "\u230A", Lfr: "\u{1D50F}", lfr: "\u{1D529}", lg: "\u2276", lgE: "\u2A91", lHar: "\u2962", lhard: "\u21BD", lharu: "\u21BC", lharul: "\u296A", lhblk: "\u2584", LJcy: "\u0409", ljcy: "\u0459", llarr: "\u21C7", ll: "\u226A", Ll: "\u22D8", llcorner: "\u231E", Lleftarrow: "\u21DA", llhard: "\u296B", lltri: "\u25FA", Lmidot: "\u013F", lmidot: "\u0140", lmoustache: "\u23B0", lmoust: "\u23B0", lnap: "\u2A89", lnapprox: "\u2A89", lne: "\u2A87", lnE: "\u2268", lneq: "\u2A87", lneqq: "\u2268", lnsim: "\u22E6", loang: "\u27EC", loarr: "\u21FD", lobrk: "\u27E6", longleftarrow: "\u27F5", LongLeftArrow: "\u27F5", Longleftarrow: "\u27F8", longleftrightarrow: "\u27F7", LongLeftRightArrow: "\u27F7", Longleftrightarrow: "\u27FA", longmapsto: "\u27FC", longrightarrow: "\u27F6", LongRightArrow: "\u27F6", Longrightarrow: "\u27F9", looparrowleft: "\u21AB", looparrowright: "\u21AC", lopar: "\u2985", Lopf: "\u{1D543}", lopf: "\u{1D55D}", loplus: "\u2A2D", lotimes: "\u2A34", lowast: "\u2217", lowbar: "_", LowerLeftArrow: "\u2199", LowerRightArrow: "\u2198", loz: "\u25CA", lozenge: "\u25CA", lozf: "\u29EB", lpar: "(", lparlt: "\u2993", lrarr: "\u21C6", lrcorner: "\u231F", lrhar: "\u21CB", lrhard: "\u296D", lrm: "\u200E", lrtri: "\u22BF", lsaquo: "\u2039", lscr: "\u{1D4C1}", Lscr: "\u2112", lsh: "\u21B0", Lsh: "\u21B0", lsim: "\u2272", lsime: "\u2A8D", lsimg: "\u2A8F", lsqb: "[", lsquo: "\u2018", lsquor: "\u201A", Lstrok: "\u0141", lstrok: "\u0142", ltcc: "\u2AA6", ltcir: "\u2A79", lt: "<", LT: "<", Lt: "\u226A", ltdot: "\u22D6", lthree: "\u22CB", ltimes: "\u22C9", ltlarr: "\u2976", ltquest: "\u2A7B", ltri: "\u25C3", ltrie: "\u22B4", ltrif: "\u25C2", ltrPar: "\u2996", lurdshar: "\u294A", luruhar: "\u2966", lvertneqq: "\u2268\uFE00", lvnE: "\u2268\uFE00", macr: "\xAF", male: "\u2642", malt: "\u2720", maltese: "\u2720", Map: "\u2905", map: "\u21A6", mapsto: "\u21A6", mapstodown: "\u21A7", mapstoleft: "\u21A4", mapstoup: "\u21A5", marker: "\u25AE", mcomma: "\u2A29", Mcy: "\u041C", mcy: "\u043C", mdash: "\u2014", mDDot: "\u223A", measuredangle: "\u2221", MediumSpace: "\u205F", Mellintrf: "\u2133", Mfr: "\u{1D510}", mfr: "\u{1D52A}", mho: "\u2127", micro: "\xB5", midast: "*", midcir: "\u2AF0", mid: "\u2223", middot: "\xB7", minusb: "\u229F", minus: "\u2212", minusd: "\u2238", minusdu: "\u2A2A", MinusPlus: "\u2213", mlcp: "\u2ADB", mldr: "\u2026", mnplus: "\u2213", models: "\u22A7", Mopf: "\u{1D544}", mopf: "\u{1D55E}", mp: "\u2213", mscr: "\u{1D4C2}", Mscr: "\u2133", mstpos: "\u223E", Mu: "\u039C", mu: "\u03BC", multimap: "\u22B8", mumap: "\u22B8", nabla: "\u2207", Nacute: "\u0143", nacute: "\u0144", nang: "\u2220\u20D2", nap: "\u2249", napE: "\u2A70\u0338", napid: "\u224B\u0338", napos: "\u0149", napprox: "\u2249", natural: "\u266E", naturals: "\u2115", natur: "\u266E", nbsp: "\xA0", nbump: "\u224E\u0338", nbumpe: "\u224F\u0338", ncap: "\u2A43", Ncaron: "\u0147", ncaron: "\u0148", Ncedil: "\u0145", ncedil: "\u0146", ncong: "\u2247", ncongdot: "\u2A6D\u0338", ncup: "\u2A42", Ncy: "\u041D", ncy: "\u043D", ndash: "\u2013", nearhk: "\u2924", nearr: "\u2197", neArr: "\u21D7", nearrow: "\u2197", ne: "\u2260", nedot: "\u2250\u0338", NegativeMediumSpace: "\u200B", NegativeThickSpace: "\u200B", NegativeThinSpace: "\u200B", NegativeVeryThinSpace: "\u200B", nequiv: "\u2262", nesear: "\u2928", nesim: "\u2242\u0338", NestedGreaterGreater: "\u226B", NestedLessLess: "\u226A", NewLine: "\n", nexist: "\u2204", nexists: "\u2204", Nfr: "\u{1D511}", nfr: "\u{1D52B}", ngE: "\u2267\u0338", nge: "\u2271", ngeq: "\u2271", ngeqq: "\u2267\u0338", ngeqslant: "\u2A7E\u0338", nges: "\u2A7E\u0338", nGg: "\u22D9\u0338", ngsim: "\u2275", nGt: "\u226B\u20D2", ngt: "\u226F", ngtr: "\u226F", nGtv: "\u226B\u0338", nharr: "\u21AE", nhArr: "\u21CE", nhpar: "\u2AF2", ni: "\u220B", nis: "\u22FC", nisd: "\u22FA", niv: "\u220B", NJcy: "\u040A", njcy: "\u045A", nlarr: "\u219A", nlArr: "\u21CD", nldr: "\u2025", nlE: "\u2266\u0338", nle: "\u2270", nleftarrow: "\u219A", nLeftarrow: "\u21CD", nleftrightarrow: "\u21AE", nLeftrightarrow: "\u21CE", nleq: "\u2270", nleqq: "\u2266\u0338", nleqslant: "\u2A7D\u0338", nles: "\u2A7D\u0338", nless: "\u226E", nLl: "\u22D8\u0338", nlsim: "\u2274", nLt: "\u226A\u20D2", nlt: "\u226E", nltri: "\u22EA", nltrie: "\u22EC", nLtv: "\u226A\u0338", nmid: "\u2224", NoBreak: "\u2060", NonBreakingSpace: "\xA0", nopf: "\u{1D55F}", Nopf: "\u2115", Not: "\u2AEC", not: "\xAC", NotCongruent: "\u2262", NotCupCap: "\u226D", NotDoubleVerticalBar: "\u2226", NotElement: "\u2209", NotEqual: "\u2260", NotEqualTilde: "\u2242\u0338", NotExists: "\u2204", NotGreater: "\u226F", NotGreaterEqual: "\u2271", NotGreaterFullEqual: "\u2267\u0338", NotGreaterGreater: "\u226B\u0338", NotGreaterLess: "\u2279", NotGreaterSlantEqual: "\u2A7E\u0338", NotGreaterTilde: "\u2275", NotHumpDownHump: "\u224E\u0338", NotHumpEqual: "\u224F\u0338", notin: "\u2209", notindot: "\u22F5\u0338", notinE: "\u22F9\u0338", notinva: "\u2209", notinvb: "\u22F7", notinvc: "\u22F6", NotLeftTriangleBar: "\u29CF\u0338", NotLeftTriangle: "\u22EA", NotLeftTriangleEqual: "\u22EC", NotLess: "\u226E", NotLessEqual: "\u2270", NotLessGreater: "\u2278", NotLessLess: "\u226A\u0338", NotLessSlantEqual: "\u2A7D\u0338", NotLessTilde: "\u2274", NotNestedGreaterGreater: "\u2AA2\u0338", NotNestedLessLess: "\u2AA1\u0338", notni: "\u220C", notniva: "\u220C", notnivb: "\u22FE", notnivc: "\u22FD", NotPrecedes: "\u2280", NotPrecedesEqual: "\u2AAF\u0338", NotPrecedesSlantEqual: "\u22E0", NotReverseElement: "\u220C", NotRightTriangleBar: "\u29D0\u0338", NotRightTriangle: "\u22EB", NotRightTriangleEqual: "\u22ED", NotSquareSubset: "\u228F\u0338", NotSquareSubsetEqual: "\u22E2", NotSquareSuperset: "\u2290\u0338", NotSquareSupersetEqual: "\u22E3", NotSubset: "\u2282\u20D2", NotSubsetEqual: "\u2288", NotSucceeds: "\u2281", NotSucceedsEqual: "\u2AB0\u0338", NotSucceedsSlantEqual: "\u22E1", NotSucceedsTilde: "\u227F\u0338", NotSuperset: "\u2283\u20D2", NotSupersetEqual: "\u2289", NotTilde: "\u2241", NotTildeEqual: "\u2244", NotTildeFullEqual: "\u2247", NotTildeTilde: "\u2249", NotVerticalBar: "\u2224", nparallel: "\u2226", npar: "\u2226", nparsl: "\u2AFD\u20E5", npart: "\u2202\u0338", npolint: "\u2A14", npr: "\u2280", nprcue: "\u22E0", nprec: "\u2280", npreceq: "\u2AAF\u0338", npre: "\u2AAF\u0338", nrarrc: "\u2933\u0338", nrarr: "\u219B", nrArr: "\u21CF", nrarrw: "\u219D\u0338", nrightarrow: "\u219B", nRightarrow: "\u21CF", nrtri: "\u22EB", nrtrie: "\u22ED", nsc: "\u2281", nsccue: "\u22E1", nsce: "\u2AB0\u0338", Nscr: "\u{1D4A9}", nscr: "\u{1D4C3}", nshortmid: "\u2224", nshortparallel: "\u2226", nsim: "\u2241", nsime: "\u2244", nsimeq: "\u2244", nsmid: "\u2224", nspar: "\u2226", nsqsube: "\u22E2", nsqsupe: "\u22E3", nsub: "\u2284", nsubE: "\u2AC5\u0338", nsube: "\u2288", nsubset: "\u2282\u20D2", nsubseteq: "\u2288", nsubseteqq: "\u2AC5\u0338", nsucc: "\u2281", nsucceq: "\u2AB0\u0338", nsup: "\u2285", nsupE: "\u2AC6\u0338", nsupe: "\u2289", nsupset: "\u2283\u20D2", nsupseteq: "\u2289", nsupseteqq: "\u2AC6\u0338", ntgl: "\u2279", Ntilde: "\xD1", ntilde: "\xF1", ntlg: "\u2278", ntriangleleft: "\u22EA", ntrianglelefteq: "\u22EC", ntriangleright: "\u22EB", ntrianglerighteq: "\u22ED", Nu: "\u039D", nu: "\u03BD", num: "#", numero: "\u2116", numsp: "\u2007", nvap: "\u224D\u20D2", nvdash: "\u22AC", nvDash: "\u22AD", nVdash: "\u22AE", nVDash: "\u22AF", nvge: "\u2265\u20D2", nvgt: ">\u20D2", nvHarr: "\u2904", nvinfin: "\u29DE", nvlArr: "\u2902", nvle: "\u2264\u20D2", nvlt: "<\u20D2", nvltrie: "\u22B4\u20D2", nvrArr: "\u2903", nvrtrie: "\u22B5\u20D2", nvsim: "\u223C\u20D2", nwarhk: "\u2923", nwarr: "\u2196", nwArr: "\u21D6", nwarrow: "\u2196", nwnear: "\u2927", Oacute: "\xD3", oacute: "\xF3", oast: "\u229B", Ocirc: "\xD4", ocirc: "\xF4", ocir: "\u229A", Ocy: "\u041E", ocy: "\u043E", odash: "\u229D", Odblac: "\u0150", odblac: "\u0151", odiv: "\u2A38", odot: "\u2299", odsold: "\u29BC", OElig: "\u0152", oelig: "\u0153", ofcir: "\u29BF", Ofr: "\u{1D512}", ofr: "\u{1D52C}", ogon: "\u02DB", Ograve: "\xD2", ograve: "\xF2", ogt: "\u29C1", ohbar: "\u29B5", ohm: "\u03A9", oint: "\u222E", olarr: "\u21BA", olcir: "\u29BE", olcross: "\u29BB", oline: "\u203E", olt: "\u29C0", Omacr: "\u014C", omacr: "\u014D", Omega: "\u03A9", omega: "\u03C9", Omicron: "\u039F", omicron: "\u03BF", omid: "\u29B6", ominus: "\u2296", Oopf: "\u{1D546}", oopf: "\u{1D560}", opar: "\u29B7", OpenCurlyDoubleQuote: "\u201C", OpenCurlyQuote: "\u2018", operp: "\u29B9", oplus: "\u2295", orarr: "\u21BB", Or: "\u2A54", or: "\u2228", ord: "\u2A5D", order: "\u2134", orderof: "\u2134", ordf: "\xAA", ordm: "\xBA", origof: "\u22B6", oror: "\u2A56", orslope: "\u2A57", orv: "\u2A5B", oS: "\u24C8", Oscr: "\u{1D4AA}", oscr: "\u2134", Oslash: "\xD8", oslash: "\xF8", osol: "\u2298", Otilde: "\xD5", otilde: "\xF5", otimesas: "\u2A36", Otimes: "\u2A37", otimes: "\u2297", Ouml: "\xD6", ouml: "\xF6", ovbar: "\u233D", OverBar: "\u203E", OverBrace: "\u23DE", OverBracket: "\u23B4", OverParenthesis: "\u23DC", para: "\xB6", parallel: "\u2225", par: "\u2225", parsim: "\u2AF3", parsl: "\u2AFD", part: "\u2202", PartialD: "\u2202", Pcy: "\u041F", pcy: "\u043F", percnt: "%", period: ".", permil: "\u2030", perp: "\u22A5", pertenk: "\u2031", Pfr: "\u{1D513}", pfr: "\u{1D52D}", Phi: "\u03A6", phi: "\u03C6", phiv: "\u03D5", phmmat: "\u2133", phone: "\u260E", Pi: "\u03A0", pi: "\u03C0", pitchfork: "\u22D4", piv: "\u03D6", planck: "\u210F", planckh: "\u210E", plankv: "\u210F", plusacir: "\u2A23", plusb: "\u229E", pluscir: "\u2A22", plus: "+", plusdo: "\u2214", plusdu: "\u2A25", pluse: "\u2A72", PlusMinus: "\xB1", plusmn: "\xB1", plussim: "\u2A26", plustwo: "\u2A27", pm: "\xB1", Poincareplane: "\u210C", pointint: "\u2A15", popf: "\u{1D561}", Popf: "\u2119", pound: "\xA3", prap: "\u2AB7", Pr: "\u2ABB", pr: "\u227A", prcue: "\u227C", precapprox: "\u2AB7", prec: "\u227A", preccurlyeq: "\u227C", Precedes: "\u227A", PrecedesEqual: "\u2AAF", PrecedesSlantEqual: "\u227C", PrecedesTilde: "\u227E", preceq: "\u2AAF", precnapprox: "\u2AB9", precneqq: "\u2AB5", precnsim: "\u22E8", pre: "\u2AAF", prE: "\u2AB3", precsim: "\u227E", prime: "\u2032", Prime: "\u2033", primes: "\u2119", prnap: "\u2AB9", prnE: "\u2AB5", prnsim: "\u22E8", prod: "\u220F", Product: "\u220F", profalar: "\u232E", profline: "\u2312", profsurf: "\u2313", prop: "\u221D", Proportional: "\u221D", Proportion: "\u2237", propto: "\u221D", prsim: "\u227E", prurel: "\u22B0", Pscr: "\u{1D4AB}", pscr: "\u{1D4C5}", Psi: "\u03A8", psi: "\u03C8", puncsp: "\u2008", Qfr: "\u{1D514}", qfr: "\u{1D52E}", qint: "\u2A0C", qopf: "\u{1D562}", Qopf: "\u211A", qprime: "\u2057", Qscr: "\u{1D4AC}", qscr: "\u{1D4C6}", quaternions: "\u210D", quatint: "\u2A16", quest: "?", questeq: "\u225F", quot: '"', QUOT: '"', rAarr: "\u21DB", race: "\u223D\u0331", Racute: "\u0154", racute: "\u0155", radic: "\u221A", raemptyv: "\u29B3", rang: "\u27E9", Rang: "\u27EB", rangd: "\u2992", range: "\u29A5", rangle: "\u27E9", raquo: "\xBB", rarrap: "\u2975", rarrb: "\u21E5", rarrbfs: "\u2920", rarrc: "\u2933", rarr: "\u2192", Rarr: "\u21A0", rArr: "\u21D2", rarrfs: "\u291E", rarrhk: "\u21AA", rarrlp: "\u21AC", rarrpl: "\u2945", rarrsim: "\u2974", Rarrtl: "\u2916", rarrtl: "\u21A3", rarrw: "\u219D", ratail: "\u291A", rAtail: "\u291C", ratio: "\u2236", rationals: "\u211A", rbarr: "\u290D", rBarr: "\u290F", RBarr: "\u2910", rbbrk: "\u2773", rbrace: "}", rbrack: "]", rbrke: "\u298C", rbrksld: "\u298E", rbrkslu: "\u2990", Rcaron: "\u0158", rcaron: "\u0159", Rcedil: "\u0156", rcedil: "\u0157", rceil: "\u2309", rcub: "}", Rcy: "\u0420", rcy: "\u0440", rdca: "\u2937", rdldhar: "\u2969", rdquo: "\u201D", rdquor: "\u201D", rdsh: "\u21B3", real: "\u211C", realine: "\u211B", realpart: "\u211C", reals: "\u211D", Re: "\u211C", rect: "\u25AD", reg: "\xAE", REG: "\xAE", ReverseElement: "\u220B", ReverseEquilibrium: "\u21CB", ReverseUpEquilibrium: "\u296F", rfisht: "\u297D", rfloor: "\u230B", rfr: "\u{1D52F}", Rfr: "\u211C", rHar: "\u2964", rhard: "\u21C1", rharu: "\u21C0", rharul: "\u296C", Rho: "\u03A1", rho: "\u03C1", rhov: "\u03F1", RightAngleBracket: "\u27E9", RightArrowBar: "\u21E5", rightarrow: "\u2192", RightArrow: "\u2192", Rightarrow: "\u21D2", RightArrowLeftArrow: "\u21C4", rightarrowtail: "\u21A3", RightCeiling: "\u2309", RightDoubleBracket: "\u27E7", RightDownTeeVector: "\u295D", RightDownVectorBar: "\u2955", RightDownVector: "\u21C2", RightFloor: "\u230B", rightharpoondown: "\u21C1", rightharpoonup: "\u21C0", rightleftarrows: "\u21C4", rightleftharpoons: "\u21CC", rightrightarrows: "\u21C9", rightsquigarrow: "\u219D", RightTeeArrow: "\u21A6", RightTee: "\u22A2", RightTeeVector: "\u295B", rightthreetimes: "\u22CC", RightTriangleBar: "\u29D0", RightTriangle: "\u22B3", RightTriangleEqual: "\u22B5", RightUpDownVector: "\u294F", RightUpTeeVector: "\u295C", RightUpVectorBar: "\u2954", RightUpVector: "\u21BE", RightVectorBar: "\u2953", RightVector: "\u21C0", ring: "\u02DA", risingdotseq: "\u2253", rlarr: "\u21C4", rlhar: "\u21CC", rlm: "\u200F", rmoustache: "\u23B1", rmoust: "\u23B1", rnmid: "\u2AEE", roang: "\u27ED", roarr: "\u21FE", robrk: "\u27E7", ropar: "\u2986", ropf: "\u{1D563}", Ropf: "\u211D", roplus: "\u2A2E", rotimes: "\u2A35", RoundImplies: "\u2970", rpar: ")", rpargt: "\u2994", rppolint: "\u2A12", rrarr: "\u21C9", Rrightarrow: "\u21DB", rsaquo: "\u203A", rscr: "\u{1D4C7}", Rscr: "\u211B", rsh: "\u21B1", Rsh: "\u21B1", rsqb: "]", rsquo: "\u2019", rsquor: "\u2019", rthree: "\u22CC", rtimes: "\u22CA", rtri: "\u25B9", rtrie: "\u22B5", rtrif: "\u25B8", rtriltri: "\u29CE", RuleDelayed: "\u29F4", ruluhar: "\u2968", rx: "\u211E", Sacute: "\u015A", sacute: "\u015B", sbquo: "\u201A", scap: "\u2AB8", Scaron: "\u0160", scaron: "\u0161", Sc: "\u2ABC", sc: "\u227B", sccue: "\u227D", sce: "\u2AB0", scE: "\u2AB4", Scedil: "\u015E", scedil: "\u015F", Scirc: "\u015C", scirc: "\u015D", scnap: "\u2ABA", scnE: "\u2AB6", scnsim: "\u22E9", scpolint: "\u2A13", scsim: "\u227F", Scy: "\u0421", scy: "\u0441", sdotb: "\u22A1", sdot: "\u22C5", sdote: "\u2A66", searhk: "\u2925", searr: "\u2198", seArr: "\u21D8", searrow: "\u2198", sect: "\xA7", semi: ";", seswar: "\u2929", setminus: "\u2216", setmn: "\u2216", sext: "\u2736", Sfr: "\u{1D516}", sfr: "\u{1D530}", sfrown: "\u2322", sharp: "\u266F", SHCHcy: "\u0429", shchcy: "\u0449", SHcy: "\u0428", shcy: "\u0448", ShortDownArrow: "\u2193", ShortLeftArrow: "\u2190", shortmid: "\u2223", shortparallel: "\u2225", ShortRightArrow: "\u2192", ShortUpArrow: "\u2191", shy: "\xAD", Sigma: "\u03A3", sigma: "\u03C3", sigmaf: "\u03C2", sigmav: "\u03C2", sim: "\u223C", simdot: "\u2A6A", sime: "\u2243", simeq: "\u2243", simg: "\u2A9E", simgE: "\u2AA0", siml: "\u2A9D", simlE: "\u2A9F", simne: "\u2246", simplus: "\u2A24", simrarr: "\u2972", slarr: "\u2190", SmallCircle: "\u2218", smallsetminus: "\u2216", smashp: "\u2A33", smeparsl: "\u29E4", smid: "\u2223", smile: "\u2323", smt: "\u2AAA", smte: "\u2AAC", smtes: "\u2AAC\uFE00", SOFTcy: "\u042C", softcy: "\u044C", solbar: "\u233F", solb: "\u29C4", sol: "/", Sopf: "\u{1D54A}", sopf: "\u{1D564}", spades: "\u2660", spadesuit: "\u2660", spar: "\u2225", sqcap: "\u2293", sqcaps: "\u2293\uFE00", sqcup: "\u2294", sqcups: "\u2294\uFE00", Sqrt: "\u221A", sqsub: "\u228F", sqsube: "\u2291", sqsubset: "\u228F", sqsubseteq: "\u2291", sqsup: "\u2290", sqsupe: "\u2292", sqsupset: "\u2290", sqsupseteq: "\u2292", square: "\u25A1", Square: "\u25A1", SquareIntersection: "\u2293", SquareSubset: "\u228F", SquareSubsetEqual: "\u2291", SquareSuperset: "\u2290", SquareSupersetEqual: "\u2292", SquareUnion: "\u2294", squarf: "\u25AA", squ: "\u25A1", squf: "\u25AA", srarr: "\u2192", Sscr: "\u{1D4AE}", sscr: "\u{1D4C8}", ssetmn: "\u2216", ssmile: "\u2323", sstarf: "\u22C6", Star: "\u22C6", star: "\u2606", starf: "\u2605", straightepsilon: "\u03F5", straightphi: "\u03D5", strns: "\xAF", sub: "\u2282", Sub: "\u22D0", subdot: "\u2ABD", subE: "\u2AC5", sube: "\u2286", subedot: "\u2AC3", submult: "\u2AC1", subnE: "\u2ACB", subne: "\u228A", subplus: "\u2ABF", subrarr: "\u2979", subset: "\u2282", Subset: "\u22D0", subseteq: "\u2286", subseteqq: "\u2AC5", SubsetEqual: "\u2286", subsetneq: "\u228A", subsetneqq: "\u2ACB", subsim: "\u2AC7", subsub: "\u2AD5", subsup: "\u2AD3", succapprox: "\u2AB8", succ: "\u227B", succcurlyeq: "\u227D", Succeeds: "\u227B", SucceedsEqual: "\u2AB0", SucceedsSlantEqual: "\u227D", SucceedsTilde: "\u227F", succeq: "\u2AB0", succnapprox: "\u2ABA", succneqq: "\u2AB6", succnsim: "\u22E9", succsim: "\u227F", SuchThat: "\u220B", sum: "\u2211", Sum: "\u2211", sung: "\u266A", sup1: "\xB9", sup2: "\xB2", sup3: "\xB3", sup: "\u2283", Sup: "\u22D1", supdot: "\u2ABE", supdsub: "\u2AD8", supE: "\u2AC6", supe: "\u2287", supedot: "\u2AC4", Superset: "\u2283", SupersetEqual: "\u2287", suphsol: "\u27C9", suphsub: "\u2AD7", suplarr: "\u297B", supmult: "\u2AC2", supnE: "\u2ACC", supne: "\u228B", supplus: "\u2AC0", supset: "\u2283", Supset: "\u22D1", supseteq: "\u2287", supseteqq: "\u2AC6", supsetneq: "\u228B", supsetneqq: "\u2ACC", supsim: "\u2AC8", supsub: "\u2AD4", supsup: "\u2AD6", swarhk: "\u2926", swarr: "\u2199", swArr: "\u21D9", swarrow: "\u2199", swnwar: "\u292A", szlig: "\xDF", Tab: "	", target: "\u2316", Tau: "\u03A4", tau: "\u03C4", tbrk: "\u23B4", Tcaron: "\u0164", tcaron: "\u0165", Tcedil: "\u0162", tcedil: "\u0163", Tcy: "\u0422", tcy: "\u0442", tdot: "\u20DB", telrec: "\u2315", Tfr: "\u{1D517}", tfr: "\u{1D531}", there4: "\u2234", therefore: "\u2234", Therefore: "\u2234", Theta: "\u0398", theta: "\u03B8", thetasym: "\u03D1", thetav: "\u03D1", thickapprox: "\u2248", thicksim: "\u223C", ThickSpace: "\u205F\u200A", ThinSpace: "\u2009", thinsp: "\u2009", thkap: "\u2248", thksim: "\u223C", THORN: "\xDE", thorn: "\xFE", tilde: "\u02DC", Tilde: "\u223C", TildeEqual: "\u2243", TildeFullEqual: "\u2245", TildeTilde: "\u2248", timesbar: "\u2A31", timesb: "\u22A0", times: "\xD7", timesd: "\u2A30", tint: "\u222D", toea: "\u2928", topbot: "\u2336", topcir: "\u2AF1", top: "\u22A4", Topf: "\u{1D54B}", topf: "\u{1D565}", topfork: "\u2ADA", tosa: "\u2929", tprime: "\u2034", trade: "\u2122", TRADE: "\u2122", triangle: "\u25B5", triangledown: "\u25BF", triangleleft: "\u25C3", trianglelefteq: "\u22B4", triangleq: "\u225C", triangleright: "\u25B9", trianglerighteq: "\u22B5", tridot: "\u25EC", trie: "\u225C", triminus: "\u2A3A", TripleDot: "\u20DB", triplus: "\u2A39", trisb: "\u29CD", tritime: "\u2A3B", trpezium: "\u23E2", Tscr: "\u{1D4AF}", tscr: "\u{1D4C9}", TScy: "\u0426", tscy: "\u0446", TSHcy: "\u040B", tshcy: "\u045B", Tstrok: "\u0166", tstrok: "\u0167", twixt: "\u226C", twoheadleftarrow: "\u219E", twoheadrightarrow: "\u21A0", Uacute: "\xDA", uacute: "\xFA", uarr: "\u2191", Uarr: "\u219F", uArr: "\u21D1", Uarrocir: "\u2949", Ubrcy: "\u040E", ubrcy: "\u045E", Ubreve: "\u016C", ubreve: "\u016D", Ucirc: "\xDB", ucirc: "\xFB", Ucy: "\u0423", ucy: "\u0443", udarr: "\u21C5", Udblac: "\u0170", udblac: "\u0171", udhar: "\u296E", ufisht: "\u297E", Ufr: "\u{1D518}", ufr: "\u{1D532}", Ugrave: "\xD9", ugrave: "\xF9", uHar: "\u2963", uharl: "\u21BF", uharr: "\u21BE", uhblk: "\u2580", ulcorn: "\u231C", ulcorner: "\u231C", ulcrop: "\u230F", ultri: "\u25F8", Umacr: "\u016A", umacr: "\u016B", uml: "\xA8", UnderBar: "_", UnderBrace: "\u23DF", UnderBracket: "\u23B5", UnderParenthesis: "\u23DD", Union: "\u22C3", UnionPlus: "\u228E", Uogon: "\u0172", uogon: "\u0173", Uopf: "\u{1D54C}", uopf: "\u{1D566}", UpArrowBar: "\u2912", uparrow: "\u2191", UpArrow: "\u2191", Uparrow: "\u21D1", UpArrowDownArrow: "\u21C5", updownarrow: "\u2195", UpDownArrow: "\u2195", Updownarrow: "\u21D5", UpEquilibrium: "\u296E", upharpoonleft: "\u21BF", upharpoonright: "\u21BE", uplus: "\u228E", UpperLeftArrow: "\u2196", UpperRightArrow: "\u2197", upsi: "\u03C5", Upsi: "\u03D2", upsih: "\u03D2", Upsilon: "\u03A5", upsilon: "\u03C5", UpTeeArrow: "\u21A5", UpTee: "\u22A5", upuparrows: "\u21C8", urcorn: "\u231D", urcorner: "\u231D", urcrop: "\u230E", Uring: "\u016E", uring: "\u016F", urtri: "\u25F9", Uscr: "\u{1D4B0}", uscr: "\u{1D4CA}", utdot: "\u22F0", Utilde: "\u0168", utilde: "\u0169", utri: "\u25B5", utrif: "\u25B4", uuarr: "\u21C8", Uuml: "\xDC", uuml: "\xFC", uwangle: "\u29A7", vangrt: "\u299C", varepsilon: "\u03F5", varkappa: "\u03F0", varnothing: "\u2205", varphi: "\u03D5", varpi: "\u03D6", varpropto: "\u221D", varr: "\u2195", vArr: "\u21D5", varrho: "\u03F1", varsigma: "\u03C2", varsubsetneq: "\u228A\uFE00", varsubsetneqq: "\u2ACB\uFE00", varsupsetneq: "\u228B\uFE00", varsupsetneqq: "\u2ACC\uFE00", vartheta: "\u03D1", vartriangleleft: "\u22B2", vartriangleright: "\u22B3", vBar: "\u2AE8", Vbar: "\u2AEB", vBarv: "\u2AE9", Vcy: "\u0412", vcy: "\u0432", vdash: "\u22A2", vDash: "\u22A8", Vdash: "\u22A9", VDash: "\u22AB", Vdashl: "\u2AE6", veebar: "\u22BB", vee: "\u2228", Vee: "\u22C1", veeeq: "\u225A", vellip: "\u22EE", verbar: "|", Verbar: "\u2016", vert: "|", Vert: "\u2016", VerticalBar: "\u2223", VerticalLine: "|", VerticalSeparator: "\u2758", VerticalTilde: "\u2240", VeryThinSpace: "\u200A", Vfr: "\u{1D519}", vfr: "\u{1D533}", vltri: "\u22B2", vnsub: "\u2282\u20D2", vnsup: "\u2283\u20D2", Vopf: "\u{1D54D}", vopf: "\u{1D567}", vprop: "\u221D", vrtri: "\u22B3", Vscr: "\u{1D4B1}", vscr: "\u{1D4CB}", vsubnE: "\u2ACB\uFE00", vsubne: "\u228A\uFE00", vsupnE: "\u2ACC\uFE00", vsupne: "\u228B\uFE00", Vvdash: "\u22AA", vzigzag: "\u299A", Wcirc: "\u0174", wcirc: "\u0175", wedbar: "\u2A5F", wedge: "\u2227", Wedge: "\u22C0", wedgeq: "\u2259", weierp: "\u2118", Wfr: "\u{1D51A}", wfr: "\u{1D534}", Wopf: "\u{1D54E}", wopf: "\u{1D568}", wp: "\u2118", wr: "\u2240", wreath: "\u2240", Wscr: "\u{1D4B2}", wscr: "\u{1D4CC}", xcap: "\u22C2", xcirc: "\u25EF", xcup: "\u22C3", xdtri: "\u25BD", Xfr: "\u{1D51B}", xfr: "\u{1D535}", xharr: "\u27F7", xhArr: "\u27FA", Xi: "\u039E", xi: "\u03BE", xlarr: "\u27F5", xlArr: "\u27F8", xmap: "\u27FC", xnis: "\u22FB", xodot: "\u2A00", Xopf: "\u{1D54F}", xopf: "\u{1D569}", xoplus: "\u2A01", xotime: "\u2A02", xrarr: "\u27F6", xrArr: "\u27F9", Xscr: "\u{1D4B3}", xscr: "\u{1D4CD}", xsqcup: "\u2A06", xuplus: "\u2A04", xutri: "\u25B3", xvee: "\u22C1", xwedge: "\u22C0", Yacute: "\xDD", yacute: "\xFD", YAcy: "\u042F", yacy: "\u044F", Ycirc: "\u0176", ycirc: "\u0177", Ycy: "\u042B", ycy: "\u044B", yen: "\xA5", Yfr: "\u{1D51C}", yfr: "\u{1D536}", YIcy: "\u0407", yicy: "\u0457", Yopf: "\u{1D550}", yopf: "\u{1D56A}", Yscr: "\u{1D4B4}", yscr: "\u{1D4CE}", YUcy: "\u042E", yucy: "\u044E", yuml: "\xFF", Yuml: "\u0178", Zacute: "\u0179", zacute: "\u017A", Zcaron: "\u017D", zcaron: "\u017E", Zcy: "\u0417", zcy: "\u0437", Zdot: "\u017B", zdot: "\u017C", zeetrf: "\u2128", ZeroWidthSpace: "\u200B", Zeta: "\u0396", zeta: "\u03B6", zfr: "\u{1D537}", Zfr: "\u2128", ZHcy: "\u0416", zhcy: "\u0436", zigrarr: "\u21DD", zopf: "\u{1D56B}", Zopf: "\u2124", Zscr: "\u{1D4B5}", zscr: "\u{1D4CF}", zwj: "\u200D", zwnj: "\u200C" };
    }
  });

  // node_modules/.pnpm/entities@2.2.0/node_modules/entities/lib/maps/legacy.json
  var require_legacy = __commonJS({
    "node_modules/.pnpm/entities@2.2.0/node_modules/entities/lib/maps/legacy.json"(exports2, module2) {
      module2.exports = { Aacute: "\xC1", aacute: "\xE1", Acirc: "\xC2", acirc: "\xE2", acute: "\xB4", AElig: "\xC6", aelig: "\xE6", Agrave: "\xC0", agrave: "\xE0", amp: "&", AMP: "&", Aring: "\xC5", aring: "\xE5", Atilde: "\xC3", atilde: "\xE3", Auml: "\xC4", auml: "\xE4", brvbar: "\xA6", Ccedil: "\xC7", ccedil: "\xE7", cedil: "\xB8", cent: "\xA2", copy: "\xA9", COPY: "\xA9", curren: "\xA4", deg: "\xB0", divide: "\xF7", Eacute: "\xC9", eacute: "\xE9", Ecirc: "\xCA", ecirc: "\xEA", Egrave: "\xC8", egrave: "\xE8", ETH: "\xD0", eth: "\xF0", Euml: "\xCB", euml: "\xEB", frac12: "\xBD", frac14: "\xBC", frac34: "\xBE", gt: ">", GT: ">", Iacute: "\xCD", iacute: "\xED", Icirc: "\xCE", icirc: "\xEE", iexcl: "\xA1", Igrave: "\xCC", igrave: "\xEC", iquest: "\xBF", Iuml: "\xCF", iuml: "\xEF", laquo: "\xAB", lt: "<", LT: "<", macr: "\xAF", micro: "\xB5", middot: "\xB7", nbsp: "\xA0", not: "\xAC", Ntilde: "\xD1", ntilde: "\xF1", Oacute: "\xD3", oacute: "\xF3", Ocirc: "\xD4", ocirc: "\xF4", Ograve: "\xD2", ograve: "\xF2", ordf: "\xAA", ordm: "\xBA", Oslash: "\xD8", oslash: "\xF8", Otilde: "\xD5", otilde: "\xF5", Ouml: "\xD6", ouml: "\xF6", para: "\xB6", plusmn: "\xB1", pound: "\xA3", quot: '"', QUOT: '"', raquo: "\xBB", reg: "\xAE", REG: "\xAE", sect: "\xA7", shy: "\xAD", sup1: "\xB9", sup2: "\xB2", sup3: "\xB3", szlig: "\xDF", THORN: "\xDE", thorn: "\xFE", times: "\xD7", Uacute: "\xDA", uacute: "\xFA", Ucirc: "\xDB", ucirc: "\xFB", Ugrave: "\xD9", ugrave: "\xF9", uml: "\xA8", Uuml: "\xDC", uuml: "\xFC", Yacute: "\xDD", yacute: "\xFD", yen: "\xA5", yuml: "\xFF" };
    }
  });

  // node_modules/.pnpm/entities@2.2.0/node_modules/entities/lib/maps/xml.json
  var require_xml = __commonJS({
    "node_modules/.pnpm/entities@2.2.0/node_modules/entities/lib/maps/xml.json"(exports2, module2) {
      module2.exports = { amp: "&", apos: "'", gt: ">", lt: "<", quot: '"' };
    }
  });

  // node_modules/.pnpm/htmlparser2@6.1.0/node_modules/htmlparser2/lib/Tokenizer.js
  var require_Tokenizer = __commonJS({
    "node_modules/.pnpm/htmlparser2@6.1.0/node_modules/htmlparser2/lib/Tokenizer.js"(exports2) {
      "use strict";
      var __importDefault = exports2 && exports2.__importDefault || function(mod) {
        return mod && mod.__esModule ? mod : { "default": mod };
      };
      Object.defineProperty(exports2, "__esModule", { value: true });
      var decode_codepoint_1 = __importDefault(require_decode_codepoint());
      var entities_json_1 = __importDefault(require_entities());
      var legacy_json_1 = __importDefault(require_legacy());
      var xml_json_1 = __importDefault(require_xml());
      function whitespace(c) {
        return c === " " || c === "\n" || c === "	" || c === "\f" || c === "\r";
      }
      function isASCIIAlpha(c) {
        return c >= "a" && c <= "z" || c >= "A" && c <= "Z";
      }
      function ifElseState(upper, SUCCESS, FAILURE) {
        var lower = upper.toLowerCase();
        if (upper === lower) {
          return function(t, c) {
            if (c === lower) {
              t._state = SUCCESS;
            } else {
              t._state = FAILURE;
              t._index--;
            }
          };
        }
        return function(t, c) {
          if (c === lower || c === upper) {
            t._state = SUCCESS;
          } else {
            t._state = FAILURE;
            t._index--;
          }
        };
      }
      function consumeSpecialNameChar(upper, NEXT_STATE) {
        var lower = upper.toLowerCase();
        return function(t, c) {
          if (c === lower || c === upper) {
            t._state = NEXT_STATE;
          } else {
            t._state = 3;
            t._index--;
          }
        };
      }
      var stateBeforeCdata1 = ifElseState(
        "C",
        24,
        16
        /* InDeclaration */
      );
      var stateBeforeCdata2 = ifElseState(
        "D",
        25,
        16
        /* InDeclaration */
      );
      var stateBeforeCdata3 = ifElseState(
        "A",
        26,
        16
        /* InDeclaration */
      );
      var stateBeforeCdata4 = ifElseState(
        "T",
        27,
        16
        /* InDeclaration */
      );
      var stateBeforeCdata5 = ifElseState(
        "A",
        28,
        16
        /* InDeclaration */
      );
      var stateBeforeScript1 = consumeSpecialNameChar(
        "R",
        35
        /* BeforeScript2 */
      );
      var stateBeforeScript2 = consumeSpecialNameChar(
        "I",
        36
        /* BeforeScript3 */
      );
      var stateBeforeScript3 = consumeSpecialNameChar(
        "P",
        37
        /* BeforeScript4 */
      );
      var stateBeforeScript4 = consumeSpecialNameChar(
        "T",
        38
        /* BeforeScript5 */
      );
      var stateAfterScript1 = ifElseState(
        "R",
        40,
        1
        /* Text */
      );
      var stateAfterScript2 = ifElseState(
        "I",
        41,
        1
        /* Text */
      );
      var stateAfterScript3 = ifElseState(
        "P",
        42,
        1
        /* Text */
      );
      var stateAfterScript4 = ifElseState(
        "T",
        43,
        1
        /* Text */
      );
      var stateBeforeStyle1 = consumeSpecialNameChar(
        "Y",
        45
        /* BeforeStyle2 */
      );
      var stateBeforeStyle2 = consumeSpecialNameChar(
        "L",
        46
        /* BeforeStyle3 */
      );
      var stateBeforeStyle3 = consumeSpecialNameChar(
        "E",
        47
        /* BeforeStyle4 */
      );
      var stateAfterStyle1 = ifElseState(
        "Y",
        49,
        1
        /* Text */
      );
      var stateAfterStyle2 = ifElseState(
        "L",
        50,
        1
        /* Text */
      );
      var stateAfterStyle3 = ifElseState(
        "E",
        51,
        1
        /* Text */
      );
      var stateBeforeSpecialT = consumeSpecialNameChar(
        "I",
        54
        /* BeforeTitle1 */
      );
      var stateBeforeTitle1 = consumeSpecialNameChar(
        "T",
        55
        /* BeforeTitle2 */
      );
      var stateBeforeTitle2 = consumeSpecialNameChar(
        "L",
        56
        /* BeforeTitle3 */
      );
      var stateBeforeTitle3 = consumeSpecialNameChar(
        "E",
        57
        /* BeforeTitle4 */
      );
      var stateAfterSpecialTEnd = ifElseState(
        "I",
        58,
        1
        /* Text */
      );
      var stateAfterTitle1 = ifElseState(
        "T",
        59,
        1
        /* Text */
      );
      var stateAfterTitle2 = ifElseState(
        "L",
        60,
        1
        /* Text */
      );
      var stateAfterTitle3 = ifElseState(
        "E",
        61,
        1
        /* Text */
      );
      var stateBeforeEntity = ifElseState(
        "#",
        63,
        64
        /* InNamedEntity */
      );
      var stateBeforeNumericEntity = ifElseState(
        "X",
        66,
        65
        /* InNumericEntity */
      );
      var Tokenizer = (
        /** @class */
        function() {
          function Tokenizer2(options, cbs) {
            var _a2;
            this._state = 1;
            this.buffer = "";
            this.sectionStart = 0;
            this._index = 0;
            this.bufferOffset = 0;
            this.baseState = 1;
            this.special = 1;
            this.running = true;
            this.ended = false;
            this.cbs = cbs;
            this.xmlMode = !!(options === null || options === void 0 ? void 0 : options.xmlMode);
            this.decodeEntities = (_a2 = options === null || options === void 0 ? void 0 : options.decodeEntities) !== null && _a2 !== void 0 ? _a2 : true;
          }
          Tokenizer2.prototype.reset = function() {
            this._state = 1;
            this.buffer = "";
            this.sectionStart = 0;
            this._index = 0;
            this.bufferOffset = 0;
            this.baseState = 1;
            this.special = 1;
            this.running = true;
            this.ended = false;
          };
          Tokenizer2.prototype.write = function(chunk) {
            if (this.ended)
              this.cbs.onerror(Error(".write() after done!"));
            this.buffer += chunk;
            this.parse();
          };
          Tokenizer2.prototype.end = function(chunk) {
            if (this.ended)
              this.cbs.onerror(Error(".end() after done!"));
            if (chunk)
              this.write(chunk);
            this.ended = true;
            if (this.running)
              this.finish();
          };
          Tokenizer2.prototype.pause = function() {
            this.running = false;
          };
          Tokenizer2.prototype.resume = function() {
            this.running = true;
            if (this._index < this.buffer.length) {
              this.parse();
            }
            if (this.ended) {
              this.finish();
            }
          };
          Tokenizer2.prototype.getAbsoluteIndex = function() {
            return this.bufferOffset + this._index;
          };
          Tokenizer2.prototype.stateText = function(c) {
            if (c === "<") {
              if (this._index > this.sectionStart) {
                this.cbs.ontext(this.getSection());
              }
              this._state = 2;
              this.sectionStart = this._index;
            } else if (this.decodeEntities && c === "&" && (this.special === 1 || this.special === 4)) {
              if (this._index > this.sectionStart) {
                this.cbs.ontext(this.getSection());
              }
              this.baseState = 1;
              this._state = 62;
              this.sectionStart = this._index;
            }
          };
          Tokenizer2.prototype.isTagStartChar = function(c) {
            return isASCIIAlpha(c) || this.xmlMode && !whitespace(c) && c !== "/" && c !== ">";
          };
          Tokenizer2.prototype.stateBeforeTagName = function(c) {
            if (c === "/") {
              this._state = 5;
            } else if (c === "<") {
              this.cbs.ontext(this.getSection());
              this.sectionStart = this._index;
            } else if (c === ">" || this.special !== 1 || whitespace(c)) {
              this._state = 1;
            } else if (c === "!") {
              this._state = 15;
              this.sectionStart = this._index + 1;
            } else if (c === "?") {
              this._state = 17;
              this.sectionStart = this._index + 1;
            } else if (!this.isTagStartChar(c)) {
              this._state = 1;
            } else {
              this._state = !this.xmlMode && (c === "s" || c === "S") ? 32 : !this.xmlMode && (c === "t" || c === "T") ? 52 : 3;
              this.sectionStart = this._index;
            }
          };
          Tokenizer2.prototype.stateInTagName = function(c) {
            if (c === "/" || c === ">" || whitespace(c)) {
              this.emitToken("onopentagname");
              this._state = 8;
              this._index--;
            }
          };
          Tokenizer2.prototype.stateBeforeClosingTagName = function(c) {
            if (whitespace(c)) {
            } else if (c === ">") {
              this._state = 1;
            } else if (this.special !== 1) {
              if (this.special !== 4 && (c === "s" || c === "S")) {
                this._state = 33;
              } else if (this.special === 4 && (c === "t" || c === "T")) {
                this._state = 53;
              } else {
                this._state = 1;
                this._index--;
              }
            } else if (!this.isTagStartChar(c)) {
              this._state = 20;
              this.sectionStart = this._index;
            } else {
              this._state = 6;
              this.sectionStart = this._index;
            }
          };
          Tokenizer2.prototype.stateInClosingTagName = function(c) {
            if (c === ">" || whitespace(c)) {
              this.emitToken("onclosetag");
              this._state = 7;
              this._index--;
            }
          };
          Tokenizer2.prototype.stateAfterClosingTagName = function(c) {
            if (c === ">") {
              this._state = 1;
              this.sectionStart = this._index + 1;
            }
          };
          Tokenizer2.prototype.stateBeforeAttributeName = function(c) {
            if (c === ">") {
              this.cbs.onopentagend();
              this._state = 1;
              this.sectionStart = this._index + 1;
            } else if (c === "/") {
              this._state = 4;
            } else if (!whitespace(c)) {
              this._state = 9;
              this.sectionStart = this._index;
            }
          };
          Tokenizer2.prototype.stateInSelfClosingTag = function(c) {
            if (c === ">") {
              this.cbs.onselfclosingtag();
              this._state = 1;
              this.sectionStart = this._index + 1;
              this.special = 1;
            } else if (!whitespace(c)) {
              this._state = 8;
              this._index--;
            }
          };
          Tokenizer2.prototype.stateInAttributeName = function(c) {
            if (c === "=" || c === "/" || c === ">" || whitespace(c)) {
              this.cbs.onattribname(this.getSection());
              this.sectionStart = -1;
              this._state = 10;
              this._index--;
            }
          };
          Tokenizer2.prototype.stateAfterAttributeName = function(c) {
            if (c === "=") {
              this._state = 11;
            } else if (c === "/" || c === ">") {
              this.cbs.onattribend(void 0);
              this._state = 8;
              this._index--;
            } else if (!whitespace(c)) {
              this.cbs.onattribend(void 0);
              this._state = 9;
              this.sectionStart = this._index;
            }
          };
          Tokenizer2.prototype.stateBeforeAttributeValue = function(c) {
            if (c === '"') {
              this._state = 12;
              this.sectionStart = this._index + 1;
            } else if (c === "'") {
              this._state = 13;
              this.sectionStart = this._index + 1;
            } else if (!whitespace(c)) {
              this._state = 14;
              this.sectionStart = this._index;
              this._index--;
            }
          };
          Tokenizer2.prototype.handleInAttributeValue = function(c, quote) {
            if (c === quote) {
              this.emitToken("onattribdata");
              this.cbs.onattribend(quote);
              this._state = 8;
            } else if (this.decodeEntities && c === "&") {
              this.emitToken("onattribdata");
              this.baseState = this._state;
              this._state = 62;
              this.sectionStart = this._index;
            }
          };
          Tokenizer2.prototype.stateInAttributeValueDoubleQuotes = function(c) {
            this.handleInAttributeValue(c, '"');
          };
          Tokenizer2.prototype.stateInAttributeValueSingleQuotes = function(c) {
            this.handleInAttributeValue(c, "'");
          };
          Tokenizer2.prototype.stateInAttributeValueNoQuotes = function(c) {
            if (whitespace(c) || c === ">") {
              this.emitToken("onattribdata");
              this.cbs.onattribend(null);
              this._state = 8;
              this._index--;
            } else if (this.decodeEntities && c === "&") {
              this.emitToken("onattribdata");
              this.baseState = this._state;
              this._state = 62;
              this.sectionStart = this._index;
            }
          };
          Tokenizer2.prototype.stateBeforeDeclaration = function(c) {
            this._state = c === "[" ? 23 : c === "-" ? 18 : 16;
          };
          Tokenizer2.prototype.stateInDeclaration = function(c) {
            if (c === ">") {
              this.cbs.ondeclaration(this.getSection());
              this._state = 1;
              this.sectionStart = this._index + 1;
            }
          };
          Tokenizer2.prototype.stateInProcessingInstruction = function(c) {
            if (c === ">") {
              this.cbs.onprocessinginstruction(this.getSection());
              this._state = 1;
              this.sectionStart = this._index + 1;
            }
          };
          Tokenizer2.prototype.stateBeforeComment = function(c) {
            if (c === "-") {
              this._state = 19;
              this.sectionStart = this._index + 1;
            } else {
              this._state = 16;
            }
          };
          Tokenizer2.prototype.stateInComment = function(c) {
            if (c === "-")
              this._state = 21;
          };
          Tokenizer2.prototype.stateInSpecialComment = function(c) {
            if (c === ">") {
              this.cbs.oncomment(this.buffer.substring(this.sectionStart, this._index));
              this._state = 1;
              this.sectionStart = this._index + 1;
            }
          };
          Tokenizer2.prototype.stateAfterComment1 = function(c) {
            if (c === "-") {
              this._state = 22;
            } else {
              this._state = 19;
            }
          };
          Tokenizer2.prototype.stateAfterComment2 = function(c) {
            if (c === ">") {
              this.cbs.oncomment(this.buffer.substring(this.sectionStart, this._index - 2));
              this._state = 1;
              this.sectionStart = this._index + 1;
            } else if (c !== "-") {
              this._state = 19;
            }
          };
          Tokenizer2.prototype.stateBeforeCdata6 = function(c) {
            if (c === "[") {
              this._state = 29;
              this.sectionStart = this._index + 1;
            } else {
              this._state = 16;
              this._index--;
            }
          };
          Tokenizer2.prototype.stateInCdata = function(c) {
            if (c === "]")
              this._state = 30;
          };
          Tokenizer2.prototype.stateAfterCdata1 = function(c) {
            if (c === "]")
              this._state = 31;
            else
              this._state = 29;
          };
          Tokenizer2.prototype.stateAfterCdata2 = function(c) {
            if (c === ">") {
              this.cbs.oncdata(this.buffer.substring(this.sectionStart, this._index - 2));
              this._state = 1;
              this.sectionStart = this._index + 1;
            } else if (c !== "]") {
              this._state = 29;
            }
          };
          Tokenizer2.prototype.stateBeforeSpecialS = function(c) {
            if (c === "c" || c === "C") {
              this._state = 34;
            } else if (c === "t" || c === "T") {
              this._state = 44;
            } else {
              this._state = 3;
              this._index--;
            }
          };
          Tokenizer2.prototype.stateBeforeSpecialSEnd = function(c) {
            if (this.special === 2 && (c === "c" || c === "C")) {
              this._state = 39;
            } else if (this.special === 3 && (c === "t" || c === "T")) {
              this._state = 48;
            } else
              this._state = 1;
          };
          Tokenizer2.prototype.stateBeforeSpecialLast = function(c, special) {
            if (c === "/" || c === ">" || whitespace(c)) {
              this.special = special;
            }
            this._state = 3;
            this._index--;
          };
          Tokenizer2.prototype.stateAfterSpecialLast = function(c, sectionStartOffset) {
            if (c === ">" || whitespace(c)) {
              this.special = 1;
              this._state = 6;
              this.sectionStart = this._index - sectionStartOffset;
              this._index--;
            } else
              this._state = 1;
          };
          Tokenizer2.prototype.parseFixedEntity = function(map) {
            if (map === void 0) {
              map = this.xmlMode ? xml_json_1.default : entities_json_1.default;
            }
            if (this.sectionStart + 1 < this._index) {
              var entity = this.buffer.substring(this.sectionStart + 1, this._index);
              if (Object.prototype.hasOwnProperty.call(map, entity)) {
                this.emitPartial(map[entity]);
                this.sectionStart = this._index + 1;
              }
            }
          };
          Tokenizer2.prototype.parseLegacyEntity = function() {
            var start = this.sectionStart + 1;
            var limit = Math.min(this._index - start, 6);
            while (limit >= 2) {
              var entity = this.buffer.substr(start, limit);
              if (Object.prototype.hasOwnProperty.call(legacy_json_1.default, entity)) {
                this.emitPartial(legacy_json_1.default[entity]);
                this.sectionStart += limit + 1;
                return;
              }
              limit--;
            }
          };
          Tokenizer2.prototype.stateInNamedEntity = function(c) {
            if (c === ";") {
              this.parseFixedEntity();
              if (this.baseState === 1 && this.sectionStart + 1 < this._index && !this.xmlMode) {
                this.parseLegacyEntity();
              }
              this._state = this.baseState;
            } else if ((c < "0" || c > "9") && !isASCIIAlpha(c)) {
              if (this.xmlMode || this.sectionStart + 1 === this._index) {
              } else if (this.baseState !== 1) {
                if (c !== "=") {
                  this.parseFixedEntity(legacy_json_1.default);
                }
              } else {
                this.parseLegacyEntity();
              }
              this._state = this.baseState;
              this._index--;
            }
          };
          Tokenizer2.prototype.decodeNumericEntity = function(offset, base, strict) {
            var sectionStart = this.sectionStart + offset;
            if (sectionStart !== this._index) {
              var entity = this.buffer.substring(sectionStart, this._index);
              var parsed = parseInt(entity, base);
              this.emitPartial(decode_codepoint_1.default(parsed));
              this.sectionStart = strict ? this._index + 1 : this._index;
            }
            this._state = this.baseState;
          };
          Tokenizer2.prototype.stateInNumericEntity = function(c) {
            if (c === ";") {
              this.decodeNumericEntity(2, 10, true);
            } else if (c < "0" || c > "9") {
              if (!this.xmlMode) {
                this.decodeNumericEntity(2, 10, false);
              } else {
                this._state = this.baseState;
              }
              this._index--;
            }
          };
          Tokenizer2.prototype.stateInHexEntity = function(c) {
            if (c === ";") {
              this.decodeNumericEntity(3, 16, true);
            } else if ((c < "a" || c > "f") && (c < "A" || c > "F") && (c < "0" || c > "9")) {
              if (!this.xmlMode) {
                this.decodeNumericEntity(3, 16, false);
              } else {
                this._state = this.baseState;
              }
              this._index--;
            }
          };
          Tokenizer2.prototype.cleanup = function() {
            if (this.sectionStart < 0) {
              this.buffer = "";
              this.bufferOffset += this._index;
              this._index = 0;
            } else if (this.running) {
              if (this._state === 1) {
                if (this.sectionStart !== this._index) {
                  this.cbs.ontext(this.buffer.substr(this.sectionStart));
                }
                this.buffer = "";
                this.bufferOffset += this._index;
                this._index = 0;
              } else if (this.sectionStart === this._index) {
                this.buffer = "";
                this.bufferOffset += this._index;
                this._index = 0;
              } else {
                this.buffer = this.buffer.substr(this.sectionStart);
                this._index -= this.sectionStart;
                this.bufferOffset += this.sectionStart;
              }
              this.sectionStart = 0;
            }
          };
          Tokenizer2.prototype.parse = function() {
            while (this._index < this.buffer.length && this.running) {
              var c = this.buffer.charAt(this._index);
              if (this._state === 1) {
                this.stateText(c);
              } else if (this._state === 12) {
                this.stateInAttributeValueDoubleQuotes(c);
              } else if (this._state === 9) {
                this.stateInAttributeName(c);
              } else if (this._state === 19) {
                this.stateInComment(c);
              } else if (this._state === 20) {
                this.stateInSpecialComment(c);
              } else if (this._state === 8) {
                this.stateBeforeAttributeName(c);
              } else if (this._state === 3) {
                this.stateInTagName(c);
              } else if (this._state === 6) {
                this.stateInClosingTagName(c);
              } else if (this._state === 2) {
                this.stateBeforeTagName(c);
              } else if (this._state === 10) {
                this.stateAfterAttributeName(c);
              } else if (this._state === 13) {
                this.stateInAttributeValueSingleQuotes(c);
              } else if (this._state === 11) {
                this.stateBeforeAttributeValue(c);
              } else if (this._state === 5) {
                this.stateBeforeClosingTagName(c);
              } else if (this._state === 7) {
                this.stateAfterClosingTagName(c);
              } else if (this._state === 32) {
                this.stateBeforeSpecialS(c);
              } else if (this._state === 21) {
                this.stateAfterComment1(c);
              } else if (this._state === 14) {
                this.stateInAttributeValueNoQuotes(c);
              } else if (this._state === 4) {
                this.stateInSelfClosingTag(c);
              } else if (this._state === 16) {
                this.stateInDeclaration(c);
              } else if (this._state === 15) {
                this.stateBeforeDeclaration(c);
              } else if (this._state === 22) {
                this.stateAfterComment2(c);
              } else if (this._state === 18) {
                this.stateBeforeComment(c);
              } else if (this._state === 33) {
                this.stateBeforeSpecialSEnd(c);
              } else if (this._state === 53) {
                stateAfterSpecialTEnd(this, c);
              } else if (this._state === 39) {
                stateAfterScript1(this, c);
              } else if (this._state === 40) {
                stateAfterScript2(this, c);
              } else if (this._state === 41) {
                stateAfterScript3(this, c);
              } else if (this._state === 34) {
                stateBeforeScript1(this, c);
              } else if (this._state === 35) {
                stateBeforeScript2(this, c);
              } else if (this._state === 36) {
                stateBeforeScript3(this, c);
              } else if (this._state === 37) {
                stateBeforeScript4(this, c);
              } else if (this._state === 38) {
                this.stateBeforeSpecialLast(
                  c,
                  2
                  /* Script */
                );
              } else if (this._state === 42) {
                stateAfterScript4(this, c);
              } else if (this._state === 43) {
                this.stateAfterSpecialLast(c, 6);
              } else if (this._state === 44) {
                stateBeforeStyle1(this, c);
              } else if (this._state === 29) {
                this.stateInCdata(c);
              } else if (this._state === 45) {
                stateBeforeStyle2(this, c);
              } else if (this._state === 46) {
                stateBeforeStyle3(this, c);
              } else if (this._state === 47) {
                this.stateBeforeSpecialLast(
                  c,
                  3
                  /* Style */
                );
              } else if (this._state === 48) {
                stateAfterStyle1(this, c);
              } else if (this._state === 49) {
                stateAfterStyle2(this, c);
              } else if (this._state === 50) {
                stateAfterStyle3(this, c);
              } else if (this._state === 51) {
                this.stateAfterSpecialLast(c, 5);
              } else if (this._state === 52) {
                stateBeforeSpecialT(this, c);
              } else if (this._state === 54) {
                stateBeforeTitle1(this, c);
              } else if (this._state === 55) {
                stateBeforeTitle2(this, c);
              } else if (this._state === 56) {
                stateBeforeTitle3(this, c);
              } else if (this._state === 57) {
                this.stateBeforeSpecialLast(
                  c,
                  4
                  /* Title */
                );
              } else if (this._state === 58) {
                stateAfterTitle1(this, c);
              } else if (this._state === 59) {
                stateAfterTitle2(this, c);
              } else if (this._state === 60) {
                stateAfterTitle3(this, c);
              } else if (this._state === 61) {
                this.stateAfterSpecialLast(c, 5);
              } else if (this._state === 17) {
                this.stateInProcessingInstruction(c);
              } else if (this._state === 64) {
                this.stateInNamedEntity(c);
              } else if (this._state === 23) {
                stateBeforeCdata1(this, c);
              } else if (this._state === 62) {
                stateBeforeEntity(this, c);
              } else if (this._state === 24) {
                stateBeforeCdata2(this, c);
              } else if (this._state === 25) {
                stateBeforeCdata3(this, c);
              } else if (this._state === 30) {
                this.stateAfterCdata1(c);
              } else if (this._state === 31) {
                this.stateAfterCdata2(c);
              } else if (this._state === 26) {
                stateBeforeCdata4(this, c);
              } else if (this._state === 27) {
                stateBeforeCdata5(this, c);
              } else if (this._state === 28) {
                this.stateBeforeCdata6(c);
              } else if (this._state === 66) {
                this.stateInHexEntity(c);
              } else if (this._state === 65) {
                this.stateInNumericEntity(c);
              } else if (this._state === 63) {
                stateBeforeNumericEntity(this, c);
              } else {
                this.cbs.onerror(Error("unknown _state"), this._state);
              }
              this._index++;
            }
            this.cleanup();
          };
          Tokenizer2.prototype.finish = function() {
            if (this.sectionStart < this._index) {
              this.handleTrailingData();
            }
            this.cbs.onend();
          };
          Tokenizer2.prototype.handleTrailingData = function() {
            var data = this.buffer.substr(this.sectionStart);
            if (this._state === 29 || this._state === 30 || this._state === 31) {
              this.cbs.oncdata(data);
            } else if (this._state === 19 || this._state === 21 || this._state === 22) {
              this.cbs.oncomment(data);
            } else if (this._state === 64 && !this.xmlMode) {
              this.parseLegacyEntity();
              if (this.sectionStart < this._index) {
                this._state = this.baseState;
                this.handleTrailingData();
              }
            } else if (this._state === 65 && !this.xmlMode) {
              this.decodeNumericEntity(2, 10, false);
              if (this.sectionStart < this._index) {
                this._state = this.baseState;
                this.handleTrailingData();
              }
            } else if (this._state === 66 && !this.xmlMode) {
              this.decodeNumericEntity(3, 16, false);
              if (this.sectionStart < this._index) {
                this._state = this.baseState;
                this.handleTrailingData();
              }
            } else if (this._state !== 3 && this._state !== 8 && this._state !== 11 && this._state !== 10 && this._state !== 9 && this._state !== 13 && this._state !== 12 && this._state !== 14 && this._state !== 6) {
              this.cbs.ontext(data);
            }
          };
          Tokenizer2.prototype.getSection = function() {
            return this.buffer.substring(this.sectionStart, this._index);
          };
          Tokenizer2.prototype.emitToken = function(name) {
            this.cbs[name](this.getSection());
            this.sectionStart = -1;
          };
          Tokenizer2.prototype.emitPartial = function(value) {
            if (this.baseState !== 1) {
              this.cbs.onattribdata(value);
            } else {
              this.cbs.ontext(value);
            }
          };
          return Tokenizer2;
        }()
      );
      exports2.default = Tokenizer;
    }
  });

  // node_modules/.pnpm/htmlparser2@6.1.0/node_modules/htmlparser2/lib/Parser.js
  var require_Parser = __commonJS({
    "node_modules/.pnpm/htmlparser2@6.1.0/node_modules/htmlparser2/lib/Parser.js"(exports2) {
      "use strict";
      var __importDefault = exports2 && exports2.__importDefault || function(mod) {
        return mod && mod.__esModule ? mod : { "default": mod };
      };
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.Parser = void 0;
      var Tokenizer_1 = __importDefault(require_Tokenizer());
      var formTags = /* @__PURE__ */ new Set([
        "input",
        "option",
        "optgroup",
        "select",
        "button",
        "datalist",
        "textarea"
      ]);
      var pTag = /* @__PURE__ */ new Set(["p"]);
      var openImpliesClose = {
        tr: /* @__PURE__ */ new Set(["tr", "th", "td"]),
        th: /* @__PURE__ */ new Set(["th"]),
        td: /* @__PURE__ */ new Set(["thead", "th", "td"]),
        body: /* @__PURE__ */ new Set(["head", "link", "script"]),
        li: /* @__PURE__ */ new Set(["li"]),
        p: pTag,
        h1: pTag,
        h2: pTag,
        h3: pTag,
        h4: pTag,
        h5: pTag,
        h6: pTag,
        select: formTags,
        input: formTags,
        output: formTags,
        button: formTags,
        datalist: formTags,
        textarea: formTags,
        option: /* @__PURE__ */ new Set(["option"]),
        optgroup: /* @__PURE__ */ new Set(["optgroup", "option"]),
        dd: /* @__PURE__ */ new Set(["dt", "dd"]),
        dt: /* @__PURE__ */ new Set(["dt", "dd"]),
        address: pTag,
        article: pTag,
        aside: pTag,
        blockquote: pTag,
        details: pTag,
        div: pTag,
        dl: pTag,
        fieldset: pTag,
        figcaption: pTag,
        figure: pTag,
        footer: pTag,
        form: pTag,
        header: pTag,
        hr: pTag,
        main: pTag,
        nav: pTag,
        ol: pTag,
        pre: pTag,
        section: pTag,
        table: pTag,
        ul: pTag,
        rt: /* @__PURE__ */ new Set(["rt", "rp"]),
        rp: /* @__PURE__ */ new Set(["rt", "rp"]),
        tbody: /* @__PURE__ */ new Set(["thead", "tbody"]),
        tfoot: /* @__PURE__ */ new Set(["thead", "tbody"])
      };
      var voidElements = /* @__PURE__ */ new Set([
        "area",
        "base",
        "basefont",
        "br",
        "col",
        "command",
        "embed",
        "frame",
        "hr",
        "img",
        "input",
        "isindex",
        "keygen",
        "link",
        "meta",
        "param",
        "source",
        "track",
        "wbr"
      ]);
      var foreignContextElements = /* @__PURE__ */ new Set(["math", "svg"]);
      var htmlIntegrationElements = /* @__PURE__ */ new Set([
        "mi",
        "mo",
        "mn",
        "ms",
        "mtext",
        "annotation-xml",
        "foreignObject",
        "desc",
        "title"
      ]);
      var reNameEnd = /\s|\//;
      var Parser = (
        /** @class */
        function() {
          function Parser2(cbs, options) {
            if (options === void 0) {
              options = {};
            }
            var _a2, _b2, _c, _d, _e;
            this.startIndex = 0;
            this.endIndex = null;
            this.tagname = "";
            this.attribname = "";
            this.attribvalue = "";
            this.attribs = null;
            this.stack = [];
            this.foreignContext = [];
            this.options = options;
            this.cbs = cbs !== null && cbs !== void 0 ? cbs : {};
            this.lowerCaseTagNames = (_a2 = options.lowerCaseTags) !== null && _a2 !== void 0 ? _a2 : !options.xmlMode;
            this.lowerCaseAttributeNames = (_b2 = options.lowerCaseAttributeNames) !== null && _b2 !== void 0 ? _b2 : !options.xmlMode;
            this.tokenizer = new ((_c = options.Tokenizer) !== null && _c !== void 0 ? _c : Tokenizer_1.default)(this.options, this);
            (_e = (_d = this.cbs).onparserinit) === null || _e === void 0 ? void 0 : _e.call(_d, this);
          }
          Parser2.prototype.updatePosition = function(initialOffset) {
            if (this.endIndex === null) {
              if (this.tokenizer.sectionStart <= initialOffset) {
                this.startIndex = 0;
              } else {
                this.startIndex = this.tokenizer.sectionStart - initialOffset;
              }
            } else {
              this.startIndex = this.endIndex + 1;
            }
            this.endIndex = this.tokenizer.getAbsoluteIndex();
          };
          Parser2.prototype.ontext = function(data) {
            var _a2, _b2;
            this.updatePosition(1);
            this.endIndex--;
            (_b2 = (_a2 = this.cbs).ontext) === null || _b2 === void 0 ? void 0 : _b2.call(_a2, data);
          };
          Parser2.prototype.onopentagname = function(name) {
            var _a2, _b2;
            if (this.lowerCaseTagNames) {
              name = name.toLowerCase();
            }
            this.tagname = name;
            if (!this.options.xmlMode && Object.prototype.hasOwnProperty.call(openImpliesClose, name)) {
              var el = void 0;
              while (this.stack.length > 0 && openImpliesClose[name].has(el = this.stack[this.stack.length - 1])) {
                this.onclosetag(el);
              }
            }
            if (this.options.xmlMode || !voidElements.has(name)) {
              this.stack.push(name);
              if (foreignContextElements.has(name)) {
                this.foreignContext.push(true);
              } else if (htmlIntegrationElements.has(name)) {
                this.foreignContext.push(false);
              }
            }
            (_b2 = (_a2 = this.cbs).onopentagname) === null || _b2 === void 0 ? void 0 : _b2.call(_a2, name);
            if (this.cbs.onopentag)
              this.attribs = {};
          };
          Parser2.prototype.onopentagend = function() {
            var _a2, _b2;
            this.updatePosition(1);
            if (this.attribs) {
              (_b2 = (_a2 = this.cbs).onopentag) === null || _b2 === void 0 ? void 0 : _b2.call(_a2, this.tagname, this.attribs);
              this.attribs = null;
            }
            if (!this.options.xmlMode && this.cbs.onclosetag && voidElements.has(this.tagname)) {
              this.cbs.onclosetag(this.tagname);
            }
            this.tagname = "";
          };
          Parser2.prototype.onclosetag = function(name) {
            this.updatePosition(1);
            if (this.lowerCaseTagNames) {
              name = name.toLowerCase();
            }
            if (foreignContextElements.has(name) || htmlIntegrationElements.has(name)) {
              this.foreignContext.pop();
            }
            if (this.stack.length && (this.options.xmlMode || !voidElements.has(name))) {
              var pos = this.stack.lastIndexOf(name);
              if (pos !== -1) {
                if (this.cbs.onclosetag) {
                  pos = this.stack.length - pos;
                  while (pos--) {
                    this.cbs.onclosetag(this.stack.pop());
                  }
                } else
                  this.stack.length = pos;
              } else if (name === "p" && !this.options.xmlMode) {
                this.onopentagname(name);
                this.closeCurrentTag();
              }
            } else if (!this.options.xmlMode && (name === "br" || name === "p")) {
              this.onopentagname(name);
              this.closeCurrentTag();
            }
          };
          Parser2.prototype.onselfclosingtag = function() {
            if (this.options.xmlMode || this.options.recognizeSelfClosing || this.foreignContext[this.foreignContext.length - 1]) {
              this.closeCurrentTag();
            } else {
              this.onopentagend();
            }
          };
          Parser2.prototype.closeCurrentTag = function() {
            var _a2, _b2;
            var name = this.tagname;
            this.onopentagend();
            if (this.stack[this.stack.length - 1] === name) {
              (_b2 = (_a2 = this.cbs).onclosetag) === null || _b2 === void 0 ? void 0 : _b2.call(_a2, name);
              this.stack.pop();
            }
          };
          Parser2.prototype.onattribname = function(name) {
            if (this.lowerCaseAttributeNames) {
              name = name.toLowerCase();
            }
            this.attribname = name;
          };
          Parser2.prototype.onattribdata = function(value) {
            this.attribvalue += value;
          };
          Parser2.prototype.onattribend = function(quote) {
            var _a2, _b2;
            (_b2 = (_a2 = this.cbs).onattribute) === null || _b2 === void 0 ? void 0 : _b2.call(_a2, this.attribname, this.attribvalue, quote);
            if (this.attribs && !Object.prototype.hasOwnProperty.call(this.attribs, this.attribname)) {
              this.attribs[this.attribname] = this.attribvalue;
            }
            this.attribname = "";
            this.attribvalue = "";
          };
          Parser2.prototype.getInstructionName = function(value) {
            var idx = value.search(reNameEnd);
            var name = idx < 0 ? value : value.substr(0, idx);
            if (this.lowerCaseTagNames) {
              name = name.toLowerCase();
            }
            return name;
          };
          Parser2.prototype.ondeclaration = function(value) {
            if (this.cbs.onprocessinginstruction) {
              var name_1 = this.getInstructionName(value);
              this.cbs.onprocessinginstruction("!" + name_1, "!" + value);
            }
          };
          Parser2.prototype.onprocessinginstruction = function(value) {
            if (this.cbs.onprocessinginstruction) {
              var name_2 = this.getInstructionName(value);
              this.cbs.onprocessinginstruction("?" + name_2, "?" + value);
            }
          };
          Parser2.prototype.oncomment = function(value) {
            var _a2, _b2, _c, _d;
            this.updatePosition(4);
            (_b2 = (_a2 = this.cbs).oncomment) === null || _b2 === void 0 ? void 0 : _b2.call(_a2, value);
            (_d = (_c = this.cbs).oncommentend) === null || _d === void 0 ? void 0 : _d.call(_c);
          };
          Parser2.prototype.oncdata = function(value) {
            var _a2, _b2, _c, _d, _e, _f;
            this.updatePosition(1);
            if (this.options.xmlMode || this.options.recognizeCDATA) {
              (_b2 = (_a2 = this.cbs).oncdatastart) === null || _b2 === void 0 ? void 0 : _b2.call(_a2);
              (_d = (_c = this.cbs).ontext) === null || _d === void 0 ? void 0 : _d.call(_c, value);
              (_f = (_e = this.cbs).oncdataend) === null || _f === void 0 ? void 0 : _f.call(_e);
            } else {
              this.oncomment("[CDATA[" + value + "]]");
            }
          };
          Parser2.prototype.onerror = function(err2) {
            var _a2, _b2;
            (_b2 = (_a2 = this.cbs).onerror) === null || _b2 === void 0 ? void 0 : _b2.call(_a2, err2);
          };
          Parser2.prototype.onend = function() {
            var _a2, _b2;
            if (this.cbs.onclosetag) {
              for (var i = this.stack.length; i > 0; this.cbs.onclosetag(this.stack[--i]))
                ;
            }
            (_b2 = (_a2 = this.cbs).onend) === null || _b2 === void 0 ? void 0 : _b2.call(_a2);
          };
          Parser2.prototype.reset = function() {
            var _a2, _b2, _c, _d;
            (_b2 = (_a2 = this.cbs).onreset) === null || _b2 === void 0 ? void 0 : _b2.call(_a2);
            this.tokenizer.reset();
            this.tagname = "";
            this.attribname = "";
            this.attribs = null;
            this.stack = [];
            (_d = (_c = this.cbs).onparserinit) === null || _d === void 0 ? void 0 : _d.call(_c, this);
          };
          Parser2.prototype.parseComplete = function(data) {
            this.reset();
            this.end(data);
          };
          Parser2.prototype.write = function(chunk) {
            this.tokenizer.write(chunk);
          };
          Parser2.prototype.end = function(chunk) {
            this.tokenizer.end(chunk);
          };
          Parser2.prototype.pause = function() {
            this.tokenizer.pause();
          };
          Parser2.prototype.resume = function() {
            this.tokenizer.resume();
          };
          Parser2.prototype.parseChunk = function(chunk) {
            this.write(chunk);
          };
          Parser2.prototype.done = function(chunk) {
            this.end(chunk);
          };
          return Parser2;
        }()
      );
      exports2.Parser = Parser;
    }
  });

  // node_modules/.pnpm/domelementtype@2.3.0/node_modules/domelementtype/lib/index.js
  var require_lib = __commonJS({
    "node_modules/.pnpm/domelementtype@2.3.0/node_modules/domelementtype/lib/index.js"(exports2) {
      "use strict";
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.Doctype = exports2.CDATA = exports2.Tag = exports2.Style = exports2.Script = exports2.Comment = exports2.Directive = exports2.Text = exports2.Root = exports2.isTag = exports2.ElementType = void 0;
      var ElementType;
      (function(ElementType2) {
        ElementType2["Root"] = "root";
        ElementType2["Text"] = "text";
        ElementType2["Directive"] = "directive";
        ElementType2["Comment"] = "comment";
        ElementType2["Script"] = "script";
        ElementType2["Style"] = "style";
        ElementType2["Tag"] = "tag";
        ElementType2["CDATA"] = "cdata";
        ElementType2["Doctype"] = "doctype";
      })(ElementType = exports2.ElementType || (exports2.ElementType = {}));
      function isTag(elem) {
        return elem.type === ElementType.Tag || elem.type === ElementType.Script || elem.type === ElementType.Style;
      }
      exports2.isTag = isTag;
      exports2.Root = ElementType.Root;
      exports2.Text = ElementType.Text;
      exports2.Directive = ElementType.Directive;
      exports2.Comment = ElementType.Comment;
      exports2.Script = ElementType.Script;
      exports2.Style = ElementType.Style;
      exports2.Tag = ElementType.Tag;
      exports2.CDATA = ElementType.CDATA;
      exports2.Doctype = ElementType.Doctype;
    }
  });

  // node_modules/.pnpm/domhandler@4.3.1/node_modules/domhandler/lib/node.js
  var require_node = __commonJS({
    "node_modules/.pnpm/domhandler@4.3.1/node_modules/domhandler/lib/node.js"(exports2) {
      "use strict";
      var __extends = exports2 && exports2.__extends || function() {
        var extendStatics = function(d, b) {
          extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b3) {
            d2.__proto__ = b3;
          } || function(d2, b3) {
            for (var p in b3)
              if (Object.prototype.hasOwnProperty.call(b3, p))
                d2[p] = b3[p];
          };
          return extendStatics(d, b);
        };
        return function(d, b) {
          if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
          extendStatics(d, b);
          function __() {
            this.constructor = d;
          }
          d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
        };
      }();
      var __assign = exports2 && exports2.__assign || function() {
        __assign = Object.assign || function(t) {
          for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s)
              if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
          }
          return t;
        };
        return __assign.apply(this, arguments);
      };
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.cloneNode = exports2.hasChildren = exports2.isDocument = exports2.isDirective = exports2.isComment = exports2.isText = exports2.isCDATA = exports2.isTag = exports2.Element = exports2.Document = exports2.NodeWithChildren = exports2.ProcessingInstruction = exports2.Comment = exports2.Text = exports2.DataNode = exports2.Node = void 0;
      var domelementtype_1 = require_lib();
      var nodeTypes = /* @__PURE__ */ new Map([
        [domelementtype_1.ElementType.Tag, 1],
        [domelementtype_1.ElementType.Script, 1],
        [domelementtype_1.ElementType.Style, 1],
        [domelementtype_1.ElementType.Directive, 1],
        [domelementtype_1.ElementType.Text, 3],
        [domelementtype_1.ElementType.CDATA, 4],
        [domelementtype_1.ElementType.Comment, 8],
        [domelementtype_1.ElementType.Root, 9]
      ]);
      var Node = (
        /** @class */
        function() {
          function Node2(type) {
            this.type = type;
            this.parent = null;
            this.prev = null;
            this.next = null;
            this.startIndex = null;
            this.endIndex = null;
          }
          Object.defineProperty(Node2.prototype, "nodeType", {
            // Read-only aliases
            /**
             * [DOM spec](https://dom.spec.whatwg.org/#dom-node-nodetype)-compatible
             * node {@link type}.
             */
            get: function() {
              var _a2;
              return (_a2 = nodeTypes.get(this.type)) !== null && _a2 !== void 0 ? _a2 : 1;
            },
            enumerable: false,
            configurable: true
          });
          Object.defineProperty(Node2.prototype, "parentNode", {
            // Read-write aliases for properties
            /**
             * Same as {@link parent}.
             * [DOM spec](https://dom.spec.whatwg.org)-compatible alias.
             */
            get: function() {
              return this.parent;
            },
            set: function(parent) {
              this.parent = parent;
            },
            enumerable: false,
            configurable: true
          });
          Object.defineProperty(Node2.prototype, "previousSibling", {
            /**
             * Same as {@link prev}.
             * [DOM spec](https://dom.spec.whatwg.org)-compatible alias.
             */
            get: function() {
              return this.prev;
            },
            set: function(prev) {
              this.prev = prev;
            },
            enumerable: false,
            configurable: true
          });
          Object.defineProperty(Node2.prototype, "nextSibling", {
            /**
             * Same as {@link next}.
             * [DOM spec](https://dom.spec.whatwg.org)-compatible alias.
             */
            get: function() {
              return this.next;
            },
            set: function(next) {
              this.next = next;
            },
            enumerable: false,
            configurable: true
          });
          Node2.prototype.cloneNode = function(recursive) {
            if (recursive === void 0) {
              recursive = false;
            }
            return cloneNode(this, recursive);
          };
          return Node2;
        }()
      );
      exports2.Node = Node;
      var DataNode = (
        /** @class */
        function(_super) {
          __extends(DataNode2, _super);
          function DataNode2(type, data) {
            var _this = _super.call(this, type) || this;
            _this.data = data;
            return _this;
          }
          Object.defineProperty(DataNode2.prototype, "nodeValue", {
            /**
             * Same as {@link data}.
             * [DOM spec](https://dom.spec.whatwg.org)-compatible alias.
             */
            get: function() {
              return this.data;
            },
            set: function(data) {
              this.data = data;
            },
            enumerable: false,
            configurable: true
          });
          return DataNode2;
        }(Node)
      );
      exports2.DataNode = DataNode;
      var Text = (
        /** @class */
        function(_super) {
          __extends(Text2, _super);
          function Text2(data) {
            return _super.call(this, domelementtype_1.ElementType.Text, data) || this;
          }
          return Text2;
        }(DataNode)
      );
      exports2.Text = Text;
      var Comment = (
        /** @class */
        function(_super) {
          __extends(Comment2, _super);
          function Comment2(data) {
            return _super.call(this, domelementtype_1.ElementType.Comment, data) || this;
          }
          return Comment2;
        }(DataNode)
      );
      exports2.Comment = Comment;
      var ProcessingInstruction = (
        /** @class */
        function(_super) {
          __extends(ProcessingInstruction2, _super);
          function ProcessingInstruction2(name, data) {
            var _this = _super.call(this, domelementtype_1.ElementType.Directive, data) || this;
            _this.name = name;
            return _this;
          }
          return ProcessingInstruction2;
        }(DataNode)
      );
      exports2.ProcessingInstruction = ProcessingInstruction;
      var NodeWithChildren = (
        /** @class */
        function(_super) {
          __extends(NodeWithChildren2, _super);
          function NodeWithChildren2(type, children) {
            var _this = _super.call(this, type) || this;
            _this.children = children;
            return _this;
          }
          Object.defineProperty(NodeWithChildren2.prototype, "firstChild", {
            // Aliases
            /** First child of the node. */
            get: function() {
              var _a2;
              return (_a2 = this.children[0]) !== null && _a2 !== void 0 ? _a2 : null;
            },
            enumerable: false,
            configurable: true
          });
          Object.defineProperty(NodeWithChildren2.prototype, "lastChild", {
            /** Last child of the node. */
            get: function() {
              return this.children.length > 0 ? this.children[this.children.length - 1] : null;
            },
            enumerable: false,
            configurable: true
          });
          Object.defineProperty(NodeWithChildren2.prototype, "childNodes", {
            /**
             * Same as {@link children}.
             * [DOM spec](https://dom.spec.whatwg.org)-compatible alias.
             */
            get: function() {
              return this.children;
            },
            set: function(children) {
              this.children = children;
            },
            enumerable: false,
            configurable: true
          });
          return NodeWithChildren2;
        }(Node)
      );
      exports2.NodeWithChildren = NodeWithChildren;
      var Document = (
        /** @class */
        function(_super) {
          __extends(Document2, _super);
          function Document2(children) {
            return _super.call(this, domelementtype_1.ElementType.Root, children) || this;
          }
          return Document2;
        }(NodeWithChildren)
      );
      exports2.Document = Document;
      var Element = (
        /** @class */
        function(_super) {
          __extends(Element2, _super);
          function Element2(name, attribs, children, type) {
            if (children === void 0) {
              children = [];
            }
            if (type === void 0) {
              type = name === "script" ? domelementtype_1.ElementType.Script : name === "style" ? domelementtype_1.ElementType.Style : domelementtype_1.ElementType.Tag;
            }
            var _this = _super.call(this, type, children) || this;
            _this.name = name;
            _this.attribs = attribs;
            return _this;
          }
          Object.defineProperty(Element2.prototype, "tagName", {
            // DOM Level 1 aliases
            /**
             * Same as {@link name}.
             * [DOM spec](https://dom.spec.whatwg.org)-compatible alias.
             */
            get: function() {
              return this.name;
            },
            set: function(name) {
              this.name = name;
            },
            enumerable: false,
            configurable: true
          });
          Object.defineProperty(Element2.prototype, "attributes", {
            get: function() {
              var _this = this;
              return Object.keys(this.attribs).map(function(name) {
                var _a2, _b2;
                return {
                  name,
                  value: _this.attribs[name],
                  namespace: (_a2 = _this["x-attribsNamespace"]) === null || _a2 === void 0 ? void 0 : _a2[name],
                  prefix: (_b2 = _this["x-attribsPrefix"]) === null || _b2 === void 0 ? void 0 : _b2[name]
                };
              });
            },
            enumerable: false,
            configurable: true
          });
          return Element2;
        }(NodeWithChildren)
      );
      exports2.Element = Element;
      function isTag(node) {
        return (0, domelementtype_1.isTag)(node);
      }
      exports2.isTag = isTag;
      function isCDATA(node) {
        return node.type === domelementtype_1.ElementType.CDATA;
      }
      exports2.isCDATA = isCDATA;
      function isText(node) {
        return node.type === domelementtype_1.ElementType.Text;
      }
      exports2.isText = isText;
      function isComment(node) {
        return node.type === domelementtype_1.ElementType.Comment;
      }
      exports2.isComment = isComment;
      function isDirective(node) {
        return node.type === domelementtype_1.ElementType.Directive;
      }
      exports2.isDirective = isDirective;
      function isDocument(node) {
        return node.type === domelementtype_1.ElementType.Root;
      }
      exports2.isDocument = isDocument;
      function hasChildren(node) {
        return Object.prototype.hasOwnProperty.call(node, "children");
      }
      exports2.hasChildren = hasChildren;
      function cloneNode(node, recursive) {
        if (recursive === void 0) {
          recursive = false;
        }
        var result;
        if (isText(node)) {
          result = new Text(node.data);
        } else if (isComment(node)) {
          result = new Comment(node.data);
        } else if (isTag(node)) {
          var children = recursive ? cloneChildren(node.children) : [];
          var clone_1 = new Element(node.name, __assign({}, node.attribs), children);
          children.forEach(function(child) {
            return child.parent = clone_1;
          });
          if (node.namespace != null) {
            clone_1.namespace = node.namespace;
          }
          if (node["x-attribsNamespace"]) {
            clone_1["x-attribsNamespace"] = __assign({}, node["x-attribsNamespace"]);
          }
          if (node["x-attribsPrefix"]) {
            clone_1["x-attribsPrefix"] = __assign({}, node["x-attribsPrefix"]);
          }
          result = clone_1;
        } else if (isCDATA(node)) {
          var children = recursive ? cloneChildren(node.children) : [];
          var clone_2 = new NodeWithChildren(domelementtype_1.ElementType.CDATA, children);
          children.forEach(function(child) {
            return child.parent = clone_2;
          });
          result = clone_2;
        } else if (isDocument(node)) {
          var children = recursive ? cloneChildren(node.children) : [];
          var clone_3 = new Document(children);
          children.forEach(function(child) {
            return child.parent = clone_3;
          });
          if (node["x-mode"]) {
            clone_3["x-mode"] = node["x-mode"];
          }
          result = clone_3;
        } else if (isDirective(node)) {
          var instruction = new ProcessingInstruction(node.name, node.data);
          if (node["x-name"] != null) {
            instruction["x-name"] = node["x-name"];
            instruction["x-publicId"] = node["x-publicId"];
            instruction["x-systemId"] = node["x-systemId"];
          }
          result = instruction;
        } else {
          throw new Error("Not implemented yet: ".concat(node.type));
        }
        result.startIndex = node.startIndex;
        result.endIndex = node.endIndex;
        if (node.sourceCodeLocation != null) {
          result.sourceCodeLocation = node.sourceCodeLocation;
        }
        return result;
      }
      exports2.cloneNode = cloneNode;
      function cloneChildren(childs) {
        var children = childs.map(function(child) {
          return cloneNode(child, true);
        });
        for (var i = 1; i < children.length; i++) {
          children[i].prev = children[i - 1];
          children[i - 1].next = children[i];
        }
        return children;
      }
    }
  });

  // node_modules/.pnpm/domhandler@4.3.1/node_modules/domhandler/lib/index.js
  var require_lib2 = __commonJS({
    "node_modules/.pnpm/domhandler@4.3.1/node_modules/domhandler/lib/index.js"(exports2) {
      "use strict";
      var __createBinding = exports2 && exports2.__createBinding || (Object.create ? function(o, m, k, k2) {
        if (k2 === void 0)
          k2 = k;
        var desc = Object.getOwnPropertyDescriptor(m, k);
        if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
          desc = { enumerable: true, get: function() {
            return m[k];
          } };
        }
        Object.defineProperty(o, k2, desc);
      } : function(o, m, k, k2) {
        if (k2 === void 0)
          k2 = k;
        o[k2] = m[k];
      });
      var __exportStar = exports2 && exports2.__exportStar || function(m, exports3) {
        for (var p in m)
          if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports3, p))
            __createBinding(exports3, m, p);
      };
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.DomHandler = void 0;
      var domelementtype_1 = require_lib();
      var node_1 = require_node();
      __exportStar(require_node(), exports2);
      var reWhitespace = /\s+/g;
      var defaultOpts = {
        normalizeWhitespace: false,
        withStartIndices: false,
        withEndIndices: false,
        xmlMode: false
      };
      var DomHandler = (
        /** @class */
        function() {
          function DomHandler2(callback, options, elementCB) {
            this.dom = [];
            this.root = new node_1.Document(this.dom);
            this.done = false;
            this.tagStack = [this.root];
            this.lastNode = null;
            this.parser = null;
            if (typeof options === "function") {
              elementCB = options;
              options = defaultOpts;
            }
            if (typeof callback === "object") {
              options = callback;
              callback = void 0;
            }
            this.callback = callback !== null && callback !== void 0 ? callback : null;
            this.options = options !== null && options !== void 0 ? options : defaultOpts;
            this.elementCB = elementCB !== null && elementCB !== void 0 ? elementCB : null;
          }
          DomHandler2.prototype.onparserinit = function(parser) {
            this.parser = parser;
          };
          DomHandler2.prototype.onreset = function() {
            this.dom = [];
            this.root = new node_1.Document(this.dom);
            this.done = false;
            this.tagStack = [this.root];
            this.lastNode = null;
            this.parser = null;
          };
          DomHandler2.prototype.onend = function() {
            if (this.done)
              return;
            this.done = true;
            this.parser = null;
            this.handleCallback(null);
          };
          DomHandler2.prototype.onerror = function(error) {
            this.handleCallback(error);
          };
          DomHandler2.prototype.onclosetag = function() {
            this.lastNode = null;
            var elem = this.tagStack.pop();
            if (this.options.withEndIndices) {
              elem.endIndex = this.parser.endIndex;
            }
            if (this.elementCB)
              this.elementCB(elem);
          };
          DomHandler2.prototype.onopentag = function(name, attribs) {
            var type = this.options.xmlMode ? domelementtype_1.ElementType.Tag : void 0;
            var element = new node_1.Element(name, attribs, void 0, type);
            this.addNode(element);
            this.tagStack.push(element);
          };
          DomHandler2.prototype.ontext = function(data) {
            var normalizeWhitespace = this.options.normalizeWhitespace;
            var lastNode = this.lastNode;
            if (lastNode && lastNode.type === domelementtype_1.ElementType.Text) {
              if (normalizeWhitespace) {
                lastNode.data = (lastNode.data + data).replace(reWhitespace, " ");
              } else {
                lastNode.data += data;
              }
              if (this.options.withEndIndices) {
                lastNode.endIndex = this.parser.endIndex;
              }
            } else {
              if (normalizeWhitespace) {
                data = data.replace(reWhitespace, " ");
              }
              var node = new node_1.Text(data);
              this.addNode(node);
              this.lastNode = node;
            }
          };
          DomHandler2.prototype.oncomment = function(data) {
            if (this.lastNode && this.lastNode.type === domelementtype_1.ElementType.Comment) {
              this.lastNode.data += data;
              return;
            }
            var node = new node_1.Comment(data);
            this.addNode(node);
            this.lastNode = node;
          };
          DomHandler2.prototype.oncommentend = function() {
            this.lastNode = null;
          };
          DomHandler2.prototype.oncdatastart = function() {
            var text = new node_1.Text("");
            var node = new node_1.NodeWithChildren(domelementtype_1.ElementType.CDATA, [text]);
            this.addNode(node);
            text.parent = node;
            this.lastNode = text;
          };
          DomHandler2.prototype.oncdataend = function() {
            this.lastNode = null;
          };
          DomHandler2.prototype.onprocessinginstruction = function(name, data) {
            var node = new node_1.ProcessingInstruction(name, data);
            this.addNode(node);
          };
          DomHandler2.prototype.handleCallback = function(error) {
            if (typeof this.callback === "function") {
              this.callback(error, this.dom);
            } else if (error) {
              throw error;
            }
          };
          DomHandler2.prototype.addNode = function(node) {
            var parent = this.tagStack[this.tagStack.length - 1];
            var previousSibling = parent.children[parent.children.length - 1];
            if (this.options.withStartIndices) {
              node.startIndex = this.parser.startIndex;
            }
            if (this.options.withEndIndices) {
              node.endIndex = this.parser.endIndex;
            }
            parent.children.push(node);
            if (previousSibling) {
              node.prev = previousSibling;
              previousSibling.next = node;
            }
            node.parent = parent;
            this.lastNode = null;
          };
          return DomHandler2;
        }()
      );
      exports2.DomHandler = DomHandler;
      exports2.default = DomHandler;
    }
  });

  // node_modules/.pnpm/entities@2.2.0/node_modules/entities/lib/decode.js
  var require_decode2 = __commonJS({
    "node_modules/.pnpm/entities@2.2.0/node_modules/entities/lib/decode.js"(exports2) {
      "use strict";
      var __importDefault = exports2 && exports2.__importDefault || function(mod) {
        return mod && mod.__esModule ? mod : { "default": mod };
      };
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.decodeHTML = exports2.decodeHTMLStrict = exports2.decodeXML = void 0;
      var entities_json_1 = __importDefault(require_entities());
      var legacy_json_1 = __importDefault(require_legacy());
      var xml_json_1 = __importDefault(require_xml());
      var decode_codepoint_1 = __importDefault(require_decode_codepoint());
      var strictEntityRe = /&(?:[a-zA-Z0-9]+|#[xX][\da-fA-F]+|#\d+);/g;
      exports2.decodeXML = getStrictDecoder(xml_json_1.default);
      exports2.decodeHTMLStrict = getStrictDecoder(entities_json_1.default);
      function getStrictDecoder(map) {
        var replace = getReplacer(map);
        return function(str) {
          return String(str).replace(strictEntityRe, replace);
        };
      }
      var sorter = function(a, b) {
        return a < b ? 1 : -1;
      };
      exports2.decodeHTML = function() {
        var legacy = Object.keys(legacy_json_1.default).sort(sorter);
        var keys = Object.keys(entities_json_1.default).sort(sorter);
        for (var i = 0, j = 0; i < keys.length; i++) {
          if (legacy[j] === keys[i]) {
            keys[i] += ";?";
            j++;
          } else {
            keys[i] += ";";
          }
        }
        var re = new RegExp("&(?:" + keys.join("|") + "|#[xX][\\da-fA-F]+;?|#\\d+;?)", "g");
        var replace = getReplacer(entities_json_1.default);
        function replacer(str) {
          if (str.substr(-1) !== ";")
            str += ";";
          return replace(str);
        }
        return function(str) {
          return String(str).replace(re, replacer);
        };
      }();
      function getReplacer(map) {
        return function replace(str) {
          if (str.charAt(1) === "#") {
            var secondChar = str.charAt(2);
            if (secondChar === "X" || secondChar === "x") {
              return decode_codepoint_1.default(parseInt(str.substr(3), 16));
            }
            return decode_codepoint_1.default(parseInt(str.substr(2), 10));
          }
          return map[str.slice(1, -1)] || str;
        };
      }
    }
  });

  // node_modules/.pnpm/entities@2.2.0/node_modules/entities/lib/encode.js
  var require_encode = __commonJS({
    "node_modules/.pnpm/entities@2.2.0/node_modules/entities/lib/encode.js"(exports2) {
      "use strict";
      var __importDefault = exports2 && exports2.__importDefault || function(mod) {
        return mod && mod.__esModule ? mod : { "default": mod };
      };
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.escapeUTF8 = exports2.escape = exports2.encodeNonAsciiHTML = exports2.encodeHTML = exports2.encodeXML = void 0;
      var xml_json_1 = __importDefault(require_xml());
      var inverseXML = getInverseObj(xml_json_1.default);
      var xmlReplacer = getInverseReplacer(inverseXML);
      exports2.encodeXML = getASCIIEncoder(inverseXML);
      var entities_json_1 = __importDefault(require_entities());
      var inverseHTML = getInverseObj(entities_json_1.default);
      var htmlReplacer = getInverseReplacer(inverseHTML);
      exports2.encodeHTML = getInverse(inverseHTML, htmlReplacer);
      exports2.encodeNonAsciiHTML = getASCIIEncoder(inverseHTML);
      function getInverseObj(obj) {
        return Object.keys(obj).sort().reduce(function(inverse, name) {
          inverse[obj[name]] = "&" + name + ";";
          return inverse;
        }, {});
      }
      function getInverseReplacer(inverse) {
        var single = [];
        var multiple = [];
        for (var _i = 0, _a2 = Object.keys(inverse); _i < _a2.length; _i++) {
          var k = _a2[_i];
          if (k.length === 1) {
            single.push("\\" + k);
          } else {
            multiple.push(k);
          }
        }
        single.sort();
        for (var start = 0; start < single.length - 1; start++) {
          var end = start;
          while (end < single.length - 1 && single[end].charCodeAt(1) + 1 === single[end + 1].charCodeAt(1)) {
            end += 1;
          }
          var count = 1 + end - start;
          if (count < 3)
            continue;
          single.splice(start, count, single[start] + "-" + single[end]);
        }
        multiple.unshift("[" + single.join("") + "]");
        return new RegExp(multiple.join("|"), "g");
      }
      var reNonASCII = /(?:[\x80-\uD7FF\uE000-\uFFFF]|[\uD800-\uDBFF][\uDC00-\uDFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF])/g;
      var getCodePoint = (
        // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition
        String.prototype.codePointAt != null ? (
          // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
          function(str) {
            return str.codePointAt(0);
          }
        ) : (
          // http://mathiasbynens.be/notes/javascript-encoding#surrogate-formulae
          function(c) {
            return (c.charCodeAt(0) - 55296) * 1024 + c.charCodeAt(1) - 56320 + 65536;
          }
        )
      );
      function singleCharReplacer(c) {
        return "&#x" + (c.length > 1 ? getCodePoint(c) : c.charCodeAt(0)).toString(16).toUpperCase() + ";";
      }
      function getInverse(inverse, re) {
        return function(data) {
          return data.replace(re, function(name) {
            return inverse[name];
          }).replace(reNonASCII, singleCharReplacer);
        };
      }
      var reEscapeChars = new RegExp(xmlReplacer.source + "|" + reNonASCII.source, "g");
      function escape(data) {
        return data.replace(reEscapeChars, singleCharReplacer);
      }
      exports2.escape = escape;
      function escapeUTF8(data) {
        return data.replace(xmlReplacer, singleCharReplacer);
      }
      exports2.escapeUTF8 = escapeUTF8;
      function getASCIIEncoder(obj) {
        return function(data) {
          return data.replace(reEscapeChars, function(c) {
            return obj[c] || singleCharReplacer(c);
          });
        };
      }
    }
  });

  // node_modules/.pnpm/entities@2.2.0/node_modules/entities/lib/index.js
  var require_lib3 = __commonJS({
    "node_modules/.pnpm/entities@2.2.0/node_modules/entities/lib/index.js"(exports2) {
      "use strict";
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.decodeXMLStrict = exports2.decodeHTML5Strict = exports2.decodeHTML4Strict = exports2.decodeHTML5 = exports2.decodeHTML4 = exports2.decodeHTMLStrict = exports2.decodeHTML = exports2.decodeXML = exports2.encodeHTML5 = exports2.encodeHTML4 = exports2.escapeUTF8 = exports2.escape = exports2.encodeNonAsciiHTML = exports2.encodeHTML = exports2.encodeXML = exports2.encode = exports2.decodeStrict = exports2.decode = void 0;
      var decode_1 = require_decode2();
      var encode_1 = require_encode();
      function decode(data, level) {
        return (!level || level <= 0 ? decode_1.decodeXML : decode_1.decodeHTML)(data);
      }
      exports2.decode = decode;
      function decodeStrict(data, level) {
        return (!level || level <= 0 ? decode_1.decodeXML : decode_1.decodeHTMLStrict)(data);
      }
      exports2.decodeStrict = decodeStrict;
      function encode(data, level) {
        return (!level || level <= 0 ? encode_1.encodeXML : encode_1.encodeHTML)(data);
      }
      exports2.encode = encode;
      var encode_2 = require_encode();
      Object.defineProperty(exports2, "encodeXML", { enumerable: true, get: function() {
        return encode_2.encodeXML;
      } });
      Object.defineProperty(exports2, "encodeHTML", { enumerable: true, get: function() {
        return encode_2.encodeHTML;
      } });
      Object.defineProperty(exports2, "encodeNonAsciiHTML", { enumerable: true, get: function() {
        return encode_2.encodeNonAsciiHTML;
      } });
      Object.defineProperty(exports2, "escape", { enumerable: true, get: function() {
        return encode_2.escape;
      } });
      Object.defineProperty(exports2, "escapeUTF8", { enumerable: true, get: function() {
        return encode_2.escapeUTF8;
      } });
      Object.defineProperty(exports2, "encodeHTML4", { enumerable: true, get: function() {
        return encode_2.encodeHTML;
      } });
      Object.defineProperty(exports2, "encodeHTML5", { enumerable: true, get: function() {
        return encode_2.encodeHTML;
      } });
      var decode_2 = require_decode2();
      Object.defineProperty(exports2, "decodeXML", { enumerable: true, get: function() {
        return decode_2.decodeXML;
      } });
      Object.defineProperty(exports2, "decodeHTML", { enumerable: true, get: function() {
        return decode_2.decodeHTML;
      } });
      Object.defineProperty(exports2, "decodeHTMLStrict", { enumerable: true, get: function() {
        return decode_2.decodeHTMLStrict;
      } });
      Object.defineProperty(exports2, "decodeHTML4", { enumerable: true, get: function() {
        return decode_2.decodeHTML;
      } });
      Object.defineProperty(exports2, "decodeHTML5", { enumerable: true, get: function() {
        return decode_2.decodeHTML;
      } });
      Object.defineProperty(exports2, "decodeHTML4Strict", { enumerable: true, get: function() {
        return decode_2.decodeHTMLStrict;
      } });
      Object.defineProperty(exports2, "decodeHTML5Strict", { enumerable: true, get: function() {
        return decode_2.decodeHTMLStrict;
      } });
      Object.defineProperty(exports2, "decodeXMLStrict", { enumerable: true, get: function() {
        return decode_2.decodeXML;
      } });
    }
  });

  // node_modules/.pnpm/dom-serializer@1.4.1/node_modules/dom-serializer/lib/foreignNames.js
  var require_foreignNames = __commonJS({
    "node_modules/.pnpm/dom-serializer@1.4.1/node_modules/dom-serializer/lib/foreignNames.js"(exports2) {
      "use strict";
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.attributeNames = exports2.elementNames = void 0;
      exports2.elementNames = /* @__PURE__ */ new Map([
        ["altglyph", "altGlyph"],
        ["altglyphdef", "altGlyphDef"],
        ["altglyphitem", "altGlyphItem"],
        ["animatecolor", "animateColor"],
        ["animatemotion", "animateMotion"],
        ["animatetransform", "animateTransform"],
        ["clippath", "clipPath"],
        ["feblend", "feBlend"],
        ["fecolormatrix", "feColorMatrix"],
        ["fecomponenttransfer", "feComponentTransfer"],
        ["fecomposite", "feComposite"],
        ["feconvolvematrix", "feConvolveMatrix"],
        ["fediffuselighting", "feDiffuseLighting"],
        ["fedisplacementmap", "feDisplacementMap"],
        ["fedistantlight", "feDistantLight"],
        ["fedropshadow", "feDropShadow"],
        ["feflood", "feFlood"],
        ["fefunca", "feFuncA"],
        ["fefuncb", "feFuncB"],
        ["fefuncg", "feFuncG"],
        ["fefuncr", "feFuncR"],
        ["fegaussianblur", "feGaussianBlur"],
        ["feimage", "feImage"],
        ["femerge", "feMerge"],
        ["femergenode", "feMergeNode"],
        ["femorphology", "feMorphology"],
        ["feoffset", "feOffset"],
        ["fepointlight", "fePointLight"],
        ["fespecularlighting", "feSpecularLighting"],
        ["fespotlight", "feSpotLight"],
        ["fetile", "feTile"],
        ["feturbulence", "feTurbulence"],
        ["foreignobject", "foreignObject"],
        ["glyphref", "glyphRef"],
        ["lineargradient", "linearGradient"],
        ["radialgradient", "radialGradient"],
        ["textpath", "textPath"]
      ]);
      exports2.attributeNames = /* @__PURE__ */ new Map([
        ["definitionurl", "definitionURL"],
        ["attributename", "attributeName"],
        ["attributetype", "attributeType"],
        ["basefrequency", "baseFrequency"],
        ["baseprofile", "baseProfile"],
        ["calcmode", "calcMode"],
        ["clippathunits", "clipPathUnits"],
        ["diffuseconstant", "diffuseConstant"],
        ["edgemode", "edgeMode"],
        ["filterunits", "filterUnits"],
        ["glyphref", "glyphRef"],
        ["gradienttransform", "gradientTransform"],
        ["gradientunits", "gradientUnits"],
        ["kernelmatrix", "kernelMatrix"],
        ["kernelunitlength", "kernelUnitLength"],
        ["keypoints", "keyPoints"],
        ["keysplines", "keySplines"],
        ["keytimes", "keyTimes"],
        ["lengthadjust", "lengthAdjust"],
        ["limitingconeangle", "limitingConeAngle"],
        ["markerheight", "markerHeight"],
        ["markerunits", "markerUnits"],
        ["markerwidth", "markerWidth"],
        ["maskcontentunits", "maskContentUnits"],
        ["maskunits", "maskUnits"],
        ["numoctaves", "numOctaves"],
        ["pathlength", "pathLength"],
        ["patterncontentunits", "patternContentUnits"],
        ["patterntransform", "patternTransform"],
        ["patternunits", "patternUnits"],
        ["pointsatx", "pointsAtX"],
        ["pointsaty", "pointsAtY"],
        ["pointsatz", "pointsAtZ"],
        ["preservealpha", "preserveAlpha"],
        ["preserveaspectratio", "preserveAspectRatio"],
        ["primitiveunits", "primitiveUnits"],
        ["refx", "refX"],
        ["refy", "refY"],
        ["repeatcount", "repeatCount"],
        ["repeatdur", "repeatDur"],
        ["requiredextensions", "requiredExtensions"],
        ["requiredfeatures", "requiredFeatures"],
        ["specularconstant", "specularConstant"],
        ["specularexponent", "specularExponent"],
        ["spreadmethod", "spreadMethod"],
        ["startoffset", "startOffset"],
        ["stddeviation", "stdDeviation"],
        ["stitchtiles", "stitchTiles"],
        ["surfacescale", "surfaceScale"],
        ["systemlanguage", "systemLanguage"],
        ["tablevalues", "tableValues"],
        ["targetx", "targetX"],
        ["targety", "targetY"],
        ["textlength", "textLength"],
        ["viewbox", "viewBox"],
        ["viewtarget", "viewTarget"],
        ["xchannelselector", "xChannelSelector"],
        ["ychannelselector", "yChannelSelector"],
        ["zoomandpan", "zoomAndPan"]
      ]);
    }
  });

  // node_modules/.pnpm/dom-serializer@1.4.1/node_modules/dom-serializer/lib/index.js
  var require_lib4 = __commonJS({
    "node_modules/.pnpm/dom-serializer@1.4.1/node_modules/dom-serializer/lib/index.js"(exports2) {
      "use strict";
      var __assign = exports2 && exports2.__assign || function() {
        __assign = Object.assign || function(t) {
          for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s)
              if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
          }
          return t;
        };
        return __assign.apply(this, arguments);
      };
      var __createBinding = exports2 && exports2.__createBinding || (Object.create ? function(o, m, k, k2) {
        if (k2 === void 0)
          k2 = k;
        Object.defineProperty(o, k2, { enumerable: true, get: function() {
          return m[k];
        } });
      } : function(o, m, k, k2) {
        if (k2 === void 0)
          k2 = k;
        o[k2] = m[k];
      });
      var __setModuleDefault = exports2 && exports2.__setModuleDefault || (Object.create ? function(o, v) {
        Object.defineProperty(o, "default", { enumerable: true, value: v });
      } : function(o, v) {
        o["default"] = v;
      });
      var __importStar = exports2 && exports2.__importStar || function(mod) {
        if (mod && mod.__esModule)
          return mod;
        var result = {};
        if (mod != null) {
          for (var k in mod)
            if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
              __createBinding(result, mod, k);
        }
        __setModuleDefault(result, mod);
        return result;
      };
      Object.defineProperty(exports2, "__esModule", { value: true });
      var ElementType = __importStar(require_lib());
      var entities_1 = require_lib3();
      var foreignNames_1 = require_foreignNames();
      var unencodedElements = /* @__PURE__ */ new Set([
        "style",
        "script",
        "xmp",
        "iframe",
        "noembed",
        "noframes",
        "plaintext",
        "noscript"
      ]);
      function formatAttributes(attributes, opts) {
        if (!attributes)
          return;
        return Object.keys(attributes).map(function(key) {
          var _a2, _b2;
          var value = (_a2 = attributes[key]) !== null && _a2 !== void 0 ? _a2 : "";
          if (opts.xmlMode === "foreign") {
            key = (_b2 = foreignNames_1.attributeNames.get(key)) !== null && _b2 !== void 0 ? _b2 : key;
          }
          if (!opts.emptyAttrs && !opts.xmlMode && value === "") {
            return key;
          }
          return key + '="' + (opts.decodeEntities !== false ? entities_1.encodeXML(value) : value.replace(/"/g, "&quot;")) + '"';
        }).join(" ");
      }
      var singleTag = /* @__PURE__ */ new Set([
        "area",
        "base",
        "basefont",
        "br",
        "col",
        "command",
        "embed",
        "frame",
        "hr",
        "img",
        "input",
        "isindex",
        "keygen",
        "link",
        "meta",
        "param",
        "source",
        "track",
        "wbr"
      ]);
      function render(node, options) {
        if (options === void 0) {
          options = {};
        }
        var nodes = "length" in node ? node : [node];
        var output = "";
        for (var i = 0; i < nodes.length; i++) {
          output += renderNode(nodes[i], options);
        }
        return output;
      }
      exports2.default = render;
      function renderNode(node, options) {
        switch (node.type) {
          case ElementType.Root:
            return render(node.children, options);
          case ElementType.Directive:
          case ElementType.Doctype:
            return renderDirective(node);
          case ElementType.Comment:
            return renderComment(node);
          case ElementType.CDATA:
            return renderCdata(node);
          case ElementType.Script:
          case ElementType.Style:
          case ElementType.Tag:
            return renderTag(node, options);
          case ElementType.Text:
            return renderText(node, options);
        }
      }
      var foreignModeIntegrationPoints = /* @__PURE__ */ new Set([
        "mi",
        "mo",
        "mn",
        "ms",
        "mtext",
        "annotation-xml",
        "foreignObject",
        "desc",
        "title"
      ]);
      var foreignElements = /* @__PURE__ */ new Set(["svg", "math"]);
      function renderTag(elem, opts) {
        var _a2;
        if (opts.xmlMode === "foreign") {
          elem.name = (_a2 = foreignNames_1.elementNames.get(elem.name)) !== null && _a2 !== void 0 ? _a2 : elem.name;
          if (elem.parent && foreignModeIntegrationPoints.has(elem.parent.name)) {
            opts = __assign(__assign({}, opts), { xmlMode: false });
          }
        }
        if (!opts.xmlMode && foreignElements.has(elem.name)) {
          opts = __assign(__assign({}, opts), { xmlMode: "foreign" });
        }
        var tag = "<" + elem.name;
        var attribs = formatAttributes(elem.attribs, opts);
        if (attribs) {
          tag += " " + attribs;
        }
        if (elem.children.length === 0 && (opts.xmlMode ? (
          // In XML mode or foreign mode, and user hasn't explicitly turned off self-closing tags
          opts.selfClosingTags !== false
        ) : (
          // User explicitly asked for self-closing tags, even in HTML mode
          opts.selfClosingTags && singleTag.has(elem.name)
        ))) {
          if (!opts.xmlMode)
            tag += " ";
          tag += "/>";
        } else {
          tag += ">";
          if (elem.children.length > 0) {
            tag += render(elem.children, opts);
          }
          if (opts.xmlMode || !singleTag.has(elem.name)) {
            tag += "</" + elem.name + ">";
          }
        }
        return tag;
      }
      function renderDirective(elem) {
        return "<" + elem.data + ">";
      }
      function renderText(elem, opts) {
        var data = elem.data || "";
        if (opts.decodeEntities !== false && !(!opts.xmlMode && elem.parent && unencodedElements.has(elem.parent.name))) {
          data = entities_1.encodeXML(data);
        }
        return data;
      }
      function renderCdata(elem) {
        return "<![CDATA[" + elem.children[0].data + "]]>";
      }
      function renderComment(elem) {
        return "<!--" + elem.data + "-->";
      }
    }
  });

  // node_modules/.pnpm/domutils@2.8.0/node_modules/domutils/lib/stringify.js
  var require_stringify = __commonJS({
    "node_modules/.pnpm/domutils@2.8.0/node_modules/domutils/lib/stringify.js"(exports2) {
      "use strict";
      var __importDefault = exports2 && exports2.__importDefault || function(mod) {
        return mod && mod.__esModule ? mod : { "default": mod };
      };
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.innerText = exports2.textContent = exports2.getText = exports2.getInnerHTML = exports2.getOuterHTML = void 0;
      var domhandler_1 = require_lib2();
      var dom_serializer_1 = __importDefault(require_lib4());
      var domelementtype_1 = require_lib();
      function getOuterHTML(node, options) {
        return (0, dom_serializer_1.default)(node, options);
      }
      exports2.getOuterHTML = getOuterHTML;
      function getInnerHTML(node, options) {
        return (0, domhandler_1.hasChildren)(node) ? node.children.map(function(node2) {
          return getOuterHTML(node2, options);
        }).join("") : "";
      }
      exports2.getInnerHTML = getInnerHTML;
      function getText(node) {
        if (Array.isArray(node))
          return node.map(getText).join("");
        if ((0, domhandler_1.isTag)(node))
          return node.name === "br" ? "\n" : getText(node.children);
        if ((0, domhandler_1.isCDATA)(node))
          return getText(node.children);
        if ((0, domhandler_1.isText)(node))
          return node.data;
        return "";
      }
      exports2.getText = getText;
      function textContent(node) {
        if (Array.isArray(node))
          return node.map(textContent).join("");
        if ((0, domhandler_1.hasChildren)(node) && !(0, domhandler_1.isComment)(node)) {
          return textContent(node.children);
        }
        if ((0, domhandler_1.isText)(node))
          return node.data;
        return "";
      }
      exports2.textContent = textContent;
      function innerText(node) {
        if (Array.isArray(node))
          return node.map(innerText).join("");
        if ((0, domhandler_1.hasChildren)(node) && (node.type === domelementtype_1.ElementType.Tag || (0, domhandler_1.isCDATA)(node))) {
          return innerText(node.children);
        }
        if ((0, domhandler_1.isText)(node))
          return node.data;
        return "";
      }
      exports2.innerText = innerText;
    }
  });

  // node_modules/.pnpm/domutils@2.8.0/node_modules/domutils/lib/traversal.js
  var require_traversal = __commonJS({
    "node_modules/.pnpm/domutils@2.8.0/node_modules/domutils/lib/traversal.js"(exports2) {
      "use strict";
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.prevElementSibling = exports2.nextElementSibling = exports2.getName = exports2.hasAttrib = exports2.getAttributeValue = exports2.getSiblings = exports2.getParent = exports2.getChildren = void 0;
      var domhandler_1 = require_lib2();
      var emptyArray = [];
      function getChildren(elem) {
        var _a2;
        return (_a2 = elem.children) !== null && _a2 !== void 0 ? _a2 : emptyArray;
      }
      exports2.getChildren = getChildren;
      function getParent(elem) {
        return elem.parent || null;
      }
      exports2.getParent = getParent;
      function getSiblings(elem) {
        var _a2, _b2;
        var parent = getParent(elem);
        if (parent != null)
          return getChildren(parent);
        var siblings = [elem];
        var prev = elem.prev, next = elem.next;
        while (prev != null) {
          siblings.unshift(prev);
          _a2 = prev, prev = _a2.prev;
        }
        while (next != null) {
          siblings.push(next);
          _b2 = next, next = _b2.next;
        }
        return siblings;
      }
      exports2.getSiblings = getSiblings;
      function getAttributeValue(elem, name) {
        var _a2;
        return (_a2 = elem.attribs) === null || _a2 === void 0 ? void 0 : _a2[name];
      }
      exports2.getAttributeValue = getAttributeValue;
      function hasAttrib(elem, name) {
        return elem.attribs != null && Object.prototype.hasOwnProperty.call(elem.attribs, name) && elem.attribs[name] != null;
      }
      exports2.hasAttrib = hasAttrib;
      function getName(elem) {
        return elem.name;
      }
      exports2.getName = getName;
      function nextElementSibling(elem) {
        var _a2;
        var next = elem.next;
        while (next !== null && !(0, domhandler_1.isTag)(next))
          _a2 = next, next = _a2.next;
        return next;
      }
      exports2.nextElementSibling = nextElementSibling;
      function prevElementSibling(elem) {
        var _a2;
        var prev = elem.prev;
        while (prev !== null && !(0, domhandler_1.isTag)(prev))
          _a2 = prev, prev = _a2.prev;
        return prev;
      }
      exports2.prevElementSibling = prevElementSibling;
    }
  });

  // node_modules/.pnpm/domutils@2.8.0/node_modules/domutils/lib/manipulation.js
  var require_manipulation = __commonJS({
    "node_modules/.pnpm/domutils@2.8.0/node_modules/domutils/lib/manipulation.js"(exports2) {
      "use strict";
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.prepend = exports2.prependChild = exports2.append = exports2.appendChild = exports2.replaceElement = exports2.removeElement = void 0;
      function removeElement(elem) {
        if (elem.prev)
          elem.prev.next = elem.next;
        if (elem.next)
          elem.next.prev = elem.prev;
        if (elem.parent) {
          var childs = elem.parent.children;
          childs.splice(childs.lastIndexOf(elem), 1);
        }
      }
      exports2.removeElement = removeElement;
      function replaceElement(elem, replacement) {
        var prev = replacement.prev = elem.prev;
        if (prev) {
          prev.next = replacement;
        }
        var next = replacement.next = elem.next;
        if (next) {
          next.prev = replacement;
        }
        var parent = replacement.parent = elem.parent;
        if (parent) {
          var childs = parent.children;
          childs[childs.lastIndexOf(elem)] = replacement;
        }
      }
      exports2.replaceElement = replaceElement;
      function appendChild(elem, child) {
        removeElement(child);
        child.next = null;
        child.parent = elem;
        if (elem.children.push(child) > 1) {
          var sibling = elem.children[elem.children.length - 2];
          sibling.next = child;
          child.prev = sibling;
        } else {
          child.prev = null;
        }
      }
      exports2.appendChild = appendChild;
      function append(elem, next) {
        removeElement(next);
        var parent = elem.parent;
        var currNext = elem.next;
        next.next = currNext;
        next.prev = elem;
        elem.next = next;
        next.parent = parent;
        if (currNext) {
          currNext.prev = next;
          if (parent) {
            var childs = parent.children;
            childs.splice(childs.lastIndexOf(currNext), 0, next);
          }
        } else if (parent) {
          parent.children.push(next);
        }
      }
      exports2.append = append;
      function prependChild(elem, child) {
        removeElement(child);
        child.parent = elem;
        child.prev = null;
        if (elem.children.unshift(child) !== 1) {
          var sibling = elem.children[1];
          sibling.prev = child;
          child.next = sibling;
        } else {
          child.next = null;
        }
      }
      exports2.prependChild = prependChild;
      function prepend(elem, prev) {
        removeElement(prev);
        var parent = elem.parent;
        if (parent) {
          var childs = parent.children;
          childs.splice(childs.indexOf(elem), 0, prev);
        }
        if (elem.prev) {
          elem.prev.next = prev;
        }
        prev.parent = parent;
        prev.prev = elem.prev;
        prev.next = elem;
        elem.prev = prev;
      }
      exports2.prepend = prepend;
    }
  });

  // node_modules/.pnpm/domutils@2.8.0/node_modules/domutils/lib/querying.js
  var require_querying = __commonJS({
    "node_modules/.pnpm/domutils@2.8.0/node_modules/domutils/lib/querying.js"(exports2) {
      "use strict";
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.findAll = exports2.existsOne = exports2.findOne = exports2.findOneChild = exports2.find = exports2.filter = void 0;
      var domhandler_1 = require_lib2();
      function filter(test, node, recurse, limit) {
        if (recurse === void 0) {
          recurse = true;
        }
        if (limit === void 0) {
          limit = Infinity;
        }
        if (!Array.isArray(node))
          node = [node];
        return find(test, node, recurse, limit);
      }
      exports2.filter = filter;
      function find(test, nodes, recurse, limit) {
        var result = [];
        for (var _i = 0, nodes_1 = nodes; _i < nodes_1.length; _i++) {
          var elem = nodes_1[_i];
          if (test(elem)) {
            result.push(elem);
            if (--limit <= 0)
              break;
          }
          if (recurse && (0, domhandler_1.hasChildren)(elem) && elem.children.length > 0) {
            var children = find(test, elem.children, recurse, limit);
            result.push.apply(result, children);
            limit -= children.length;
            if (limit <= 0)
              break;
          }
        }
        return result;
      }
      exports2.find = find;
      function findOneChild(test, nodes) {
        return nodes.find(test);
      }
      exports2.findOneChild = findOneChild;
      function findOne(test, nodes, recurse) {
        if (recurse === void 0) {
          recurse = true;
        }
        var elem = null;
        for (var i = 0; i < nodes.length && !elem; i++) {
          var checked = nodes[i];
          if (!(0, domhandler_1.isTag)(checked)) {
            continue;
          } else if (test(checked)) {
            elem = checked;
          } else if (recurse && checked.children.length > 0) {
            elem = findOne(test, checked.children);
          }
        }
        return elem;
      }
      exports2.findOne = findOne;
      function existsOne(test, nodes) {
        return nodes.some(function(checked) {
          return (0, domhandler_1.isTag)(checked) && (test(checked) || checked.children.length > 0 && existsOne(test, checked.children));
        });
      }
      exports2.existsOne = existsOne;
      function findAll(test, nodes) {
        var _a2;
        var result = [];
        var stack = nodes.filter(domhandler_1.isTag);
        var elem;
        while (elem = stack.shift()) {
          var children = (_a2 = elem.children) === null || _a2 === void 0 ? void 0 : _a2.filter(domhandler_1.isTag);
          if (children && children.length > 0) {
            stack.unshift.apply(stack, children);
          }
          if (test(elem))
            result.push(elem);
        }
        return result;
      }
      exports2.findAll = findAll;
    }
  });

  // node_modules/.pnpm/domutils@2.8.0/node_modules/domutils/lib/legacy.js
  var require_legacy2 = __commonJS({
    "node_modules/.pnpm/domutils@2.8.0/node_modules/domutils/lib/legacy.js"(exports2) {
      "use strict";
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.getElementsByTagType = exports2.getElementsByTagName = exports2.getElementById = exports2.getElements = exports2.testElement = void 0;
      var domhandler_1 = require_lib2();
      var querying_1 = require_querying();
      var Checks = {
        tag_name: function(name) {
          if (typeof name === "function") {
            return function(elem) {
              return (0, domhandler_1.isTag)(elem) && name(elem.name);
            };
          } else if (name === "*") {
            return domhandler_1.isTag;
          }
          return function(elem) {
            return (0, domhandler_1.isTag)(elem) && elem.name === name;
          };
        },
        tag_type: function(type) {
          if (typeof type === "function") {
            return function(elem) {
              return type(elem.type);
            };
          }
          return function(elem) {
            return elem.type === type;
          };
        },
        tag_contains: function(data) {
          if (typeof data === "function") {
            return function(elem) {
              return (0, domhandler_1.isText)(elem) && data(elem.data);
            };
          }
          return function(elem) {
            return (0, domhandler_1.isText)(elem) && elem.data === data;
          };
        }
      };
      function getAttribCheck(attrib, value) {
        if (typeof value === "function") {
          return function(elem) {
            return (0, domhandler_1.isTag)(elem) && value(elem.attribs[attrib]);
          };
        }
        return function(elem) {
          return (0, domhandler_1.isTag)(elem) && elem.attribs[attrib] === value;
        };
      }
      function combineFuncs(a, b) {
        return function(elem) {
          return a(elem) || b(elem);
        };
      }
      function compileTest(options) {
        var funcs = Object.keys(options).map(function(key) {
          var value = options[key];
          return Object.prototype.hasOwnProperty.call(Checks, key) ? Checks[key](value) : getAttribCheck(key, value);
        });
        return funcs.length === 0 ? null : funcs.reduce(combineFuncs);
      }
      function testElement(options, node) {
        var test = compileTest(options);
        return test ? test(node) : true;
      }
      exports2.testElement = testElement;
      function getElements(options, nodes, recurse, limit) {
        if (limit === void 0) {
          limit = Infinity;
        }
        var test = compileTest(options);
        return test ? (0, querying_1.filter)(test, nodes, recurse, limit) : [];
      }
      exports2.getElements = getElements;
      function getElementById(id, nodes, recurse) {
        if (recurse === void 0) {
          recurse = true;
        }
        if (!Array.isArray(nodes))
          nodes = [nodes];
        return (0, querying_1.findOne)(getAttribCheck("id", id), nodes, recurse);
      }
      exports2.getElementById = getElementById;
      function getElementsByTagName(tagName, nodes, recurse, limit) {
        if (recurse === void 0) {
          recurse = true;
        }
        if (limit === void 0) {
          limit = Infinity;
        }
        return (0, querying_1.filter)(Checks.tag_name(tagName), nodes, recurse, limit);
      }
      exports2.getElementsByTagName = getElementsByTagName;
      function getElementsByTagType(type, nodes, recurse, limit) {
        if (recurse === void 0) {
          recurse = true;
        }
        if (limit === void 0) {
          limit = Infinity;
        }
        return (0, querying_1.filter)(Checks.tag_type(type), nodes, recurse, limit);
      }
      exports2.getElementsByTagType = getElementsByTagType;
    }
  });

  // node_modules/.pnpm/domutils@2.8.0/node_modules/domutils/lib/helpers.js
  var require_helpers = __commonJS({
    "node_modules/.pnpm/domutils@2.8.0/node_modules/domutils/lib/helpers.js"(exports2) {
      "use strict";
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.uniqueSort = exports2.compareDocumentPosition = exports2.removeSubsets = void 0;
      var domhandler_1 = require_lib2();
      function removeSubsets(nodes) {
        var idx = nodes.length;
        while (--idx >= 0) {
          var node = nodes[idx];
          if (idx > 0 && nodes.lastIndexOf(node, idx - 1) >= 0) {
            nodes.splice(idx, 1);
            continue;
          }
          for (var ancestor = node.parent; ancestor; ancestor = ancestor.parent) {
            if (nodes.includes(ancestor)) {
              nodes.splice(idx, 1);
              break;
            }
          }
        }
        return nodes;
      }
      exports2.removeSubsets = removeSubsets;
      function compareDocumentPosition(nodeA, nodeB) {
        var aParents = [];
        var bParents = [];
        if (nodeA === nodeB) {
          return 0;
        }
        var current = (0, domhandler_1.hasChildren)(nodeA) ? nodeA : nodeA.parent;
        while (current) {
          aParents.unshift(current);
          current = current.parent;
        }
        current = (0, domhandler_1.hasChildren)(nodeB) ? nodeB : nodeB.parent;
        while (current) {
          bParents.unshift(current);
          current = current.parent;
        }
        var maxIdx = Math.min(aParents.length, bParents.length);
        var idx = 0;
        while (idx < maxIdx && aParents[idx] === bParents[idx]) {
          idx++;
        }
        if (idx === 0) {
          return 1;
        }
        var sharedParent = aParents[idx - 1];
        var siblings = sharedParent.children;
        var aSibling = aParents[idx];
        var bSibling = bParents[idx];
        if (siblings.indexOf(aSibling) > siblings.indexOf(bSibling)) {
          if (sharedParent === nodeB) {
            return 4 | 16;
          }
          return 4;
        }
        if (sharedParent === nodeA) {
          return 2 | 8;
        }
        return 2;
      }
      exports2.compareDocumentPosition = compareDocumentPosition;
      function uniqueSort(nodes) {
        nodes = nodes.filter(function(node, i, arr) {
          return !arr.includes(node, i + 1);
        });
        nodes.sort(function(a, b) {
          var relative = compareDocumentPosition(a, b);
          if (relative & 2) {
            return -1;
          } else if (relative & 4) {
            return 1;
          }
          return 0;
        });
        return nodes;
      }
      exports2.uniqueSort = uniqueSort;
    }
  });

  // node_modules/.pnpm/domutils@2.8.0/node_modules/domutils/lib/feeds.js
  var require_feeds = __commonJS({
    "node_modules/.pnpm/domutils@2.8.0/node_modules/domutils/lib/feeds.js"(exports2) {
      "use strict";
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.getFeed = void 0;
      var stringify_1 = require_stringify();
      var legacy_1 = require_legacy2();
      function getFeed(doc) {
        var feedRoot = getOneElement(isValidFeed, doc);
        return !feedRoot ? null : feedRoot.name === "feed" ? getAtomFeed(feedRoot) : getRssFeed(feedRoot);
      }
      exports2.getFeed = getFeed;
      function getAtomFeed(feedRoot) {
        var _a2;
        var childs = feedRoot.children;
        var feed = {
          type: "atom",
          items: (0, legacy_1.getElementsByTagName)("entry", childs).map(function(item) {
            var _a3;
            var children = item.children;
            var entry = { media: getMediaElements(children) };
            addConditionally(entry, "id", "id", children);
            addConditionally(entry, "title", "title", children);
            var href2 = (_a3 = getOneElement("link", children)) === null || _a3 === void 0 ? void 0 : _a3.attribs.href;
            if (href2) {
              entry.link = href2;
            }
            var description = fetch2("summary", children) || fetch2("content", children);
            if (description) {
              entry.description = description;
            }
            var pubDate = fetch2("updated", children);
            if (pubDate) {
              entry.pubDate = new Date(pubDate);
            }
            return entry;
          })
        };
        addConditionally(feed, "id", "id", childs);
        addConditionally(feed, "title", "title", childs);
        var href = (_a2 = getOneElement("link", childs)) === null || _a2 === void 0 ? void 0 : _a2.attribs.href;
        if (href) {
          feed.link = href;
        }
        addConditionally(feed, "description", "subtitle", childs);
        var updated = fetch2("updated", childs);
        if (updated) {
          feed.updated = new Date(updated);
        }
        addConditionally(feed, "author", "email", childs, true);
        return feed;
      }
      function getRssFeed(feedRoot) {
        var _a2, _b2;
        var childs = (_b2 = (_a2 = getOneElement("channel", feedRoot.children)) === null || _a2 === void 0 ? void 0 : _a2.children) !== null && _b2 !== void 0 ? _b2 : [];
        var feed = {
          type: feedRoot.name.substr(0, 3),
          id: "",
          items: (0, legacy_1.getElementsByTagName)("item", feedRoot.children).map(function(item) {
            var children = item.children;
            var entry = { media: getMediaElements(children) };
            addConditionally(entry, "id", "guid", children);
            addConditionally(entry, "title", "title", children);
            addConditionally(entry, "link", "link", children);
            addConditionally(entry, "description", "description", children);
            var pubDate = fetch2("pubDate", children);
            if (pubDate)
              entry.pubDate = new Date(pubDate);
            return entry;
          })
        };
        addConditionally(feed, "title", "title", childs);
        addConditionally(feed, "link", "link", childs);
        addConditionally(feed, "description", "description", childs);
        var updated = fetch2("lastBuildDate", childs);
        if (updated) {
          feed.updated = new Date(updated);
        }
        addConditionally(feed, "author", "managingEditor", childs, true);
        return feed;
      }
      var MEDIA_KEYS_STRING = ["url", "type", "lang"];
      var MEDIA_KEYS_INT = [
        "fileSize",
        "bitrate",
        "framerate",
        "samplingrate",
        "channels",
        "duration",
        "height",
        "width"
      ];
      function getMediaElements(where) {
        return (0, legacy_1.getElementsByTagName)("media:content", where).map(function(elem) {
          var attribs = elem.attribs;
          var media = {
            medium: attribs.medium,
            isDefault: !!attribs.isDefault
          };
          for (var _i = 0, MEDIA_KEYS_STRING_1 = MEDIA_KEYS_STRING; _i < MEDIA_KEYS_STRING_1.length; _i++) {
            var attrib = MEDIA_KEYS_STRING_1[_i];
            if (attribs[attrib]) {
              media[attrib] = attribs[attrib];
            }
          }
          for (var _a2 = 0, MEDIA_KEYS_INT_1 = MEDIA_KEYS_INT; _a2 < MEDIA_KEYS_INT_1.length; _a2++) {
            var attrib = MEDIA_KEYS_INT_1[_a2];
            if (attribs[attrib]) {
              media[attrib] = parseInt(attribs[attrib], 10);
            }
          }
          if (attribs.expression) {
            media.expression = attribs.expression;
          }
          return media;
        });
      }
      function getOneElement(tagName, node) {
        return (0, legacy_1.getElementsByTagName)(tagName, node, true, 1)[0];
      }
      function fetch2(tagName, where, recurse) {
        if (recurse === void 0) {
          recurse = false;
        }
        return (0, stringify_1.textContent)((0, legacy_1.getElementsByTagName)(tagName, where, recurse, 1)).trim();
      }
      function addConditionally(obj, prop, tagName, where, recurse) {
        if (recurse === void 0) {
          recurse = false;
        }
        var val = fetch2(tagName, where, recurse);
        if (val)
          obj[prop] = val;
      }
      function isValidFeed(value) {
        return value === "rss" || value === "feed" || value === "rdf:RDF";
      }
    }
  });

  // node_modules/.pnpm/domutils@2.8.0/node_modules/domutils/lib/index.js
  var require_lib5 = __commonJS({
    "node_modules/.pnpm/domutils@2.8.0/node_modules/domutils/lib/index.js"(exports2) {
      "use strict";
      var __createBinding = exports2 && exports2.__createBinding || (Object.create ? function(o, m, k, k2) {
        if (k2 === void 0)
          k2 = k;
        Object.defineProperty(o, k2, { enumerable: true, get: function() {
          return m[k];
        } });
      } : function(o, m, k, k2) {
        if (k2 === void 0)
          k2 = k;
        o[k2] = m[k];
      });
      var __exportStar = exports2 && exports2.__exportStar || function(m, exports3) {
        for (var p in m)
          if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports3, p))
            __createBinding(exports3, m, p);
      };
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.hasChildren = exports2.isDocument = exports2.isComment = exports2.isText = exports2.isCDATA = exports2.isTag = void 0;
      __exportStar(require_stringify(), exports2);
      __exportStar(require_traversal(), exports2);
      __exportStar(require_manipulation(), exports2);
      __exportStar(require_querying(), exports2);
      __exportStar(require_legacy2(), exports2);
      __exportStar(require_helpers(), exports2);
      __exportStar(require_feeds(), exports2);
      var domhandler_1 = require_lib2();
      Object.defineProperty(exports2, "isTag", { enumerable: true, get: function() {
        return domhandler_1.isTag;
      } });
      Object.defineProperty(exports2, "isCDATA", { enumerable: true, get: function() {
        return domhandler_1.isCDATA;
      } });
      Object.defineProperty(exports2, "isText", { enumerable: true, get: function() {
        return domhandler_1.isText;
      } });
      Object.defineProperty(exports2, "isComment", { enumerable: true, get: function() {
        return domhandler_1.isComment;
      } });
      Object.defineProperty(exports2, "isDocument", { enumerable: true, get: function() {
        return domhandler_1.isDocument;
      } });
      Object.defineProperty(exports2, "hasChildren", { enumerable: true, get: function() {
        return domhandler_1.hasChildren;
      } });
    }
  });

  // node_modules/.pnpm/htmlparser2@6.1.0/node_modules/htmlparser2/lib/FeedHandler.js
  var require_FeedHandler = __commonJS({
    "node_modules/.pnpm/htmlparser2@6.1.0/node_modules/htmlparser2/lib/FeedHandler.js"(exports2) {
      "use strict";
      var __extends = exports2 && exports2.__extends || function() {
        var extendStatics = function(d, b) {
          extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b3) {
            d2.__proto__ = b3;
          } || function(d2, b3) {
            for (var p in b3)
              if (Object.prototype.hasOwnProperty.call(b3, p))
                d2[p] = b3[p];
          };
          return extendStatics(d, b);
        };
        return function(d, b) {
          if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
          extendStatics(d, b);
          function __() {
            this.constructor = d;
          }
          d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
        };
      }();
      var __createBinding = exports2 && exports2.__createBinding || (Object.create ? function(o, m, k, k2) {
        if (k2 === void 0)
          k2 = k;
        Object.defineProperty(o, k2, { enumerable: true, get: function() {
          return m[k];
        } });
      } : function(o, m, k, k2) {
        if (k2 === void 0)
          k2 = k;
        o[k2] = m[k];
      });
      var __setModuleDefault = exports2 && exports2.__setModuleDefault || (Object.create ? function(o, v) {
        Object.defineProperty(o, "default", { enumerable: true, value: v });
      } : function(o, v) {
        o["default"] = v;
      });
      var __importStar = exports2 && exports2.__importStar || function(mod) {
        if (mod && mod.__esModule)
          return mod;
        var result = {};
        if (mod != null) {
          for (var k in mod)
            if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
              __createBinding(result, mod, k);
        }
        __setModuleDefault(result, mod);
        return result;
      };
      var __importDefault = exports2 && exports2.__importDefault || function(mod) {
        return mod && mod.__esModule ? mod : { "default": mod };
      };
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.parseFeed = exports2.FeedHandler = void 0;
      var domhandler_1 = __importDefault(require_lib2());
      var DomUtils = __importStar(require_lib5());
      var Parser_1 = require_Parser();
      var FeedItemMediaMedium;
      (function(FeedItemMediaMedium2) {
        FeedItemMediaMedium2[FeedItemMediaMedium2["image"] = 0] = "image";
        FeedItemMediaMedium2[FeedItemMediaMedium2["audio"] = 1] = "audio";
        FeedItemMediaMedium2[FeedItemMediaMedium2["video"] = 2] = "video";
        FeedItemMediaMedium2[FeedItemMediaMedium2["document"] = 3] = "document";
        FeedItemMediaMedium2[FeedItemMediaMedium2["executable"] = 4] = "executable";
      })(FeedItemMediaMedium || (FeedItemMediaMedium = {}));
      var FeedItemMediaExpression;
      (function(FeedItemMediaExpression2) {
        FeedItemMediaExpression2[FeedItemMediaExpression2["sample"] = 0] = "sample";
        FeedItemMediaExpression2[FeedItemMediaExpression2["full"] = 1] = "full";
        FeedItemMediaExpression2[FeedItemMediaExpression2["nonstop"] = 2] = "nonstop";
      })(FeedItemMediaExpression || (FeedItemMediaExpression = {}));
      var FeedHandler = (
        /** @class */
        function(_super) {
          __extends(FeedHandler2, _super);
          function FeedHandler2(callback, options) {
            var _this = this;
            if (typeof callback === "object") {
              callback = void 0;
              options = callback;
            }
            _this = _super.call(this, callback, options) || this;
            return _this;
          }
          FeedHandler2.prototype.onend = function() {
            var _a2, _b2;
            var feedRoot = getOneElement(isValidFeed, this.dom);
            if (!feedRoot) {
              this.handleCallback(new Error("couldn't find root of feed"));
              return;
            }
            var feed = {};
            if (feedRoot.name === "feed") {
              var childs = feedRoot.children;
              feed.type = "atom";
              addConditionally(feed, "id", "id", childs);
              addConditionally(feed, "title", "title", childs);
              var href = getAttribute("href", getOneElement("link", childs));
              if (href) {
                feed.link = href;
              }
              addConditionally(feed, "description", "subtitle", childs);
              var updated = fetch2("updated", childs);
              if (updated) {
                feed.updated = new Date(updated);
              }
              addConditionally(feed, "author", "email", childs, true);
              feed.items = getElements("entry", childs).map(function(item) {
                var entry = {};
                var children = item.children;
                addConditionally(entry, "id", "id", children);
                addConditionally(entry, "title", "title", children);
                var href2 = getAttribute("href", getOneElement("link", children));
                if (href2) {
                  entry.link = href2;
                }
                var description = fetch2("summary", children) || fetch2("content", children);
                if (description) {
                  entry.description = description;
                }
                var pubDate = fetch2("updated", children);
                if (pubDate) {
                  entry.pubDate = new Date(pubDate);
                }
                entry.media = getMediaElements(children);
                return entry;
              });
            } else {
              var childs = (_b2 = (_a2 = getOneElement("channel", feedRoot.children)) === null || _a2 === void 0 ? void 0 : _a2.children) !== null && _b2 !== void 0 ? _b2 : [];
              feed.type = feedRoot.name.substr(0, 3);
              feed.id = "";
              addConditionally(feed, "title", "title", childs);
              addConditionally(feed, "link", "link", childs);
              addConditionally(feed, "description", "description", childs);
              var updated = fetch2("lastBuildDate", childs);
              if (updated) {
                feed.updated = new Date(updated);
              }
              addConditionally(feed, "author", "managingEditor", childs, true);
              feed.items = getElements("item", feedRoot.children).map(function(item) {
                var entry = {};
                var children = item.children;
                addConditionally(entry, "id", "guid", children);
                addConditionally(entry, "title", "title", children);
                addConditionally(entry, "link", "link", children);
                addConditionally(entry, "description", "description", children);
                var pubDate = fetch2("pubDate", children);
                if (pubDate)
                  entry.pubDate = new Date(pubDate);
                entry.media = getMediaElements(children);
                return entry;
              });
            }
            this.feed = feed;
            this.handleCallback(null);
          };
          return FeedHandler2;
        }(domhandler_1.default)
      );
      exports2.FeedHandler = FeedHandler;
      function getMediaElements(where) {
        return getElements("media:content", where).map(function(elem) {
          var media = {
            medium: elem.attribs.medium,
            isDefault: !!elem.attribs.isDefault
          };
          if (elem.attribs.url) {
            media.url = elem.attribs.url;
          }
          if (elem.attribs.fileSize) {
            media.fileSize = parseInt(elem.attribs.fileSize, 10);
          }
          if (elem.attribs.type) {
            media.type = elem.attribs.type;
          }
          if (elem.attribs.expression) {
            media.expression = elem.attribs.expression;
          }
          if (elem.attribs.bitrate) {
            media.bitrate = parseInt(elem.attribs.bitrate, 10);
          }
          if (elem.attribs.framerate) {
            media.framerate = parseInt(elem.attribs.framerate, 10);
          }
          if (elem.attribs.samplingrate) {
            media.samplingrate = parseInt(elem.attribs.samplingrate, 10);
          }
          if (elem.attribs.channels) {
            media.channels = parseInt(elem.attribs.channels, 10);
          }
          if (elem.attribs.duration) {
            media.duration = parseInt(elem.attribs.duration, 10);
          }
          if (elem.attribs.height) {
            media.height = parseInt(elem.attribs.height, 10);
          }
          if (elem.attribs.width) {
            media.width = parseInt(elem.attribs.width, 10);
          }
          if (elem.attribs.lang) {
            media.lang = elem.attribs.lang;
          }
          return media;
        });
      }
      function getElements(tagName, where) {
        return DomUtils.getElementsByTagName(tagName, where, true);
      }
      function getOneElement(tagName, node) {
        return DomUtils.getElementsByTagName(tagName, node, true, 1)[0];
      }
      function fetch2(tagName, where, recurse) {
        if (recurse === void 0) {
          recurse = false;
        }
        return DomUtils.getText(DomUtils.getElementsByTagName(tagName, where, recurse, 1)).trim();
      }
      function getAttribute(name, elem) {
        if (!elem) {
          return null;
        }
        var attribs = elem.attribs;
        return attribs[name];
      }
      function addConditionally(obj, prop, what, where, recurse) {
        if (recurse === void 0) {
          recurse = false;
        }
        var tmp = fetch2(what, where, recurse);
        if (tmp)
          obj[prop] = tmp;
      }
      function isValidFeed(value) {
        return value === "rss" || value === "feed" || value === "rdf:RDF";
      }
      function parseFeed(feed, options) {
        if (options === void 0) {
          options = { xmlMode: true };
        }
        var handler = new FeedHandler(options);
        new Parser_1.Parser(handler, options).end(feed);
        return handler.feed;
      }
      exports2.parseFeed = parseFeed;
    }
  });

  // node_modules/.pnpm/htmlparser2@6.1.0/node_modules/htmlparser2/lib/index.js
  var require_lib6 = __commonJS({
    "node_modules/.pnpm/htmlparser2@6.1.0/node_modules/htmlparser2/lib/index.js"(exports2) {
      "use strict";
      var __createBinding = exports2 && exports2.__createBinding || (Object.create ? function(o, m, k, k2) {
        if (k2 === void 0)
          k2 = k;
        Object.defineProperty(o, k2, { enumerable: true, get: function() {
          return m[k];
        } });
      } : function(o, m, k, k2) {
        if (k2 === void 0)
          k2 = k;
        o[k2] = m[k];
      });
      var __setModuleDefault = exports2 && exports2.__setModuleDefault || (Object.create ? function(o, v) {
        Object.defineProperty(o, "default", { enumerable: true, value: v });
      } : function(o, v) {
        o["default"] = v;
      });
      var __importStar = exports2 && exports2.__importStar || function(mod) {
        if (mod && mod.__esModule)
          return mod;
        var result = {};
        if (mod != null) {
          for (var k in mod)
            if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
              __createBinding(result, mod, k);
        }
        __setModuleDefault(result, mod);
        return result;
      };
      var __exportStar = exports2 && exports2.__exportStar || function(m, exports3) {
        for (var p in m)
          if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports3, p))
            __createBinding(exports3, m, p);
      };
      var __importDefault = exports2 && exports2.__importDefault || function(mod) {
        return mod && mod.__esModule ? mod : { "default": mod };
      };
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.RssHandler = exports2.DefaultHandler = exports2.DomUtils = exports2.ElementType = exports2.Tokenizer = exports2.createDomStream = exports2.parseDOM = exports2.parseDocument = exports2.DomHandler = exports2.Parser = void 0;
      var Parser_1 = require_Parser();
      Object.defineProperty(exports2, "Parser", { enumerable: true, get: function() {
        return Parser_1.Parser;
      } });
      var domhandler_1 = require_lib2();
      Object.defineProperty(exports2, "DomHandler", { enumerable: true, get: function() {
        return domhandler_1.DomHandler;
      } });
      Object.defineProperty(exports2, "DefaultHandler", { enumerable: true, get: function() {
        return domhandler_1.DomHandler;
      } });
      function parseDocument(data, options) {
        var handler = new domhandler_1.DomHandler(void 0, options);
        new Parser_1.Parser(handler, options).end(data);
        return handler.root;
      }
      exports2.parseDocument = parseDocument;
      function parseDOM(data, options) {
        return parseDocument(data, options).children;
      }
      exports2.parseDOM = parseDOM;
      function createDomStream(cb, options, elementCb) {
        var handler = new domhandler_1.DomHandler(cb, options, elementCb);
        return new Parser_1.Parser(handler, options);
      }
      exports2.createDomStream = createDomStream;
      var Tokenizer_1 = require_Tokenizer();
      Object.defineProperty(exports2, "Tokenizer", { enumerable: true, get: function() {
        return __importDefault(Tokenizer_1).default;
      } });
      var ElementType = __importStar(require_lib());
      exports2.ElementType = ElementType;
      __exportStar(require_FeedHandler(), exports2);
      exports2.DomUtils = __importStar(require_lib5());
      var FeedHandler_1 = require_FeedHandler();
      Object.defineProperty(exports2, "RssHandler", { enumerable: true, get: function() {
        return FeedHandler_1.FeedHandler;
      } });
    }
  });

  // node_modules/.pnpm/utila@0.4.0/node_modules/utila/lib/array.js
  var require_array = __commonJS({
    "node_modules/.pnpm/utila@0.4.0/node_modules/utila/lib/array.js"(exports2, module2) {
      var array;
      module2.exports = array = {
        /*
        	Tries to turn anything into an array.
        */
        from: function(r) {
          return Array.prototype.slice.call(r);
        },
        /*
        	Clone of an array. Properties will be shallow copies.
        */
        simpleClone: function(a) {
          return a.slice(0);
        },
        shallowEqual: function(a1, a2) {
          var i, val, _i, _len;
          if (!(Array.isArray(a1) && Array.isArray(a2) && a1.length === a2.length)) {
            return false;
          }
          for (i = _i = 0, _len = a1.length; _i < _len; i = ++_i) {
            val = a1[i];
            if (a2[i] !== val) {
              return false;
            }
          }
          return true;
        },
        pluck: function(a, i) {
          var index, value, _i, _len;
          if (a.length < 1) {
            return a;
          }
          for (index = _i = 0, _len = a.length; _i < _len; index = ++_i) {
            value = a[index];
            if (index > i) {
              a[index - 1] = a[index];
            }
          }
          a.length = a.length - 1;
          return a;
        },
        pluckItem: function(a, item) {
          var index, removed, value, _i, _len;
          if (a.length < 1) {
            return a;
          }
          removed = 0;
          for (index = _i = 0, _len = a.length; _i < _len; index = ++_i) {
            value = a[index];
            if (value === item) {
              removed++;
              continue;
            }
            if (removed !== 0) {
              a[index - removed] = a[index];
            }
          }
          if (removed > 0) {
            a.length = a.length - removed;
          }
          return a;
        },
        pluckOneItem: function(a, item) {
          var index, reached, value, _i, _len;
          if (a.length < 1) {
            return a;
          }
          reached = false;
          for (index = _i = 0, _len = a.length; _i < _len; index = ++_i) {
            value = a[index];
            if (!reached) {
              if (value === item) {
                reached = true;
                continue;
              }
            } else {
              a[index - 1] = a[index];
            }
          }
          if (reached) {
            a.length = a.length - 1;
          }
          return a;
        },
        pluckByCallback: function(a, cb) {
          var index, removed, value, _i, _len;
          if (a.length < 1) {
            return a;
          }
          removed = 0;
          for (index = _i = 0, _len = a.length; _i < _len; index = ++_i) {
            value = a[index];
            if (cb(value, index)) {
              removed++;
              continue;
            }
            if (removed !== 0) {
              a[index - removed] = a[index];
            }
          }
          if (removed > 0) {
            a.length = a.length - removed;
          }
          return a;
        },
        pluckMultiple: function(array2, indexesToRemove) {
          var i, removedSoFar, _i, _len;
          if (array2.length < 1) {
            return array2;
          }
          removedSoFar = 0;
          indexesToRemove.sort();
          for (_i = 0, _len = indexesToRemove.length; _i < _len; _i++) {
            i = indexesToRemove[_i];
            this.pluck(array2, i - removedSoFar);
            removedSoFar++;
          }
          return array2;
        },
        injectByCallback: function(a, toInject, shouldInject) {
          var i, len, val, valA, valB, _i, _len;
          valA = null;
          valB = null;
          len = a.length;
          if (len < 1) {
            a.push(toInject);
            return a;
          }
          for (i = _i = 0, _len = a.length; _i < _len; i = ++_i) {
            val = a[i];
            valA = valB;
            valB = val;
            if (shouldInject(valA, valB, toInject)) {
              return a.splice(i, 0, toInject);
            }
          }
          a.push(toInject);
          return a;
        },
        injectInIndex: function(a, index, toInject) {
          var i, len, toPut, toPutNext;
          len = a.length;
          i = index;
          if (len < 1) {
            a.push(toInject);
            return a;
          }
          toPut = toInject;
          toPutNext = null;
          for (; i <= len; i++) {
            toPutNext = a[i];
            a[i] = toPut;
            toPut = toPutNext;
          }
          ;
          return null;
        }
      };
    }
  });

  // node_modules/.pnpm/utila@0.4.0/node_modules/utila/lib/classic.js
  var require_classic = __commonJS({
    "node_modules/.pnpm/utila@0.4.0/node_modules/utila/lib/classic.js"(exports2, module2) {
      var classic;
      var __slice = [].slice;
      module2.exports = classic = {};
      classic.implement = function() {
        var classProto, classReference, desc, member, mixin, mixins, _i, _j, _len;
        mixins = 2 <= arguments.length ? __slice.call(arguments, 0, _i = arguments.length - 1) : (_i = 0, []), classReference = arguments[_i++];
        for (_j = 0, _len = mixins.length; _j < _len; _j++) {
          mixin = mixins[_j];
          classProto = classReference.prototype;
          for (member in mixin.prototype) {
            if (!Object.getOwnPropertyDescriptor(classProto, member)) {
              desc = Object.getOwnPropertyDescriptor(mixin.prototype, member);
              Object.defineProperty(classProto, member, desc);
            }
          }
        }
        return classReference;
      };
      classic.mix = function() {
        var classProto, classReference, desc, member, mixin, mixins, _i, _j, _len;
        mixins = 2 <= arguments.length ? __slice.call(arguments, 0, _i = arguments.length - 1) : (_i = 0, []), classReference = arguments[_i++];
        classProto = classReference.prototype;
        classReference.__mixinCloners = [];
        classReference.__applyClonersFor = function(instance, args2) {
          var cloner, _j2, _len2, _ref;
          if (args2 == null) {
            args2 = null;
          }
          _ref = classReference.__mixinCloners;
          for (_j2 = 0, _len2 = _ref.length; _j2 < _len2; _j2++) {
            cloner = _ref[_j2];
            cloner.apply(instance, args2);
          }
        };
        classReference.__mixinInitializers = [];
        classReference.__initMixinsFor = function(instance, args2) {
          var initializer, _j2, _len2, _ref;
          if (args2 == null) {
            args2 = null;
          }
          _ref = classReference.__mixinInitializers;
          for (_j2 = 0, _len2 = _ref.length; _j2 < _len2; _j2++) {
            initializer = _ref[_j2];
            initializer.apply(instance, args2);
          }
        };
        classReference.__mixinQuitters = [];
        classReference.__applyQuittersFor = function(instance, args2) {
          var quitter, _j2, _len2, _ref;
          if (args2 == null) {
            args2 = null;
          }
          _ref = classReference.__mixinQuitters;
          for (_j2 = 0, _len2 = _ref.length; _j2 < _len2; _j2++) {
            quitter = _ref[_j2];
            quitter.apply(instance, args2);
          }
        };
        for (_j = 0, _len = mixins.length; _j < _len; _j++) {
          mixin = mixins[_j];
          if (!(mixin.constructor instanceof Function)) {
            throw Error("Mixin should be a function");
          }
          for (member in mixin.prototype) {
            if (member.substr(0, 11) === "__initMixin") {
              classReference.__mixinInitializers.push(mixin.prototype[member]);
              continue;
            } else if (member.substr(0, 11) === "__clonerFor") {
              classReference.__mixinCloners.push(mixin.prototype[member]);
              continue;
            } else if (member.substr(0, 12) === "__quitterFor") {
              classReference.__mixinQuitters.push(mixin.prototype[member]);
              continue;
            }
            if (!Object.getOwnPropertyDescriptor(classProto, member)) {
              desc = Object.getOwnPropertyDescriptor(mixin.prototype, member);
              Object.defineProperty(classProto, member, desc);
            }
          }
        }
        return classReference;
      };
    }
  });

  // node_modules/.pnpm/utila@0.4.0/node_modules/utila/lib/_common.js
  var require_common = __commonJS({
    "node_modules/.pnpm/utila@0.4.0/node_modules/utila/lib/_common.js"(exports2, module2) {
      var common;
      module2.exports = common = {
        /*
        	Checks to see if o is an object, and it isn't an instance
        	of some class.
        */
        isBareObject: function(o) {
          if (o != null && o.constructor === Object) {
            return true;
          }
          return false;
        },
        /*
        	Returns type of an object, including:
        	undefined, null, string, number, array,
        	arguments, element, textnode, whitespace, and object
        */
        typeOf: function(item) {
          var _ref;
          if (item === null) {
            return "null";
          }
          if (typeof item !== "object") {
            return typeof item;
          }
          if (Array.isArray(item)) {
            return "array";
          }
          if (item.nodeName) {
            if (item.nodeType === 1) {
              return "element";
            }
            if (item.nodeType === 3) {
              return (_ref = /\S/.test(item.nodeValue)) != null ? _ref : {
                "textnode": "whitespace"
              };
            }
          } else if (typeof item.length === "number") {
            if (item.callee) {
              return "arguments";
            }
          }
          return typeof item;
        },
        clone: function(item, includePrototype) {
          if (includePrototype == null) {
            includePrototype = false;
          }
          switch (common.typeOf(item)) {
            case "array":
              return common._cloneArray(item, includePrototype);
            case "object":
              return common._cloneObject(item, includePrototype);
            default:
              return item;
          }
        },
        /*
        	Deep clone of an object.
        	From MooTools
        */
        _cloneObject: function(o, includePrototype) {
          var clone, key;
          if (includePrototype == null) {
            includePrototype = false;
          }
          if (common.isBareObject(o)) {
            clone = {};
            for (key in o) {
              clone[key] = common.clone(o[key], includePrototype);
            }
            return clone;
          } else {
            if (!includePrototype) {
              return o;
            }
            if (o instanceof Function) {
              return o;
            }
            clone = Object.create(o.constructor.prototype);
            for (key in o) {
              if (o.hasOwnProperty(key)) {
                clone[key] = common.clone(o[key], includePrototype);
              }
            }
            return clone;
          }
        },
        /*
        	Deep clone of an array.
        	From MooTools
        */
        _cloneArray: function(a, includePrototype) {
          var clone, i;
          if (includePrototype == null) {
            includePrototype = false;
          }
          i = a.length;
          clone = new Array(i);
          while (i--) {
            clone[i] = common.clone(a[i], includePrototype);
          }
          return clone;
        }
      };
    }
  });

  // node_modules/.pnpm/utila@0.4.0/node_modules/utila/lib/object.js
  var require_object = __commonJS({
    "node_modules/.pnpm/utila@0.4.0/node_modules/utila/lib/object.js"(exports2, module2) {
      var object;
      var _common;
      var __hasProp = {}.hasOwnProperty;
      _common = require_common();
      module2.exports = object = {
        isBareObject: _common.isBareObject.bind(_common),
        /*
        	if object is an instance of a class
        */
        isInstance: function(what) {
          return !this.isBareObject(what);
        },
        /*
        	Alias to _common.typeOf
        */
        typeOf: _common.typeOf.bind(_common),
        /*
        	Alias to _common.clone
        */
        clone: _common.clone.bind(_common),
        /*
        	Empties an object of its properties.
        */
        empty: function(o) {
          var prop;
          for (prop in o) {
            if (o.hasOwnProperty(prop)) {
              delete o[prop];
            }
          }
          return o;
        },
        /*
        	Empties an object. Doesn't check for hasOwnProperty, so it's a tiny
        	bit faster. Use it for plain objects.
        */
        fastEmpty: function(o) {
          var property;
          for (property in o) {
            delete o[property];
          }
          return o;
        },
        /*
        	Overrides values fomr `newValues` on `base`, as long as they
        	already exist in base.
        */
        overrideOnto: function(base, newValues) {
          var key, newVal, oldVal;
          if (!this.isBareObject(newValues) || !this.isBareObject(base)) {
            return base;
          }
          for (key in base) {
            oldVal = base[key];
            newVal = newValues[key];
            if (newVal === void 0) {
              continue;
            }
            if (typeof newVal !== "object" || this.isInstance(newVal)) {
              base[key] = this.clone(newVal);
            } else {
              if (typeof oldVal !== "object" || this.isInstance(oldVal)) {
                base[key] = this.clone(newVal);
              } else {
                this.overrideOnto(oldVal, newVal);
              }
            }
          }
          return base;
        },
        /*
        	Takes a clone of 'base' and runs #overrideOnto on it
        */
        override: function(base, newValues) {
          return this.overrideOnto(this.clone(base), newValues);
        },
        append: function(base, toAppend) {
          return this.appendOnto(this.clone(base), toAppend);
        },
        appendOnto: function(base, toAppend) {
          var key, newVal, oldVal;
          if (!this.isBareObject(toAppend) || !this.isBareObject(base)) {
            return base;
          }
          for (key in toAppend) {
            if (!__hasProp.call(toAppend, key))
              continue;
            newVal = toAppend[key];
            if (newVal === void 0) {
              continue;
            }
            if (typeof newVal !== "object" || this.isInstance(newVal)) {
              base[key] = newVal;
            } else {
              oldVal = base[key];
              if (typeof oldVal !== "object" || this.isInstance(oldVal)) {
                base[key] = this.clone(newVal);
              } else {
                this.appendOnto(oldVal, newVal);
              }
            }
          }
          return base;
        },
        groupProps: function(obj, groups) {
          var def, defs, grouped, key, name, shouldAdd, val, _i, _len;
          grouped = {};
          for (name in groups) {
            defs = groups[name];
            grouped[name] = {};
          }
          grouped["rest"] = {};
          top:
            for (key in obj) {
              val = obj[key];
              shouldAdd = false;
              for (name in groups) {
                defs = groups[name];
                if (!Array.isArray(defs)) {
                  defs = [defs];
                }
                for (_i = 0, _len = defs.length; _i < _len; _i++) {
                  def = defs[_i];
                  if (typeof def === "string") {
                    if (key === def) {
                      shouldAdd = true;
                    }
                  } else if (def instanceof RegExp) {
                    if (def.test(key)) {
                      shouldAdd = true;
                    }
                  } else if (def instanceof Function) {
                    if (def(key)) {
                      shouldAdd = true;
                    }
                  } else {
                    throw Error("Group definitions must either						be strings, regexes, or functions.");
                  }
                  if (shouldAdd) {
                    grouped[name][key] = val;
                    continue top;
                  }
                }
              }
              grouped["rest"][key] = val;
            }
          return grouped;
        }
      };
    }
  });

  // node_modules/.pnpm/utila@0.4.0/node_modules/utila/lib/string.js
  var require_string = __commonJS({
    "node_modules/.pnpm/utila@0.4.0/node_modules/utila/lib/string.js"(exports2, module2) {
      module2.exports = {
        pad: function(n, width, z) {
          if (z == null) {
            z = "0";
          }
          n = n + "";
          if (n.length >= width) {
            return n;
          } else {
            return new Array(width - n.length + 1).join(z) + n;
          }
        }
      };
    }
  });

  // node_modules/.pnpm/utila@0.4.0/node_modules/utila/lib/Emitter.js
  var require_Emitter = __commonJS({
    "node_modules/.pnpm/utila@0.4.0/node_modules/utila/lib/Emitter.js"(exports2, module2) {
      var Emitter;
      var array;
      array = require_array();
      module2.exports = Emitter = function() {
        function Emitter2() {
          this._listeners = {};
          this._listenersForAnyEvent = [];
          this._disabledEmitters = {};
        }
        Emitter2.prototype.on = function(eventName, listener) {
          if (this._listeners[eventName] == null) {
            this._listeners[eventName] = [];
          }
          this._listeners[eventName].push(listener);
          return this;
        };
        Emitter2.prototype.once = function(eventName, listener) {
          var cb, ran, _this = this;
          ran = false;
          cb = function() {
            if (ran) {
              return;
            }
            ran = true;
            listener();
            return setTimeout(function() {
              return _this.removeEvent(eventName, cb);
            }, 0);
          };
          this.on(eventName, cb);
          return this;
        };
        Emitter2.prototype.onAnyEvent = function(listener) {
          this._listenersForAnyEvent.push(listener);
          return this;
        };
        Emitter2.prototype.removeEvent = function(eventName, listener) {
          if (this._listeners[eventName] == null) {
            return this;
          }
          array.pluckOneItem(this._listeners[eventName], listener);
          return this;
        };
        Emitter2.prototype.removeListeners = function(eventName) {
          if (this._listeners[eventName] == null) {
            return this;
          }
          this._listeners[eventName].length = 0;
          return this;
        };
        Emitter2.prototype.removeAllListeners = function() {
          var listeners, name, _ref;
          _ref = this._listeners;
          for (name in _ref) {
            listeners = _ref[name];
            listeners.length = 0;
          }
          return this;
        };
        Emitter2.prototype._emit = function(eventName, data) {
          var listener, _i, _j, _len, _len1, _ref, _ref1;
          _ref = this._listenersForAnyEvent;
          for (_i = 0, _len = _ref.length; _i < _len; _i++) {
            listener = _ref[_i];
            listener.call(this, data, eventName);
          }
          if (this._listeners[eventName] == null) {
            return;
          }
          _ref1 = this._listeners[eventName];
          for (_j = 0, _len1 = _ref1.length; _j < _len1; _j++) {
            listener = _ref1[_j];
            listener.call(this, data);
          }
        };
        Emitter2.prototype._throttleEmitterMethod = function(fnName, time) {
          var lastCallArgs, originalFn, pend, pending, runIt, timer, _this = this;
          if (time == null) {
            time = 1e3;
          }
          originalFn = this[fnName];
          if (typeof originalFn !== "function") {
            throw Error("this class does not have a method called '" + fnName + "'");
          }
          lastCallArgs = null;
          pending = false;
          timer = null;
          this[fnName] = function() {
            lastCallArgs = arguments;
            return pend();
          };
          pend = function() {
            if (pending) {
              clearTimeout(timer);
            }
            timer = setTimeout(runIt, time);
            return pending = true;
          };
          return runIt = function() {
            pending = false;
            return originalFn.apply(_this, lastCallArgs);
          };
        };
        Emitter2.prototype._disableEmitter = function(fnName) {
          if (this._disabledEmitters[fnName] != null) {
            throw Error("" + fnName + " is already a disabled emitter");
          }
          this._disabledEmitters[fnName] = this[fnName];
          return this[fnName] = function() {
          };
        };
        Emitter2.prototype._enableEmitter = function(fnName) {
          var fn;
          fn = this._disabledEmitters[fnName];
          if (fn == null) {
            throw Error("" + fnName + " is not a disabled emitter");
          }
          this[fnName] = fn;
          return delete this._disabledEmitters[fnName];
        };
        return Emitter2;
      }();
    }
  });

  // node_modules/.pnpm/utila@0.4.0/node_modules/utila/lib/utila.js
  var require_utila = __commonJS({
    "node_modules/.pnpm/utila@0.4.0/node_modules/utila/lib/utila.js"(exports2, module2) {
      var utila;
      module2.exports = utila = {
        array: require_array(),
        classic: require_classic(),
        object: require_object(),
        string: require_string(),
        Emitter: require_Emitter()
      };
    }
  });

  // node_modules/.pnpm/dom-converter@0.2.0/node_modules/dom-converter/lib/objectToSaneObject.js
  var require_objectToSaneObject = __commonJS({
    "node_modules/.pnpm/dom-converter@0.2.0/node_modules/dom-converter/lib/objectToSaneObject.js"(exports2, module2) {
      var object;
      var self2;
      var hasProp = {}.hasOwnProperty;
      object = require_utila().object;
      module2.exports = self2 = {
        sanitize: function(val) {
          return self2._toChildren(val);
        },
        _toChildren: function(val) {
          var ref;
          if (object.isBareObject(val)) {
            return self2._objectToChildren(val);
          } else if (Array.isArray(val)) {
            return self2._arrayToChildren(val);
          } else if (val === null || typeof val === "undefined") {
            return [];
          } else if ((ref = typeof val) === "string" || ref === "number") {
            return [String(val)];
          } else {
            throw Error("not a valid child node: `" + val);
          }
        },
        _objectToChildren: function(o) {
          var a, cur, key, val;
          a = [];
          for (key in o) {
            if (!hasProp.call(o, key))
              continue;
            val = o[key];
            cur = {};
            cur[key] = self2.sanitize(val);
            a.push(cur);
          }
          return a;
        },
        _arrayToChildren: function(a) {
          var i, len, ret, v;
          ret = [];
          for (i = 0, len = a.length; i < len; i++) {
            v = a[i];
            ret.push(self2._toNode(v));
          }
          return ret;
        },
        _toNode: function(o) {
          var key, keys, obj, ref;
          if ((ref = typeof o) === "string" || ref === "number") {
            return String(o);
          } else if (object.isBareObject(o)) {
            keys = Object.keys(o);
            if (keys.length !== 1) {
              throw Error("a node must only have one key as tag name");
            }
            key = keys[0];
            obj = {};
            obj[key] = self2._toChildren(o[key]);
            return obj;
          } else {
            throw Error("not a valid node: `" + o + "`");
          }
        }
      };
    }
  });

  // node_modules/.pnpm/dom-converter@0.2.0/node_modules/dom-converter/lib/saneObjectToDom.js
  var require_saneObjectToDom = __commonJS({
    "node_modules/.pnpm/dom-converter@0.2.0/node_modules/dom-converter/lib/saneObjectToDom.js"(exports2, module2) {
      var self2;
      var hasProp = {}.hasOwnProperty;
      module2.exports = self2 = {
        convert: function(obj) {
          return self2._arrayToChildren(obj);
        },
        _arrayToChildren: function(a, parent) {
          var children, j, len, node, prev, v;
          if (parent == null) {
            parent = null;
          }
          children = [];
          prev = null;
          for (j = 0, len = a.length; j < len; j++) {
            v = a[j];
            if (typeof v === "string") {
              node = self2._getTextNodeFor(v);
            } else {
              node = self2._objectToNode(v, parent);
              node.prev = null;
              node.next = null;
              node.parent = parent;
              if (prev != null) {
                node.prev = prev;
                prev.next = node;
              }
              prev = node;
            }
            children.push(node);
          }
          return children;
        },
        _objectToNode: function(o) {
          var attribs, children, i, k, key, name, node, ref, v, val;
          i = 0;
          for (k in o) {
            if (!hasProp.call(o, k))
              continue;
            v = o[k];
            if (i > 0) {
              throw Error("_objectToNode() only accepts an object with one key/value");
            }
            key = k;
            val = v;
            i++;
          }
          node = {};
          if (typeof key !== "string") {
            throw Error("_objectToNode()'s key must be a string of tag name and classes");
          }
          if (typeof val === "string") {
            children = [self2._getTextNodeFor(val)];
          } else if (Array.isArray(val)) {
            children = self2._arrayToChildren(val, node);
          } else {
            inspect(o);
            throw Error("_objectToNode()'s key's value must only be a string or an array");
          }
          node.type = "tag";
          ref = self2._parseTag(key), name = ref.name, attribs = ref.attribs;
          node.name = name;
          node.attribs = attribs;
          node.children = children;
          return node;
        },
        _getTextNodeFor: function(s) {
          return {
            type: "text",
            data: s
          };
        },
        _nameRx: /^[a-zA-Z\-\_]{1}[a-zA-Z0-9\-\_]*$/,
        _parseTag: function(k) {
          var attribs, classes, cls, id, m, name, parts;
          if (!k.match(/^[a-zA-Z0-9\#\-\_\.\[\]\"\'\=\,\s]+$/) || k.match(/^[0-9]+/)) {
            throw Error("cannot parse tag `" + k + "`");
          }
          attribs = {};
          parts = {
            name: "",
            attribs
          };
          if (m = k.match(/^([^\.#]+)/)) {
            name = m[1];
            if (!name.match(self2._nameRx)) {
              throw Error("tag name `" + name + "` is not valid");
            }
            parts.name = name;
            k = k.substr(name.length, k.length);
          }
          if (m = k.match(/^#([a-zA-Z0-9\-]+)/)) {
            id = m[1];
            if (!id.match(self2._nameRx)) {
              throw Error("tag id `" + id + "` is not valid");
            }
            attribs.id = id;
            k = k.substr(id.length + 1, k.length);
          }
          classes = [];
          while (m = k.match(/\.([a-zA-Z0-9\-\_]+)/)) {
            cls = m[1];
            if (!cls.match(self2._nameRx)) {
              throw Error("tag class `" + cls + "` is not valid");
            }
            classes.push(cls);
            k = k.replace("." + cls, "");
          }
          if (classes.length) {
            attribs["class"] = classes.join(" ");
          }
          return parts;
        }
      };
    }
  });

  // node_modules/.pnpm/dom-converter@0.2.0/node_modules/dom-converter/lib/domToMarkup.js
  var require_domToMarkup = __commonJS({
    "node_modules/.pnpm/dom-converter@0.2.0/node_modules/dom-converter/lib/domToMarkup.js"() {
    }
  });

  // node_modules/.pnpm/dom-converter@0.2.0/node_modules/dom-converter/lib/domConverter.js
  var require_domConverter = __commonJS({
    "node_modules/.pnpm/dom-converter@0.2.0/node_modules/dom-converter/lib/domConverter.js"(exports2, module2) {
      var domToMarkup;
      var object;
      var objectToSaneObject;
      var saneObjectToDom;
      var self2;
      objectToSaneObject = require_objectToSaneObject();
      saneObjectToDom = require_saneObjectToDom();
      domToMarkup = require_domToMarkup();
      object = require_utila().object;
      module2.exports = self2 = {
        objectToDom: function(o) {
          o = self2._object2SaneObject(o);
          return saneObjectToDom.convert(o);
        },
        object2markup: function(o) {
          var dom;
          dom = self2.objectToDom(o);
          return domToMarkup.convert(dom);
        },
        domToMarkup: function(dom) {
          return domToMarkup.convert(dom);
        },
        _object2SaneObject: function(o) {
          if (!Array.isArray(o)) {
            if (!object.isBareObject(o)) {
              throw Error("toDom() only accepts arrays and bare objects as input");
            }
          }
          return objectToSaneObject.sanitize(o);
        }
      };
    }
  });

  // node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_listCacheClear.js
  var require_listCacheClear = __commonJS({
    "node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_listCacheClear.js"(exports2, module2) {
      function listCacheClear() {
        this.__data__ = [];
        this.size = 0;
      }
      module2.exports = listCacheClear;
    }
  });

  // node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/eq.js
  var require_eq = __commonJS({
    "node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/eq.js"(exports2, module2) {
      function eq(value, other) {
        return value === other || value !== value && other !== other;
      }
      module2.exports = eq;
    }
  });

  // node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_assocIndexOf.js
  var require_assocIndexOf = __commonJS({
    "node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_assocIndexOf.js"(exports2, module2) {
      var eq = require_eq();
      function assocIndexOf(array, key) {
        var length = array.length;
        while (length--) {
          if (eq(array[length][0], key)) {
            return length;
          }
        }
        return -1;
      }
      module2.exports = assocIndexOf;
    }
  });

  // node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_listCacheDelete.js
  var require_listCacheDelete = __commonJS({
    "node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_listCacheDelete.js"(exports2, module2) {
      var assocIndexOf = require_assocIndexOf();
      var arrayProto = Array.prototype;
      var splice = arrayProto.splice;
      function listCacheDelete(key) {
        var data = this.__data__, index = assocIndexOf(data, key);
        if (index < 0) {
          return false;
        }
        var lastIndex = data.length - 1;
        if (index == lastIndex) {
          data.pop();
        } else {
          splice.call(data, index, 1);
        }
        --this.size;
        return true;
      }
      module2.exports = listCacheDelete;
    }
  });

  // node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_listCacheGet.js
  var require_listCacheGet = __commonJS({
    "node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_listCacheGet.js"(exports2, module2) {
      var assocIndexOf = require_assocIndexOf();
      function listCacheGet(key) {
        var data = this.__data__, index = assocIndexOf(data, key);
        return index < 0 ? void 0 : data[index][1];
      }
      module2.exports = listCacheGet;
    }
  });

  // node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_listCacheHas.js
  var require_listCacheHas = __commonJS({
    "node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_listCacheHas.js"(exports2, module2) {
      var assocIndexOf = require_assocIndexOf();
      function listCacheHas(key) {
        return assocIndexOf(this.__data__, key) > -1;
      }
      module2.exports = listCacheHas;
    }
  });

  // node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_listCacheSet.js
  var require_listCacheSet = __commonJS({
    "node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_listCacheSet.js"(exports2, module2) {
      var assocIndexOf = require_assocIndexOf();
      function listCacheSet(key, value) {
        var data = this.__data__, index = assocIndexOf(data, key);
        if (index < 0) {
          ++this.size;
          data.push([key, value]);
        } else {
          data[index][1] = value;
        }
        return this;
      }
      module2.exports = listCacheSet;
    }
  });

  // node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_ListCache.js
  var require_ListCache = __commonJS({
    "node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_ListCache.js"(exports2, module2) {
      var listCacheClear = require_listCacheClear();
      var listCacheDelete = require_listCacheDelete();
      var listCacheGet = require_listCacheGet();
      var listCacheHas = require_listCacheHas();
      var listCacheSet = require_listCacheSet();
      function ListCache(entries) {
        var index = -1, length = entries == null ? 0 : entries.length;
        this.clear();
        while (++index < length) {
          var entry = entries[index];
          this.set(entry[0], entry[1]);
        }
      }
      ListCache.prototype.clear = listCacheClear;
      ListCache.prototype["delete"] = listCacheDelete;
      ListCache.prototype.get = listCacheGet;
      ListCache.prototype.has = listCacheHas;
      ListCache.prototype.set = listCacheSet;
      module2.exports = ListCache;
    }
  });

  // node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_stackClear.js
  var require_stackClear = __commonJS({
    "node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_stackClear.js"(exports2, module2) {
      var ListCache = require_ListCache();
      function stackClear() {
        this.__data__ = new ListCache();
        this.size = 0;
      }
      module2.exports = stackClear;
    }
  });

  // node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_stackDelete.js
  var require_stackDelete = __commonJS({
    "node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_stackDelete.js"(exports2, module2) {
      function stackDelete(key) {
        var data = this.__data__, result = data["delete"](key);
        this.size = data.size;
        return result;
      }
      module2.exports = stackDelete;
    }
  });

  // node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_stackGet.js
  var require_stackGet = __commonJS({
    "node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_stackGet.js"(exports2, module2) {
      function stackGet(key) {
        return this.__data__.get(key);
      }
      module2.exports = stackGet;
    }
  });

  // node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_stackHas.js
  var require_stackHas = __commonJS({
    "node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_stackHas.js"(exports2, module2) {
      function stackHas(key) {
        return this.__data__.has(key);
      }
      module2.exports = stackHas;
    }
  });

  // node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/isObject.js
  var require_isObject = __commonJS({
    "node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/isObject.js"(exports2, module2) {
      function isObject(value) {
        var type = typeof value;
        return value != null && (type == "object" || type == "function");
      }
      module2.exports = isObject;
    }
  });

  // node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/isFunction.js
  var require_isFunction = __commonJS({
    "node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/isFunction.js"(exports2, module2) {
      var baseGetTag = require_baseGetTag();
      var isObject = require_isObject();
      var asyncTag = "[object AsyncFunction]";
      var funcTag = "[object Function]";
      var genTag = "[object GeneratorFunction]";
      var proxyTag = "[object Proxy]";
      function isFunction(value) {
        if (!isObject(value)) {
          return false;
        }
        var tag = baseGetTag(value);
        return tag == funcTag || tag == genTag || tag == asyncTag || tag == proxyTag;
      }
      module2.exports = isFunction;
    }
  });

  // node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_coreJsData.js
  var require_coreJsData = __commonJS({
    "node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_coreJsData.js"(exports2, module2) {
      var root = require_root();
      var coreJsData = root["__core-js_shared__"];
      module2.exports = coreJsData;
    }
  });

  // node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_isMasked.js
  var require_isMasked = __commonJS({
    "node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_isMasked.js"(exports2, module2) {
      var coreJsData = require_coreJsData();
      var maskSrcKey = function() {
        var uid = /[^.]+$/.exec(coreJsData && coreJsData.keys && coreJsData.keys.IE_PROTO || "");
        return uid ? "Symbol(src)_1." + uid : "";
      }();
      function isMasked(func) {
        return !!maskSrcKey && maskSrcKey in func;
      }
      module2.exports = isMasked;
    }
  });

  // node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_toSource.js
  var require_toSource = __commonJS({
    "node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_toSource.js"(exports2, module2) {
      var funcProto = Function.prototype;
      var funcToString = funcProto.toString;
      function toSource(func) {
        if (func != null) {
          try {
            return funcToString.call(func);
          } catch (e) {
          }
          try {
            return func + "";
          } catch (e) {
          }
        }
        return "";
      }
      module2.exports = toSource;
    }
  });

  // node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_baseIsNative.js
  var require_baseIsNative = __commonJS({
    "node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_baseIsNative.js"(exports2, module2) {
      var isFunction = require_isFunction();
      var isMasked = require_isMasked();
      var isObject = require_isObject();
      var toSource = require_toSource();
      var reRegExpChar = /[\\^$.*+?()[\]{}|]/g;
      var reIsHostCtor = /^\[object .+?Constructor\]$/;
      var funcProto = Function.prototype;
      var objectProto = Object.prototype;
      var funcToString = funcProto.toString;
      var hasOwnProperty = objectProto.hasOwnProperty;
      var reIsNative = RegExp(
        "^" + funcToString.call(hasOwnProperty).replace(reRegExpChar, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$"
      );
      function baseIsNative(value) {
        if (!isObject(value) || isMasked(value)) {
          return false;
        }
        var pattern = isFunction(value) ? reIsNative : reIsHostCtor;
        return pattern.test(toSource(value));
      }
      module2.exports = baseIsNative;
    }
  });

  // node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_getValue.js
  var require_getValue = __commonJS({
    "node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_getValue.js"(exports2, module2) {
      function getValue(object, key) {
        return object == null ? void 0 : object[key];
      }
      module2.exports = getValue;
    }
  });

  // node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_getNative.js
  var require_getNative = __commonJS({
    "node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_getNative.js"(exports2, module2) {
      var baseIsNative = require_baseIsNative();
      var getValue = require_getValue();
      function getNative(object, key) {
        var value = getValue(object, key);
        return baseIsNative(value) ? value : void 0;
      }
      module2.exports = getNative;
    }
  });

  // node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_Map.js
  var require_Map = __commonJS({
    "node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_Map.js"(exports2, module2) {
      var getNative = require_getNative();
      var root = require_root();
      var Map2 = getNative(root, "Map");
      module2.exports = Map2;
    }
  });

  // node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_nativeCreate.js
  var require_nativeCreate = __commonJS({
    "node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_nativeCreate.js"(exports2, module2) {
      var getNative = require_getNative();
      var nativeCreate = getNative(Object, "create");
      module2.exports = nativeCreate;
    }
  });

  // node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_hashClear.js
  var require_hashClear = __commonJS({
    "node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_hashClear.js"(exports2, module2) {
      var nativeCreate = require_nativeCreate();
      function hashClear() {
        this.__data__ = nativeCreate ? nativeCreate(null) : {};
        this.size = 0;
      }
      module2.exports = hashClear;
    }
  });

  // node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_hashDelete.js
  var require_hashDelete = __commonJS({
    "node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_hashDelete.js"(exports2, module2) {
      function hashDelete(key) {
        var result = this.has(key) && delete this.__data__[key];
        this.size -= result ? 1 : 0;
        return result;
      }
      module2.exports = hashDelete;
    }
  });

  // node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_hashGet.js
  var require_hashGet = __commonJS({
    "node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_hashGet.js"(exports2, module2) {
      var nativeCreate = require_nativeCreate();
      var HASH_UNDEFINED = "__lodash_hash_undefined__";
      var objectProto = Object.prototype;
      var hasOwnProperty = objectProto.hasOwnProperty;
      function hashGet(key) {
        var data = this.__data__;
        if (nativeCreate) {
          var result = data[key];
          return result === HASH_UNDEFINED ? void 0 : result;
        }
        return hasOwnProperty.call(data, key) ? data[key] : void 0;
      }
      module2.exports = hashGet;
    }
  });

  // node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_hashHas.js
  var require_hashHas = __commonJS({
    "node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_hashHas.js"(exports2, module2) {
      var nativeCreate = require_nativeCreate();
      var objectProto = Object.prototype;
      var hasOwnProperty = objectProto.hasOwnProperty;
      function hashHas(key) {
        var data = this.__data__;
        return nativeCreate ? data[key] !== void 0 : hasOwnProperty.call(data, key);
      }
      module2.exports = hashHas;
    }
  });

  // node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_hashSet.js
  var require_hashSet = __commonJS({
    "node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_hashSet.js"(exports2, module2) {
      var nativeCreate = require_nativeCreate();
      var HASH_UNDEFINED = "__lodash_hash_undefined__";
      function hashSet(key, value) {
        var data = this.__data__;
        this.size += this.has(key) ? 0 : 1;
        data[key] = nativeCreate && value === void 0 ? HASH_UNDEFINED : value;
        return this;
      }
      module2.exports = hashSet;
    }
  });

  // node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_Hash.js
  var require_Hash = __commonJS({
    "node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_Hash.js"(exports2, module2) {
      var hashClear = require_hashClear();
      var hashDelete = require_hashDelete();
      var hashGet = require_hashGet();
      var hashHas = require_hashHas();
      var hashSet = require_hashSet();
      function Hash(entries) {
        var index = -1, length = entries == null ? 0 : entries.length;
        this.clear();
        while (++index < length) {
          var entry = entries[index];
          this.set(entry[0], entry[1]);
        }
      }
      Hash.prototype.clear = hashClear;
      Hash.prototype["delete"] = hashDelete;
      Hash.prototype.get = hashGet;
      Hash.prototype.has = hashHas;
      Hash.prototype.set = hashSet;
      module2.exports = Hash;
    }
  });

  // node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_mapCacheClear.js
  var require_mapCacheClear = __commonJS({
    "node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_mapCacheClear.js"(exports2, module2) {
      var Hash = require_Hash();
      var ListCache = require_ListCache();
      var Map2 = require_Map();
      function mapCacheClear() {
        this.size = 0;
        this.__data__ = {
          "hash": new Hash(),
          "map": new (Map2 || ListCache)(),
          "string": new Hash()
        };
      }
      module2.exports = mapCacheClear;
    }
  });

  // node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_isKeyable.js
  var require_isKeyable = __commonJS({
    "node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_isKeyable.js"(exports2, module2) {
      function isKeyable(value) {
        var type = typeof value;
        return type == "string" || type == "number" || type == "symbol" || type == "boolean" ? value !== "__proto__" : value === null;
      }
      module2.exports = isKeyable;
    }
  });

  // node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_getMapData.js
  var require_getMapData = __commonJS({
    "node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_getMapData.js"(exports2, module2) {
      var isKeyable = require_isKeyable();
      function getMapData(map, key) {
        var data = map.__data__;
        return isKeyable(key) ? data[typeof key == "string" ? "string" : "hash"] : data.map;
      }
      module2.exports = getMapData;
    }
  });

  // node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_mapCacheDelete.js
  var require_mapCacheDelete = __commonJS({
    "node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_mapCacheDelete.js"(exports2, module2) {
      var getMapData = require_getMapData();
      function mapCacheDelete(key) {
        var result = getMapData(this, key)["delete"](key);
        this.size -= result ? 1 : 0;
        return result;
      }
      module2.exports = mapCacheDelete;
    }
  });

  // node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_mapCacheGet.js
  var require_mapCacheGet = __commonJS({
    "node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_mapCacheGet.js"(exports2, module2) {
      var getMapData = require_getMapData();
      function mapCacheGet(key) {
        return getMapData(this, key).get(key);
      }
      module2.exports = mapCacheGet;
    }
  });

  // node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_mapCacheHas.js
  var require_mapCacheHas = __commonJS({
    "node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_mapCacheHas.js"(exports2, module2) {
      var getMapData = require_getMapData();
      function mapCacheHas(key) {
        return getMapData(this, key).has(key);
      }
      module2.exports = mapCacheHas;
    }
  });

  // node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_mapCacheSet.js
  var require_mapCacheSet = __commonJS({
    "node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_mapCacheSet.js"(exports2, module2) {
      var getMapData = require_getMapData();
      function mapCacheSet(key, value) {
        var data = getMapData(this, key), size = data.size;
        data.set(key, value);
        this.size += data.size == size ? 0 : 1;
        return this;
      }
      module2.exports = mapCacheSet;
    }
  });

  // node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_MapCache.js
  var require_MapCache = __commonJS({
    "node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_MapCache.js"(exports2, module2) {
      var mapCacheClear = require_mapCacheClear();
      var mapCacheDelete = require_mapCacheDelete();
      var mapCacheGet = require_mapCacheGet();
      var mapCacheHas = require_mapCacheHas();
      var mapCacheSet = require_mapCacheSet();
      function MapCache(entries) {
        var index = -1, length = entries == null ? 0 : entries.length;
        this.clear();
        while (++index < length) {
          var entry = entries[index];
          this.set(entry[0], entry[1]);
        }
      }
      MapCache.prototype.clear = mapCacheClear;
      MapCache.prototype["delete"] = mapCacheDelete;
      MapCache.prototype.get = mapCacheGet;
      MapCache.prototype.has = mapCacheHas;
      MapCache.prototype.set = mapCacheSet;
      module2.exports = MapCache;
    }
  });

  // node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_stackSet.js
  var require_stackSet = __commonJS({
    "node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_stackSet.js"(exports2, module2) {
      var ListCache = require_ListCache();
      var Map2 = require_Map();
      var MapCache = require_MapCache();
      var LARGE_ARRAY_SIZE = 200;
      function stackSet(key, value) {
        var data = this.__data__;
        if (data instanceof ListCache) {
          var pairs = data.__data__;
          if (!Map2 || pairs.length < LARGE_ARRAY_SIZE - 1) {
            pairs.push([key, value]);
            this.size = ++data.size;
            return this;
          }
          data = this.__data__ = new MapCache(pairs);
        }
        data.set(key, value);
        this.size = data.size;
        return this;
      }
      module2.exports = stackSet;
    }
  });

  // node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_Stack.js
  var require_Stack = __commonJS({
    "node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_Stack.js"(exports2, module2) {
      var ListCache = require_ListCache();
      var stackClear = require_stackClear();
      var stackDelete = require_stackDelete();
      var stackGet = require_stackGet();
      var stackHas = require_stackHas();
      var stackSet = require_stackSet();
      function Stack(entries) {
        var data = this.__data__ = new ListCache(entries);
        this.size = data.size;
      }
      Stack.prototype.clear = stackClear;
      Stack.prototype["delete"] = stackDelete;
      Stack.prototype.get = stackGet;
      Stack.prototype.has = stackHas;
      Stack.prototype.set = stackSet;
      module2.exports = Stack;
    }
  });

  // node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_defineProperty.js
  var require_defineProperty = __commonJS({
    "node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_defineProperty.js"(exports2, module2) {
      var getNative = require_getNative();
      var defineProperty = function() {
        try {
          var func = getNative(Object, "defineProperty");
          func({}, "", {});
          return func;
        } catch (e) {
        }
      }();
      module2.exports = defineProperty;
    }
  });

  // node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_baseAssignValue.js
  var require_baseAssignValue = __commonJS({
    "node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_baseAssignValue.js"(exports2, module2) {
      var defineProperty = require_defineProperty();
      function baseAssignValue(object, key, value) {
        if (key == "__proto__" && defineProperty) {
          defineProperty(object, key, {
            "configurable": true,
            "enumerable": true,
            "value": value,
            "writable": true
          });
        } else {
          object[key] = value;
        }
      }
      module2.exports = baseAssignValue;
    }
  });

  // node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_assignMergeValue.js
  var require_assignMergeValue = __commonJS({
    "node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_assignMergeValue.js"(exports2, module2) {
      var baseAssignValue = require_baseAssignValue();
      var eq = require_eq();
      function assignMergeValue(object, key, value) {
        if (value !== void 0 && !eq(object[key], value) || value === void 0 && !(key in object)) {
          baseAssignValue(object, key, value);
        }
      }
      module2.exports = assignMergeValue;
    }
  });

  // node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_createBaseFor.js
  var require_createBaseFor = __commonJS({
    "node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_createBaseFor.js"(exports2, module2) {
      function createBaseFor(fromRight) {
        return function(object, iteratee, keysFunc) {
          var index = -1, iterable = Object(object), props = keysFunc(object), length = props.length;
          while (length--) {
            var key = props[fromRight ? length : ++index];
            if (iteratee(iterable[key], key, iterable) === false) {
              break;
            }
          }
          return object;
        };
      }
      module2.exports = createBaseFor;
    }
  });

  // node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_baseFor.js
  var require_baseFor = __commonJS({
    "node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_baseFor.js"(exports2, module2) {
      var createBaseFor = require_createBaseFor();
      var baseFor = createBaseFor();
      module2.exports = baseFor;
    }
  });

  // node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_cloneBuffer.js
  var require_cloneBuffer = __commonJS({
    "node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_cloneBuffer.js"(exports2, module2) {
      var root = require_root();
      var freeExports = typeof exports2 == "object" && exports2 && !exports2.nodeType && exports2;
      var freeModule = freeExports && typeof module2 == "object" && module2 && !module2.nodeType && module2;
      var moduleExports = freeModule && freeModule.exports === freeExports;
      var Buffer4 = moduleExports ? root.Buffer : void 0;
      var allocUnsafe = Buffer4 ? Buffer4.allocUnsafe : void 0;
      function cloneBuffer(buffer, isDeep) {
        if (isDeep) {
          return buffer.slice();
        }
        var length = buffer.length, result = allocUnsafe ? allocUnsafe(length) : new buffer.constructor(length);
        buffer.copy(result);
        return result;
      }
      module2.exports = cloneBuffer;
    }
  });

  // node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_Uint8Array.js
  var require_Uint8Array = __commonJS({
    "node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_Uint8Array.js"(exports2, module2) {
      var root = require_root();
      var Uint8Array2 = root.Uint8Array;
      module2.exports = Uint8Array2;
    }
  });

  // node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_cloneArrayBuffer.js
  var require_cloneArrayBuffer = __commonJS({
    "node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_cloneArrayBuffer.js"(exports2, module2) {
      var Uint8Array2 = require_Uint8Array();
      function cloneArrayBuffer(arrayBuffer) {
        var result = new arrayBuffer.constructor(arrayBuffer.byteLength);
        new Uint8Array2(result).set(new Uint8Array2(arrayBuffer));
        return result;
      }
      module2.exports = cloneArrayBuffer;
    }
  });

  // node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_cloneTypedArray.js
  var require_cloneTypedArray = __commonJS({
    "node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_cloneTypedArray.js"(exports2, module2) {
      var cloneArrayBuffer = require_cloneArrayBuffer();
      function cloneTypedArray(typedArray, isDeep) {
        var buffer = isDeep ? cloneArrayBuffer(typedArray.buffer) : typedArray.buffer;
        return new typedArray.constructor(buffer, typedArray.byteOffset, typedArray.length);
      }
      module2.exports = cloneTypedArray;
    }
  });

  // node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_copyArray.js
  var require_copyArray = __commonJS({
    "node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_copyArray.js"(exports2, module2) {
      function copyArray(source, array) {
        var index = -1, length = source.length;
        array || (array = Array(length));
        while (++index < length) {
          array[index] = source[index];
        }
        return array;
      }
      module2.exports = copyArray;
    }
  });

  // node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_baseCreate.js
  var require_baseCreate = __commonJS({
    "node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_baseCreate.js"(exports2, module2) {
      var isObject = require_isObject();
      var objectCreate = Object.create;
      var baseCreate = function() {
        function object() {
        }
        return function(proto3) {
          if (!isObject(proto3)) {
            return {};
          }
          if (objectCreate) {
            return objectCreate(proto3);
          }
          object.prototype = proto3;
          var result = new object();
          object.prototype = void 0;
          return result;
        };
      }();
      module2.exports = baseCreate;
    }
  });

  // node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_isPrototype.js
  var require_isPrototype = __commonJS({
    "node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_isPrototype.js"(exports2, module2) {
      var objectProto = Object.prototype;
      function isPrototype(value) {
        var Ctor = value && value.constructor, proto3 = typeof Ctor == "function" && Ctor.prototype || objectProto;
        return value === proto3;
      }
      module2.exports = isPrototype;
    }
  });

  // node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_initCloneObject.js
  var require_initCloneObject = __commonJS({
    "node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_initCloneObject.js"(exports2, module2) {
      var baseCreate = require_baseCreate();
      var getPrototype = require_getPrototype();
      var isPrototype = require_isPrototype();
      function initCloneObject(object) {
        return typeof object.constructor == "function" && !isPrototype(object) ? baseCreate(getPrototype(object)) : {};
      }
      module2.exports = initCloneObject;
    }
  });

  // node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_baseIsArguments.js
  var require_baseIsArguments = __commonJS({
    "node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_baseIsArguments.js"(exports2, module2) {
      var baseGetTag = require_baseGetTag();
      var isObjectLike = require_isObjectLike();
      var argsTag = "[object Arguments]";
      function baseIsArguments(value) {
        return isObjectLike(value) && baseGetTag(value) == argsTag;
      }
      module2.exports = baseIsArguments;
    }
  });

  // node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/isArguments.js
  var require_isArguments = __commonJS({
    "node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/isArguments.js"(exports2, module2) {
      var baseIsArguments = require_baseIsArguments();
      var isObjectLike = require_isObjectLike();
      var objectProto = Object.prototype;
      var hasOwnProperty = objectProto.hasOwnProperty;
      var propertyIsEnumerable = objectProto.propertyIsEnumerable;
      var isArguments = baseIsArguments(function() {
        return arguments;
      }()) ? baseIsArguments : function(value) {
        return isObjectLike(value) && hasOwnProperty.call(value, "callee") && !propertyIsEnumerable.call(value, "callee");
      };
      module2.exports = isArguments;
    }
  });

  // node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/isArray.js
  var require_isArray = __commonJS({
    "node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/isArray.js"(exports2, module2) {
      var isArray = Array.isArray;
      module2.exports = isArray;
    }
  });

  // node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/isLength.js
  var require_isLength = __commonJS({
    "node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/isLength.js"(exports2, module2) {
      var MAX_SAFE_INTEGER = 9007199254740991;
      function isLength(value) {
        return typeof value == "number" && value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;
      }
      module2.exports = isLength;
    }
  });

  // node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/isArrayLike.js
  var require_isArrayLike = __commonJS({
    "node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/isArrayLike.js"(exports2, module2) {
      var isFunction = require_isFunction();
      var isLength = require_isLength();
      function isArrayLike(value) {
        return value != null && isLength(value.length) && !isFunction(value);
      }
      module2.exports = isArrayLike;
    }
  });

  // node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/isArrayLikeObject.js
  var require_isArrayLikeObject = __commonJS({
    "node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/isArrayLikeObject.js"(exports2, module2) {
      var isArrayLike = require_isArrayLike();
      var isObjectLike = require_isObjectLike();
      function isArrayLikeObject(value) {
        return isObjectLike(value) && isArrayLike(value);
      }
      module2.exports = isArrayLikeObject;
    }
  });

  // node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/stubFalse.js
  var require_stubFalse = __commonJS({
    "node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/stubFalse.js"(exports2, module2) {
      function stubFalse() {
        return false;
      }
      module2.exports = stubFalse;
    }
  });

  // node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/isBuffer.js
  var require_isBuffer = __commonJS({
    "node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/isBuffer.js"(exports2, module2) {
      var root = require_root();
      var stubFalse = require_stubFalse();
      var freeExports = typeof exports2 == "object" && exports2 && !exports2.nodeType && exports2;
      var freeModule = freeExports && typeof module2 == "object" && module2 && !module2.nodeType && module2;
      var moduleExports = freeModule && freeModule.exports === freeExports;
      var Buffer4 = moduleExports ? root.Buffer : void 0;
      var nativeIsBuffer = Buffer4 ? Buffer4.isBuffer : void 0;
      var isBuffer = nativeIsBuffer || stubFalse;
      module2.exports = isBuffer;
    }
  });

  // node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_baseIsTypedArray.js
  var require_baseIsTypedArray = __commonJS({
    "node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_baseIsTypedArray.js"(exports2, module2) {
      var baseGetTag = require_baseGetTag();
      var isLength = require_isLength();
      var isObjectLike = require_isObjectLike();
      var argsTag = "[object Arguments]";
      var arrayTag = "[object Array]";
      var boolTag = "[object Boolean]";
      var dateTag = "[object Date]";
      var errorTag = "[object Error]";
      var funcTag = "[object Function]";
      var mapTag = "[object Map]";
      var numberTag = "[object Number]";
      var objectTag = "[object Object]";
      var regexpTag = "[object RegExp]";
      var setTag = "[object Set]";
      var stringTag = "[object String]";
      var weakMapTag = "[object WeakMap]";
      var arrayBufferTag = "[object ArrayBuffer]";
      var dataViewTag = "[object DataView]";
      var float32Tag = "[object Float32Array]";
      var float64Tag = "[object Float64Array]";
      var int8Tag = "[object Int8Array]";
      var int16Tag = "[object Int16Array]";
      var int32Tag = "[object Int32Array]";
      var uint8Tag = "[object Uint8Array]";
      var uint8ClampedTag = "[object Uint8ClampedArray]";
      var uint16Tag = "[object Uint16Array]";
      var uint32Tag = "[object Uint32Array]";
      var typedArrayTags = {};
      typedArrayTags[float32Tag] = typedArrayTags[float64Tag] = typedArrayTags[int8Tag] = typedArrayTags[int16Tag] = typedArrayTags[int32Tag] = typedArrayTags[uint8Tag] = typedArrayTags[uint8ClampedTag] = typedArrayTags[uint16Tag] = typedArrayTags[uint32Tag] = true;
      typedArrayTags[argsTag] = typedArrayTags[arrayTag] = typedArrayTags[arrayBufferTag] = typedArrayTags[boolTag] = typedArrayTags[dataViewTag] = typedArrayTags[dateTag] = typedArrayTags[errorTag] = typedArrayTags[funcTag] = typedArrayTags[mapTag] = typedArrayTags[numberTag] = typedArrayTags[objectTag] = typedArrayTags[regexpTag] = typedArrayTags[setTag] = typedArrayTags[stringTag] = typedArrayTags[weakMapTag] = false;
      function baseIsTypedArray(value) {
        return isObjectLike(value) && isLength(value.length) && !!typedArrayTags[baseGetTag(value)];
      }
      module2.exports = baseIsTypedArray;
    }
  });

  // node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_baseUnary.js
  var require_baseUnary = __commonJS({
    "node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_baseUnary.js"(exports2, module2) {
      function baseUnary(func) {
        return function(value) {
          return func(value);
        };
      }
      module2.exports = baseUnary;
    }
  });

  // node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_nodeUtil.js
  var require_nodeUtil = __commonJS({
    "node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_nodeUtil.js"(exports2, module2) {
      var freeGlobal = require_freeGlobal();
      var freeExports = typeof exports2 == "object" && exports2 && !exports2.nodeType && exports2;
      var freeModule = freeExports && typeof module2 == "object" && module2 && !module2.nodeType && module2;
      var moduleExports = freeModule && freeModule.exports === freeExports;
      var freeProcess = moduleExports && freeGlobal.process;
      var nodeUtil = function() {
        try {
          var types = freeModule && freeModule.require && freeModule.require("util").types;
          if (types) {
            return types;
          }
          return freeProcess && freeProcess.binding && freeProcess.binding("util");
        } catch (e) {
        }
      }();
      module2.exports = nodeUtil;
    }
  });

  // node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/isTypedArray.js
  var require_isTypedArray = __commonJS({
    "node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/isTypedArray.js"(exports2, module2) {
      var baseIsTypedArray = require_baseIsTypedArray();
      var baseUnary = require_baseUnary();
      var nodeUtil = require_nodeUtil();
      var nodeIsTypedArray = nodeUtil && nodeUtil.isTypedArray;
      var isTypedArray = nodeIsTypedArray ? baseUnary(nodeIsTypedArray) : baseIsTypedArray;
      module2.exports = isTypedArray;
    }
  });

  // node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_safeGet.js
  var require_safeGet = __commonJS({
    "node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_safeGet.js"(exports2, module2) {
      function safeGet(object, key) {
        if (key === "constructor" && typeof object[key] === "function") {
          return;
        }
        if (key == "__proto__") {
          return;
        }
        return object[key];
      }
      module2.exports = safeGet;
    }
  });

  // node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_assignValue.js
  var require_assignValue = __commonJS({
    "node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_assignValue.js"(exports2, module2) {
      var baseAssignValue = require_baseAssignValue();
      var eq = require_eq();
      var objectProto = Object.prototype;
      var hasOwnProperty = objectProto.hasOwnProperty;
      function assignValue(object, key, value) {
        var objValue = object[key];
        if (!(hasOwnProperty.call(object, key) && eq(objValue, value)) || value === void 0 && !(key in object)) {
          baseAssignValue(object, key, value);
        }
      }
      module2.exports = assignValue;
    }
  });

  // node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_copyObject.js
  var require_copyObject = __commonJS({
    "node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_copyObject.js"(exports2, module2) {
      var assignValue = require_assignValue();
      var baseAssignValue = require_baseAssignValue();
      function copyObject(source, props, object, customizer) {
        var isNew = !object;
        object || (object = {});
        var index = -1, length = props.length;
        while (++index < length) {
          var key = props[index];
          var newValue = customizer ? customizer(object[key], source[key], key, object, source) : void 0;
          if (newValue === void 0) {
            newValue = source[key];
          }
          if (isNew) {
            baseAssignValue(object, key, newValue);
          } else {
            assignValue(object, key, newValue);
          }
        }
        return object;
      }
      module2.exports = copyObject;
    }
  });

  // node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_baseTimes.js
  var require_baseTimes = __commonJS({
    "node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_baseTimes.js"(exports2, module2) {
      function baseTimes(n, iteratee) {
        var index = -1, result = Array(n);
        while (++index < n) {
          result[index] = iteratee(index);
        }
        return result;
      }
      module2.exports = baseTimes;
    }
  });

  // node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_isIndex.js
  var require_isIndex = __commonJS({
    "node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_isIndex.js"(exports2, module2) {
      var MAX_SAFE_INTEGER = 9007199254740991;
      var reIsUint = /^(?:0|[1-9]\d*)$/;
      function isIndex(value, length) {
        var type = typeof value;
        length = length == null ? MAX_SAFE_INTEGER : length;
        return !!length && (type == "number" || type != "symbol" && reIsUint.test(value)) && (value > -1 && value % 1 == 0 && value < length);
      }
      module2.exports = isIndex;
    }
  });

  // node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_arrayLikeKeys.js
  var require_arrayLikeKeys = __commonJS({
    "node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_arrayLikeKeys.js"(exports2, module2) {
      var baseTimes = require_baseTimes();
      var isArguments = require_isArguments();
      var isArray = require_isArray();
      var isBuffer = require_isBuffer();
      var isIndex = require_isIndex();
      var isTypedArray = require_isTypedArray();
      var objectProto = Object.prototype;
      var hasOwnProperty = objectProto.hasOwnProperty;
      function arrayLikeKeys(value, inherited) {
        var isArr = isArray(value), isArg = !isArr && isArguments(value), isBuff = !isArr && !isArg && isBuffer(value), isType = !isArr && !isArg && !isBuff && isTypedArray(value), skipIndexes = isArr || isArg || isBuff || isType, result = skipIndexes ? baseTimes(value.length, String) : [], length = result.length;
        for (var key in value) {
          if ((inherited || hasOwnProperty.call(value, key)) && !(skipIndexes && // Safari 9 has enumerable `arguments.length` in strict mode.
          (key == "length" || // Node.js 0.10 has enumerable non-index properties on buffers.
          isBuff && (key == "offset" || key == "parent") || // PhantomJS 2 has enumerable non-index properties on typed arrays.
          isType && (key == "buffer" || key == "byteLength" || key == "byteOffset") || // Skip index properties.
          isIndex(key, length)))) {
            result.push(key);
          }
        }
        return result;
      }
      module2.exports = arrayLikeKeys;
    }
  });

  // node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_nativeKeysIn.js
  var require_nativeKeysIn = __commonJS({
    "node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_nativeKeysIn.js"(exports2, module2) {
      function nativeKeysIn(object) {
        var result = [];
        if (object != null) {
          for (var key in Object(object)) {
            result.push(key);
          }
        }
        return result;
      }
      module2.exports = nativeKeysIn;
    }
  });

  // node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_baseKeysIn.js
  var require_baseKeysIn = __commonJS({
    "node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_baseKeysIn.js"(exports2, module2) {
      var isObject = require_isObject();
      var isPrototype = require_isPrototype();
      var nativeKeysIn = require_nativeKeysIn();
      var objectProto = Object.prototype;
      var hasOwnProperty = objectProto.hasOwnProperty;
      function baseKeysIn(object) {
        if (!isObject(object)) {
          return nativeKeysIn(object);
        }
        var isProto = isPrototype(object), result = [];
        for (var key in object) {
          if (!(key == "constructor" && (isProto || !hasOwnProperty.call(object, key)))) {
            result.push(key);
          }
        }
        return result;
      }
      module2.exports = baseKeysIn;
    }
  });

  // node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/keysIn.js
  var require_keysIn = __commonJS({
    "node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/keysIn.js"(exports2, module2) {
      var arrayLikeKeys = require_arrayLikeKeys();
      var baseKeysIn = require_baseKeysIn();
      var isArrayLike = require_isArrayLike();
      function keysIn(object) {
        return isArrayLike(object) ? arrayLikeKeys(object, true) : baseKeysIn(object);
      }
      module2.exports = keysIn;
    }
  });

  // node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/toPlainObject.js
  var require_toPlainObject = __commonJS({
    "node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/toPlainObject.js"(exports2, module2) {
      var copyObject = require_copyObject();
      var keysIn = require_keysIn();
      function toPlainObject(value) {
        return copyObject(value, keysIn(value));
      }
      module2.exports = toPlainObject;
    }
  });

  // node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_baseMergeDeep.js
  var require_baseMergeDeep = __commonJS({
    "node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_baseMergeDeep.js"(exports2, module2) {
      var assignMergeValue = require_assignMergeValue();
      var cloneBuffer = require_cloneBuffer();
      var cloneTypedArray = require_cloneTypedArray();
      var copyArray = require_copyArray();
      var initCloneObject = require_initCloneObject();
      var isArguments = require_isArguments();
      var isArray = require_isArray();
      var isArrayLikeObject = require_isArrayLikeObject();
      var isBuffer = require_isBuffer();
      var isFunction = require_isFunction();
      var isObject = require_isObject();
      var isPlainObject = require_isPlainObject();
      var isTypedArray = require_isTypedArray();
      var safeGet = require_safeGet();
      var toPlainObject = require_toPlainObject();
      function baseMergeDeep(object, source, key, srcIndex, mergeFunc, customizer, stack) {
        var objValue = safeGet(object, key), srcValue = safeGet(source, key), stacked = stack.get(srcValue);
        if (stacked) {
          assignMergeValue(object, key, stacked);
          return;
        }
        var newValue = customizer ? customizer(objValue, srcValue, key + "", object, source, stack) : void 0;
        var isCommon = newValue === void 0;
        if (isCommon) {
          var isArr = isArray(srcValue), isBuff = !isArr && isBuffer(srcValue), isTyped = !isArr && !isBuff && isTypedArray(srcValue);
          newValue = srcValue;
          if (isArr || isBuff || isTyped) {
            if (isArray(objValue)) {
              newValue = objValue;
            } else if (isArrayLikeObject(objValue)) {
              newValue = copyArray(objValue);
            } else if (isBuff) {
              isCommon = false;
              newValue = cloneBuffer(srcValue, true);
            } else if (isTyped) {
              isCommon = false;
              newValue = cloneTypedArray(srcValue, true);
            } else {
              newValue = [];
            }
          } else if (isPlainObject(srcValue) || isArguments(srcValue)) {
            newValue = objValue;
            if (isArguments(objValue)) {
              newValue = toPlainObject(objValue);
            } else if (!isObject(objValue) || isFunction(objValue)) {
              newValue = initCloneObject(srcValue);
            }
          } else {
            isCommon = false;
          }
        }
        if (isCommon) {
          stack.set(srcValue, newValue);
          mergeFunc(newValue, srcValue, srcIndex, customizer, stack);
          stack["delete"](srcValue);
        }
        assignMergeValue(object, key, newValue);
      }
      module2.exports = baseMergeDeep;
    }
  });

  // node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_baseMerge.js
  var require_baseMerge = __commonJS({
    "node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_baseMerge.js"(exports2, module2) {
      var Stack = require_Stack();
      var assignMergeValue = require_assignMergeValue();
      var baseFor = require_baseFor();
      var baseMergeDeep = require_baseMergeDeep();
      var isObject = require_isObject();
      var keysIn = require_keysIn();
      var safeGet = require_safeGet();
      function baseMerge(object, source, srcIndex, customizer, stack) {
        if (object === source) {
          return;
        }
        baseFor(source, function(srcValue, key) {
          stack || (stack = new Stack());
          if (isObject(srcValue)) {
            baseMergeDeep(object, source, key, srcIndex, baseMerge, customizer, stack);
          } else {
            var newValue = customizer ? customizer(safeGet(object, key), srcValue, key + "", object, source, stack) : void 0;
            if (newValue === void 0) {
              newValue = srcValue;
            }
            assignMergeValue(object, key, newValue);
          }
        }, keysIn);
      }
      module2.exports = baseMerge;
    }
  });

  // node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/identity.js
  var require_identity = __commonJS({
    "node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/identity.js"(exports2, module2) {
      function identity(value) {
        return value;
      }
      module2.exports = identity;
    }
  });

  // node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_apply.js
  var require_apply = __commonJS({
    "node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_apply.js"(exports2, module2) {
      function apply(func, thisArg, args2) {
        switch (args2.length) {
          case 0:
            return func.call(thisArg);
          case 1:
            return func.call(thisArg, args2[0]);
          case 2:
            return func.call(thisArg, args2[0], args2[1]);
          case 3:
            return func.call(thisArg, args2[0], args2[1], args2[2]);
        }
        return func.apply(thisArg, args2);
      }
      module2.exports = apply;
    }
  });

  // node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_overRest.js
  var require_overRest = __commonJS({
    "node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_overRest.js"(exports2, module2) {
      var apply = require_apply();
      var nativeMax = Math.max;
      function overRest(func, start, transform) {
        start = nativeMax(start === void 0 ? func.length - 1 : start, 0);
        return function() {
          var args2 = arguments, index = -1, length = nativeMax(args2.length - start, 0), array = Array(length);
          while (++index < length) {
            array[index] = args2[start + index];
          }
          index = -1;
          var otherArgs = Array(start + 1);
          while (++index < start) {
            otherArgs[index] = args2[index];
          }
          otherArgs[start] = transform(array);
          return apply(func, this, otherArgs);
        };
      }
      module2.exports = overRest;
    }
  });

  // node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/constant.js
  var require_constant = __commonJS({
    "node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/constant.js"(exports2, module2) {
      function constant(value) {
        return function() {
          return value;
        };
      }
      module2.exports = constant;
    }
  });

  // node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_baseSetToString.js
  var require_baseSetToString = __commonJS({
    "node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_baseSetToString.js"(exports2, module2) {
      var constant = require_constant();
      var defineProperty = require_defineProperty();
      var identity = require_identity();
      var baseSetToString = !defineProperty ? identity : function(func, string) {
        return defineProperty(func, "toString", {
          "configurable": true,
          "enumerable": false,
          "value": constant(string),
          "writable": true
        });
      };
      module2.exports = baseSetToString;
    }
  });

  // node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_shortOut.js
  var require_shortOut = __commonJS({
    "node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_shortOut.js"(exports2, module2) {
      var HOT_COUNT = 800;
      var HOT_SPAN = 16;
      var nativeNow = Date.now;
      function shortOut(func) {
        var count = 0, lastCalled = 0;
        return function() {
          var stamp = nativeNow(), remaining = HOT_SPAN - (stamp - lastCalled);
          lastCalled = stamp;
          if (remaining > 0) {
            if (++count >= HOT_COUNT) {
              return arguments[0];
            }
          } else {
            count = 0;
          }
          return func.apply(void 0, arguments);
        };
      }
      module2.exports = shortOut;
    }
  });

  // node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_setToString.js
  var require_setToString = __commonJS({
    "node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_setToString.js"(exports2, module2) {
      var baseSetToString = require_baseSetToString();
      var shortOut = require_shortOut();
      var setToString = shortOut(baseSetToString);
      module2.exports = setToString;
    }
  });

  // node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_baseRest.js
  var require_baseRest = __commonJS({
    "node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_baseRest.js"(exports2, module2) {
      var identity = require_identity();
      var overRest = require_overRest();
      var setToString = require_setToString();
      function baseRest(func, start) {
        return setToString(overRest(func, start, identity), func + "");
      }
      module2.exports = baseRest;
    }
  });

  // node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_isIterateeCall.js
  var require_isIterateeCall = __commonJS({
    "node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_isIterateeCall.js"(exports2, module2) {
      var eq = require_eq();
      var isArrayLike = require_isArrayLike();
      var isIndex = require_isIndex();
      var isObject = require_isObject();
      function isIterateeCall(value, index, object) {
        if (!isObject(object)) {
          return false;
        }
        var type = typeof index;
        if (type == "number" ? isArrayLike(object) && isIndex(index, object.length) : type == "string" && index in object) {
          return eq(object[index], value);
        }
        return false;
      }
      module2.exports = isIterateeCall;
    }
  });

  // node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_createAssigner.js
  var require_createAssigner = __commonJS({
    "node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_createAssigner.js"(exports2, module2) {
      var baseRest = require_baseRest();
      var isIterateeCall = require_isIterateeCall();
      function createAssigner(assigner) {
        return baseRest(function(object, sources) {
          var index = -1, length = sources.length, customizer = length > 1 ? sources[length - 1] : void 0, guard = length > 2 ? sources[2] : void 0;
          customizer = assigner.length > 3 && typeof customizer == "function" ? (length--, customizer) : void 0;
          if (guard && isIterateeCall(sources[0], sources[1], guard)) {
            customizer = length < 3 ? void 0 : customizer;
            length = 1;
          }
          object = Object(object);
          while (++index < length) {
            var source = sources[index];
            if (source) {
              assigner(object, source, index, customizer);
            }
          }
          return object;
        });
      }
      module2.exports = createAssigner;
    }
  });

  // node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/merge.js
  var require_merge = __commonJS({
    "node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/merge.js"(exports2, module2) {
      var baseMerge = require_baseMerge();
      var createAssigner = require_createAssigner();
      var merge = createAssigner(function(object, source, srcIndex) {
        baseMerge(object, source, srcIndex);
      });
      module2.exports = merge;
    }
  });

  // node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_arrayEach.js
  var require_arrayEach = __commonJS({
    "node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_arrayEach.js"(exports2, module2) {
      function arrayEach(array, iteratee) {
        var index = -1, length = array == null ? 0 : array.length;
        while (++index < length) {
          if (iteratee(array[index], index, array) === false) {
            break;
          }
        }
        return array;
      }
      module2.exports = arrayEach;
    }
  });

  // node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_nativeKeys.js
  var require_nativeKeys = __commonJS({
    "node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_nativeKeys.js"(exports2, module2) {
      var overArg = require_overArg();
      var nativeKeys = overArg(Object.keys, Object);
      module2.exports = nativeKeys;
    }
  });

  // node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_baseKeys.js
  var require_baseKeys = __commonJS({
    "node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_baseKeys.js"(exports2, module2) {
      var isPrototype = require_isPrototype();
      var nativeKeys = require_nativeKeys();
      var objectProto = Object.prototype;
      var hasOwnProperty = objectProto.hasOwnProperty;
      function baseKeys(object) {
        if (!isPrototype(object)) {
          return nativeKeys(object);
        }
        var result = [];
        for (var key in Object(object)) {
          if (hasOwnProperty.call(object, key) && key != "constructor") {
            result.push(key);
          }
        }
        return result;
      }
      module2.exports = baseKeys;
    }
  });

  // node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/keys.js
  var require_keys = __commonJS({
    "node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/keys.js"(exports2, module2) {
      var arrayLikeKeys = require_arrayLikeKeys();
      var baseKeys = require_baseKeys();
      var isArrayLike = require_isArrayLike();
      function keys(object) {
        return isArrayLike(object) ? arrayLikeKeys(object) : baseKeys(object);
      }
      module2.exports = keys;
    }
  });

  // node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_baseAssign.js
  var require_baseAssign = __commonJS({
    "node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_baseAssign.js"(exports2, module2) {
      var copyObject = require_copyObject();
      var keys = require_keys();
      function baseAssign(object, source) {
        return object && copyObject(source, keys(source), object);
      }
      module2.exports = baseAssign;
    }
  });

  // node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_baseAssignIn.js
  var require_baseAssignIn = __commonJS({
    "node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_baseAssignIn.js"(exports2, module2) {
      var copyObject = require_copyObject();
      var keysIn = require_keysIn();
      function baseAssignIn(object, source) {
        return object && copyObject(source, keysIn(source), object);
      }
      module2.exports = baseAssignIn;
    }
  });

  // node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_arrayFilter.js
  var require_arrayFilter = __commonJS({
    "node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_arrayFilter.js"(exports2, module2) {
      function arrayFilter(array, predicate) {
        var index = -1, length = array == null ? 0 : array.length, resIndex = 0, result = [];
        while (++index < length) {
          var value = array[index];
          if (predicate(value, index, array)) {
            result[resIndex++] = value;
          }
        }
        return result;
      }
      module2.exports = arrayFilter;
    }
  });

  // node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/stubArray.js
  var require_stubArray = __commonJS({
    "node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/stubArray.js"(exports2, module2) {
      function stubArray() {
        return [];
      }
      module2.exports = stubArray;
    }
  });

  // node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_getSymbols.js
  var require_getSymbols = __commonJS({
    "node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_getSymbols.js"(exports2, module2) {
      var arrayFilter = require_arrayFilter();
      var stubArray = require_stubArray();
      var objectProto = Object.prototype;
      var propertyIsEnumerable = objectProto.propertyIsEnumerable;
      var nativeGetSymbols = Object.getOwnPropertySymbols;
      var getSymbols = !nativeGetSymbols ? stubArray : function(object) {
        if (object == null) {
          return [];
        }
        object = Object(object);
        return arrayFilter(nativeGetSymbols(object), function(symbol) {
          return propertyIsEnumerable.call(object, symbol);
        });
      };
      module2.exports = getSymbols;
    }
  });

  // node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_copySymbols.js
  var require_copySymbols = __commonJS({
    "node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_copySymbols.js"(exports2, module2) {
      var copyObject = require_copyObject();
      var getSymbols = require_getSymbols();
      function copySymbols(source, object) {
        return copyObject(source, getSymbols(source), object);
      }
      module2.exports = copySymbols;
    }
  });

  // node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_arrayPush.js
  var require_arrayPush = __commonJS({
    "node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_arrayPush.js"(exports2, module2) {
      function arrayPush(array, values) {
        var index = -1, length = values.length, offset = array.length;
        while (++index < length) {
          array[offset + index] = values[index];
        }
        return array;
      }
      module2.exports = arrayPush;
    }
  });

  // node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_getSymbolsIn.js
  var require_getSymbolsIn = __commonJS({
    "node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_getSymbolsIn.js"(exports2, module2) {
      var arrayPush = require_arrayPush();
      var getPrototype = require_getPrototype();
      var getSymbols = require_getSymbols();
      var stubArray = require_stubArray();
      var nativeGetSymbols = Object.getOwnPropertySymbols;
      var getSymbolsIn = !nativeGetSymbols ? stubArray : function(object) {
        var result = [];
        while (object) {
          arrayPush(result, getSymbols(object));
          object = getPrototype(object);
        }
        return result;
      };
      module2.exports = getSymbolsIn;
    }
  });

  // node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_copySymbolsIn.js
  var require_copySymbolsIn = __commonJS({
    "node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_copySymbolsIn.js"(exports2, module2) {
      var copyObject = require_copyObject();
      var getSymbolsIn = require_getSymbolsIn();
      function copySymbolsIn(source, object) {
        return copyObject(source, getSymbolsIn(source), object);
      }
      module2.exports = copySymbolsIn;
    }
  });

  // node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_baseGetAllKeys.js
  var require_baseGetAllKeys = __commonJS({
    "node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_baseGetAllKeys.js"(exports2, module2) {
      var arrayPush = require_arrayPush();
      var isArray = require_isArray();
      function baseGetAllKeys(object, keysFunc, symbolsFunc) {
        var result = keysFunc(object);
        return isArray(object) ? result : arrayPush(result, symbolsFunc(object));
      }
      module2.exports = baseGetAllKeys;
    }
  });

  // node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_getAllKeys.js
  var require_getAllKeys = __commonJS({
    "node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_getAllKeys.js"(exports2, module2) {
      var baseGetAllKeys = require_baseGetAllKeys();
      var getSymbols = require_getSymbols();
      var keys = require_keys();
      function getAllKeys(object) {
        return baseGetAllKeys(object, keys, getSymbols);
      }
      module2.exports = getAllKeys;
    }
  });

  // node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_getAllKeysIn.js
  var require_getAllKeysIn = __commonJS({
    "node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_getAllKeysIn.js"(exports2, module2) {
      var baseGetAllKeys = require_baseGetAllKeys();
      var getSymbolsIn = require_getSymbolsIn();
      var keysIn = require_keysIn();
      function getAllKeysIn(object) {
        return baseGetAllKeys(object, keysIn, getSymbolsIn);
      }
      module2.exports = getAllKeysIn;
    }
  });

  // node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_DataView.js
  var require_DataView = __commonJS({
    "node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_DataView.js"(exports2, module2) {
      var getNative = require_getNative();
      var root = require_root();
      var DataView2 = getNative(root, "DataView");
      module2.exports = DataView2;
    }
  });

  // node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_Promise.js
  var require_Promise = __commonJS({
    "node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_Promise.js"(exports2, module2) {
      var getNative = require_getNative();
      var root = require_root();
      var Promise2 = getNative(root, "Promise");
      module2.exports = Promise2;
    }
  });

  // node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_Set.js
  var require_Set = __commonJS({
    "node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_Set.js"(exports2, module2) {
      var getNative = require_getNative();
      var root = require_root();
      var Set2 = getNative(root, "Set");
      module2.exports = Set2;
    }
  });

  // node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_WeakMap.js
  var require_WeakMap = __commonJS({
    "node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_WeakMap.js"(exports2, module2) {
      var getNative = require_getNative();
      var root = require_root();
      var WeakMap2 = getNative(root, "WeakMap");
      module2.exports = WeakMap2;
    }
  });

  // node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_getTag.js
  var require_getTag = __commonJS({
    "node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_getTag.js"(exports2, module2) {
      var DataView2 = require_DataView();
      var Map2 = require_Map();
      var Promise2 = require_Promise();
      var Set2 = require_Set();
      var WeakMap2 = require_WeakMap();
      var baseGetTag = require_baseGetTag();
      var toSource = require_toSource();
      var mapTag = "[object Map]";
      var objectTag = "[object Object]";
      var promiseTag = "[object Promise]";
      var setTag = "[object Set]";
      var weakMapTag = "[object WeakMap]";
      var dataViewTag = "[object DataView]";
      var dataViewCtorString = toSource(DataView2);
      var mapCtorString = toSource(Map2);
      var promiseCtorString = toSource(Promise2);
      var setCtorString = toSource(Set2);
      var weakMapCtorString = toSource(WeakMap2);
      var getTag = baseGetTag;
      if (DataView2 && getTag(new DataView2(new ArrayBuffer(1))) != dataViewTag || Map2 && getTag(new Map2()) != mapTag || Promise2 && getTag(Promise2.resolve()) != promiseTag || Set2 && getTag(new Set2()) != setTag || WeakMap2 && getTag(new WeakMap2()) != weakMapTag) {
        getTag = function(value) {
          var result = baseGetTag(value), Ctor = result == objectTag ? value.constructor : void 0, ctorString = Ctor ? toSource(Ctor) : "";
          if (ctorString) {
            switch (ctorString) {
              case dataViewCtorString:
                return dataViewTag;
              case mapCtorString:
                return mapTag;
              case promiseCtorString:
                return promiseTag;
              case setCtorString:
                return setTag;
              case weakMapCtorString:
                return weakMapTag;
            }
          }
          return result;
        };
      }
      module2.exports = getTag;
    }
  });

  // node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_initCloneArray.js
  var require_initCloneArray = __commonJS({
    "node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_initCloneArray.js"(exports2, module2) {
      var objectProto = Object.prototype;
      var hasOwnProperty = objectProto.hasOwnProperty;
      function initCloneArray(array) {
        var length = array.length, result = new array.constructor(length);
        if (length && typeof array[0] == "string" && hasOwnProperty.call(array, "index")) {
          result.index = array.index;
          result.input = array.input;
        }
        return result;
      }
      module2.exports = initCloneArray;
    }
  });

  // node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_cloneDataView.js
  var require_cloneDataView = __commonJS({
    "node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_cloneDataView.js"(exports2, module2) {
      var cloneArrayBuffer = require_cloneArrayBuffer();
      function cloneDataView(dataView, isDeep) {
        var buffer = isDeep ? cloneArrayBuffer(dataView.buffer) : dataView.buffer;
        return new dataView.constructor(buffer, dataView.byteOffset, dataView.byteLength);
      }
      module2.exports = cloneDataView;
    }
  });

  // node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_cloneRegExp.js
  var require_cloneRegExp = __commonJS({
    "node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_cloneRegExp.js"(exports2, module2) {
      var reFlags = /\w*$/;
      function cloneRegExp(regexp) {
        var result = new regexp.constructor(regexp.source, reFlags.exec(regexp));
        result.lastIndex = regexp.lastIndex;
        return result;
      }
      module2.exports = cloneRegExp;
    }
  });

  // node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_cloneSymbol.js
  var require_cloneSymbol = __commonJS({
    "node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_cloneSymbol.js"(exports2, module2) {
      var Symbol2 = require_Symbol();
      var symbolProto = Symbol2 ? Symbol2.prototype : void 0;
      var symbolValueOf = symbolProto ? symbolProto.valueOf : void 0;
      function cloneSymbol(symbol) {
        return symbolValueOf ? Object(symbolValueOf.call(symbol)) : {};
      }
      module2.exports = cloneSymbol;
    }
  });

  // node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_initCloneByTag.js
  var require_initCloneByTag = __commonJS({
    "node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_initCloneByTag.js"(exports2, module2) {
      var cloneArrayBuffer = require_cloneArrayBuffer();
      var cloneDataView = require_cloneDataView();
      var cloneRegExp = require_cloneRegExp();
      var cloneSymbol = require_cloneSymbol();
      var cloneTypedArray = require_cloneTypedArray();
      var boolTag = "[object Boolean]";
      var dateTag = "[object Date]";
      var mapTag = "[object Map]";
      var numberTag = "[object Number]";
      var regexpTag = "[object RegExp]";
      var setTag = "[object Set]";
      var stringTag = "[object String]";
      var symbolTag = "[object Symbol]";
      var arrayBufferTag = "[object ArrayBuffer]";
      var dataViewTag = "[object DataView]";
      var float32Tag = "[object Float32Array]";
      var float64Tag = "[object Float64Array]";
      var int8Tag = "[object Int8Array]";
      var int16Tag = "[object Int16Array]";
      var int32Tag = "[object Int32Array]";
      var uint8Tag = "[object Uint8Array]";
      var uint8ClampedTag = "[object Uint8ClampedArray]";
      var uint16Tag = "[object Uint16Array]";
      var uint32Tag = "[object Uint32Array]";
      function initCloneByTag(object, tag, isDeep) {
        var Ctor = object.constructor;
        switch (tag) {
          case arrayBufferTag:
            return cloneArrayBuffer(object);
          case boolTag:
          case dateTag:
            return new Ctor(+object);
          case dataViewTag:
            return cloneDataView(object, isDeep);
          case float32Tag:
          case float64Tag:
          case int8Tag:
          case int16Tag:
          case int32Tag:
          case uint8Tag:
          case uint8ClampedTag:
          case uint16Tag:
          case uint32Tag:
            return cloneTypedArray(object, isDeep);
          case mapTag:
            return new Ctor();
          case numberTag:
          case stringTag:
            return new Ctor(object);
          case regexpTag:
            return cloneRegExp(object);
          case setTag:
            return new Ctor();
          case symbolTag:
            return cloneSymbol(object);
        }
      }
      module2.exports = initCloneByTag;
    }
  });

  // node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_baseIsMap.js
  var require_baseIsMap = __commonJS({
    "node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_baseIsMap.js"(exports2, module2) {
      var getTag = require_getTag();
      var isObjectLike = require_isObjectLike();
      var mapTag = "[object Map]";
      function baseIsMap(value) {
        return isObjectLike(value) && getTag(value) == mapTag;
      }
      module2.exports = baseIsMap;
    }
  });

  // node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/isMap.js
  var require_isMap = __commonJS({
    "node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/isMap.js"(exports2, module2) {
      var baseIsMap = require_baseIsMap();
      var baseUnary = require_baseUnary();
      var nodeUtil = require_nodeUtil();
      var nodeIsMap = nodeUtil && nodeUtil.isMap;
      var isMap = nodeIsMap ? baseUnary(nodeIsMap) : baseIsMap;
      module2.exports = isMap;
    }
  });

  // node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_baseIsSet.js
  var require_baseIsSet = __commonJS({
    "node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_baseIsSet.js"(exports2, module2) {
      var getTag = require_getTag();
      var isObjectLike = require_isObjectLike();
      var setTag = "[object Set]";
      function baseIsSet(value) {
        return isObjectLike(value) && getTag(value) == setTag;
      }
      module2.exports = baseIsSet;
    }
  });

  // node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/isSet.js
  var require_isSet = __commonJS({
    "node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/isSet.js"(exports2, module2) {
      var baseIsSet = require_baseIsSet();
      var baseUnary = require_baseUnary();
      var nodeUtil = require_nodeUtil();
      var nodeIsSet = nodeUtil && nodeUtil.isSet;
      var isSet = nodeIsSet ? baseUnary(nodeIsSet) : baseIsSet;
      module2.exports = isSet;
    }
  });

  // node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_baseClone.js
  var require_baseClone = __commonJS({
    "node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_baseClone.js"(exports2, module2) {
      var Stack = require_Stack();
      var arrayEach = require_arrayEach();
      var assignValue = require_assignValue();
      var baseAssign = require_baseAssign();
      var baseAssignIn = require_baseAssignIn();
      var cloneBuffer = require_cloneBuffer();
      var copyArray = require_copyArray();
      var copySymbols = require_copySymbols();
      var copySymbolsIn = require_copySymbolsIn();
      var getAllKeys = require_getAllKeys();
      var getAllKeysIn = require_getAllKeysIn();
      var getTag = require_getTag();
      var initCloneArray = require_initCloneArray();
      var initCloneByTag = require_initCloneByTag();
      var initCloneObject = require_initCloneObject();
      var isArray = require_isArray();
      var isBuffer = require_isBuffer();
      var isMap = require_isMap();
      var isObject = require_isObject();
      var isSet = require_isSet();
      var keys = require_keys();
      var keysIn = require_keysIn();
      var CLONE_DEEP_FLAG = 1;
      var CLONE_FLAT_FLAG = 2;
      var CLONE_SYMBOLS_FLAG = 4;
      var argsTag = "[object Arguments]";
      var arrayTag = "[object Array]";
      var boolTag = "[object Boolean]";
      var dateTag = "[object Date]";
      var errorTag = "[object Error]";
      var funcTag = "[object Function]";
      var genTag = "[object GeneratorFunction]";
      var mapTag = "[object Map]";
      var numberTag = "[object Number]";
      var objectTag = "[object Object]";
      var regexpTag = "[object RegExp]";
      var setTag = "[object Set]";
      var stringTag = "[object String]";
      var symbolTag = "[object Symbol]";
      var weakMapTag = "[object WeakMap]";
      var arrayBufferTag = "[object ArrayBuffer]";
      var dataViewTag = "[object DataView]";
      var float32Tag = "[object Float32Array]";
      var float64Tag = "[object Float64Array]";
      var int8Tag = "[object Int8Array]";
      var int16Tag = "[object Int16Array]";
      var int32Tag = "[object Int32Array]";
      var uint8Tag = "[object Uint8Array]";
      var uint8ClampedTag = "[object Uint8ClampedArray]";
      var uint16Tag = "[object Uint16Array]";
      var uint32Tag = "[object Uint32Array]";
      var cloneableTags = {};
      cloneableTags[argsTag] = cloneableTags[arrayTag] = cloneableTags[arrayBufferTag] = cloneableTags[dataViewTag] = cloneableTags[boolTag] = cloneableTags[dateTag] = cloneableTags[float32Tag] = cloneableTags[float64Tag] = cloneableTags[int8Tag] = cloneableTags[int16Tag] = cloneableTags[int32Tag] = cloneableTags[mapTag] = cloneableTags[numberTag] = cloneableTags[objectTag] = cloneableTags[regexpTag] = cloneableTags[setTag] = cloneableTags[stringTag] = cloneableTags[symbolTag] = cloneableTags[uint8Tag] = cloneableTags[uint8ClampedTag] = cloneableTags[uint16Tag] = cloneableTags[uint32Tag] = true;
      cloneableTags[errorTag] = cloneableTags[funcTag] = cloneableTags[weakMapTag] = false;
      function baseClone(value, bitmask, customizer, key, object, stack) {
        var result, isDeep = bitmask & CLONE_DEEP_FLAG, isFlat = bitmask & CLONE_FLAT_FLAG, isFull = bitmask & CLONE_SYMBOLS_FLAG;
        if (customizer) {
          result = object ? customizer(value, key, object, stack) : customizer(value);
        }
        if (result !== void 0) {
          return result;
        }
        if (!isObject(value)) {
          return value;
        }
        var isArr = isArray(value);
        if (isArr) {
          result = initCloneArray(value);
          if (!isDeep) {
            return copyArray(value, result);
          }
        } else {
          var tag = getTag(value), isFunc = tag == funcTag || tag == genTag;
          if (isBuffer(value)) {
            return cloneBuffer(value, isDeep);
          }
          if (tag == objectTag || tag == argsTag || isFunc && !object) {
            result = isFlat || isFunc ? {} : initCloneObject(value);
            if (!isDeep) {
              return isFlat ? copySymbolsIn(value, baseAssignIn(result, value)) : copySymbols(value, baseAssign(result, value));
            }
          } else {
            if (!cloneableTags[tag]) {
              return object ? value : {};
            }
            result = initCloneByTag(value, tag, isDeep);
          }
        }
        stack || (stack = new Stack());
        var stacked = stack.get(value);
        if (stacked) {
          return stacked;
        }
        stack.set(value, result);
        if (isSet(value)) {
          value.forEach(function(subValue) {
            result.add(baseClone(subValue, bitmask, customizer, subValue, value, stack));
          });
        } else if (isMap(value)) {
          value.forEach(function(subValue, key2) {
            result.set(key2, baseClone(subValue, bitmask, customizer, key2, value, stack));
          });
        }
        var keysFunc = isFull ? isFlat ? getAllKeysIn : getAllKeys : isFlat ? keysIn : keys;
        var props = isArr ? void 0 : keysFunc(value);
        arrayEach(props || value, function(subValue, key2) {
          if (props) {
            key2 = subValue;
            subValue = value[key2];
          }
          assignValue(result, key2, baseClone(subValue, bitmask, customizer, key2, value, stack));
        });
        return result;
      }
      module2.exports = baseClone;
    }
  });

  // node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/cloneDeep.js
  var require_cloneDeep = __commonJS({
    "node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/cloneDeep.js"(exports2, module2) {
      var baseClone = require_baseClone();
      var CLONE_DEEP_FLAG = 1;
      var CLONE_SYMBOLS_FLAG = 4;
      function cloneDeep(value) {
        return baseClone(value, CLONE_DEEP_FLAG | CLONE_SYMBOLS_FLAG);
      }
      module2.exports = cloneDeep;
    }
  });

  // node_modules/.pnpm/renderkid@3.0.0/node_modules/renderkid/lib/tools.js
  var require_tools = __commonJS({
    "node_modules/.pnpm/renderkid@3.0.0/node_modules/renderkid/lib/tools.js"(exports2, module2) {
      "use strict";
      var cloneDeep;
      var htmlparser;
      var isPlainObject;
      var merge;
      var _objectToDom;
      var self2;
      htmlparser = require_lib6();
      var _require = require_domConverter();
      _objectToDom = _require.objectToDom;
      merge = require_merge();
      cloneDeep = require_cloneDeep();
      isPlainObject = require_isPlainObject();
      module2.exports = self2 = {
        repeatString: function repeatString(str, times) {
          var i, j, output, ref;
          output = "";
          for (i = j = 0, ref = times; 0 <= ref ? j < ref : j > ref; i = 0 <= ref ? ++j : --j) {
            output += str;
          }
          return output;
        },
        cloneAndMergeDeep: function cloneAndMergeDeep(base, toAppend) {
          return merge(cloneDeep(base), toAppend);
        },
        toDom: function toDom(subject) {
          if (typeof subject === "string") {
            return self2.stringToDom(subject);
          } else if (isPlainObject(subject)) {
            return self2._objectToDom(subject);
          } else {
            throw Error("tools.toDom() only supports strings and objects");
          }
        },
        stringToDom: function stringToDom(string) {
          var handler, parser;
          handler = new htmlparser.DomHandler();
          parser = new htmlparser.Parser(handler);
          parser.write(string);
          parser.end();
          return handler.dom;
        },
        _fixQuotesInDom: function _fixQuotesInDom(input) {
          var j, len, node;
          if (Array.isArray(input)) {
            for (j = 0, len = input.length; j < len; j++) {
              node = input[j];
              self2._fixQuotesInDom(node);
            }
            return input;
          }
          node = input;
          if (node.type === "text") {
            return node.data = self2._quoteNodeText(node.data);
          } else {
            return self2._fixQuotesInDom(node.children);
          }
        },
        objectToDom: function objectToDom(o) {
          if (!Array.isArray(o)) {
            if (!isPlainObject(o)) {
              throw Error("objectToDom() only accepts a bare object or an array");
            }
          }
          return self2._fixQuotesInDom(_objectToDom(o));
        },
        quote: function quote(str) {
          return String(str).replace(/</g, "&lt;").replace(/>/g, "&gt;").replace(/\"/g, "&quot;").replace(/\ /g, "&sp;").replace(/\n/g, "<br />");
        },
        _quoteNodeText: function _quoteNodeText(text) {
          return String(text).replace(/\&/g, "&amp;").replace(/</g, "&lt;").replace(/>/g, "&gt;").replace(/\"/g, "&quot;").replace(/\ /g, "&sp;").replace(/\n/g, "&nl;");
        },
        getCols: function getCols() {
          var cols, tty3;
          tty3 = __require("tty");
          cols = function() {
            try {
              if (tty3.isatty(1) && tty3.isatty(2)) {
                if (process.stdout.getWindowSize) {
                  return process.stdout.getWindowSize(1)[0];
                } else if (tty3.getWindowSize) {
                  return tty3.getWindowSize()[1];
                } else if (process.stdout.columns) {
                  return process.stdout.columns;
                }
              }
            } catch (error) {
            }
          }();
          if (typeof cols === "number" && cols > 30) {
            return cols;
          } else {
            return 80;
          }
        }
      };
    }
  });

  // node_modules/.pnpm/renderkid@3.0.0/node_modules/renderkid/lib/ansiPainter/tags.js
  var require_tags = __commonJS({
    "node_modules/.pnpm/renderkid@3.0.0/node_modules/renderkid/lib/ansiPainter/tags.js"(exports2, module2) {
      "use strict";
      var color;
      var colors;
      var i;
      var len;
      var tags;
      module2.exports = tags = {
        "none": {
          color: "none",
          bg: "none"
        },
        "bg-none": {
          color: "inherit",
          bg: "none"
        },
        "color-none": {
          color: "none",
          bg: "inherit"
        }
      };
      colors = ["black", "red", "green", "yellow", "blue", "magenta", "cyan", "white", "grey", "bright-red", "bright-green", "bright-yellow", "bright-blue", "bright-magenta", "bright-cyan", "bright-white"];
      for (i = 0, len = colors.length; i < len; i++) {
        color = colors[i];
        tags[color] = {
          color,
          bg: "inherit"
        };
        tags["color-".concat(color)] = {
          color,
          bg: "inherit"
        };
        tags["bg-".concat(color)] = {
          color: "inherit",
          bg: color
        };
      }
    }
  });

  // node_modules/.pnpm/renderkid@3.0.0/node_modules/renderkid/lib/ansiPainter/styles.js
  var require_styles = __commonJS({
    "node_modules/.pnpm/renderkid@3.0.0/node_modules/renderkid/lib/ansiPainter/styles.js"(exports2, module2) {
      "use strict";
      var codes;
      var styles5;
      module2.exports = styles5 = {};
      styles5.codes = codes = {
        "none": 0,
        "black": 30,
        "red": 31,
        "green": 32,
        "yellow": 33,
        "blue": 34,
        "magenta": 35,
        "cyan": 36,
        "white": 37,
        "grey": 90,
        "bright-red": 91,
        "bright-green": 92,
        "bright-yellow": 93,
        "bright-blue": 94,
        "bright-magenta": 95,
        "bright-cyan": 96,
        "bright-white": 97,
        "bg-black": 40,
        "bg-red": 41,
        "bg-green": 42,
        "bg-yellow": 43,
        "bg-blue": 44,
        "bg-magenta": 45,
        "bg-cyan": 46,
        "bg-white": 47,
        "bg-grey": 100,
        "bg-bright-red": 101,
        "bg-bright-green": 102,
        "bg-bright-yellow": 103,
        "bg-bright-blue": 104,
        "bg-bright-magenta": 105,
        "bg-bright-cyan": 106,
        "bg-bright-white": 107
      };
      styles5.color = function(str) {
        var code;
        if (str === "none") {
          return "";
        }
        code = codes[str];
        if (code == null) {
          throw Error("Unknown color `".concat(str, "`"));
        }
        return "\x1B[" + code + "m";
      };
      styles5.bg = function(str) {
        var code;
        if (str === "none") {
          return "";
        }
        code = codes["bg-" + str];
        if (code == null) {
          throw Error("Unknown bg color `".concat(str, "`"));
        }
        return "\x1B[" + code + "m";
      };
      styles5.none = function(str) {
        return "\x1B[" + codes.none + "m";
      };
    }
  });

  // node_modules/.pnpm/renderkid@3.0.0/node_modules/renderkid/lib/AnsiPainter.js
  var require_AnsiPainter = __commonJS({
    "node_modules/.pnpm/renderkid@3.0.0/node_modules/renderkid/lib/AnsiPainter.js"(exports2, module2) {
      "use strict";
      function _classCallCheck(instance, Constructor) {
        if (!(instance instanceof Constructor)) {
          throw new TypeError("Cannot call a class as a function");
        }
      }
      function _defineProperties(target, props) {
        for (var i = 0; i < props.length; i++) {
          var descriptor = props[i];
          descriptor.enumerable = descriptor.enumerable || false;
          descriptor.configurable = true;
          if ("value" in descriptor)
            descriptor.writable = true;
          Object.defineProperty(target, descriptor.key, descriptor);
        }
      }
      function _createClass(Constructor, protoProps, staticProps) {
        if (protoProps)
          _defineProperties(Constructor.prototype, protoProps);
        if (staticProps)
          _defineProperties(Constructor, staticProps);
        return Constructor;
      }
      var AnsiPainter;
      var styles5;
      var tags;
      var tools;
      var hasProp = {}.hasOwnProperty;
      tools = require_tools();
      tags = require_tags();
      styles5 = require_styles();
      module2.exports = AnsiPainter = function() {
        var self2;
        var AnsiPainter2 = /* @__PURE__ */ function() {
          function AnsiPainter3() {
            _classCallCheck(this, AnsiPainter3);
          }
          _createClass(AnsiPainter3, [{
            key: "paint",
            value: function paint(s) {
              return this._replaceSpecialStrings(this._renderDom(this._parse(s)));
            }
          }, {
            key: "_replaceSpecialStrings",
            value: function _replaceSpecialStrings(str) {
              return str.replace(/&sp;/g, " ").replace(/&lt;/g, "<").replace(/&gt;/g, ">").replace(/&quot;/g, '"').replace(/&amp;/g, "&");
            }
          }, {
            key: "_parse",
            value: function _parse(string) {
              var injectFakeRoot = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : true;
              if (injectFakeRoot) {
                string = "<none>" + string + "</none>";
              }
              return tools.toDom(string);
            }
          }, {
            key: "_renderDom",
            value: function _renderDom(dom) {
              var parentStyles;
              parentStyles = {
                bg: "none",
                color: "none"
              };
              return this._renderChildren(dom, parentStyles);
            }
          }, {
            key: "_renderChildren",
            value: function _renderChildren(children, parentStyles) {
              var child, n, ret;
              ret = "";
              for (n in children) {
                if (!hasProp.call(children, n))
                  continue;
                child = children[n];
                ret += this._renderNode(child, parentStyles);
              }
              return ret;
            }
          }, {
            key: "_renderNode",
            value: function _renderNode(node, parentStyles) {
              if (node.type === "text") {
                return this._renderTextNode(node, parentStyles);
              } else {
                return this._renderTag(node, parentStyles);
              }
            }
          }, {
            key: "_renderTextNode",
            value: function _renderTextNode(node, parentStyles) {
              return this._wrapInStyle(node.data, parentStyles);
            }
          }, {
            key: "_wrapInStyle",
            value: function _wrapInStyle(str, style) {
              return styles5.color(style.color) + styles5.bg(style.bg) + str + styles5.none();
            }
          }, {
            key: "_renderTag",
            value: function _renderTag(node, parentStyles) {
              var currentStyles, tagStyles;
              tagStyles = this._getStylesForTagName(node.name);
              currentStyles = this._mixStyles(parentStyles, tagStyles);
              return this._renderChildren(node.children, currentStyles);
            }
          }, {
            key: "_mixStyles",
            value: function _mixStyles() {
              var final, i, key, len, style, val;
              final = {};
              for (var _len = arguments.length, styles6 = new Array(_len), _key = 0; _key < _len; _key++) {
                styles6[_key] = arguments[_key];
              }
              for (i = 0, len = styles6.length; i < len; i++) {
                style = styles6[i];
                for (key in style) {
                  if (!hasProp.call(style, key))
                    continue;
                  val = style[key];
                  if (final[key] == null || val !== "inherit") {
                    final[key] = val;
                  }
                }
              }
              return final;
            }
          }, {
            key: "_getStylesForTagName",
            value: function _getStylesForTagName(name) {
              if (tags[name] == null) {
                throw Error("Unknown tag name `".concat(name, "`"));
              }
              return tags[name];
            }
          }], [{
            key: "getInstance",
            value: function getInstance() {
              if (self2._instance == null) {
                self2._instance = new self2();
              }
              return self2._instance;
            }
          }, {
            key: "paint",
            value: function paint(str) {
              return self2.getInstance().paint(str);
            }
          }, {
            key: "strip",
            value: function strip(s) {
              return s.replace(/\x1b\[[0-9]+m/g, "");
            }
          }]);
          return AnsiPainter3;
        }();
        ;
        AnsiPainter2.tags = tags;
        self2 = AnsiPainter2;
        return AnsiPainter2;
      }.call(void 0);
    }
  });

  // node_modules/.pnpm/renderkid@3.0.0/node_modules/renderkid/lib/renderKid/styleApplier/_common.js
  var require_common2 = __commonJS({
    "node_modules/.pnpm/renderkid@3.0.0/node_modules/renderkid/lib/renderKid/styleApplier/_common.js"(exports2, module2) {
      "use strict";
      var AnsiPainter;
      var _common;
      AnsiPainter = require_AnsiPainter();
      module2.exports = _common = {
        getStyleTagsFor: function getStyleTagsFor(style) {
          var i, len, ret, tag, tagName, tagsToAdd;
          tagsToAdd = [];
          if (style.color != null) {
            tagName = "color-" + style.color;
            if (AnsiPainter.tags[tagName] == null) {
              throw Error("Unknown color `".concat(style.color, "`"));
            }
            tagsToAdd.push(tagName);
          }
          if (style.background != null) {
            tagName = "bg-" + style.background;
            if (AnsiPainter.tags[tagName] == null) {
              throw Error("Unknown background `".concat(style.background, "`"));
            }
            tagsToAdd.push(tagName);
          }
          ret = {
            before: "",
            after: ""
          };
          for (i = 0, len = tagsToAdd.length; i < len; i++) {
            tag = tagsToAdd[i];
            ret.before = "<".concat(tag, ">") + ret.before;
            ret.after = ret.after + "</".concat(tag, ">");
          }
          return ret;
        }
      };
    }
  });

  // node_modules/.pnpm/renderkid@3.0.0/node_modules/renderkid/lib/renderKid/styleApplier/inline.js
  var require_inline = __commonJS({
    "node_modules/.pnpm/renderkid@3.0.0/node_modules/renderkid/lib/renderKid/styleApplier/inline.js"(exports2, module2) {
      "use strict";
      var _common;
      var inlineStyleApplier;
      var self2;
      var tools;
      tools = require_tools();
      _common = require_common2();
      module2.exports = inlineStyleApplier = self2 = {
        applyTo: function applyTo(el, style) {
          var ret;
          ret = _common.getStyleTagsFor(style);
          if (style.marginLeft != null) {
            ret.before = tools.repeatString("&sp;", parseInt(style.marginLeft)) + ret.before;
          }
          if (style.marginRight != null) {
            ret.after += tools.repeatString("&sp;", parseInt(style.marginRight));
          }
          if (style.paddingLeft != null) {
            ret.before += tools.repeatString("&sp;", parseInt(style.paddingLeft));
          }
          if (style.paddingRight != null) {
            ret.after = tools.repeatString("&sp;", parseInt(style.paddingRight)) + ret.after;
          }
          return ret;
        }
      };
    }
  });

  // node_modules/.pnpm/renderkid@3.0.0/node_modules/renderkid/lib/renderKid/styleApplier/block.js
  var require_block = __commonJS({
    "node_modules/.pnpm/renderkid@3.0.0/node_modules/renderkid/lib/renderKid/styleApplier/block.js"(exports2, module2) {
      "use strict";
      var _common;
      var blockStyleApplier;
      var merge;
      var self2;
      _common = require_common2();
      merge = require_merge();
      module2.exports = blockStyleApplier = self2 = {
        applyTo: function applyTo(el, style) {
          var config2, ret;
          ret = _common.getStyleTagsFor(style);
          ret.blockConfig = config2 = {};
          this._margins(style, config2);
          this._bullet(style, config2);
          this._dims(style, config2);
          return ret;
        },
        _margins: function _margins(style, config2) {
          if (style.marginLeft != null) {
            merge(config2, {
              linePrependor: {
                options: {
                  amount: parseInt(style.marginLeft)
                }
              }
            });
          }
          if (style.marginRight != null) {
            merge(config2, {
              lineAppendor: {
                options: {
                  amount: parseInt(style.marginRight)
                }
              }
            });
          }
          if (style.marginTop != null) {
            merge(config2, {
              blockPrependor: {
                options: {
                  amount: parseInt(style.marginTop)
                }
              }
            });
          }
          if (style.marginBottom != null) {
            merge(config2, {
              blockAppendor: {
                options: {
                  amount: parseInt(style.marginBottom)
                }
              }
            });
          }
        },
        _bullet: function _bullet(style, config2) {
          var after, before, bullet, conf;
          if (style.bullet != null && style.bullet.enabled) {
            bullet = style.bullet;
            conf = {};
            conf.alignment = style.bullet.alignment;
            var _common$getStyleTagsF = _common.getStyleTagsFor({
              color: bullet.color,
              background: bullet.background
            });
            before = _common$getStyleTagsF.before;
            after = _common$getStyleTagsF.after;
            conf.char = before + bullet.char + after;
            merge(config2, {
              linePrependor: {
                options: {
                  bullet: conf
                }
              }
            });
          }
        },
        _dims: function _dims(style, config2) {
          var w;
          if (style.width != null) {
            w = parseInt(style.width);
            config2.width = w;
          }
        }
      };
    }
  });

  // node_modules/.pnpm/boolbase@1.0.0/node_modules/boolbase/index.js
  var require_boolbase = __commonJS({
    "node_modules/.pnpm/boolbase@1.0.0/node_modules/boolbase/index.js"(exports2, module2) {
      module2.exports = {
        trueFunc: function trueFunc() {
          return true;
        },
        falseFunc: function falseFunc() {
          return false;
        }
      };
    }
  });

  // node_modules/.pnpm/css-what@6.1.0/node_modules/css-what/lib/commonjs/types.js
  var require_types = __commonJS({
    "node_modules/.pnpm/css-what@6.1.0/node_modules/css-what/lib/commonjs/types.js"(exports2) {
      "use strict";
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.AttributeAction = exports2.IgnoreCaseMode = exports2.SelectorType = void 0;
      var SelectorType;
      (function(SelectorType2) {
        SelectorType2["Attribute"] = "attribute";
        SelectorType2["Pseudo"] = "pseudo";
        SelectorType2["PseudoElement"] = "pseudo-element";
        SelectorType2["Tag"] = "tag";
        SelectorType2["Universal"] = "universal";
        SelectorType2["Adjacent"] = "adjacent";
        SelectorType2["Child"] = "child";
        SelectorType2["Descendant"] = "descendant";
        SelectorType2["Parent"] = "parent";
        SelectorType2["Sibling"] = "sibling";
        SelectorType2["ColumnCombinator"] = "column-combinator";
      })(SelectorType = exports2.SelectorType || (exports2.SelectorType = {}));
      exports2.IgnoreCaseMode = {
        Unknown: null,
        QuirksMode: "quirks",
        IgnoreCase: true,
        CaseSensitive: false
      };
      var AttributeAction;
      (function(AttributeAction2) {
        AttributeAction2["Any"] = "any";
        AttributeAction2["Element"] = "element";
        AttributeAction2["End"] = "end";
        AttributeAction2["Equals"] = "equals";
        AttributeAction2["Exists"] = "exists";
        AttributeAction2["Hyphen"] = "hyphen";
        AttributeAction2["Not"] = "not";
        AttributeAction2["Start"] = "start";
      })(AttributeAction = exports2.AttributeAction || (exports2.AttributeAction = {}));
    }
  });

  // node_modules/.pnpm/css-what@6.1.0/node_modules/css-what/lib/commonjs/parse.js
  var require_parse = __commonJS({
    "node_modules/.pnpm/css-what@6.1.0/node_modules/css-what/lib/commonjs/parse.js"(exports2) {
      "use strict";
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.parse = exports2.isTraversal = void 0;
      var types_1 = require_types();
      var reName = /^[^\\#]?(?:\\(?:[\da-f]{1,6}\s?|.)|[\w\-\u00b0-\uFFFF])+/;
      var reEscape = /\\([\da-f]{1,6}\s?|(\s)|.)/gi;
      var actionTypes = /* @__PURE__ */ new Map([
        [126, types_1.AttributeAction.Element],
        [94, types_1.AttributeAction.Start],
        [36, types_1.AttributeAction.End],
        [42, types_1.AttributeAction.Any],
        [33, types_1.AttributeAction.Not],
        [124, types_1.AttributeAction.Hyphen]
      ]);
      var unpackPseudos = /* @__PURE__ */ new Set([
        "has",
        "not",
        "matches",
        "is",
        "where",
        "host",
        "host-context"
      ]);
      function isTraversal(selector) {
        switch (selector.type) {
          case types_1.SelectorType.Adjacent:
          case types_1.SelectorType.Child:
          case types_1.SelectorType.Descendant:
          case types_1.SelectorType.Parent:
          case types_1.SelectorType.Sibling:
          case types_1.SelectorType.ColumnCombinator:
            return true;
          default:
            return false;
        }
      }
      exports2.isTraversal = isTraversal;
      var stripQuotesFromPseudos = /* @__PURE__ */ new Set(["contains", "icontains"]);
      function funescape(_, escaped, escapedWhitespace) {
        var high = parseInt(escaped, 16) - 65536;
        return high !== high || escapedWhitespace ? escaped : high < 0 ? (
          // BMP codepoint
          String.fromCharCode(high + 65536)
        ) : (
          // Supplemental Plane codepoint (surrogate pair)
          String.fromCharCode(high >> 10 | 55296, high & 1023 | 56320)
        );
      }
      function unescapeCSS(str) {
        return str.replace(reEscape, funescape);
      }
      function isQuote(c) {
        return c === 39 || c === 34;
      }
      function isWhitespace(c) {
        return c === 32 || c === 9 || c === 10 || c === 12 || c === 13;
      }
      function parse4(selector) {
        var subselects = [];
        var endIndex = parseSelector(subselects, "".concat(selector), 0);
        if (endIndex < selector.length) {
          throw new Error("Unmatched selector: ".concat(selector.slice(endIndex)));
        }
        return subselects;
      }
      exports2.parse = parse4;
      function parseSelector(subselects, selector, selectorIndex) {
        var tokens = [];
        function getName(offset) {
          var match = selector.slice(selectorIndex + offset).match(reName);
          if (!match) {
            throw new Error("Expected name, found ".concat(selector.slice(selectorIndex)));
          }
          var name = match[0];
          selectorIndex += offset + name.length;
          return unescapeCSS(name);
        }
        function stripWhitespace(offset) {
          selectorIndex += offset;
          while (selectorIndex < selector.length && isWhitespace(selector.charCodeAt(selectorIndex))) {
            selectorIndex++;
          }
        }
        function readValueWithParenthesis() {
          selectorIndex += 1;
          var start = selectorIndex;
          var counter = 1;
          for (; counter > 0 && selectorIndex < selector.length; selectorIndex++) {
            if (selector.charCodeAt(selectorIndex) === 40 && !isEscaped(selectorIndex)) {
              counter++;
            } else if (selector.charCodeAt(selectorIndex) === 41 && !isEscaped(selectorIndex)) {
              counter--;
            }
          }
          if (counter) {
            throw new Error("Parenthesis not matched");
          }
          return unescapeCSS(selector.slice(start, selectorIndex - 1));
        }
        function isEscaped(pos) {
          var slashCount = 0;
          while (selector.charCodeAt(--pos) === 92)
            slashCount++;
          return (slashCount & 1) === 1;
        }
        function ensureNotTraversal() {
          if (tokens.length > 0 && isTraversal(tokens[tokens.length - 1])) {
            throw new Error("Did not expect successive traversals.");
          }
        }
        function addTraversal(type) {
          if (tokens.length > 0 && tokens[tokens.length - 1].type === types_1.SelectorType.Descendant) {
            tokens[tokens.length - 1].type = type;
            return;
          }
          ensureNotTraversal();
          tokens.push({ type });
        }
        function addSpecialAttribute(name, action3) {
          tokens.push({
            type: types_1.SelectorType.Attribute,
            name,
            action: action3,
            value: getName(1),
            namespace: null,
            ignoreCase: "quirks"
          });
        }
        function finalizeSubselector() {
          if (tokens.length && tokens[tokens.length - 1].type === types_1.SelectorType.Descendant) {
            tokens.pop();
          }
          if (tokens.length === 0) {
            throw new Error("Empty sub-selector");
          }
          subselects.push(tokens);
        }
        stripWhitespace(0);
        if (selector.length === selectorIndex) {
          return selectorIndex;
        }
        loop:
          while (selectorIndex < selector.length) {
            var firstChar = selector.charCodeAt(selectorIndex);
            switch (firstChar) {
              case 32:
              case 9:
              case 10:
              case 12:
              case 13: {
                if (tokens.length === 0 || tokens[0].type !== types_1.SelectorType.Descendant) {
                  ensureNotTraversal();
                  tokens.push({ type: types_1.SelectorType.Descendant });
                }
                stripWhitespace(1);
                break;
              }
              case 62: {
                addTraversal(types_1.SelectorType.Child);
                stripWhitespace(1);
                break;
              }
              case 60: {
                addTraversal(types_1.SelectorType.Parent);
                stripWhitespace(1);
                break;
              }
              case 126: {
                addTraversal(types_1.SelectorType.Sibling);
                stripWhitespace(1);
                break;
              }
              case 43: {
                addTraversal(types_1.SelectorType.Adjacent);
                stripWhitespace(1);
                break;
              }
              case 46: {
                addSpecialAttribute("class", types_1.AttributeAction.Element);
                break;
              }
              case 35: {
                addSpecialAttribute("id", types_1.AttributeAction.Equals);
                break;
              }
              case 91: {
                stripWhitespace(1);
                var name_1 = void 0;
                var namespace = null;
                if (selector.charCodeAt(selectorIndex) === 124) {
                  name_1 = getName(1);
                } else if (selector.startsWith("*|", selectorIndex)) {
                  namespace = "*";
                  name_1 = getName(2);
                } else {
                  name_1 = getName(0);
                  if (selector.charCodeAt(selectorIndex) === 124 && selector.charCodeAt(selectorIndex + 1) !== 61) {
                    namespace = name_1;
                    name_1 = getName(1);
                  }
                }
                stripWhitespace(0);
                var action2 = types_1.AttributeAction.Exists;
                var possibleAction = actionTypes.get(selector.charCodeAt(selectorIndex));
                if (possibleAction) {
                  action2 = possibleAction;
                  if (selector.charCodeAt(selectorIndex + 1) !== 61) {
                    throw new Error("Expected `=`");
                  }
                  stripWhitespace(2);
                } else if (selector.charCodeAt(selectorIndex) === 61) {
                  action2 = types_1.AttributeAction.Equals;
                  stripWhitespace(1);
                }
                var value = "";
                var ignoreCase = null;
                if (action2 !== "exists") {
                  if (isQuote(selector.charCodeAt(selectorIndex))) {
                    var quote = selector.charCodeAt(selectorIndex);
                    var sectionEnd = selectorIndex + 1;
                    while (sectionEnd < selector.length && (selector.charCodeAt(sectionEnd) !== quote || isEscaped(sectionEnd))) {
                      sectionEnd += 1;
                    }
                    if (selector.charCodeAt(sectionEnd) !== quote) {
                      throw new Error("Attribute value didn't end");
                    }
                    value = unescapeCSS(selector.slice(selectorIndex + 1, sectionEnd));
                    selectorIndex = sectionEnd + 1;
                  } else {
                    var valueStart = selectorIndex;
                    while (selectorIndex < selector.length && (!isWhitespace(selector.charCodeAt(selectorIndex)) && selector.charCodeAt(selectorIndex) !== 93 || isEscaped(selectorIndex))) {
                      selectorIndex += 1;
                    }
                    value = unescapeCSS(selector.slice(valueStart, selectorIndex));
                  }
                  stripWhitespace(0);
                  var forceIgnore = selector.charCodeAt(selectorIndex) | 32;
                  if (forceIgnore === 115) {
                    ignoreCase = false;
                    stripWhitespace(1);
                  } else if (forceIgnore === 105) {
                    ignoreCase = true;
                    stripWhitespace(1);
                  }
                }
                if (selector.charCodeAt(selectorIndex) !== 93) {
                  throw new Error("Attribute selector didn't terminate");
                }
                selectorIndex += 1;
                var attributeSelector = {
                  type: types_1.SelectorType.Attribute,
                  name: name_1,
                  action: action2,
                  value,
                  namespace,
                  ignoreCase
                };
                tokens.push(attributeSelector);
                break;
              }
              case 58: {
                if (selector.charCodeAt(selectorIndex + 1) === 58) {
                  tokens.push({
                    type: types_1.SelectorType.PseudoElement,
                    name: getName(2).toLowerCase(),
                    data: selector.charCodeAt(selectorIndex) === 40 ? readValueWithParenthesis() : null
                  });
                  continue;
                }
                var name_2 = getName(1).toLowerCase();
                var data = null;
                if (selector.charCodeAt(selectorIndex) === 40) {
                  if (unpackPseudos.has(name_2)) {
                    if (isQuote(selector.charCodeAt(selectorIndex + 1))) {
                      throw new Error("Pseudo-selector ".concat(name_2, " cannot be quoted"));
                    }
                    data = [];
                    selectorIndex = parseSelector(data, selector, selectorIndex + 1);
                    if (selector.charCodeAt(selectorIndex) !== 41) {
                      throw new Error("Missing closing parenthesis in :".concat(name_2, " (").concat(selector, ")"));
                    }
                    selectorIndex += 1;
                  } else {
                    data = readValueWithParenthesis();
                    if (stripQuotesFromPseudos.has(name_2)) {
                      var quot = data.charCodeAt(0);
                      if (quot === data.charCodeAt(data.length - 1) && isQuote(quot)) {
                        data = data.slice(1, -1);
                      }
                    }
                    data = unescapeCSS(data);
                  }
                }
                tokens.push({ type: types_1.SelectorType.Pseudo, name: name_2, data });
                break;
              }
              case 44: {
                finalizeSubselector();
                tokens = [];
                stripWhitespace(1);
                break;
              }
              default: {
                if (selector.startsWith("/*", selectorIndex)) {
                  var endIndex = selector.indexOf("*/", selectorIndex + 2);
                  if (endIndex < 0) {
                    throw new Error("Comment was not terminated");
                  }
                  selectorIndex = endIndex + 2;
                  if (tokens.length === 0) {
                    stripWhitespace(0);
                  }
                  break;
                }
                var namespace = null;
                var name_3 = void 0;
                if (firstChar === 42) {
                  selectorIndex += 1;
                  name_3 = "*";
                } else if (firstChar === 124) {
                  name_3 = "";
                  if (selector.charCodeAt(selectorIndex + 1) === 124) {
                    addTraversal(types_1.SelectorType.ColumnCombinator);
                    stripWhitespace(2);
                    break;
                  }
                } else if (reName.test(selector.slice(selectorIndex))) {
                  name_3 = getName(0);
                } else {
                  break loop;
                }
                if (selector.charCodeAt(selectorIndex) === 124 && selector.charCodeAt(selectorIndex + 1) !== 124) {
                  namespace = name_3;
                  if (selector.charCodeAt(selectorIndex + 1) === 42) {
                    name_3 = "*";
                    selectorIndex += 2;
                  } else {
                    name_3 = getName(1);
                  }
                }
                tokens.push(name_3 === "*" ? { type: types_1.SelectorType.Universal, namespace } : { type: types_1.SelectorType.Tag, name: name_3, namespace });
              }
            }
          }
        finalizeSubselector();
        return selectorIndex;
      }
    }
  });

  // node_modules/.pnpm/css-what@6.1.0/node_modules/css-what/lib/commonjs/stringify.js
  var require_stringify2 = __commonJS({
    "node_modules/.pnpm/css-what@6.1.0/node_modules/css-what/lib/commonjs/stringify.js"(exports2) {
      "use strict";
      var __spreadArray = exports2 && exports2.__spreadArray || function(to, from, pack) {
        if (pack || arguments.length === 2)
          for (var i = 0, l = from.length, ar; i < l; i++) {
            if (ar || !(i in from)) {
              if (!ar)
                ar = Array.prototype.slice.call(from, 0, i);
              ar[i] = from[i];
            }
          }
        return to.concat(ar || Array.prototype.slice.call(from));
      };
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.stringify = void 0;
      var types_1 = require_types();
      var attribValChars = ["\\", '"'];
      var pseudoValChars = __spreadArray(__spreadArray([], attribValChars, true), ["(", ")"], false);
      var charsToEscapeInAttributeValue = new Set(attribValChars.map(function(c) {
        return c.charCodeAt(0);
      }));
      var charsToEscapeInPseudoValue = new Set(pseudoValChars.map(function(c) {
        return c.charCodeAt(0);
      }));
      var charsToEscapeInName = new Set(__spreadArray(__spreadArray([], pseudoValChars, true), [
        "~",
        "^",
        "$",
        "*",
        "+",
        "!",
        "|",
        ":",
        "[",
        "]",
        " ",
        "."
      ], false).map(function(c) {
        return c.charCodeAt(0);
      }));
      function stringify(selector) {
        return selector.map(function(token) {
          return token.map(stringifyToken).join("");
        }).join(", ");
      }
      exports2.stringify = stringify;
      function stringifyToken(token, index, arr) {
        switch (token.type) {
          case types_1.SelectorType.Child:
            return index === 0 ? "> " : " > ";
          case types_1.SelectorType.Parent:
            return index === 0 ? "< " : " < ";
          case types_1.SelectorType.Sibling:
            return index === 0 ? "~ " : " ~ ";
          case types_1.SelectorType.Adjacent:
            return index === 0 ? "+ " : " + ";
          case types_1.SelectorType.Descendant:
            return " ";
          case types_1.SelectorType.ColumnCombinator:
            return index === 0 ? "|| " : " || ";
          case types_1.SelectorType.Universal:
            return token.namespace === "*" && index + 1 < arr.length && "name" in arr[index + 1] ? "" : "".concat(getNamespace(token.namespace), "*");
          case types_1.SelectorType.Tag:
            return getNamespacedName(token);
          case types_1.SelectorType.PseudoElement:
            return "::".concat(escapeName(token.name, charsToEscapeInName)).concat(token.data === null ? "" : "(".concat(escapeName(token.data, charsToEscapeInPseudoValue), ")"));
          case types_1.SelectorType.Pseudo:
            return ":".concat(escapeName(token.name, charsToEscapeInName)).concat(token.data === null ? "" : "(".concat(typeof token.data === "string" ? escapeName(token.data, charsToEscapeInPseudoValue) : stringify(token.data), ")"));
          case types_1.SelectorType.Attribute: {
            if (token.name === "id" && token.action === types_1.AttributeAction.Equals && token.ignoreCase === "quirks" && !token.namespace) {
              return "#".concat(escapeName(token.value, charsToEscapeInName));
            }
            if (token.name === "class" && token.action === types_1.AttributeAction.Element && token.ignoreCase === "quirks" && !token.namespace) {
              return ".".concat(escapeName(token.value, charsToEscapeInName));
            }
            var name_1 = getNamespacedName(token);
            if (token.action === types_1.AttributeAction.Exists) {
              return "[".concat(name_1, "]");
            }
            return "[".concat(name_1).concat(getActionValue(token.action), '="').concat(escapeName(token.value, charsToEscapeInAttributeValue), '"').concat(token.ignoreCase === null ? "" : token.ignoreCase ? " i" : " s", "]");
          }
        }
      }
      function getActionValue(action2) {
        switch (action2) {
          case types_1.AttributeAction.Equals:
            return "";
          case types_1.AttributeAction.Element:
            return "~";
          case types_1.AttributeAction.Start:
            return "^";
          case types_1.AttributeAction.End:
            return "$";
          case types_1.AttributeAction.Any:
            return "*";
          case types_1.AttributeAction.Not:
            return "!";
          case types_1.AttributeAction.Hyphen:
            return "|";
          case types_1.AttributeAction.Exists:
            throw new Error("Shouldn't be here");
        }
      }
      function getNamespacedName(token) {
        return "".concat(getNamespace(token.namespace)).concat(escapeName(token.name, charsToEscapeInName));
      }
      function getNamespace(namespace) {
        return namespace !== null ? "".concat(namespace === "*" ? "*" : escapeName(namespace, charsToEscapeInName), "|") : "";
      }
      function escapeName(str, charsToEscape) {
        var lastIdx = 0;
        var ret = "";
        for (var i = 0; i < str.length; i++) {
          if (charsToEscape.has(str.charCodeAt(i))) {
            ret += "".concat(str.slice(lastIdx, i), "\\").concat(str.charAt(i));
            lastIdx = i + 1;
          }
        }
        return ret.length > 0 ? ret + str.slice(lastIdx) : str;
      }
    }
  });

  // node_modules/.pnpm/css-what@6.1.0/node_modules/css-what/lib/commonjs/index.js
  var require_commonjs = __commonJS({
    "node_modules/.pnpm/css-what@6.1.0/node_modules/css-what/lib/commonjs/index.js"(exports2) {
      "use strict";
      var __createBinding = exports2 && exports2.__createBinding || (Object.create ? function(o, m, k, k2) {
        if (k2 === void 0)
          k2 = k;
        var desc = Object.getOwnPropertyDescriptor(m, k);
        if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
          desc = { enumerable: true, get: function() {
            return m[k];
          } };
        }
        Object.defineProperty(o, k2, desc);
      } : function(o, m, k, k2) {
        if (k2 === void 0)
          k2 = k;
        o[k2] = m[k];
      });
      var __exportStar = exports2 && exports2.__exportStar || function(m, exports3) {
        for (var p in m)
          if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports3, p))
            __createBinding(exports3, m, p);
      };
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.stringify = exports2.parse = exports2.isTraversal = void 0;
      __exportStar(require_types(), exports2);
      var parse_1 = require_parse();
      Object.defineProperty(exports2, "isTraversal", { enumerable: true, get: function() {
        return parse_1.isTraversal;
      } });
      Object.defineProperty(exports2, "parse", { enumerable: true, get: function() {
        return parse_1.parse;
      } });
      var stringify_1 = require_stringify2();
      Object.defineProperty(exports2, "stringify", { enumerable: true, get: function() {
        return stringify_1.stringify;
      } });
    }
  });

  // node_modules/.pnpm/css-select@4.3.0/node_modules/css-select/lib/procedure.js
  var require_procedure = __commonJS({
    "node_modules/.pnpm/css-select@4.3.0/node_modules/css-select/lib/procedure.js"(exports2) {
      "use strict";
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.isTraversal = exports2.procedure = void 0;
      exports2.procedure = {
        universal: 50,
        tag: 30,
        attribute: 1,
        pseudo: 0,
        "pseudo-element": 0,
        "column-combinator": -1,
        descendant: -1,
        child: -1,
        parent: -1,
        sibling: -1,
        adjacent: -1,
        _flexibleDescendant: -1
      };
      function isTraversal(t) {
        return exports2.procedure[t.type] < 0;
      }
      exports2.isTraversal = isTraversal;
    }
  });

  // node_modules/.pnpm/css-select@4.3.0/node_modules/css-select/lib/sort.js
  var require_sort = __commonJS({
    "node_modules/.pnpm/css-select@4.3.0/node_modules/css-select/lib/sort.js"(exports2) {
      "use strict";
      Object.defineProperty(exports2, "__esModule", { value: true });
      var css_what_1 = require_commonjs();
      var procedure_1 = require_procedure();
      var attributes = {
        exists: 10,
        equals: 8,
        not: 7,
        start: 6,
        end: 6,
        any: 5,
        hyphen: 4,
        element: 4
      };
      function sortByProcedure(arr) {
        var procs = arr.map(getProcedure);
        for (var i = 1; i < arr.length; i++) {
          var procNew = procs[i];
          if (procNew < 0)
            continue;
          for (var j = i - 1; j >= 0 && procNew < procs[j]; j--) {
            var token = arr[j + 1];
            arr[j + 1] = arr[j];
            arr[j] = token;
            procs[j + 1] = procs[j];
            procs[j] = procNew;
          }
        }
      }
      exports2.default = sortByProcedure;
      function getProcedure(token) {
        var proc = procedure_1.procedure[token.type];
        if (token.type === css_what_1.SelectorType.Attribute) {
          proc = attributes[token.action];
          if (proc === attributes.equals && token.name === "id") {
            proc = 9;
          }
          if (token.ignoreCase) {
            proc >>= 1;
          }
        } else if (token.type === css_what_1.SelectorType.Pseudo) {
          if (!token.data) {
            proc = 3;
          } else if (token.name === "has" || token.name === "contains") {
            proc = 0;
          } else if (Array.isArray(token.data)) {
            proc = 0;
            for (var i = 0; i < token.data.length; i++) {
              if (token.data[i].length !== 1)
                continue;
              var cur = getProcedure(token.data[i][0]);
              if (cur === 0) {
                proc = 0;
                break;
              }
              if (cur > proc)
                proc = cur;
            }
            if (token.data.length > 1 && proc > 0)
              proc -= 1;
          } else {
            proc = 1;
          }
        }
        return proc;
      }
    }
  });

  // node_modules/.pnpm/css-select@4.3.0/node_modules/css-select/lib/attributes.js
  var require_attributes = __commonJS({
    "node_modules/.pnpm/css-select@4.3.0/node_modules/css-select/lib/attributes.js"(exports2) {
      "use strict";
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.attributeRules = void 0;
      var boolbase_1 = require_boolbase();
      var reChars = /[-[\]{}()*+?.,\\^$|#\s]/g;
      function escapeRegex(value) {
        return value.replace(reChars, "\\$&");
      }
      var caseInsensitiveAttributes = /* @__PURE__ */ new Set([
        "accept",
        "accept-charset",
        "align",
        "alink",
        "axis",
        "bgcolor",
        "charset",
        "checked",
        "clear",
        "codetype",
        "color",
        "compact",
        "declare",
        "defer",
        "dir",
        "direction",
        "disabled",
        "enctype",
        "face",
        "frame",
        "hreflang",
        "http-equiv",
        "lang",
        "language",
        "link",
        "media",
        "method",
        "multiple",
        "nohref",
        "noresize",
        "noshade",
        "nowrap",
        "readonly",
        "rel",
        "rev",
        "rules",
        "scope",
        "scrolling",
        "selected",
        "shape",
        "target",
        "text",
        "type",
        "valign",
        "valuetype",
        "vlink"
      ]);
      function shouldIgnoreCase(selector, options) {
        return typeof selector.ignoreCase === "boolean" ? selector.ignoreCase : selector.ignoreCase === "quirks" ? !!options.quirksMode : !options.xmlMode && caseInsensitiveAttributes.has(selector.name);
      }
      exports2.attributeRules = {
        equals: function(next, data, options) {
          var adapter = options.adapter;
          var name = data.name;
          var value = data.value;
          if (shouldIgnoreCase(data, options)) {
            value = value.toLowerCase();
            return function(elem) {
              var attr = adapter.getAttributeValue(elem, name);
              return attr != null && attr.length === value.length && attr.toLowerCase() === value && next(elem);
            };
          }
          return function(elem) {
            return adapter.getAttributeValue(elem, name) === value && next(elem);
          };
        },
        hyphen: function(next, data, options) {
          var adapter = options.adapter;
          var name = data.name;
          var value = data.value;
          var len = value.length;
          if (shouldIgnoreCase(data, options)) {
            value = value.toLowerCase();
            return function hyphenIC(elem) {
              var attr = adapter.getAttributeValue(elem, name);
              return attr != null && (attr.length === len || attr.charAt(len) === "-") && attr.substr(0, len).toLowerCase() === value && next(elem);
            };
          }
          return function hyphen(elem) {
            var attr = adapter.getAttributeValue(elem, name);
            return attr != null && (attr.length === len || attr.charAt(len) === "-") && attr.substr(0, len) === value && next(elem);
          };
        },
        element: function(next, data, options) {
          var adapter = options.adapter;
          var name = data.name, value = data.value;
          if (/\s/.test(value)) {
            return boolbase_1.falseFunc;
          }
          var regex = new RegExp("(?:^|\\s)".concat(escapeRegex(value), "(?:$|\\s)"), shouldIgnoreCase(data, options) ? "i" : "");
          return function element(elem) {
            var attr = adapter.getAttributeValue(elem, name);
            return attr != null && attr.length >= value.length && regex.test(attr) && next(elem);
          };
        },
        exists: function(next, _a2, _b2) {
          var name = _a2.name;
          var adapter = _b2.adapter;
          return function(elem) {
            return adapter.hasAttrib(elem, name) && next(elem);
          };
        },
        start: function(next, data, options) {
          var adapter = options.adapter;
          var name = data.name;
          var value = data.value;
          var len = value.length;
          if (len === 0) {
            return boolbase_1.falseFunc;
          }
          if (shouldIgnoreCase(data, options)) {
            value = value.toLowerCase();
            return function(elem) {
              var attr = adapter.getAttributeValue(elem, name);
              return attr != null && attr.length >= len && attr.substr(0, len).toLowerCase() === value && next(elem);
            };
          }
          return function(elem) {
            var _a2;
            return !!((_a2 = adapter.getAttributeValue(elem, name)) === null || _a2 === void 0 ? void 0 : _a2.startsWith(value)) && next(elem);
          };
        },
        end: function(next, data, options) {
          var adapter = options.adapter;
          var name = data.name;
          var value = data.value;
          var len = -value.length;
          if (len === 0) {
            return boolbase_1.falseFunc;
          }
          if (shouldIgnoreCase(data, options)) {
            value = value.toLowerCase();
            return function(elem) {
              var _a2;
              return ((_a2 = adapter.getAttributeValue(elem, name)) === null || _a2 === void 0 ? void 0 : _a2.substr(len).toLowerCase()) === value && next(elem);
            };
          }
          return function(elem) {
            var _a2;
            return !!((_a2 = adapter.getAttributeValue(elem, name)) === null || _a2 === void 0 ? void 0 : _a2.endsWith(value)) && next(elem);
          };
        },
        any: function(next, data, options) {
          var adapter = options.adapter;
          var name = data.name, value = data.value;
          if (value === "") {
            return boolbase_1.falseFunc;
          }
          if (shouldIgnoreCase(data, options)) {
            var regex_1 = new RegExp(escapeRegex(value), "i");
            return function anyIC(elem) {
              var attr = adapter.getAttributeValue(elem, name);
              return attr != null && attr.length >= value.length && regex_1.test(attr) && next(elem);
            };
          }
          return function(elem) {
            var _a2;
            return !!((_a2 = adapter.getAttributeValue(elem, name)) === null || _a2 === void 0 ? void 0 : _a2.includes(value)) && next(elem);
          };
        },
        not: function(next, data, options) {
          var adapter = options.adapter;
          var name = data.name;
          var value = data.value;
          if (value === "") {
            return function(elem) {
              return !!adapter.getAttributeValue(elem, name) && next(elem);
            };
          } else if (shouldIgnoreCase(data, options)) {
            value = value.toLowerCase();
            return function(elem) {
              var attr = adapter.getAttributeValue(elem, name);
              return (attr == null || attr.length !== value.length || attr.toLowerCase() !== value) && next(elem);
            };
          }
          return function(elem) {
            return adapter.getAttributeValue(elem, name) !== value && next(elem);
          };
        }
      };
    }
  });

  // node_modules/.pnpm/nth-check@2.1.1/node_modules/nth-check/lib/parse.js
  var require_parse2 = __commonJS({
    "node_modules/.pnpm/nth-check@2.1.1/node_modules/nth-check/lib/parse.js"(exports2) {
      "use strict";
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.parse = void 0;
      var whitespace = /* @__PURE__ */ new Set([9, 10, 12, 13, 32]);
      var ZERO = "0".charCodeAt(0);
      var NINE = "9".charCodeAt(0);
      function parse4(formula) {
        formula = formula.trim().toLowerCase();
        if (formula === "even") {
          return [2, 0];
        } else if (formula === "odd") {
          return [2, 1];
        }
        var idx = 0;
        var a = 0;
        var sign = readSign();
        var number = readNumber();
        if (idx < formula.length && formula.charAt(idx) === "n") {
          idx++;
          a = sign * (number !== null && number !== void 0 ? number : 1);
          skipWhitespace();
          if (idx < formula.length) {
            sign = readSign();
            skipWhitespace();
            number = readNumber();
          } else {
            sign = number = 0;
          }
        }
        if (number === null || idx < formula.length) {
          throw new Error("n-th rule couldn't be parsed ('".concat(formula, "')"));
        }
        return [a, sign * number];
        function readSign() {
          if (formula.charAt(idx) === "-") {
            idx++;
            return -1;
          }
          if (formula.charAt(idx) === "+") {
            idx++;
          }
          return 1;
        }
        function readNumber() {
          var start = idx;
          var value = 0;
          while (idx < formula.length && formula.charCodeAt(idx) >= ZERO && formula.charCodeAt(idx) <= NINE) {
            value = value * 10 + (formula.charCodeAt(idx) - ZERO);
            idx++;
          }
          return idx === start ? null : value;
        }
        function skipWhitespace() {
          while (idx < formula.length && whitespace.has(formula.charCodeAt(idx))) {
            idx++;
          }
        }
      }
      exports2.parse = parse4;
    }
  });

  // node_modules/.pnpm/nth-check@2.1.1/node_modules/nth-check/lib/compile.js
  var require_compile = __commonJS({
    "node_modules/.pnpm/nth-check@2.1.1/node_modules/nth-check/lib/compile.js"(exports2) {
      "use strict";
      var __importDefault = exports2 && exports2.__importDefault || function(mod) {
        return mod && mod.__esModule ? mod : { "default": mod };
      };
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.generate = exports2.compile = void 0;
      var boolbase_1 = __importDefault(require_boolbase());
      function compile(parsed) {
        var a = parsed[0];
        var b = parsed[1] - 1;
        if (b < 0 && a <= 0)
          return boolbase_1.default.falseFunc;
        if (a === -1)
          return function(index) {
            return index <= b;
          };
        if (a === 0)
          return function(index) {
            return index === b;
          };
        if (a === 1)
          return b < 0 ? boolbase_1.default.trueFunc : function(index) {
            return index >= b;
          };
        var absA = Math.abs(a);
        var bMod = (b % absA + absA) % absA;
        return a > 1 ? function(index) {
          return index >= b && index % absA === bMod;
        } : function(index) {
          return index <= b && index % absA === bMod;
        };
      }
      exports2.compile = compile;
      function generate(parsed) {
        var a = parsed[0];
        var b = parsed[1] - 1;
        var n = 0;
        if (a < 0) {
          var aPos_1 = -a;
          var minValue_1 = (b % aPos_1 + aPos_1) % aPos_1;
          return function() {
            var val = minValue_1 + aPos_1 * n++;
            return val > b ? null : val;
          };
        }
        if (a === 0)
          return b < 0 ? (
            // There are no result  always return `null`
            function() {
              return null;
            }
          ) : (
            // Return `b` exactly once
            function() {
              return n++ === 0 ? b : null;
            }
          );
        if (b < 0) {
          b += a * Math.ceil(-b / a);
        }
        return function() {
          return a * n++ + b;
        };
      }
      exports2.generate = generate;
    }
  });

  // node_modules/.pnpm/nth-check@2.1.1/node_modules/nth-check/lib/index.js
  var require_lib7 = __commonJS({
    "node_modules/.pnpm/nth-check@2.1.1/node_modules/nth-check/lib/index.js"(exports2) {
      "use strict";
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.sequence = exports2.generate = exports2.compile = exports2.parse = void 0;
      var parse_js_1 = require_parse2();
      Object.defineProperty(exports2, "parse", { enumerable: true, get: function() {
        return parse_js_1.parse;
      } });
      var compile_js_1 = require_compile();
      Object.defineProperty(exports2, "compile", { enumerable: true, get: function() {
        return compile_js_1.compile;
      } });
      Object.defineProperty(exports2, "generate", { enumerable: true, get: function() {
        return compile_js_1.generate;
      } });
      function nthCheck(formula) {
        return (0, compile_js_1.compile)((0, parse_js_1.parse)(formula));
      }
      exports2.default = nthCheck;
      function sequence(formula) {
        return (0, compile_js_1.generate)((0, parse_js_1.parse)(formula));
      }
      exports2.sequence = sequence;
    }
  });

  // node_modules/.pnpm/css-select@4.3.0/node_modules/css-select/lib/pseudo-selectors/filters.js
  var require_filters = __commonJS({
    "node_modules/.pnpm/css-select@4.3.0/node_modules/css-select/lib/pseudo-selectors/filters.js"(exports2) {
      "use strict";
      var __importDefault = exports2 && exports2.__importDefault || function(mod) {
        return mod && mod.__esModule ? mod : { "default": mod };
      };
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.filters = void 0;
      var nth_check_1 = __importDefault(require_lib7());
      var boolbase_1 = require_boolbase();
      function getChildFunc(next, adapter) {
        return function(elem) {
          var parent = adapter.getParent(elem);
          return parent != null && adapter.isTag(parent) && next(elem);
        };
      }
      exports2.filters = {
        contains: function(next, text, _a2) {
          var adapter = _a2.adapter;
          return function contains(elem) {
            return next(elem) && adapter.getText(elem).includes(text);
          };
        },
        icontains: function(next, text, _a2) {
          var adapter = _a2.adapter;
          var itext = text.toLowerCase();
          return function icontains(elem) {
            return next(elem) && adapter.getText(elem).toLowerCase().includes(itext);
          };
        },
        // Location specific methods
        "nth-child": function(next, rule, _a2) {
          var adapter = _a2.adapter, equals = _a2.equals;
          var func = (0, nth_check_1.default)(rule);
          if (func === boolbase_1.falseFunc)
            return boolbase_1.falseFunc;
          if (func === boolbase_1.trueFunc)
            return getChildFunc(next, adapter);
          return function nthChild(elem) {
            var siblings = adapter.getSiblings(elem);
            var pos = 0;
            for (var i = 0; i < siblings.length; i++) {
              if (equals(elem, siblings[i]))
                break;
              if (adapter.isTag(siblings[i])) {
                pos++;
              }
            }
            return func(pos) && next(elem);
          };
        },
        "nth-last-child": function(next, rule, _a2) {
          var adapter = _a2.adapter, equals = _a2.equals;
          var func = (0, nth_check_1.default)(rule);
          if (func === boolbase_1.falseFunc)
            return boolbase_1.falseFunc;
          if (func === boolbase_1.trueFunc)
            return getChildFunc(next, adapter);
          return function nthLastChild(elem) {
            var siblings = adapter.getSiblings(elem);
            var pos = 0;
            for (var i = siblings.length - 1; i >= 0; i--) {
              if (equals(elem, siblings[i]))
                break;
              if (adapter.isTag(siblings[i])) {
                pos++;
              }
            }
            return func(pos) && next(elem);
          };
        },
        "nth-of-type": function(next, rule, _a2) {
          var adapter = _a2.adapter, equals = _a2.equals;
          var func = (0, nth_check_1.default)(rule);
          if (func === boolbase_1.falseFunc)
            return boolbase_1.falseFunc;
          if (func === boolbase_1.trueFunc)
            return getChildFunc(next, adapter);
          return function nthOfType(elem) {
            var siblings = adapter.getSiblings(elem);
            var pos = 0;
            for (var i = 0; i < siblings.length; i++) {
              var currentSibling = siblings[i];
              if (equals(elem, currentSibling))
                break;
              if (adapter.isTag(currentSibling) && adapter.getName(currentSibling) === adapter.getName(elem)) {
                pos++;
              }
            }
            return func(pos) && next(elem);
          };
        },
        "nth-last-of-type": function(next, rule, _a2) {
          var adapter = _a2.adapter, equals = _a2.equals;
          var func = (0, nth_check_1.default)(rule);
          if (func === boolbase_1.falseFunc)
            return boolbase_1.falseFunc;
          if (func === boolbase_1.trueFunc)
            return getChildFunc(next, adapter);
          return function nthLastOfType(elem) {
            var siblings = adapter.getSiblings(elem);
            var pos = 0;
            for (var i = siblings.length - 1; i >= 0; i--) {
              var currentSibling = siblings[i];
              if (equals(elem, currentSibling))
                break;
              if (adapter.isTag(currentSibling) && adapter.getName(currentSibling) === adapter.getName(elem)) {
                pos++;
              }
            }
            return func(pos) && next(elem);
          };
        },
        // TODO determine the actual root element
        root: function(next, _rule, _a2) {
          var adapter = _a2.adapter;
          return function(elem) {
            var parent = adapter.getParent(elem);
            return (parent == null || !adapter.isTag(parent)) && next(elem);
          };
        },
        scope: function(next, rule, options, context2) {
          var equals = options.equals;
          if (!context2 || context2.length === 0) {
            return exports2.filters.root(next, rule, options);
          }
          if (context2.length === 1) {
            return function(elem) {
              return equals(context2[0], elem) && next(elem);
            };
          }
          return function(elem) {
            return context2.includes(elem) && next(elem);
          };
        },
        hover: dynamicStatePseudo("isHovered"),
        visited: dynamicStatePseudo("isVisited"),
        active: dynamicStatePseudo("isActive")
      };
      function dynamicStatePseudo(name) {
        return function dynamicPseudo(next, _rule, _a2) {
          var adapter = _a2.adapter;
          var func = adapter[name];
          if (typeof func !== "function") {
            return boolbase_1.falseFunc;
          }
          return function active(elem) {
            return func(elem) && next(elem);
          };
        };
      }
    }
  });

  // node_modules/.pnpm/css-select@4.3.0/node_modules/css-select/lib/pseudo-selectors/pseudos.js
  var require_pseudos = __commonJS({
    "node_modules/.pnpm/css-select@4.3.0/node_modules/css-select/lib/pseudo-selectors/pseudos.js"(exports2) {
      "use strict";
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.verifyPseudoArgs = exports2.pseudos = void 0;
      exports2.pseudos = {
        empty: function(elem, _a2) {
          var adapter = _a2.adapter;
          return !adapter.getChildren(elem).some(function(elem2) {
            return adapter.isTag(elem2) || adapter.getText(elem2) !== "";
          });
        },
        "first-child": function(elem, _a2) {
          var adapter = _a2.adapter, equals = _a2.equals;
          var firstChild = adapter.getSiblings(elem).find(function(elem2) {
            return adapter.isTag(elem2);
          });
          return firstChild != null && equals(elem, firstChild);
        },
        "last-child": function(elem, _a2) {
          var adapter = _a2.adapter, equals = _a2.equals;
          var siblings = adapter.getSiblings(elem);
          for (var i = siblings.length - 1; i >= 0; i--) {
            if (equals(elem, siblings[i]))
              return true;
            if (adapter.isTag(siblings[i]))
              break;
          }
          return false;
        },
        "first-of-type": function(elem, _a2) {
          var adapter = _a2.adapter, equals = _a2.equals;
          var siblings = adapter.getSiblings(elem);
          var elemName = adapter.getName(elem);
          for (var i = 0; i < siblings.length; i++) {
            var currentSibling = siblings[i];
            if (equals(elem, currentSibling))
              return true;
            if (adapter.isTag(currentSibling) && adapter.getName(currentSibling) === elemName) {
              break;
            }
          }
          return false;
        },
        "last-of-type": function(elem, _a2) {
          var adapter = _a2.adapter, equals = _a2.equals;
          var siblings = adapter.getSiblings(elem);
          var elemName = adapter.getName(elem);
          for (var i = siblings.length - 1; i >= 0; i--) {
            var currentSibling = siblings[i];
            if (equals(elem, currentSibling))
              return true;
            if (adapter.isTag(currentSibling) && adapter.getName(currentSibling) === elemName) {
              break;
            }
          }
          return false;
        },
        "only-of-type": function(elem, _a2) {
          var adapter = _a2.adapter, equals = _a2.equals;
          var elemName = adapter.getName(elem);
          return adapter.getSiblings(elem).every(function(sibling) {
            return equals(elem, sibling) || !adapter.isTag(sibling) || adapter.getName(sibling) !== elemName;
          });
        },
        "only-child": function(elem, _a2) {
          var adapter = _a2.adapter, equals = _a2.equals;
          return adapter.getSiblings(elem).every(function(sibling) {
            return equals(elem, sibling) || !adapter.isTag(sibling);
          });
        }
      };
      function verifyPseudoArgs(func, name, subselect) {
        if (subselect === null) {
          if (func.length > 2) {
            throw new Error("pseudo-selector :".concat(name, " requires an argument"));
          }
        } else if (func.length === 2) {
          throw new Error("pseudo-selector :".concat(name, " doesn't have any arguments"));
        }
      }
      exports2.verifyPseudoArgs = verifyPseudoArgs;
    }
  });

  // node_modules/.pnpm/css-select@4.3.0/node_modules/css-select/lib/pseudo-selectors/aliases.js
  var require_aliases = __commonJS({
    "node_modules/.pnpm/css-select@4.3.0/node_modules/css-select/lib/pseudo-selectors/aliases.js"(exports2) {
      "use strict";
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.aliases = void 0;
      exports2.aliases = {
        // Links
        "any-link": ":is(a, area, link)[href]",
        link: ":any-link:not(:visited)",
        // Forms
        // https://html.spec.whatwg.org/multipage/scripting.html#disabled-elements
        disabled: ":is(\n        :is(button, input, select, textarea, optgroup, option)[disabled],\n        optgroup[disabled] > option,\n        fieldset[disabled]:not(fieldset[disabled] legend:first-of-type *)\n    )",
        enabled: ":not(:disabled)",
        checked: ":is(:is(input[type=radio], input[type=checkbox])[checked], option:selected)",
        required: ":is(input, select, textarea)[required]",
        optional: ":is(input, select, textarea):not([required])",
        // JQuery extensions
        // https://html.spec.whatwg.org/multipage/form-elements.html#concept-option-selectedness
        selected: "option:is([selected], select:not([multiple]):not(:has(> option[selected])) > :first-of-type)",
        checkbox: "[type=checkbox]",
        file: "[type=file]",
        password: "[type=password]",
        radio: "[type=radio]",
        reset: "[type=reset]",
        image: "[type=image]",
        submit: "[type=submit]",
        parent: ":not(:empty)",
        header: ":is(h1, h2, h3, h4, h5, h6)",
        button: ":is(button, input[type=button])",
        input: ":is(input, textarea, select, button)",
        text: "input:is(:not([type!='']), [type=text])"
      };
    }
  });

  // node_modules/.pnpm/css-select@4.3.0/node_modules/css-select/lib/pseudo-selectors/subselects.js
  var require_subselects = __commonJS({
    "node_modules/.pnpm/css-select@4.3.0/node_modules/css-select/lib/pseudo-selectors/subselects.js"(exports2) {
      "use strict";
      var __spreadArray = exports2 && exports2.__spreadArray || function(to, from, pack) {
        if (pack || arguments.length === 2)
          for (var i = 0, l = from.length, ar; i < l; i++) {
            if (ar || !(i in from)) {
              if (!ar)
                ar = Array.prototype.slice.call(from, 0, i);
              ar[i] = from[i];
            }
          }
        return to.concat(ar || Array.prototype.slice.call(from));
      };
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.subselects = exports2.getNextSiblings = exports2.ensureIsTag = exports2.PLACEHOLDER_ELEMENT = void 0;
      var boolbase_1 = require_boolbase();
      var procedure_1 = require_procedure();
      exports2.PLACEHOLDER_ELEMENT = {};
      function ensureIsTag(next, adapter) {
        if (next === boolbase_1.falseFunc)
          return boolbase_1.falseFunc;
        return function(elem) {
          return adapter.isTag(elem) && next(elem);
        };
      }
      exports2.ensureIsTag = ensureIsTag;
      function getNextSiblings(elem, adapter) {
        var siblings = adapter.getSiblings(elem);
        if (siblings.length <= 1)
          return [];
        var elemIndex = siblings.indexOf(elem);
        if (elemIndex < 0 || elemIndex === siblings.length - 1)
          return [];
        return siblings.slice(elemIndex + 1).filter(adapter.isTag);
      }
      exports2.getNextSiblings = getNextSiblings;
      var is = function(next, token, options, context2, compileToken) {
        var opts = {
          xmlMode: !!options.xmlMode,
          adapter: options.adapter,
          equals: options.equals
        };
        var func = compileToken(token, opts, context2);
        return function(elem) {
          return func(elem) && next(elem);
        };
      };
      exports2.subselects = {
        is,
        /**
         * `:matches` and `:where` are aliases for `:is`.
         */
        matches: is,
        where: is,
        not: function(next, token, options, context2, compileToken) {
          var opts = {
            xmlMode: !!options.xmlMode,
            adapter: options.adapter,
            equals: options.equals
          };
          var func = compileToken(token, opts, context2);
          if (func === boolbase_1.falseFunc)
            return next;
          if (func === boolbase_1.trueFunc)
            return boolbase_1.falseFunc;
          return function not(elem) {
            return !func(elem) && next(elem);
          };
        },
        has: function(next, subselect, options, _context, compileToken) {
          var adapter = options.adapter;
          var opts = {
            xmlMode: !!options.xmlMode,
            adapter,
            equals: options.equals
          };
          var context2 = subselect.some(function(s) {
            return s.some(procedure_1.isTraversal);
          }) ? [exports2.PLACEHOLDER_ELEMENT] : void 0;
          var compiled = compileToken(subselect, opts, context2);
          if (compiled === boolbase_1.falseFunc)
            return boolbase_1.falseFunc;
          if (compiled === boolbase_1.trueFunc) {
            return function(elem) {
              return adapter.getChildren(elem).some(adapter.isTag) && next(elem);
            };
          }
          var hasElement = ensureIsTag(compiled, adapter);
          var _a2 = compiled.shouldTestNextSiblings, shouldTestNextSiblings = _a2 === void 0 ? false : _a2;
          if (context2) {
            return function(elem) {
              context2[0] = elem;
              var childs = adapter.getChildren(elem);
              var nextElements = shouldTestNextSiblings ? __spreadArray(__spreadArray([], childs, true), getNextSiblings(elem, adapter), true) : childs;
              return next(elem) && adapter.existsOne(hasElement, nextElements);
            };
          }
          return function(elem) {
            return next(elem) && adapter.existsOne(hasElement, adapter.getChildren(elem));
          };
        }
      };
    }
  });

  // node_modules/.pnpm/css-select@4.3.0/node_modules/css-select/lib/pseudo-selectors/index.js
  var require_pseudo_selectors = __commonJS({
    "node_modules/.pnpm/css-select@4.3.0/node_modules/css-select/lib/pseudo-selectors/index.js"(exports2) {
      "use strict";
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.compilePseudoSelector = exports2.aliases = exports2.pseudos = exports2.filters = void 0;
      var boolbase_1 = require_boolbase();
      var css_what_1 = require_commonjs();
      var filters_1 = require_filters();
      Object.defineProperty(exports2, "filters", { enumerable: true, get: function() {
        return filters_1.filters;
      } });
      var pseudos_1 = require_pseudos();
      Object.defineProperty(exports2, "pseudos", { enumerable: true, get: function() {
        return pseudos_1.pseudos;
      } });
      var aliases_1 = require_aliases();
      Object.defineProperty(exports2, "aliases", { enumerable: true, get: function() {
        return aliases_1.aliases;
      } });
      var subselects_1 = require_subselects();
      function compilePseudoSelector(next, selector, options, context2, compileToken) {
        var name = selector.name, data = selector.data;
        if (Array.isArray(data)) {
          return subselects_1.subselects[name](next, data, options, context2, compileToken);
        }
        if (name in aliases_1.aliases) {
          if (data != null) {
            throw new Error("Pseudo ".concat(name, " doesn't have any arguments"));
          }
          var alias = (0, css_what_1.parse)(aliases_1.aliases[name]);
          return subselects_1.subselects.is(next, alias, options, context2, compileToken);
        }
        if (name in filters_1.filters) {
          return filters_1.filters[name](next, data, options, context2);
        }
        if (name in pseudos_1.pseudos) {
          var pseudo_1 = pseudos_1.pseudos[name];
          (0, pseudos_1.verifyPseudoArgs)(pseudo_1, name, data);
          return pseudo_1 === boolbase_1.falseFunc ? boolbase_1.falseFunc : next === boolbase_1.trueFunc ? function(elem) {
            return pseudo_1(elem, options, data);
          } : function(elem) {
            return pseudo_1(elem, options, data) && next(elem);
          };
        }
        throw new Error("unmatched pseudo-class :".concat(name));
      }
      exports2.compilePseudoSelector = compilePseudoSelector;
    }
  });

  // node_modules/.pnpm/css-select@4.3.0/node_modules/css-select/lib/general.js
  var require_general = __commonJS({
    "node_modules/.pnpm/css-select@4.3.0/node_modules/css-select/lib/general.js"(exports2) {
      "use strict";
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.compileGeneralSelector = void 0;
      var attributes_1 = require_attributes();
      var pseudo_selectors_1 = require_pseudo_selectors();
      var css_what_1 = require_commonjs();
      function compileGeneralSelector(next, selector, options, context2, compileToken) {
        var adapter = options.adapter, equals = options.equals;
        switch (selector.type) {
          case css_what_1.SelectorType.PseudoElement: {
            throw new Error("Pseudo-elements are not supported by css-select");
          }
          case css_what_1.SelectorType.ColumnCombinator: {
            throw new Error("Column combinators are not yet supported by css-select");
          }
          case css_what_1.SelectorType.Attribute: {
            if (selector.namespace != null) {
              throw new Error("Namespaced attributes are not yet supported by css-select");
            }
            if (!options.xmlMode || options.lowerCaseAttributeNames) {
              selector.name = selector.name.toLowerCase();
            }
            return attributes_1.attributeRules[selector.action](next, selector, options);
          }
          case css_what_1.SelectorType.Pseudo: {
            return (0, pseudo_selectors_1.compilePseudoSelector)(next, selector, options, context2, compileToken);
          }
          case css_what_1.SelectorType.Tag: {
            if (selector.namespace != null) {
              throw new Error("Namespaced tag names are not yet supported by css-select");
            }
            var name_1 = selector.name;
            if (!options.xmlMode || options.lowerCaseTags) {
              name_1 = name_1.toLowerCase();
            }
            return function tag(elem) {
              return adapter.getName(elem) === name_1 && next(elem);
            };
          }
          case css_what_1.SelectorType.Descendant: {
            if (options.cacheResults === false || typeof WeakSet === "undefined") {
              return function descendant(elem) {
                var current = elem;
                while (current = adapter.getParent(current)) {
                  if (adapter.isTag(current) && next(current)) {
                    return true;
                  }
                }
                return false;
              };
            }
            var isFalseCache_1 = /* @__PURE__ */ new WeakSet();
            return function cachedDescendant(elem) {
              var current = elem;
              while (current = adapter.getParent(current)) {
                if (!isFalseCache_1.has(current)) {
                  if (adapter.isTag(current) && next(current)) {
                    return true;
                  }
                  isFalseCache_1.add(current);
                }
              }
              return false;
            };
          }
          case "_flexibleDescendant": {
            return function flexibleDescendant(elem) {
              var current = elem;
              do {
                if (adapter.isTag(current) && next(current))
                  return true;
              } while (current = adapter.getParent(current));
              return false;
            };
          }
          case css_what_1.SelectorType.Parent: {
            return function parent(elem) {
              return adapter.getChildren(elem).some(function(elem2) {
                return adapter.isTag(elem2) && next(elem2);
              });
            };
          }
          case css_what_1.SelectorType.Child: {
            return function child(elem) {
              var parent = adapter.getParent(elem);
              return parent != null && adapter.isTag(parent) && next(parent);
            };
          }
          case css_what_1.SelectorType.Sibling: {
            return function sibling(elem) {
              var siblings = adapter.getSiblings(elem);
              for (var i = 0; i < siblings.length; i++) {
                var currentSibling = siblings[i];
                if (equals(elem, currentSibling))
                  break;
                if (adapter.isTag(currentSibling) && next(currentSibling)) {
                  return true;
                }
              }
              return false;
            };
          }
          case css_what_1.SelectorType.Adjacent: {
            if (adapter.prevElementSibling) {
              return function adjacent(elem) {
                var previous = adapter.prevElementSibling(elem);
                return previous != null && next(previous);
              };
            }
            return function adjacent(elem) {
              var siblings = adapter.getSiblings(elem);
              var lastElement;
              for (var i = 0; i < siblings.length; i++) {
                var currentSibling = siblings[i];
                if (equals(elem, currentSibling))
                  break;
                if (adapter.isTag(currentSibling)) {
                  lastElement = currentSibling;
                }
              }
              return !!lastElement && next(lastElement);
            };
          }
          case css_what_1.SelectorType.Universal: {
            if (selector.namespace != null && selector.namespace !== "*") {
              throw new Error("Namespaced universal selectors are not yet supported by css-select");
            }
            return next;
          }
        }
      }
      exports2.compileGeneralSelector = compileGeneralSelector;
    }
  });

  // node_modules/.pnpm/css-select@4.3.0/node_modules/css-select/lib/compile.js
  var require_compile2 = __commonJS({
    "node_modules/.pnpm/css-select@4.3.0/node_modules/css-select/lib/compile.js"(exports2) {
      "use strict";
      var __importDefault = exports2 && exports2.__importDefault || function(mod) {
        return mod && mod.__esModule ? mod : { "default": mod };
      };
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.compileToken = exports2.compileUnsafe = exports2.compile = void 0;
      var css_what_1 = require_commonjs();
      var boolbase_1 = require_boolbase();
      var sort_1 = __importDefault(require_sort());
      var procedure_1 = require_procedure();
      var general_1 = require_general();
      var subselects_1 = require_subselects();
      function compile(selector, options, context2) {
        var next = compileUnsafe(selector, options, context2);
        return (0, subselects_1.ensureIsTag)(next, options.adapter);
      }
      exports2.compile = compile;
      function compileUnsafe(selector, options, context2) {
        var token = typeof selector === "string" ? (0, css_what_1.parse)(selector) : selector;
        return compileToken(token, options, context2);
      }
      exports2.compileUnsafe = compileUnsafe;
      function includesScopePseudo(t) {
        return t.type === "pseudo" && (t.name === "scope" || Array.isArray(t.data) && t.data.some(function(data) {
          return data.some(includesScopePseudo);
        }));
      }
      var DESCENDANT_TOKEN = { type: css_what_1.SelectorType.Descendant };
      var FLEXIBLE_DESCENDANT_TOKEN = {
        type: "_flexibleDescendant"
      };
      var SCOPE_TOKEN = {
        type: css_what_1.SelectorType.Pseudo,
        name: "scope",
        data: null
      };
      function absolutize(token, _a2, context2) {
        var adapter = _a2.adapter;
        var hasContext = !!(context2 === null || context2 === void 0 ? void 0 : context2.every(function(e) {
          var parent = adapter.isTag(e) && adapter.getParent(e);
          return e === subselects_1.PLACEHOLDER_ELEMENT || parent && adapter.isTag(parent);
        }));
        for (var _i = 0, token_1 = token; _i < token_1.length; _i++) {
          var t = token_1[_i];
          if (t.length > 0 && (0, procedure_1.isTraversal)(t[0]) && t[0].type !== "descendant") {
          } else if (hasContext && !t.some(includesScopePseudo)) {
            t.unshift(DESCENDANT_TOKEN);
          } else {
            continue;
          }
          t.unshift(SCOPE_TOKEN);
        }
      }
      function compileToken(token, options, context2) {
        var _a2;
        token = token.filter(function(t) {
          return t.length > 0;
        });
        token.forEach(sort_1.default);
        context2 = (_a2 = options.context) !== null && _a2 !== void 0 ? _a2 : context2;
        var isArrayContext = Array.isArray(context2);
        var finalContext = context2 && (Array.isArray(context2) ? context2 : [context2]);
        absolutize(token, options, finalContext);
        var shouldTestNextSiblings = false;
        var query = token.map(function(rules) {
          if (rules.length >= 2) {
            var first = rules[0], second = rules[1];
            if (first.type !== "pseudo" || first.name !== "scope") {
            } else if (isArrayContext && second.type === "descendant") {
              rules[1] = FLEXIBLE_DESCENDANT_TOKEN;
            } else if (second.type === "adjacent" || second.type === "sibling") {
              shouldTestNextSiblings = true;
            }
          }
          return compileRules(rules, options, finalContext);
        }).reduce(reduceRules, boolbase_1.falseFunc);
        query.shouldTestNextSiblings = shouldTestNextSiblings;
        return query;
      }
      exports2.compileToken = compileToken;
      function compileRules(rules, options, context2) {
        var _a2;
        return rules.reduce(function(previous, rule) {
          return previous === boolbase_1.falseFunc ? boolbase_1.falseFunc : (0, general_1.compileGeneralSelector)(previous, rule, options, context2, compileToken);
        }, (_a2 = options.rootFunc) !== null && _a2 !== void 0 ? _a2 : boolbase_1.trueFunc);
      }
      function reduceRules(a, b) {
        if (b === boolbase_1.falseFunc || a === boolbase_1.trueFunc) {
          return a;
        }
        if (a === boolbase_1.falseFunc || b === boolbase_1.trueFunc) {
          return b;
        }
        return function combine(elem) {
          return a(elem) || b(elem);
        };
      }
    }
  });

  // node_modules/.pnpm/css-select@4.3.0/node_modules/css-select/lib/index.js
  var require_lib8 = __commonJS({
    "node_modules/.pnpm/css-select@4.3.0/node_modules/css-select/lib/index.js"(exports2) {
      "use strict";
      var __createBinding = exports2 && exports2.__createBinding || (Object.create ? function(o, m, k, k2) {
        if (k2 === void 0)
          k2 = k;
        var desc = Object.getOwnPropertyDescriptor(m, k);
        if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
          desc = { enumerable: true, get: function() {
            return m[k];
          } };
        }
        Object.defineProperty(o, k2, desc);
      } : function(o, m, k, k2) {
        if (k2 === void 0)
          k2 = k;
        o[k2] = m[k];
      });
      var __setModuleDefault = exports2 && exports2.__setModuleDefault || (Object.create ? function(o, v) {
        Object.defineProperty(o, "default", { enumerable: true, value: v });
      } : function(o, v) {
        o["default"] = v;
      });
      var __importStar = exports2 && exports2.__importStar || function(mod) {
        if (mod && mod.__esModule)
          return mod;
        var result = {};
        if (mod != null) {
          for (var k in mod)
            if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
              __createBinding(result, mod, k);
        }
        __setModuleDefault(result, mod);
        return result;
      };
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.aliases = exports2.pseudos = exports2.filters = exports2.is = exports2.selectOne = exports2.selectAll = exports2.prepareContext = exports2._compileToken = exports2._compileUnsafe = exports2.compile = void 0;
      var DomUtils = __importStar(require_lib5());
      var boolbase_1 = require_boolbase();
      var compile_1 = require_compile2();
      var subselects_1 = require_subselects();
      var defaultEquals = function(a, b) {
        return a === b;
      };
      var defaultOptions = {
        adapter: DomUtils,
        equals: defaultEquals
      };
      function convertOptionFormats(options) {
        var _a2, _b2, _c, _d;
        var opts = options !== null && options !== void 0 ? options : defaultOptions;
        (_a2 = opts.adapter) !== null && _a2 !== void 0 ? _a2 : opts.adapter = DomUtils;
        (_b2 = opts.equals) !== null && _b2 !== void 0 ? _b2 : opts.equals = (_d = (_c = opts.adapter) === null || _c === void 0 ? void 0 : _c.equals) !== null && _d !== void 0 ? _d : defaultEquals;
        return opts;
      }
      function wrapCompile(func) {
        return function addAdapter(selector, options, context2) {
          var opts = convertOptionFormats(options);
          return func(selector, opts, context2);
        };
      }
      exports2.compile = wrapCompile(compile_1.compile);
      exports2._compileUnsafe = wrapCompile(compile_1.compileUnsafe);
      exports2._compileToken = wrapCompile(compile_1.compileToken);
      function getSelectorFunc(searchFunc) {
        return function select(query, elements, options) {
          var opts = convertOptionFormats(options);
          if (typeof query !== "function") {
            query = (0, compile_1.compileUnsafe)(query, opts, elements);
          }
          var filteredElements = prepareContext(elements, opts.adapter, query.shouldTestNextSiblings);
          return searchFunc(query, filteredElements, opts);
        };
      }
      function prepareContext(elems, adapter, shouldTestNextSiblings) {
        if (shouldTestNextSiblings === void 0) {
          shouldTestNextSiblings = false;
        }
        if (shouldTestNextSiblings) {
          elems = appendNextSiblings(elems, adapter);
        }
        return Array.isArray(elems) ? adapter.removeSubsets(elems) : adapter.getChildren(elems);
      }
      exports2.prepareContext = prepareContext;
      function appendNextSiblings(elem, adapter) {
        var elems = Array.isArray(elem) ? elem.slice(0) : [elem];
        var elemsLength = elems.length;
        for (var i = 0; i < elemsLength; i++) {
          var nextSiblings = (0, subselects_1.getNextSiblings)(elems[i], adapter);
          elems.push.apply(elems, nextSiblings);
        }
        return elems;
      }
      exports2.selectAll = getSelectorFunc(function(query, elems, options) {
        return query === boolbase_1.falseFunc || !elems || elems.length === 0 ? [] : options.adapter.findAll(query, elems);
      });
      exports2.selectOne = getSelectorFunc(function(query, elems, options) {
        return query === boolbase_1.falseFunc || !elems || elems.length === 0 ? null : options.adapter.findOne(query, elems);
      });
      function is(elem, query, options) {
        var opts = convertOptionFormats(options);
        return (typeof query === "function" ? query : (0, compile_1.compile)(query, opts))(elem);
      }
      exports2.is = is;
      exports2.default = exports2.selectAll;
      var pseudo_selectors_1 = require_pseudo_selectors();
      Object.defineProperty(exports2, "filters", { enumerable: true, get: function() {
        return pseudo_selectors_1.filters;
      } });
      Object.defineProperty(exports2, "pseudos", { enumerable: true, get: function() {
        return pseudo_selectors_1.pseudos;
      } });
      Object.defineProperty(exports2, "aliases", { enumerable: true, get: function() {
        return pseudo_selectors_1.aliases;
      } });
    }
  });

  // node_modules/.pnpm/renderkid@3.0.0/node_modules/renderkid/lib/renderKid/styles/rule/Selector.js
  var require_Selector = __commonJS({
    "node_modules/.pnpm/renderkid@3.0.0/node_modules/renderkid/lib/renderKid/styles/rule/Selector.js"(exports2, module2) {
      "use strict";
      function _classCallCheck(instance, Constructor) {
        if (!(instance instanceof Constructor)) {
          throw new TypeError("Cannot call a class as a function");
        }
      }
      function _defineProperties(target, props) {
        for (var i = 0; i < props.length; i++) {
          var descriptor = props[i];
          descriptor.enumerable = descriptor.enumerable || false;
          descriptor.configurable = true;
          if ("value" in descriptor)
            descriptor.writable = true;
          Object.defineProperty(target, descriptor.key, descriptor);
        }
      }
      function _createClass(Constructor, protoProps, staticProps) {
        if (protoProps)
          _defineProperties(Constructor.prototype, protoProps);
        if (staticProps)
          _defineProperties(Constructor, staticProps);
        return Constructor;
      }
      var CSSSelect;
      var Selector;
      CSSSelect = require_lib8();
      module2.exports = Selector = function() {
        var self2;
        var Selector2 = /* @__PURE__ */ function() {
          function Selector3(text1) {
            _classCallCheck(this, Selector3);
            this.text = text1;
            this._fn = CSSSelect.compile(this.text);
            this.priority = self2.calculatePriority(this.text);
          }
          _createClass(Selector3, [{
            key: "matches",
            value: function matches(elem) {
              return CSSSelect.is(elem, this._fn);
            }
            // This stupid piece of code is supposed to calculate
            // selector priority, somehow according to
            // http://www.w3.org/wiki/CSS/Training/Priority_level_of_selector
          }], [{
            key: "calculatePriority",
            value: function calculatePriority(text) {
              var n, priotrity;
              priotrity = 0;
              if (n = text.match(/[\#]{1}/g)) {
                priotrity += 100 * n.length;
              }
              if (n = text.match(/[a-zA-Z]+/g)) {
                priotrity += 2 * n.length;
              }
              if (n = text.match(/\*/g)) {
                priotrity += 1 * n.length;
              }
              return priotrity;
            }
          }]);
          return Selector3;
        }();
        ;
        self2 = Selector2;
        return Selector2;
      }.call(void 0);
    }
  });

  // node_modules/.pnpm/renderkid@3.0.0/node_modules/renderkid/lib/renderKid/styles/rule/declarationBlock/_Declaration.js
  var require_Declaration = __commonJS({
    "node_modules/.pnpm/renderkid@3.0.0/node_modules/renderkid/lib/renderKid/styles/rule/declarationBlock/_Declaration.js"(exports2, module2) {
      "use strict";
      function _classCallCheck(instance, Constructor) {
        if (!(instance instanceof Constructor)) {
          throw new TypeError("Cannot call a class as a function");
        }
      }
      function _defineProperties(target, props) {
        for (var i = 0; i < props.length; i++) {
          var descriptor = props[i];
          descriptor.enumerable = descriptor.enumerable || false;
          descriptor.configurable = true;
          if ("value" in descriptor)
            descriptor.writable = true;
          Object.defineProperty(target, descriptor.key, descriptor);
        }
      }
      function _createClass(Constructor, protoProps, staticProps) {
        if (protoProps)
          _defineProperties(Constructor.prototype, protoProps);
        if (staticProps)
          _defineProperties(Constructor, staticProps);
        return Constructor;
      }
      var _Declaration;
      module2.exports = _Declaration = function() {
        var self2;
        var _Declaration2 = /* @__PURE__ */ function() {
          function _Declaration3(prop1, val) {
            _classCallCheck(this, _Declaration3);
            this.prop = prop1;
            this.important = false;
            this.set(val);
          }
          _createClass(_Declaration3, [{
            key: "get",
            value: function get4() {
              return this._get();
            }
          }, {
            key: "_get",
            value: function _get() {
              return this.val;
            }
          }, {
            key: "_pickImportantClause",
            value: function _pickImportantClause(val) {
              if (self2.importantClauseRx.test(String(val))) {
                this.important = true;
                return val.replace(self2.importantClauseRx, "");
              } else {
                this.important = false;
                return val;
              }
            }
          }, {
            key: "set",
            value: function set(val) {
              val = self2.sanitizeValue(val);
              val = this._pickImportantClause(val);
              val = val.trim();
              if (this._handleNullOrInherit(val)) {
                return this;
              }
              this._set(val);
              return this;
            }
          }, {
            key: "_set",
            value: function _set(val) {
              return this.val = val;
            }
          }, {
            key: "_handleNullOrInherit",
            value: function _handleNullOrInherit(val) {
              if (val === "") {
                this.val = "";
                return true;
              }
              if (val === "inherit") {
                if (this.constructor.inheritAllowed) {
                  this.val = "inherit";
                } else {
                  throw Error("Inherit is not allowed for `".concat(this.prop, "`"));
                }
                return true;
              } else {
                return false;
              }
            }
          }], [{
            key: "setOnto",
            value: function setOnto(declarations, prop, val) {
              var dec;
              if (!(dec = declarations[prop])) {
                return declarations[prop] = new this(prop, val);
              } else {
                return dec.set(val);
              }
            }
          }, {
            key: "sanitizeValue",
            value: function sanitizeValue(val) {
              return String(val).trim().replace(/[\s]+/g, " ");
            }
          }]);
          return _Declaration3;
        }();
        ;
        self2 = _Declaration2;
        _Declaration2.importantClauseRx = /(\s\!important)$/;
        _Declaration2.inheritAllowed = false;
        return _Declaration2;
      }.call(void 0);
    }
  });

  // node_modules/.pnpm/renderkid@3.0.0/node_modules/renderkid/lib/renderKid/styles/rule/declarationBlock/Arbitrary.js
  var require_Arbitrary = __commonJS({
    "node_modules/.pnpm/renderkid@3.0.0/node_modules/renderkid/lib/renderKid/styles/rule/declarationBlock/Arbitrary.js"(exports2, module2) {
      "use strict";
      function _typeof(obj) {
        "@babel/helpers - typeof";
        if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
          _typeof = function _typeof2(obj2) {
            return typeof obj2;
          };
        } else {
          _typeof = function _typeof2(obj2) {
            return obj2 && typeof Symbol === "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
          };
        }
        return _typeof(obj);
      }
      function _classCallCheck(instance, Constructor) {
        if (!(instance instanceof Constructor)) {
          throw new TypeError("Cannot call a class as a function");
        }
      }
      function _inherits(subClass, superClass) {
        if (typeof superClass !== "function" && superClass !== null) {
          throw new TypeError("Super expression must either be null or a function");
        }
        subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } });
        if (superClass)
          _setPrototypeOf(subClass, superClass);
      }
      function _setPrototypeOf(o, p) {
        _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf2(o2, p2) {
          o2.__proto__ = p2;
          return o2;
        };
        return _setPrototypeOf(o, p);
      }
      function _createSuper(Derived) {
        var hasNativeReflectConstruct = _isNativeReflectConstruct();
        return function _createSuperInternal() {
          var Super = _getPrototypeOf(Derived), result;
          if (hasNativeReflectConstruct) {
            var NewTarget = _getPrototypeOf(this).constructor;
            result = Reflect.construct(Super, arguments, NewTarget);
          } else {
            result = Super.apply(this, arguments);
          }
          return _possibleConstructorReturn(this, result);
        };
      }
      function _possibleConstructorReturn(self2, call) {
        if (call && (_typeof(call) === "object" || typeof call === "function")) {
          return call;
        }
        return _assertThisInitialized(self2);
      }
      function _assertThisInitialized(self2) {
        if (self2 === void 0) {
          throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
        }
        return self2;
      }
      function _isNativeReflectConstruct() {
        if (typeof Reflect === "undefined" || !Reflect.construct)
          return false;
        if (Reflect.construct.sham)
          return false;
        if (typeof Proxy === "function")
          return true;
        try {
          Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
          }));
          return true;
        } catch (e) {
          return false;
        }
      }
      function _getPrototypeOf(o) {
        _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf2(o2) {
          return o2.__proto__ || Object.getPrototypeOf(o2);
        };
        return _getPrototypeOf(o);
      }
      var Arbitrary;
      var _Declaration;
      _Declaration = require_Declaration();
      module2.exports = Arbitrary = /* @__PURE__ */ function(_Declaration2) {
        _inherits(Arbitrary2, _Declaration2);
        var _super = _createSuper(Arbitrary2);
        function Arbitrary2() {
          _classCallCheck(this, Arbitrary2);
          return _super.apply(this, arguments);
        }
        return Arbitrary2;
      }(_Declaration);
    }
  });

  // node_modules/.pnpm/renderkid@3.0.0/node_modules/renderkid/lib/renderKid/styles/rule/declarationBlock/Color.js
  var require_Color = __commonJS({
    "node_modules/.pnpm/renderkid@3.0.0/node_modules/renderkid/lib/renderKid/styles/rule/declarationBlock/Color.js"(exports2, module2) {
      "use strict";
      function _typeof(obj) {
        "@babel/helpers - typeof";
        if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
          _typeof = function _typeof2(obj2) {
            return typeof obj2;
          };
        } else {
          _typeof = function _typeof2(obj2) {
            return obj2 && typeof Symbol === "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
          };
        }
        return _typeof(obj);
      }
      function _classCallCheck(instance, Constructor) {
        if (!(instance instanceof Constructor)) {
          throw new TypeError("Cannot call a class as a function");
        }
      }
      function _inherits(subClass, superClass) {
        if (typeof superClass !== "function" && superClass !== null) {
          throw new TypeError("Super expression must either be null or a function");
        }
        subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } });
        if (superClass)
          _setPrototypeOf(subClass, superClass);
      }
      function _setPrototypeOf(o, p) {
        _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf2(o2, p2) {
          o2.__proto__ = p2;
          return o2;
        };
        return _setPrototypeOf(o, p);
      }
      function _createSuper(Derived) {
        var hasNativeReflectConstruct = _isNativeReflectConstruct();
        return function _createSuperInternal() {
          var Super = _getPrototypeOf(Derived), result;
          if (hasNativeReflectConstruct) {
            var NewTarget = _getPrototypeOf(this).constructor;
            result = Reflect.construct(Super, arguments, NewTarget);
          } else {
            result = Super.apply(this, arguments);
          }
          return _possibleConstructorReturn(this, result);
        };
      }
      function _possibleConstructorReturn(self2, call) {
        if (call && (_typeof(call) === "object" || typeof call === "function")) {
          return call;
        }
        return _assertThisInitialized(self2);
      }
      function _assertThisInitialized(self2) {
        if (self2 === void 0) {
          throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
        }
        return self2;
      }
      function _isNativeReflectConstruct() {
        if (typeof Reflect === "undefined" || !Reflect.construct)
          return false;
        if (Reflect.construct.sham)
          return false;
        if (typeof Proxy === "function")
          return true;
        try {
          Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
          }));
          return true;
        } catch (e) {
          return false;
        }
      }
      function _getPrototypeOf(o) {
        _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf2(o2) {
          return o2.__proto__ || Object.getPrototypeOf(o2);
        };
        return _getPrototypeOf(o);
      }
      var Color;
      var _Declaration;
      _Declaration = require_Declaration();
      module2.exports = Color = /* @__PURE__ */ function(_Declaration2) {
        _inherits(Color2, _Declaration2);
        var _super = _createSuper(Color2);
        function Color2() {
          _classCallCheck(this, Color2);
          return _super.apply(this, arguments);
        }
        return Color2;
      }(_Declaration);
    }
  });

  // node_modules/.pnpm/renderkid@3.0.0/node_modules/renderkid/lib/renderKid/styles/rule/declarationBlock/Background.js
  var require_Background = __commonJS({
    "node_modules/.pnpm/renderkid@3.0.0/node_modules/renderkid/lib/renderKid/styles/rule/declarationBlock/Background.js"(exports2, module2) {
      "use strict";
      function _typeof(obj) {
        "@babel/helpers - typeof";
        if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
          _typeof = function _typeof2(obj2) {
            return typeof obj2;
          };
        } else {
          _typeof = function _typeof2(obj2) {
            return obj2 && typeof Symbol === "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
          };
        }
        return _typeof(obj);
      }
      function _classCallCheck(instance, Constructor) {
        if (!(instance instanceof Constructor)) {
          throw new TypeError("Cannot call a class as a function");
        }
      }
      function _inherits(subClass, superClass) {
        if (typeof superClass !== "function" && superClass !== null) {
          throw new TypeError("Super expression must either be null or a function");
        }
        subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } });
        if (superClass)
          _setPrototypeOf(subClass, superClass);
      }
      function _setPrototypeOf(o, p) {
        _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf2(o2, p2) {
          o2.__proto__ = p2;
          return o2;
        };
        return _setPrototypeOf(o, p);
      }
      function _createSuper(Derived) {
        var hasNativeReflectConstruct = _isNativeReflectConstruct();
        return function _createSuperInternal() {
          var Super = _getPrototypeOf(Derived), result;
          if (hasNativeReflectConstruct) {
            var NewTarget = _getPrototypeOf(this).constructor;
            result = Reflect.construct(Super, arguments, NewTarget);
          } else {
            result = Super.apply(this, arguments);
          }
          return _possibleConstructorReturn(this, result);
        };
      }
      function _possibleConstructorReturn(self2, call) {
        if (call && (_typeof(call) === "object" || typeof call === "function")) {
          return call;
        }
        return _assertThisInitialized(self2);
      }
      function _assertThisInitialized(self2) {
        if (self2 === void 0) {
          throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
        }
        return self2;
      }
      function _isNativeReflectConstruct() {
        if (typeof Reflect === "undefined" || !Reflect.construct)
          return false;
        if (Reflect.construct.sham)
          return false;
        if (typeof Proxy === "function")
          return true;
        try {
          Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
          }));
          return true;
        } catch (e) {
          return false;
        }
      }
      function _getPrototypeOf(o) {
        _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf2(o2) {
          return o2.__proto__ || Object.getPrototypeOf(o2);
        };
        return _getPrototypeOf(o);
      }
      var Background;
      var _Declaration;
      _Declaration = require_Declaration();
      module2.exports = Background = /* @__PURE__ */ function(_Declaration2) {
        _inherits(Background2, _Declaration2);
        var _super = _createSuper(Background2);
        function Background2() {
          _classCallCheck(this, Background2);
          return _super.apply(this, arguments);
        }
        return Background2;
      }(_Declaration);
    }
  });

  // node_modules/.pnpm/renderkid@3.0.0/node_modules/renderkid/lib/renderKid/styles/rule/declarationBlock/_Length.js
  var require_Length = __commonJS({
    "node_modules/.pnpm/renderkid@3.0.0/node_modules/renderkid/lib/renderKid/styles/rule/declarationBlock/_Length.js"(exports2, module2) {
      "use strict";
      function _typeof(obj) {
        "@babel/helpers - typeof";
        if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
          _typeof = function _typeof2(obj2) {
            return typeof obj2;
          };
        } else {
          _typeof = function _typeof2(obj2) {
            return obj2 && typeof Symbol === "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
          };
        }
        return _typeof(obj);
      }
      function _classCallCheck(instance, Constructor) {
        if (!(instance instanceof Constructor)) {
          throw new TypeError("Cannot call a class as a function");
        }
      }
      function _defineProperties(target, props) {
        for (var i = 0; i < props.length; i++) {
          var descriptor = props[i];
          descriptor.enumerable = descriptor.enumerable || false;
          descriptor.configurable = true;
          if ("value" in descriptor)
            descriptor.writable = true;
          Object.defineProperty(target, descriptor.key, descriptor);
        }
      }
      function _createClass(Constructor, protoProps, staticProps) {
        if (protoProps)
          _defineProperties(Constructor.prototype, protoProps);
        if (staticProps)
          _defineProperties(Constructor, staticProps);
        return Constructor;
      }
      function _inherits(subClass, superClass) {
        if (typeof superClass !== "function" && superClass !== null) {
          throw new TypeError("Super expression must either be null or a function");
        }
        subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } });
        if (superClass)
          _setPrototypeOf(subClass, superClass);
      }
      function _setPrototypeOf(o, p) {
        _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf2(o2, p2) {
          o2.__proto__ = p2;
          return o2;
        };
        return _setPrototypeOf(o, p);
      }
      function _createSuper(Derived) {
        var hasNativeReflectConstruct = _isNativeReflectConstruct();
        return function _createSuperInternal() {
          var Super = _getPrototypeOf(Derived), result;
          if (hasNativeReflectConstruct) {
            var NewTarget = _getPrototypeOf(this).constructor;
            result = Reflect.construct(Super, arguments, NewTarget);
          } else {
            result = Super.apply(this, arguments);
          }
          return _possibleConstructorReturn(this, result);
        };
      }
      function _possibleConstructorReturn(self2, call) {
        if (call && (_typeof(call) === "object" || typeof call === "function")) {
          return call;
        }
        return _assertThisInitialized(self2);
      }
      function _assertThisInitialized(self2) {
        if (self2 === void 0) {
          throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
        }
        return self2;
      }
      function _isNativeReflectConstruct() {
        if (typeof Reflect === "undefined" || !Reflect.construct)
          return false;
        if (Reflect.construct.sham)
          return false;
        if (typeof Proxy === "function")
          return true;
        try {
          Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
          }));
          return true;
        } catch (e) {
          return false;
        }
      }
      function _getPrototypeOf(o) {
        _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf2(o2) {
          return o2.__proto__ || Object.getPrototypeOf(o2);
        };
        return _getPrototypeOf(o);
      }
      var _Declaration;
      var _Length;
      _Declaration = require_Declaration();
      module2.exports = _Length = /* @__PURE__ */ function(_Declaration2) {
        _inherits(_Length2, _Declaration2);
        var _super = _createSuper(_Length2);
        function _Length2() {
          _classCallCheck(this, _Length2);
          return _super.apply(this, arguments);
        }
        _createClass(_Length2, [{
          key: "_set",
          value: function _set(val) {
            if (!/^[0-9]+$/.test(String(val))) {
              throw Error("`".concat(this.prop, "` only takes an integer for value"));
            }
            return this.val = parseInt(val);
          }
        }]);
        return _Length2;
      }(_Declaration);
    }
  });

  // node_modules/.pnpm/renderkid@3.0.0/node_modules/renderkid/lib/renderKid/styles/rule/declarationBlock/Width.js
  var require_Width = __commonJS({
    "node_modules/.pnpm/renderkid@3.0.0/node_modules/renderkid/lib/renderKid/styles/rule/declarationBlock/Width.js"(exports2, module2) {
      "use strict";
      function _typeof(obj) {
        "@babel/helpers - typeof";
        if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
          _typeof = function _typeof2(obj2) {
            return typeof obj2;
          };
        } else {
          _typeof = function _typeof2(obj2) {
            return obj2 && typeof Symbol === "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
          };
        }
        return _typeof(obj);
      }
      function _classCallCheck(instance, Constructor) {
        if (!(instance instanceof Constructor)) {
          throw new TypeError("Cannot call a class as a function");
        }
      }
      function _inherits(subClass, superClass) {
        if (typeof superClass !== "function" && superClass !== null) {
          throw new TypeError("Super expression must either be null or a function");
        }
        subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } });
        if (superClass)
          _setPrototypeOf(subClass, superClass);
      }
      function _setPrototypeOf(o, p) {
        _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf2(o2, p2) {
          o2.__proto__ = p2;
          return o2;
        };
        return _setPrototypeOf(o, p);
      }
      function _createSuper(Derived) {
        var hasNativeReflectConstruct = _isNativeReflectConstruct();
        return function _createSuperInternal() {
          var Super = _getPrototypeOf(Derived), result;
          if (hasNativeReflectConstruct) {
            var NewTarget = _getPrototypeOf(this).constructor;
            result = Reflect.construct(Super, arguments, NewTarget);
          } else {
            result = Super.apply(this, arguments);
          }
          return _possibleConstructorReturn(this, result);
        };
      }
      function _possibleConstructorReturn(self2, call) {
        if (call && (_typeof(call) === "object" || typeof call === "function")) {
          return call;
        }
        return _assertThisInitialized(self2);
      }
      function _assertThisInitialized(self2) {
        if (self2 === void 0) {
          throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
        }
        return self2;
      }
      function _isNativeReflectConstruct() {
        if (typeof Reflect === "undefined" || !Reflect.construct)
          return false;
        if (Reflect.construct.sham)
          return false;
        if (typeof Proxy === "function")
          return true;
        try {
          Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
          }));
          return true;
        } catch (e) {
          return false;
        }
      }
      function _getPrototypeOf(o) {
        _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf2(o2) {
          return o2.__proto__ || Object.getPrototypeOf(o2);
        };
        return _getPrototypeOf(o);
      }
      var Width;
      var _Length;
      _Length = require_Length();
      module2.exports = Width = /* @__PURE__ */ function(_Length2) {
        _inherits(Width2, _Length2);
        var _super = _createSuper(Width2);
        function Width2() {
          _classCallCheck(this, Width2);
          return _super.apply(this, arguments);
        }
        return Width2;
      }(_Length);
    }
  });

  // node_modules/.pnpm/renderkid@3.0.0/node_modules/renderkid/lib/renderKid/styles/rule/declarationBlock/Height.js
  var require_Height = __commonJS({
    "node_modules/.pnpm/renderkid@3.0.0/node_modules/renderkid/lib/renderKid/styles/rule/declarationBlock/Height.js"(exports2, module2) {
      "use strict";
      function _typeof(obj) {
        "@babel/helpers - typeof";
        if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
          _typeof = function _typeof2(obj2) {
            return typeof obj2;
          };
        } else {
          _typeof = function _typeof2(obj2) {
            return obj2 && typeof Symbol === "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
          };
        }
        return _typeof(obj);
      }
      function _classCallCheck(instance, Constructor) {
        if (!(instance instanceof Constructor)) {
          throw new TypeError("Cannot call a class as a function");
        }
      }
      function _inherits(subClass, superClass) {
        if (typeof superClass !== "function" && superClass !== null) {
          throw new TypeError("Super expression must either be null or a function");
        }
        subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } });
        if (superClass)
          _setPrototypeOf(subClass, superClass);
      }
      function _setPrototypeOf(o, p) {
        _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf2(o2, p2) {
          o2.__proto__ = p2;
          return o2;
        };
        return _setPrototypeOf(o, p);
      }
      function _createSuper(Derived) {
        var hasNativeReflectConstruct = _isNativeReflectConstruct();
        return function _createSuperInternal() {
          var Super = _getPrototypeOf(Derived), result;
          if (hasNativeReflectConstruct) {
            var NewTarget = _getPrototypeOf(this).constructor;
            result = Reflect.construct(Super, arguments, NewTarget);
          } else {
            result = Super.apply(this, arguments);
          }
          return _possibleConstructorReturn(this, result);
        };
      }
      function _possibleConstructorReturn(self2, call) {
        if (call && (_typeof(call) === "object" || typeof call === "function")) {
          return call;
        }
        return _assertThisInitialized(self2);
      }
      function _assertThisInitialized(self2) {
        if (self2 === void 0) {
          throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
        }
        return self2;
      }
      function _isNativeReflectConstruct() {
        if (typeof Reflect === "undefined" || !Reflect.construct)
          return false;
        if (Reflect.construct.sham)
          return false;
        if (typeof Proxy === "function")
          return true;
        try {
          Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
          }));
          return true;
        } catch (e) {
          return false;
        }
      }
      function _getPrototypeOf(o) {
        _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf2(o2) {
          return o2.__proto__ || Object.getPrototypeOf(o2);
        };
        return _getPrototypeOf(o);
      }
      var Height;
      var _Length;
      _Length = require_Length();
      module2.exports = Height = /* @__PURE__ */ function(_Length2) {
        _inherits(Height2, _Length2);
        var _super = _createSuper(Height2);
        function Height2() {
          _classCallCheck(this, Height2);
          return _super.apply(this, arguments);
        }
        return Height2;
      }(_Length);
    }
  });

  // node_modules/.pnpm/renderkid@3.0.0/node_modules/renderkid/lib/renderKid/styles/rule/declarationBlock/Bullet.js
  var require_Bullet = __commonJS({
    "node_modules/.pnpm/renderkid@3.0.0/node_modules/renderkid/lib/renderKid/styles/rule/declarationBlock/Bullet.js"(exports2, module2) {
      "use strict";
      function _typeof(obj) {
        "@babel/helpers - typeof";
        if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
          _typeof = function _typeof2(obj2) {
            return typeof obj2;
          };
        } else {
          _typeof = function _typeof2(obj2) {
            return obj2 && typeof Symbol === "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
          };
        }
        return _typeof(obj);
      }
      function _classCallCheck(instance, Constructor) {
        if (!(instance instanceof Constructor)) {
          throw new TypeError("Cannot call a class as a function");
        }
      }
      function _defineProperties(target, props) {
        for (var i = 0; i < props.length; i++) {
          var descriptor = props[i];
          descriptor.enumerable = descriptor.enumerable || false;
          descriptor.configurable = true;
          if ("value" in descriptor)
            descriptor.writable = true;
          Object.defineProperty(target, descriptor.key, descriptor);
        }
      }
      function _createClass(Constructor, protoProps, staticProps) {
        if (protoProps)
          _defineProperties(Constructor.prototype, protoProps);
        if (staticProps)
          _defineProperties(Constructor, staticProps);
        return Constructor;
      }
      function _inherits(subClass, superClass) {
        if (typeof superClass !== "function" && superClass !== null) {
          throw new TypeError("Super expression must either be null or a function");
        }
        subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } });
        if (superClass)
          _setPrototypeOf(subClass, superClass);
      }
      function _setPrototypeOf(o, p) {
        _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf2(o2, p2) {
          o2.__proto__ = p2;
          return o2;
        };
        return _setPrototypeOf(o, p);
      }
      function _createSuper(Derived) {
        var hasNativeReflectConstruct = _isNativeReflectConstruct();
        return function _createSuperInternal() {
          var Super = _getPrototypeOf(Derived), result;
          if (hasNativeReflectConstruct) {
            var NewTarget = _getPrototypeOf(this).constructor;
            result = Reflect.construct(Super, arguments, NewTarget);
          } else {
            result = Super.apply(this, arguments);
          }
          return _possibleConstructorReturn(this, result);
        };
      }
      function _possibleConstructorReturn(self2, call) {
        if (call && (_typeof(call) === "object" || typeof call === "function")) {
          return call;
        }
        return _assertThisInitialized(self2);
      }
      function _assertThisInitialized(self2) {
        if (self2 === void 0) {
          throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
        }
        return self2;
      }
      function _isNativeReflectConstruct() {
        if (typeof Reflect === "undefined" || !Reflect.construct)
          return false;
        if (Reflect.construct.sham)
          return false;
        if (typeof Proxy === "function")
          return true;
        try {
          Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
          }));
          return true;
        } catch (e) {
          return false;
        }
      }
      function _getPrototypeOf(o) {
        _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf2(o2) {
          return o2.__proto__ || Object.getPrototypeOf(o2);
        };
        return _getPrototypeOf(o);
      }
      var Bullet;
      var _Declaration;
      _Declaration = require_Declaration();
      module2.exports = Bullet = function() {
        var self2;
        var Bullet2 = /* @__PURE__ */ function(_Declaration2) {
          _inherits(Bullet3, _Declaration2);
          var _super = _createSuper(Bullet3);
          function Bullet3() {
            _classCallCheck(this, Bullet3);
            return _super.apply(this, arguments);
          }
          _createClass(Bullet3, [{
            key: "_set",
            value: function _set(val) {
              var alignment, bg, char, color, enabled, m, original;
              val = String(val);
              original = val;
              char = null;
              enabled = false;
              color = "none";
              bg = "none";
              if (m = val.match(/\"([^"]+)\"/) || (m = val.match(/\'([^']+)\'/))) {
                char = m[1];
                val = val.replace(m[0], "");
                enabled = true;
              }
              if (m = val.match(/(none|left|right|center)/)) {
                alignment = m[1];
                val = val.replace(m[0], "");
              } else {
                alignment = "left";
              }
              if (alignment === "none") {
                enabled = false;
              }
              if (m = val.match(/color\:([\w\-]+)/)) {
                color = m[1];
                val = val.replace(m[0], "");
              }
              if (m = val.match(/bg\:([\w\-]+)/)) {
                bg = m[1];
                val = val.replace(m[0], "");
              }
              if (val.trim() !== "") {
                throw Error("Unrecognizable value `".concat(original, "` for `").concat(this.prop, "`"));
              }
              return this.val = {
                enabled,
                char,
                alignment,
                background: bg,
                color
              };
            }
          }]);
          return Bullet3;
        }(_Declaration);
        ;
        self2 = Bullet2;
        return Bullet2;
      }.call(void 0);
    }
  });

  // node_modules/.pnpm/renderkid@3.0.0/node_modules/renderkid/lib/renderKid/styles/rule/declarationBlock/Display.js
  var require_Display = __commonJS({
    "node_modules/.pnpm/renderkid@3.0.0/node_modules/renderkid/lib/renderKid/styles/rule/declarationBlock/Display.js"(exports2, module2) {
      "use strict";
      function _typeof(obj) {
        "@babel/helpers - typeof";
        if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
          _typeof = function _typeof2(obj2) {
            return typeof obj2;
          };
        } else {
          _typeof = function _typeof2(obj2) {
            return obj2 && typeof Symbol === "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
          };
        }
        return _typeof(obj);
      }
      function _classCallCheck(instance, Constructor) {
        if (!(instance instanceof Constructor)) {
          throw new TypeError("Cannot call a class as a function");
        }
      }
      function _defineProperties(target, props) {
        for (var i = 0; i < props.length; i++) {
          var descriptor = props[i];
          descriptor.enumerable = descriptor.enumerable || false;
          descriptor.configurable = true;
          if ("value" in descriptor)
            descriptor.writable = true;
          Object.defineProperty(target, descriptor.key, descriptor);
        }
      }
      function _createClass(Constructor, protoProps, staticProps) {
        if (protoProps)
          _defineProperties(Constructor.prototype, protoProps);
        if (staticProps)
          _defineProperties(Constructor, staticProps);
        return Constructor;
      }
      function _inherits(subClass, superClass) {
        if (typeof superClass !== "function" && superClass !== null) {
          throw new TypeError("Super expression must either be null or a function");
        }
        subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } });
        if (superClass)
          _setPrototypeOf(subClass, superClass);
      }
      function _setPrototypeOf(o, p) {
        _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf2(o2, p2) {
          o2.__proto__ = p2;
          return o2;
        };
        return _setPrototypeOf(o, p);
      }
      function _createSuper(Derived) {
        var hasNativeReflectConstruct = _isNativeReflectConstruct();
        return function _createSuperInternal() {
          var Super = _getPrototypeOf(Derived), result;
          if (hasNativeReflectConstruct) {
            var NewTarget = _getPrototypeOf(this).constructor;
            result = Reflect.construct(Super, arguments, NewTarget);
          } else {
            result = Super.apply(this, arguments);
          }
          return _possibleConstructorReturn(this, result);
        };
      }
      function _possibleConstructorReturn(self2, call) {
        if (call && (_typeof(call) === "object" || typeof call === "function")) {
          return call;
        }
        return _assertThisInitialized(self2);
      }
      function _assertThisInitialized(self2) {
        if (self2 === void 0) {
          throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
        }
        return self2;
      }
      function _isNativeReflectConstruct() {
        if (typeof Reflect === "undefined" || !Reflect.construct)
          return false;
        if (Reflect.construct.sham)
          return false;
        if (typeof Proxy === "function")
          return true;
        try {
          Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
          }));
          return true;
        } catch (e) {
          return false;
        }
      }
      function _getPrototypeOf(o) {
        _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf2(o2) {
          return o2.__proto__ || Object.getPrototypeOf(o2);
        };
        return _getPrototypeOf(o);
      }
      var Display;
      var _Declaration;
      var indexOf = [].indexOf;
      _Declaration = require_Declaration();
      module2.exports = Display = function() {
        var self2;
        var Display2 = /* @__PURE__ */ function(_Declaration2) {
          _inherits(Display3, _Declaration2);
          var _super = _createSuper(Display3);
          function Display3() {
            _classCallCheck(this, Display3);
            return _super.apply(this, arguments);
          }
          _createClass(Display3, [{
            key: "_set",
            value: function _set(val) {
              val = String(val).toLowerCase();
              if (indexOf.call(self2._allowed, val) < 0) {
                throw Error("Unrecognizable value `".concat(val, "` for `").concat(this.prop, "`"));
              }
              return this.val = val;
            }
          }]);
          return Display3;
        }(_Declaration);
        ;
        self2 = Display2;
        Display2._allowed = ["inline", "block", "none"];
        return Display2;
      }.call(void 0);
    }
  });

  // node_modules/.pnpm/renderkid@3.0.0/node_modules/renderkid/lib/renderKid/styles/rule/declarationBlock/MarginTop.js
  var require_MarginTop = __commonJS({
    "node_modules/.pnpm/renderkid@3.0.0/node_modules/renderkid/lib/renderKid/styles/rule/declarationBlock/MarginTop.js"(exports2, module2) {
      "use strict";
      function _typeof(obj) {
        "@babel/helpers - typeof";
        if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
          _typeof = function _typeof2(obj2) {
            return typeof obj2;
          };
        } else {
          _typeof = function _typeof2(obj2) {
            return obj2 && typeof Symbol === "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
          };
        }
        return _typeof(obj);
      }
      function _classCallCheck(instance, Constructor) {
        if (!(instance instanceof Constructor)) {
          throw new TypeError("Cannot call a class as a function");
        }
      }
      function _inherits(subClass, superClass) {
        if (typeof superClass !== "function" && superClass !== null) {
          throw new TypeError("Super expression must either be null or a function");
        }
        subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } });
        if (superClass)
          _setPrototypeOf(subClass, superClass);
      }
      function _setPrototypeOf(o, p) {
        _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf2(o2, p2) {
          o2.__proto__ = p2;
          return o2;
        };
        return _setPrototypeOf(o, p);
      }
      function _createSuper(Derived) {
        var hasNativeReflectConstruct = _isNativeReflectConstruct();
        return function _createSuperInternal() {
          var Super = _getPrototypeOf(Derived), result;
          if (hasNativeReflectConstruct) {
            var NewTarget = _getPrototypeOf(this).constructor;
            result = Reflect.construct(Super, arguments, NewTarget);
          } else {
            result = Super.apply(this, arguments);
          }
          return _possibleConstructorReturn(this, result);
        };
      }
      function _possibleConstructorReturn(self2, call) {
        if (call && (_typeof(call) === "object" || typeof call === "function")) {
          return call;
        }
        return _assertThisInitialized(self2);
      }
      function _assertThisInitialized(self2) {
        if (self2 === void 0) {
          throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
        }
        return self2;
      }
      function _isNativeReflectConstruct() {
        if (typeof Reflect === "undefined" || !Reflect.construct)
          return false;
        if (Reflect.construct.sham)
          return false;
        if (typeof Proxy === "function")
          return true;
        try {
          Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
          }));
          return true;
        } catch (e) {
          return false;
        }
      }
      function _getPrototypeOf(o) {
        _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf2(o2) {
          return o2.__proto__ || Object.getPrototypeOf(o2);
        };
        return _getPrototypeOf(o);
      }
      var MarginTop;
      var _Length;
      _Length = require_Length();
      module2.exports = MarginTop = /* @__PURE__ */ function(_Length2) {
        _inherits(MarginTop2, _Length2);
        var _super = _createSuper(MarginTop2);
        function MarginTop2() {
          _classCallCheck(this, MarginTop2);
          return _super.apply(this, arguments);
        }
        return MarginTop2;
      }(_Length);
    }
  });

  // node_modules/.pnpm/renderkid@3.0.0/node_modules/renderkid/lib/renderKid/styles/rule/declarationBlock/MarginLeft.js
  var require_MarginLeft = __commonJS({
    "node_modules/.pnpm/renderkid@3.0.0/node_modules/renderkid/lib/renderKid/styles/rule/declarationBlock/MarginLeft.js"(exports2, module2) {
      "use strict";
      function _typeof(obj) {
        "@babel/helpers - typeof";
        if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
          _typeof = function _typeof2(obj2) {
            return typeof obj2;
          };
        } else {
          _typeof = function _typeof2(obj2) {
            return obj2 && typeof Symbol === "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
          };
        }
        return _typeof(obj);
      }
      function _classCallCheck(instance, Constructor) {
        if (!(instance instanceof Constructor)) {
          throw new TypeError("Cannot call a class as a function");
        }
      }
      function _inherits(subClass, superClass) {
        if (typeof superClass !== "function" && superClass !== null) {
          throw new TypeError("Super expression must either be null or a function");
        }
        subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } });
        if (superClass)
          _setPrototypeOf(subClass, superClass);
      }
      function _setPrototypeOf(o, p) {
        _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf2(o2, p2) {
          o2.__proto__ = p2;
          return o2;
        };
        return _setPrototypeOf(o, p);
      }
      function _createSuper(Derived) {
        var hasNativeReflectConstruct = _isNativeReflectConstruct();
        return function _createSuperInternal() {
          var Super = _getPrototypeOf(Derived), result;
          if (hasNativeReflectConstruct) {
            var NewTarget = _getPrototypeOf(this).constructor;
            result = Reflect.construct(Super, arguments, NewTarget);
          } else {
            result = Super.apply(this, arguments);
          }
          return _possibleConstructorReturn(this, result);
        };
      }
      function _possibleConstructorReturn(self2, call) {
        if (call && (_typeof(call) === "object" || typeof call === "function")) {
          return call;
        }
        return _assertThisInitialized(self2);
      }
      function _assertThisInitialized(self2) {
        if (self2 === void 0) {
          throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
        }
        return self2;
      }
      function _isNativeReflectConstruct() {
        if (typeof Reflect === "undefined" || !Reflect.construct)
          return false;
        if (Reflect.construct.sham)
          return false;
        if (typeof Proxy === "function")
          return true;
        try {
          Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
          }));
          return true;
        } catch (e) {
          return false;
        }
      }
      function _getPrototypeOf(o) {
        _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf2(o2) {
          return o2.__proto__ || Object.getPrototypeOf(o2);
        };
        return _getPrototypeOf(o);
      }
      var MarginLeft;
      var _Length;
      _Length = require_Length();
      module2.exports = MarginLeft = /* @__PURE__ */ function(_Length2) {
        _inherits(MarginLeft2, _Length2);
        var _super = _createSuper(MarginLeft2);
        function MarginLeft2() {
          _classCallCheck(this, MarginLeft2);
          return _super.apply(this, arguments);
        }
        return MarginLeft2;
      }(_Length);
    }
  });

  // node_modules/.pnpm/renderkid@3.0.0/node_modules/renderkid/lib/renderKid/styles/rule/declarationBlock/MarginRight.js
  var require_MarginRight = __commonJS({
    "node_modules/.pnpm/renderkid@3.0.0/node_modules/renderkid/lib/renderKid/styles/rule/declarationBlock/MarginRight.js"(exports2, module2) {
      "use strict";
      function _typeof(obj) {
        "@babel/helpers - typeof";
        if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
          _typeof = function _typeof2(obj2) {
            return typeof obj2;
          };
        } else {
          _typeof = function _typeof2(obj2) {
            return obj2 && typeof Symbol === "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
          };
        }
        return _typeof(obj);
      }
      function _classCallCheck(instance, Constructor) {
        if (!(instance instanceof Constructor)) {
          throw new TypeError("Cannot call a class as a function");
        }
      }
      function _inherits(subClass, superClass) {
        if (typeof superClass !== "function" && superClass !== null) {
          throw new TypeError("Super expression must either be null or a function");
        }
        subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } });
        if (superClass)
          _setPrototypeOf(subClass, superClass);
      }
      function _setPrototypeOf(o, p) {
        _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf2(o2, p2) {
          o2.__proto__ = p2;
          return o2;
        };
        return _setPrototypeOf(o, p);
      }
      function _createSuper(Derived) {
        var hasNativeReflectConstruct = _isNativeReflectConstruct();
        return function _createSuperInternal() {
          var Super = _getPrototypeOf(Derived), result;
          if (hasNativeReflectConstruct) {
            var NewTarget = _getPrototypeOf(this).constructor;
            result = Reflect.construct(Super, arguments, NewTarget);
          } else {
            result = Super.apply(this, arguments);
          }
          return _possibleConstructorReturn(this, result);
        };
      }
      function _possibleConstructorReturn(self2, call) {
        if (call && (_typeof(call) === "object" || typeof call === "function")) {
          return call;
        }
        return _assertThisInitialized(self2);
      }
      function _assertThisInitialized(self2) {
        if (self2 === void 0) {
          throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
        }
        return self2;
      }
      function _isNativeReflectConstruct() {
        if (typeof Reflect === "undefined" || !Reflect.construct)
          return false;
        if (Reflect.construct.sham)
          return false;
        if (typeof Proxy === "function")
          return true;
        try {
          Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
          }));
          return true;
        } catch (e) {
          return false;
        }
      }
      function _getPrototypeOf(o) {
        _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf2(o2) {
          return o2.__proto__ || Object.getPrototypeOf(o2);
        };
        return _getPrototypeOf(o);
      }
      var MarginRight;
      var _Length;
      _Length = require_Length();
      module2.exports = MarginRight = /* @__PURE__ */ function(_Length2) {
        _inherits(MarginRight2, _Length2);
        var _super = _createSuper(MarginRight2);
        function MarginRight2() {
          _classCallCheck(this, MarginRight2);
          return _super.apply(this, arguments);
        }
        return MarginRight2;
      }(_Length);
    }
  });

  // node_modules/.pnpm/renderkid@3.0.0/node_modules/renderkid/lib/renderKid/styles/rule/declarationBlock/MarginBottom.js
  var require_MarginBottom = __commonJS({
    "node_modules/.pnpm/renderkid@3.0.0/node_modules/renderkid/lib/renderKid/styles/rule/declarationBlock/MarginBottom.js"(exports2, module2) {
      "use strict";
      function _typeof(obj) {
        "@babel/helpers - typeof";
        if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
          _typeof = function _typeof2(obj2) {
            return typeof obj2;
          };
        } else {
          _typeof = function _typeof2(obj2) {
            return obj2 && typeof Symbol === "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
          };
        }
        return _typeof(obj);
      }
      function _classCallCheck(instance, Constructor) {
        if (!(instance instanceof Constructor)) {
          throw new TypeError("Cannot call a class as a function");
        }
      }
      function _inherits(subClass, superClass) {
        if (typeof superClass !== "function" && superClass !== null) {
          throw new TypeError("Super expression must either be null or a function");
        }
        subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } });
        if (superClass)
          _setPrototypeOf(subClass, superClass);
      }
      function _setPrototypeOf(o, p) {
        _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf2(o2, p2) {
          o2.__proto__ = p2;
          return o2;
        };
        return _setPrototypeOf(o, p);
      }
      function _createSuper(Derived) {
        var hasNativeReflectConstruct = _isNativeReflectConstruct();
        return function _createSuperInternal() {
          var Super = _getPrototypeOf(Derived), result;
          if (hasNativeReflectConstruct) {
            var NewTarget = _getPrototypeOf(this).constructor;
            result = Reflect.construct(Super, arguments, NewTarget);
          } else {
            result = Super.apply(this, arguments);
          }
          return _possibleConstructorReturn(this, result);
        };
      }
      function _possibleConstructorReturn(self2, call) {
        if (call && (_typeof(call) === "object" || typeof call === "function")) {
          return call;
        }
        return _assertThisInitialized(self2);
      }
      function _assertThisInitialized(self2) {
        if (self2 === void 0) {
          throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
        }
        return self2;
      }
      function _isNativeReflectConstruct() {
        if (typeof Reflect === "undefined" || !Reflect.construct)
          return false;
        if (Reflect.construct.sham)
          return false;
        if (typeof Proxy === "function")
          return true;
        try {
          Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
          }));
          return true;
        } catch (e) {
          return false;
        }
      }
      function _getPrototypeOf(o) {
        _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf2(o2) {
          return o2.__proto__ || Object.getPrototypeOf(o2);
        };
        return _getPrototypeOf(o);
      }
      var MarginBottom;
      var _Length;
      _Length = require_Length();
      module2.exports = MarginBottom = /* @__PURE__ */ function(_Length2) {
        _inherits(MarginBottom2, _Length2);
        var _super = _createSuper(MarginBottom2);
        function MarginBottom2() {
          _classCallCheck(this, MarginBottom2);
          return _super.apply(this, arguments);
        }
        return MarginBottom2;
      }(_Length);
    }
  });

  // node_modules/.pnpm/renderkid@3.0.0/node_modules/renderkid/lib/renderKid/styles/rule/declarationBlock/Margin.js
  var require_Margin = __commonJS({
    "node_modules/.pnpm/renderkid@3.0.0/node_modules/renderkid/lib/renderKid/styles/rule/declarationBlock/Margin.js"(exports2, module2) {
      "use strict";
      function _typeof(obj) {
        "@babel/helpers - typeof";
        if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
          _typeof = function _typeof2(obj2) {
            return typeof obj2;
          };
        } else {
          _typeof = function _typeof2(obj2) {
            return obj2 && typeof Symbol === "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
          };
        }
        return _typeof(obj);
      }
      function _classCallCheck(instance, Constructor) {
        if (!(instance instanceof Constructor)) {
          throw new TypeError("Cannot call a class as a function");
        }
      }
      function _defineProperties(target, props) {
        for (var i = 0; i < props.length; i++) {
          var descriptor = props[i];
          descriptor.enumerable = descriptor.enumerable || false;
          descriptor.configurable = true;
          if ("value" in descriptor)
            descriptor.writable = true;
          Object.defineProperty(target, descriptor.key, descriptor);
        }
      }
      function _createClass(Constructor, protoProps, staticProps) {
        if (protoProps)
          _defineProperties(Constructor.prototype, protoProps);
        if (staticProps)
          _defineProperties(Constructor, staticProps);
        return Constructor;
      }
      function _inherits(subClass, superClass) {
        if (typeof superClass !== "function" && superClass !== null) {
          throw new TypeError("Super expression must either be null or a function");
        }
        subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } });
        if (superClass)
          _setPrototypeOf(subClass, superClass);
      }
      function _setPrototypeOf(o, p) {
        _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf2(o2, p2) {
          o2.__proto__ = p2;
          return o2;
        };
        return _setPrototypeOf(o, p);
      }
      function _createSuper(Derived) {
        var hasNativeReflectConstruct = _isNativeReflectConstruct();
        return function _createSuperInternal() {
          var Super = _getPrototypeOf(Derived), result;
          if (hasNativeReflectConstruct) {
            var NewTarget = _getPrototypeOf(this).constructor;
            result = Reflect.construct(Super, arguments, NewTarget);
          } else {
            result = Super.apply(this, arguments);
          }
          return _possibleConstructorReturn(this, result);
        };
      }
      function _possibleConstructorReturn(self2, call) {
        if (call && (_typeof(call) === "object" || typeof call === "function")) {
          return call;
        }
        return _assertThisInitialized(self2);
      }
      function _assertThisInitialized(self2) {
        if (self2 === void 0) {
          throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
        }
        return self2;
      }
      function _isNativeReflectConstruct() {
        if (typeof Reflect === "undefined" || !Reflect.construct)
          return false;
        if (Reflect.construct.sham)
          return false;
        if (typeof Proxy === "function")
          return true;
        try {
          Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
          }));
          return true;
        } catch (e) {
          return false;
        }
      }
      function _getPrototypeOf(o) {
        _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf2(o2) {
          return o2.__proto__ || Object.getPrototypeOf(o2);
        };
        return _getPrototypeOf(o);
      }
      var Margin;
      var MarginBottom;
      var MarginLeft;
      var MarginRight;
      var MarginTop;
      var _Declaration;
      _Declaration = require_Declaration();
      MarginTop = require_MarginTop();
      MarginLeft = require_MarginLeft();
      MarginRight = require_MarginRight();
      MarginBottom = require_MarginBottom();
      module2.exports = Margin = function() {
        var self2;
        var Margin2 = /* @__PURE__ */ function(_Declaration2) {
          _inherits(Margin3, _Declaration2);
          var _super = _createSuper(Margin3);
          function Margin3() {
            _classCallCheck(this, Margin3);
            return _super.apply(this, arguments);
          }
          _createClass(Margin3, null, [{
            key: "setOnto",
            value: function setOnto(declarations, prop, originalValue) {
              var append, val, vals;
              append = "";
              val = _Declaration.sanitizeValue(originalValue);
              if (_Declaration.importantClauseRx.test(String(val))) {
                append = " !important";
                val = val.replace(_Declaration.importantClauseRx, "");
              }
              val = val.trim();
              if (val.length === 0) {
                return self2._setAllDirections(declarations, append, append, append, append);
              }
              vals = val.split(" ").map(function(val2) {
                return val2 + append;
              });
              if (vals.length === 1) {
                return self2._setAllDirections(declarations, vals[0], vals[0], vals[0], vals[0]);
              } else if (vals.length === 2) {
                return self2._setAllDirections(declarations, vals[0], vals[1], vals[0], vals[1]);
              } else if (vals.length === 3) {
                return self2._setAllDirections(declarations, vals[0], vals[1], vals[2], vals[1]);
              } else if (vals.length === 4) {
                return self2._setAllDirections(declarations, vals[0], vals[1], vals[2], vals[3]);
              } else {
                throw Error("Can't understand value for margin: `".concat(originalValue, "`"));
              }
            }
          }, {
            key: "_setAllDirections",
            value: function _setAllDirections(declarations, top, right, bottom, left) {
              MarginTop.setOnto(declarations, "marginTop", top);
              MarginTop.setOnto(declarations, "marginRight", right);
              MarginTop.setOnto(declarations, "marginBottom", bottom);
              MarginTop.setOnto(declarations, "marginLeft", left);
            }
          }]);
          return Margin3;
        }(_Declaration);
        ;
        self2 = Margin2;
        return Margin2;
      }.call(void 0);
    }
  });

  // node_modules/.pnpm/renderkid@3.0.0/node_modules/renderkid/lib/renderKid/styles/rule/declarationBlock/PaddingTop.js
  var require_PaddingTop = __commonJS({
    "node_modules/.pnpm/renderkid@3.0.0/node_modules/renderkid/lib/renderKid/styles/rule/declarationBlock/PaddingTop.js"(exports2, module2) {
      "use strict";
      function _typeof(obj) {
        "@babel/helpers - typeof";
        if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
          _typeof = function _typeof2(obj2) {
            return typeof obj2;
          };
        } else {
          _typeof = function _typeof2(obj2) {
            return obj2 && typeof Symbol === "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
          };
        }
        return _typeof(obj);
      }
      function _classCallCheck(instance, Constructor) {
        if (!(instance instanceof Constructor)) {
          throw new TypeError("Cannot call a class as a function");
        }
      }
      function _inherits(subClass, superClass) {
        if (typeof superClass !== "function" && superClass !== null) {
          throw new TypeError("Super expression must either be null or a function");
        }
        subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } });
        if (superClass)
          _setPrototypeOf(subClass, superClass);
      }
      function _setPrototypeOf(o, p) {
        _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf2(o2, p2) {
          o2.__proto__ = p2;
          return o2;
        };
        return _setPrototypeOf(o, p);
      }
      function _createSuper(Derived) {
        var hasNativeReflectConstruct = _isNativeReflectConstruct();
        return function _createSuperInternal() {
          var Super = _getPrototypeOf(Derived), result;
          if (hasNativeReflectConstruct) {
            var NewTarget = _getPrototypeOf(this).constructor;
            result = Reflect.construct(Super, arguments, NewTarget);
          } else {
            result = Super.apply(this, arguments);
          }
          return _possibleConstructorReturn(this, result);
        };
      }
      function _possibleConstructorReturn(self2, call) {
        if (call && (_typeof(call) === "object" || typeof call === "function")) {
          return call;
        }
        return _assertThisInitialized(self2);
      }
      function _assertThisInitialized(self2) {
        if (self2 === void 0) {
          throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
        }
        return self2;
      }
      function _isNativeReflectConstruct() {
        if (typeof Reflect === "undefined" || !Reflect.construct)
          return false;
        if (Reflect.construct.sham)
          return false;
        if (typeof Proxy === "function")
          return true;
        try {
          Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
          }));
          return true;
        } catch (e) {
          return false;
        }
      }
      function _getPrototypeOf(o) {
        _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf2(o2) {
          return o2.__proto__ || Object.getPrototypeOf(o2);
        };
        return _getPrototypeOf(o);
      }
      var PaddingTop;
      var _Length;
      _Length = require_Length();
      module2.exports = PaddingTop = /* @__PURE__ */ function(_Length2) {
        _inherits(PaddingTop2, _Length2);
        var _super = _createSuper(PaddingTop2);
        function PaddingTop2() {
          _classCallCheck(this, PaddingTop2);
          return _super.apply(this, arguments);
        }
        return PaddingTop2;
      }(_Length);
    }
  });

  // node_modules/.pnpm/renderkid@3.0.0/node_modules/renderkid/lib/renderKid/styles/rule/declarationBlock/PaddingLeft.js
  var require_PaddingLeft = __commonJS({
    "node_modules/.pnpm/renderkid@3.0.0/node_modules/renderkid/lib/renderKid/styles/rule/declarationBlock/PaddingLeft.js"(exports2, module2) {
      "use strict";
      function _typeof(obj) {
        "@babel/helpers - typeof";
        if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
          _typeof = function _typeof2(obj2) {
            return typeof obj2;
          };
        } else {
          _typeof = function _typeof2(obj2) {
            return obj2 && typeof Symbol === "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
          };
        }
        return _typeof(obj);
      }
      function _classCallCheck(instance, Constructor) {
        if (!(instance instanceof Constructor)) {
          throw new TypeError("Cannot call a class as a function");
        }
      }
      function _inherits(subClass, superClass) {
        if (typeof superClass !== "function" && superClass !== null) {
          throw new TypeError("Super expression must either be null or a function");
        }
        subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } });
        if (superClass)
          _setPrototypeOf(subClass, superClass);
      }
      function _setPrototypeOf(o, p) {
        _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf2(o2, p2) {
          o2.__proto__ = p2;
          return o2;
        };
        return _setPrototypeOf(o, p);
      }
      function _createSuper(Derived) {
        var hasNativeReflectConstruct = _isNativeReflectConstruct();
        return function _createSuperInternal() {
          var Super = _getPrototypeOf(Derived), result;
          if (hasNativeReflectConstruct) {
            var NewTarget = _getPrototypeOf(this).constructor;
            result = Reflect.construct(Super, arguments, NewTarget);
          } else {
            result = Super.apply(this, arguments);
          }
          return _possibleConstructorReturn(this, result);
        };
      }
      function _possibleConstructorReturn(self2, call) {
        if (call && (_typeof(call) === "object" || typeof call === "function")) {
          return call;
        }
        return _assertThisInitialized(self2);
      }
      function _assertThisInitialized(self2) {
        if (self2 === void 0) {
          throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
        }
        return self2;
      }
      function _isNativeReflectConstruct() {
        if (typeof Reflect === "undefined" || !Reflect.construct)
          return false;
        if (Reflect.construct.sham)
          return false;
        if (typeof Proxy === "function")
          return true;
        try {
          Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
          }));
          return true;
        } catch (e) {
          return false;
        }
      }
      function _getPrototypeOf(o) {
        _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf2(o2) {
          return o2.__proto__ || Object.getPrototypeOf(o2);
        };
        return _getPrototypeOf(o);
      }
      var PaddingLeft;
      var _Length;
      _Length = require_Length();
      module2.exports = PaddingLeft = /* @__PURE__ */ function(_Length2) {
        _inherits(PaddingLeft2, _Length2);
        var _super = _createSuper(PaddingLeft2);
        function PaddingLeft2() {
          _classCallCheck(this, PaddingLeft2);
          return _super.apply(this, arguments);
        }
        return PaddingLeft2;
      }(_Length);
    }
  });

  // node_modules/.pnpm/renderkid@3.0.0/node_modules/renderkid/lib/renderKid/styles/rule/declarationBlock/PaddingRight.js
  var require_PaddingRight = __commonJS({
    "node_modules/.pnpm/renderkid@3.0.0/node_modules/renderkid/lib/renderKid/styles/rule/declarationBlock/PaddingRight.js"(exports2, module2) {
      "use strict";
      function _typeof(obj) {
        "@babel/helpers - typeof";
        if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
          _typeof = function _typeof2(obj2) {
            return typeof obj2;
          };
        } else {
          _typeof = function _typeof2(obj2) {
            return obj2 && typeof Symbol === "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
          };
        }
        return _typeof(obj);
      }
      function _classCallCheck(instance, Constructor) {
        if (!(instance instanceof Constructor)) {
          throw new TypeError("Cannot call a class as a function");
        }
      }
      function _inherits(subClass, superClass) {
        if (typeof superClass !== "function" && superClass !== null) {
          throw new TypeError("Super expression must either be null or a function");
        }
        subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } });
        if (superClass)
          _setPrototypeOf(subClass, superClass);
      }
      function _setPrototypeOf(o, p) {
        _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf2(o2, p2) {
          o2.__proto__ = p2;
          return o2;
        };
        return _setPrototypeOf(o, p);
      }
      function _createSuper(Derived) {
        var hasNativeReflectConstruct = _isNativeReflectConstruct();
        return function _createSuperInternal() {
          var Super = _getPrototypeOf(Derived), result;
          if (hasNativeReflectConstruct) {
            var NewTarget = _getPrototypeOf(this).constructor;
            result = Reflect.construct(Super, arguments, NewTarget);
          } else {
            result = Super.apply(this, arguments);
          }
          return _possibleConstructorReturn(this, result);
        };
      }
      function _possibleConstructorReturn(self2, call) {
        if (call && (_typeof(call) === "object" || typeof call === "function")) {
          return call;
        }
        return _assertThisInitialized(self2);
      }
      function _assertThisInitialized(self2) {
        if (self2 === void 0) {
          throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
        }
        return self2;
      }
      function _isNativeReflectConstruct() {
        if (typeof Reflect === "undefined" || !Reflect.construct)
          return false;
        if (Reflect.construct.sham)
          return false;
        if (typeof Proxy === "function")
          return true;
        try {
          Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
          }));
          return true;
        } catch (e) {
          return false;
        }
      }
      function _getPrototypeOf(o) {
        _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf2(o2) {
          return o2.__proto__ || Object.getPrototypeOf(o2);
        };
        return _getPrototypeOf(o);
      }
      var PaddingRight;
      var _Length;
      _Length = require_Length();
      module2.exports = PaddingRight = /* @__PURE__ */ function(_Length2) {
        _inherits(PaddingRight2, _Length2);
        var _super = _createSuper(PaddingRight2);
        function PaddingRight2() {
          _classCallCheck(this, PaddingRight2);
          return _super.apply(this, arguments);
        }
        return PaddingRight2;
      }(_Length);
    }
  });

  // node_modules/.pnpm/renderkid@3.0.0/node_modules/renderkid/lib/renderKid/styles/rule/declarationBlock/PaddingBottom.js
  var require_PaddingBottom = __commonJS({
    "node_modules/.pnpm/renderkid@3.0.0/node_modules/renderkid/lib/renderKid/styles/rule/declarationBlock/PaddingBottom.js"(exports2, module2) {
      "use strict";
      function _typeof(obj) {
        "@babel/helpers - typeof";
        if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
          _typeof = function _typeof2(obj2) {
            return typeof obj2;
          };
        } else {
          _typeof = function _typeof2(obj2) {
            return obj2 && typeof Symbol === "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
          };
        }
        return _typeof(obj);
      }
      function _classCallCheck(instance, Constructor) {
        if (!(instance instanceof Constructor)) {
          throw new TypeError("Cannot call a class as a function");
        }
      }
      function _inherits(subClass, superClass) {
        if (typeof superClass !== "function" && superClass !== null) {
          throw new TypeError("Super expression must either be null or a function");
        }
        subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } });
        if (superClass)
          _setPrototypeOf(subClass, superClass);
      }
      function _setPrototypeOf(o, p) {
        _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf2(o2, p2) {
          o2.__proto__ = p2;
          return o2;
        };
        return _setPrototypeOf(o, p);
      }
      function _createSuper(Derived) {
        var hasNativeReflectConstruct = _isNativeReflectConstruct();
        return function _createSuperInternal() {
          var Super = _getPrototypeOf(Derived), result;
          if (hasNativeReflectConstruct) {
            var NewTarget = _getPrototypeOf(this).constructor;
            result = Reflect.construct(Super, arguments, NewTarget);
          } else {
            result = Super.apply(this, arguments);
          }
          return _possibleConstructorReturn(this, result);
        };
      }
      function _possibleConstructorReturn(self2, call) {
        if (call && (_typeof(call) === "object" || typeof call === "function")) {
          return call;
        }
        return _assertThisInitialized(self2);
      }
      function _assertThisInitialized(self2) {
        if (self2 === void 0) {
          throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
        }
        return self2;
      }
      function _isNativeReflectConstruct() {
        if (typeof Reflect === "undefined" || !Reflect.construct)
          return false;
        if (Reflect.construct.sham)
          return false;
        if (typeof Proxy === "function")
          return true;
        try {
          Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
          }));
          return true;
        } catch (e) {
          return false;
        }
      }
      function _getPrototypeOf(o) {
        _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf2(o2) {
          return o2.__proto__ || Object.getPrototypeOf(o2);
        };
        return _getPrototypeOf(o);
      }
      var PaddingBottom;
      var _Length;
      _Length = require_Length();
      module2.exports = PaddingBottom = /* @__PURE__ */ function(_Length2) {
        _inherits(PaddingBottom2, _Length2);
        var _super = _createSuper(PaddingBottom2);
        function PaddingBottom2() {
          _classCallCheck(this, PaddingBottom2);
          return _super.apply(this, arguments);
        }
        return PaddingBottom2;
      }(_Length);
    }
  });

  // node_modules/.pnpm/renderkid@3.0.0/node_modules/renderkid/lib/renderKid/styles/rule/declarationBlock/Padding.js
  var require_Padding = __commonJS({
    "node_modules/.pnpm/renderkid@3.0.0/node_modules/renderkid/lib/renderKid/styles/rule/declarationBlock/Padding.js"(exports2, module2) {
      "use strict";
      function _typeof(obj) {
        "@babel/helpers - typeof";
        if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
          _typeof = function _typeof2(obj2) {
            return typeof obj2;
          };
        } else {
          _typeof = function _typeof2(obj2) {
            return obj2 && typeof Symbol === "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
          };
        }
        return _typeof(obj);
      }
      function _classCallCheck(instance, Constructor) {
        if (!(instance instanceof Constructor)) {
          throw new TypeError("Cannot call a class as a function");
        }
      }
      function _defineProperties(target, props) {
        for (var i = 0; i < props.length; i++) {
          var descriptor = props[i];
          descriptor.enumerable = descriptor.enumerable || false;
          descriptor.configurable = true;
          if ("value" in descriptor)
            descriptor.writable = true;
          Object.defineProperty(target, descriptor.key, descriptor);
        }
      }
      function _createClass(Constructor, protoProps, staticProps) {
        if (protoProps)
          _defineProperties(Constructor.prototype, protoProps);
        if (staticProps)
          _defineProperties(Constructor, staticProps);
        return Constructor;
      }
      function _inherits(subClass, superClass) {
        if (typeof superClass !== "function" && superClass !== null) {
          throw new TypeError("Super expression must either be null or a function");
        }
        subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } });
        if (superClass)
          _setPrototypeOf(subClass, superClass);
      }
      function _setPrototypeOf(o, p) {
        _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf2(o2, p2) {
          o2.__proto__ = p2;
          return o2;
        };
        return _setPrototypeOf(o, p);
      }
      function _createSuper(Derived) {
        var hasNativeReflectConstruct = _isNativeReflectConstruct();
        return function _createSuperInternal() {
          var Super = _getPrototypeOf(Derived), result;
          if (hasNativeReflectConstruct) {
            var NewTarget = _getPrototypeOf(this).constructor;
            result = Reflect.construct(Super, arguments, NewTarget);
          } else {
            result = Super.apply(this, arguments);
          }
          return _possibleConstructorReturn(this, result);
        };
      }
      function _possibleConstructorReturn(self2, call) {
        if (call && (_typeof(call) === "object" || typeof call === "function")) {
          return call;
        }
        return _assertThisInitialized(self2);
      }
      function _assertThisInitialized(self2) {
        if (self2 === void 0) {
          throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
        }
        return self2;
      }
      function _isNativeReflectConstruct() {
        if (typeof Reflect === "undefined" || !Reflect.construct)
          return false;
        if (Reflect.construct.sham)
          return false;
        if (typeof Proxy === "function")
          return true;
        try {
          Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
          }));
          return true;
        } catch (e) {
          return false;
        }
      }
      function _getPrototypeOf(o) {
        _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf2(o2) {
          return o2.__proto__ || Object.getPrototypeOf(o2);
        };
        return _getPrototypeOf(o);
      }
      var Padding;
      var PaddingBottom;
      var PaddingLeft;
      var PaddingRight;
      var PaddingTop;
      var _Declaration;
      _Declaration = require_Declaration();
      PaddingTop = require_PaddingTop();
      PaddingLeft = require_PaddingLeft();
      PaddingRight = require_PaddingRight();
      PaddingBottom = require_PaddingBottom();
      module2.exports = Padding = function() {
        var self2;
        var Padding2 = /* @__PURE__ */ function(_Declaration2) {
          _inherits(Padding3, _Declaration2);
          var _super = _createSuper(Padding3);
          function Padding3() {
            _classCallCheck(this, Padding3);
            return _super.apply(this, arguments);
          }
          _createClass(Padding3, null, [{
            key: "setOnto",
            value: function setOnto(declarations, prop, originalValue) {
              var append, val, vals;
              append = "";
              val = _Declaration.sanitizeValue(originalValue);
              if (_Declaration.importantClauseRx.test(String(val))) {
                append = " !important";
                val = val.replace(_Declaration.importantClauseRx, "");
              }
              val = val.trim();
              if (val.length === 0) {
                return self2._setAllDirections(declarations, append, append, append, append);
              }
              vals = val.split(" ").map(function(val2) {
                return val2 + append;
              });
              if (vals.length === 1) {
                return self2._setAllDirections(declarations, vals[0], vals[0], vals[0], vals[0]);
              } else if (vals.length === 2) {
                return self2._setAllDirections(declarations, vals[0], vals[1], vals[0], vals[1]);
              } else if (vals.length === 3) {
                return self2._setAllDirections(declarations, vals[0], vals[1], vals[2], vals[1]);
              } else if (vals.length === 4) {
                return self2._setAllDirections(declarations, vals[0], vals[1], vals[2], vals[3]);
              } else {
                throw Error("Can't understand value for padding: `".concat(originalValue, "`"));
              }
            }
          }, {
            key: "_setAllDirections",
            value: function _setAllDirections(declarations, top, right, bottom, left) {
              PaddingTop.setOnto(declarations, "paddingTop", top);
              PaddingTop.setOnto(declarations, "paddingRight", right);
              PaddingTop.setOnto(declarations, "paddingBottom", bottom);
              PaddingTop.setOnto(declarations, "paddingLeft", left);
            }
          }]);
          return Padding3;
        }(_Declaration);
        ;
        self2 = Padding2;
        return Padding2;
      }.call(void 0);
    }
  });

  // node_modules/.pnpm/renderkid@3.0.0/node_modules/renderkid/lib/renderKid/styles/rule/DeclarationBlock.js
  var require_DeclarationBlock = __commonJS({
    "node_modules/.pnpm/renderkid@3.0.0/node_modules/renderkid/lib/renderKid/styles/rule/DeclarationBlock.js"(exports2, module2) {
      "use strict";
      function _typeof(obj) {
        "@babel/helpers - typeof";
        if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
          _typeof = function _typeof2(obj2) {
            return typeof obj2;
          };
        } else {
          _typeof = function _typeof2(obj2) {
            return obj2 && typeof Symbol === "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
          };
        }
        return _typeof(obj);
      }
      function _classCallCheck(instance, Constructor) {
        if (!(instance instanceof Constructor)) {
          throw new TypeError("Cannot call a class as a function");
        }
      }
      function _defineProperties(target, props) {
        for (var i = 0; i < props.length; i++) {
          var descriptor = props[i];
          descriptor.enumerable = descriptor.enumerable || false;
          descriptor.configurable = true;
          if ("value" in descriptor)
            descriptor.writable = true;
          Object.defineProperty(target, descriptor.key, descriptor);
        }
      }
      function _createClass(Constructor, protoProps, staticProps) {
        if (protoProps)
          _defineProperties(Constructor.prototype, protoProps);
        if (staticProps)
          _defineProperties(Constructor, staticProps);
        return Constructor;
      }
      var Arbitrary;
      var DeclarationBlock;
      var declarationClasses;
      module2.exports = DeclarationBlock = function() {
        var self2;
        var DeclarationBlock2 = /* @__PURE__ */ function() {
          function DeclarationBlock3() {
            _classCallCheck(this, DeclarationBlock3);
            this._declarations = {};
          }
          _createClass(DeclarationBlock3, [{
            key: "set",
            value: function set(prop, value) {
              var key, val;
              if (_typeof(prop) === "object") {
                for (key in prop) {
                  val = prop[key];
                  this.set(key, val);
                }
                return this;
              }
              prop = self2.sanitizeProp(prop);
              this._getDeclarationClass(prop).setOnto(this._declarations, prop, value);
              return this;
            }
          }, {
            key: "_getDeclarationClass",
            value: function _getDeclarationClass(prop) {
              var cls;
              if (prop[0] === "_") {
                return Arbitrary;
              }
              if (!(cls = declarationClasses[prop])) {
                throw Error("Unknown property `".concat(prop, "`. Write it as `_").concat(prop, "` if you're defining a custom property"));
              }
              return cls;
            }
          }], [{
            key: "sanitizeProp",
            value: function sanitizeProp(prop) {
              return String(prop).trim();
            }
          }]);
          return DeclarationBlock3;
        }();
        ;
        self2 = DeclarationBlock2;
        return DeclarationBlock2;
      }.call(void 0);
      Arbitrary = require_Arbitrary();
      declarationClasses = {
        color: require_Color(),
        background: require_Background(),
        width: require_Width(),
        height: require_Height(),
        bullet: require_Bullet(),
        display: require_Display(),
        margin: require_Margin(),
        marginTop: require_MarginTop(),
        marginLeft: require_MarginLeft(),
        marginRight: require_MarginRight(),
        marginBottom: require_MarginBottom(),
        padding: require_Padding(),
        paddingTop: require_PaddingTop(),
        paddingLeft: require_PaddingLeft(),
        paddingRight: require_PaddingRight(),
        paddingBottom: require_PaddingBottom()
      };
    }
  });

  // node_modules/.pnpm/renderkid@3.0.0/node_modules/renderkid/lib/renderKid/styles/Rule.js
  var require_Rule = __commonJS({
    "node_modules/.pnpm/renderkid@3.0.0/node_modules/renderkid/lib/renderKid/styles/Rule.js"(exports2, module2) {
      "use strict";
      function _classCallCheck(instance, Constructor) {
        if (!(instance instanceof Constructor)) {
          throw new TypeError("Cannot call a class as a function");
        }
      }
      function _defineProperties(target, props) {
        for (var i = 0; i < props.length; i++) {
          var descriptor = props[i];
          descriptor.enumerable = descriptor.enumerable || false;
          descriptor.configurable = true;
          if ("value" in descriptor)
            descriptor.writable = true;
          Object.defineProperty(target, descriptor.key, descriptor);
        }
      }
      function _createClass(Constructor, protoProps, staticProps) {
        if (protoProps)
          _defineProperties(Constructor.prototype, protoProps);
        if (staticProps)
          _defineProperties(Constructor, staticProps);
        return Constructor;
      }
      var DeclarationBlock;
      var Rule;
      var Selector;
      Selector = require_Selector();
      DeclarationBlock = require_DeclarationBlock();
      module2.exports = Rule = /* @__PURE__ */ function() {
        function Rule2(selector) {
          _classCallCheck(this, Rule2);
          this.selector = new Selector(selector);
          this.styles = new DeclarationBlock();
        }
        _createClass(Rule2, [{
          key: "setStyles",
          value: function setStyles(styles5) {
            this.styles.set(styles5);
            return this;
          }
        }]);
        return Rule2;
      }();
    }
  });

  // node_modules/.pnpm/renderkid@3.0.0/node_modules/renderkid/lib/renderKid/styles/StyleSheet.js
  var require_StyleSheet = __commonJS({
    "node_modules/.pnpm/renderkid@3.0.0/node_modules/renderkid/lib/renderKid/styles/StyleSheet.js"(exports2, module2) {
      "use strict";
      function _typeof(obj) {
        "@babel/helpers - typeof";
        if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
          _typeof = function _typeof2(obj2) {
            return typeof obj2;
          };
        } else {
          _typeof = function _typeof2(obj2) {
            return obj2 && typeof Symbol === "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
          };
        }
        return _typeof(obj);
      }
      function _classCallCheck(instance, Constructor) {
        if (!(instance instanceof Constructor)) {
          throw new TypeError("Cannot call a class as a function");
        }
      }
      function _defineProperties(target, props) {
        for (var i = 0; i < props.length; i++) {
          var descriptor = props[i];
          descriptor.enumerable = descriptor.enumerable || false;
          descriptor.configurable = true;
          if ("value" in descriptor)
            descriptor.writable = true;
          Object.defineProperty(target, descriptor.key, descriptor);
        }
      }
      function _createClass(Constructor, protoProps, staticProps) {
        if (protoProps)
          _defineProperties(Constructor.prototype, protoProps);
        if (staticProps)
          _defineProperties(Constructor, staticProps);
        return Constructor;
      }
      var Rule;
      var StyleSheet;
      Rule = require_Rule();
      module2.exports = StyleSheet = function() {
        var self2;
        var StyleSheet2 = /* @__PURE__ */ function() {
          function StyleSheet3() {
            _classCallCheck(this, StyleSheet3);
            this._rulesBySelector = {};
          }
          _createClass(StyleSheet3, [{
            key: "setRule",
            value: function setRule(selector, styles5) {
              var key, val;
              if (typeof selector === "string") {
                this._setRule(selector, styles5);
              } else if (_typeof(selector) === "object") {
                for (key in selector) {
                  val = selector[key];
                  this._setRule(key, val);
                }
              }
              return this;
            }
          }, {
            key: "_setRule",
            value: function _setRule(s, styles5) {
              var i, len, ref, selector;
              ref = self2.splitSelectors(s);
              for (i = 0, len = ref.length; i < len; i++) {
                selector = ref[i];
                this._setSingleRule(selector, styles5);
              }
              return this;
            }
          }, {
            key: "_setSingleRule",
            value: function _setSingleRule(s, styles5) {
              var rule, selector;
              selector = self2.normalizeSelector(s);
              if (!(rule = this._rulesBySelector[selector])) {
                rule = new Rule(selector);
                this._rulesBySelector[selector] = rule;
              }
              rule.setStyles(styles5);
              return this;
            }
          }, {
            key: "getRulesFor",
            value: function getRulesFor(el) {
              var ref, rule, rules, selector;
              rules = [];
              ref = this._rulesBySelector;
              for (selector in ref) {
                rule = ref[selector];
                if (rule.selector.matches(el)) {
                  rules.push(rule);
                }
              }
              return rules;
            }
          }], [{
            key: "normalizeSelector",
            value: function normalizeSelector(selector) {
              return selector.replace(/[\s]+/g, " ").replace(/[\s]*([>\,\+]{1})[\s]*/g, "$1").trim();
            }
          }, {
            key: "splitSelectors",
            value: function splitSelectors(s) {
              return s.trim().split(",");
            }
          }]);
          return StyleSheet3;
        }();
        ;
        self2 = StyleSheet2;
        return StyleSheet2;
      }.call(void 0);
    }
  });

  // node_modules/.pnpm/renderkid@3.0.0/node_modules/renderkid/lib/renderKid/styles/rule/MixedDeclarationSet.js
  var require_MixedDeclarationSet = __commonJS({
    "node_modules/.pnpm/renderkid@3.0.0/node_modules/renderkid/lib/renderKid/styles/rule/MixedDeclarationSet.js"(exports2, module2) {
      "use strict";
      function _classCallCheck(instance, Constructor) {
        if (!(instance instanceof Constructor)) {
          throw new TypeError("Cannot call a class as a function");
        }
      }
      function _defineProperties(target, props) {
        for (var i = 0; i < props.length; i++) {
          var descriptor = props[i];
          descriptor.enumerable = descriptor.enumerable || false;
          descriptor.configurable = true;
          if ("value" in descriptor)
            descriptor.writable = true;
          Object.defineProperty(target, descriptor.key, descriptor);
        }
      }
      function _createClass(Constructor, protoProps, staticProps) {
        if (protoProps)
          _defineProperties(Constructor.prototype, protoProps);
        if (staticProps)
          _defineProperties(Constructor, staticProps);
        return Constructor;
      }
      var MixedDeclarationSet;
      module2.exports = MixedDeclarationSet = function() {
        var self2;
        var MixedDeclarationSet2 = /* @__PURE__ */ function() {
          function MixedDeclarationSet3() {
            _classCallCheck(this, MixedDeclarationSet3);
            this._declarations = {};
          }
          _createClass(MixedDeclarationSet3, [{
            key: "mixWithList",
            value: function mixWithList(rules) {
              var i, len, rule;
              rules.sort(function(a, b) {
                return a.selector.priority > b.selector.priority;
              });
              for (i = 0, len = rules.length; i < len; i++) {
                rule = rules[i];
                this._mixWithRule(rule);
              }
              return this;
            }
          }, {
            key: "_mixWithRule",
            value: function _mixWithRule(rule) {
              var dec, prop, ref;
              ref = rule.styles._declarations;
              for (prop in ref) {
                dec = ref[prop];
                this._mixWithDeclaration(dec);
              }
            }
          }, {
            key: "_mixWithDeclaration",
            value: function _mixWithDeclaration(dec) {
              var cur;
              cur = this._declarations[dec.prop];
              if (cur != null && cur.important && !dec.important) {
                return;
              }
              this._declarations[dec.prop] = dec;
            }
          }, {
            key: "get",
            value: function get4(prop) {
              if (prop == null) {
                return this._declarations;
              }
              if (this._declarations[prop] == null) {
                return null;
              }
              return this._declarations[prop].val;
            }
          }, {
            key: "toObject",
            value: function toObject() {
              var dec, obj, prop, ref;
              obj = {};
              ref = this._declarations;
              for (prop in ref) {
                dec = ref[prop];
                obj[prop] = dec.val;
              }
              return obj;
            }
          }], [{
            key: "mix",
            value: function mix() {
              var i, len, mixed, rules;
              mixed = new self2();
              for (var _len = arguments.length, ruleSets = new Array(_len), _key = 0; _key < _len; _key++) {
                ruleSets[_key] = arguments[_key];
              }
              for (i = 0, len = ruleSets.length; i < len; i++) {
                rules = ruleSets[i];
                mixed.mixWithList(rules);
              }
              return mixed;
            }
          }]);
          return MixedDeclarationSet3;
        }();
        ;
        self2 = MixedDeclarationSet2;
        return MixedDeclarationSet2;
      }.call(void 0);
    }
  });

  // node_modules/.pnpm/renderkid@3.0.0/node_modules/renderkid/lib/renderKid/Styles.js
  var require_Styles = __commonJS({
    "node_modules/.pnpm/renderkid@3.0.0/node_modules/renderkid/lib/renderKid/Styles.js"(exports2, module2) {
      "use strict";
      function _classCallCheck(instance, Constructor) {
        if (!(instance instanceof Constructor)) {
          throw new TypeError("Cannot call a class as a function");
        }
      }
      function _defineProperties(target, props) {
        for (var i = 0; i < props.length; i++) {
          var descriptor = props[i];
          descriptor.enumerable = descriptor.enumerable || false;
          descriptor.configurable = true;
          if ("value" in descriptor)
            descriptor.writable = true;
          Object.defineProperty(target, descriptor.key, descriptor);
        }
      }
      function _createClass(Constructor, protoProps, staticProps) {
        if (protoProps)
          _defineProperties(Constructor.prototype, protoProps);
        if (staticProps)
          _defineProperties(Constructor, staticProps);
        return Constructor;
      }
      var MixedDeclarationSet;
      var StyleSheet;
      var Styles;
      var terminalWidth;
      StyleSheet = require_StyleSheet();
      MixedDeclarationSet = require_MixedDeclarationSet();
      terminalWidth = require_tools().getCols();
      module2.exports = Styles = function() {
        var self2;
        var Styles2 = /* @__PURE__ */ function() {
          function Styles3() {
            _classCallCheck(this, Styles3);
            this._defaultStyles = new StyleSheet();
            this._userStyles = new StyleSheet();
            this._setDefaultStyles();
          }
          _createClass(Styles3, [{
            key: "_setDefaultStyles",
            value: function _setDefaultStyles() {
              this._defaultStyles.setRule(self2.defaultRules);
            }
          }, {
            key: "setRule",
            value: function setRule(selector, rules) {
              this._userStyles.setRule.apply(this._userStyles, arguments);
              return this;
            }
          }, {
            key: "getStyleFor",
            value: function getStyleFor(el) {
              var styles5;
              styles5 = el.styles;
              if (styles5 == null) {
                el.styles = styles5 = this._getComputedStyleFor(el);
              }
              return styles5;
            }
          }, {
            key: "_getRawStyleFor",
            value: function _getRawStyleFor(el) {
              var def, user;
              def = this._defaultStyles.getRulesFor(el);
              user = this._userStyles.getRulesFor(el);
              return MixedDeclarationSet.mix(def, user).toObject();
            }
          }, {
            key: "_getComputedStyleFor",
            value: function _getComputedStyleFor(el) {
              var decs, parent, prop, ref, val;
              decs = {};
              parent = el.parent;
              ref = this._getRawStyleFor(el);
              for (prop in ref) {
                val = ref[prop];
                if (val !== "inherit") {
                  decs[prop] = val;
                } else {
                  throw Error("Inherited styles are not supported yet.");
                }
              }
              return decs;
            }
          }]);
          return Styles3;
        }();
        ;
        self2 = Styles2;
        Styles2.defaultRules = {
          "*": {
            display: "inline"
          },
          "body": {
            background: "none",
            color: "white",
            display: "block",
            width: terminalWidth + " !important"
          }
        };
        return Styles2;
      }.call(void 0);
    }
  });

  // node_modules/.pnpm/renderkid@3.0.0/node_modules/renderkid/lib/layout/SpecialString.js
  var require_SpecialString = __commonJS({
    "node_modules/.pnpm/renderkid@3.0.0/node_modules/renderkid/lib/layout/SpecialString.js"(exports2, module2) {
      "use strict";
      function _classCallCheck(instance, Constructor) {
        if (!(instance instanceof Constructor)) {
          throw new TypeError("Cannot call a class as a function");
        }
      }
      function _defineProperties(target, props) {
        for (var i2 = 0; i2 < props.length; i2++) {
          var descriptor = props[i2];
          descriptor.enumerable = descriptor.enumerable || false;
          descriptor.configurable = true;
          if ("value" in descriptor)
            descriptor.writable = true;
          Object.defineProperty(target, descriptor.key, descriptor);
        }
      }
      function _createClass(Constructor, protoProps, staticProps) {
        if (protoProps)
          _defineProperties(Constructor.prototype, protoProps);
        if (staticProps)
          _defineProperties(Constructor, staticProps);
        return Constructor;
      }
      var SpecialString;
      var i;
      var len;
      var prop;
      var ref;
      module2.exports = SpecialString = function() {
        var self2;
        var SpecialString2 = /* @__PURE__ */ function() {
          function SpecialString3(str) {
            _classCallCheck(this, SpecialString3);
            if (!(this instanceof self2)) {
              return new self2(str);
            }
            this._str = String(str);
            this._len = 0;
          }
          _createClass(SpecialString3, [{
            key: "_getStr",
            value: function _getStr() {
              return this._str;
            }
          }, {
            key: "set",
            value: function set(str) {
              this._str = String(str);
              return this;
            }
          }, {
            key: "clone",
            value: function clone() {
              return new SpecialString3(this._str);
            }
          }, {
            key: "isEmpty",
            value: function isEmpty() {
              return this._str === "";
            }
          }, {
            key: "isOnlySpecialChars",
            value: function isOnlySpecialChars() {
              return !this.isEmpty() && this.length === 0;
            }
          }, {
            key: "_reset",
            value: function _reset() {
              return this._len = 0;
            }
          }, {
            key: "splitIn",
            value: function splitIn(limit) {
              var trimLeftEachLine = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;
              var buffer, bufferLength, justSkippedSkipChar, lines;
              buffer = "";
              bufferLength = 0;
              lines = [];
              justSkippedSkipChar = false;
              self2._countChars(this._str, function(char, charLength) {
                if (bufferLength > limit || bufferLength + charLength > limit) {
                  lines.push(buffer);
                  buffer = "";
                  bufferLength = 0;
                }
                if (bufferLength === 0 && char === " " && !justSkippedSkipChar && trimLeftEachLine) {
                  return justSkippedSkipChar = true;
                } else {
                  buffer += char;
                  bufferLength += charLength;
                  return justSkippedSkipChar = false;
                }
              });
              if (buffer.length > 0) {
                lines.push(buffer);
              }
              return lines;
            }
          }, {
            key: "trim",
            value: function trim() {
              return new SpecialString3(this.str.trim());
            }
          }, {
            key: "_getLength",
            value: function _getLength() {
              var sum;
              sum = 0;
              self2._countChars(this._str, function(char, charLength) {
                sum += charLength;
              });
              return sum;
            }
          }, {
            key: "cut",
            value: function cut(from, to) {
              var _this = this;
              var trimLeft = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : false;
              var after, before, cur, cut2;
              if (to == null) {
                to = this.length;
              }
              from = parseInt(from);
              if (from >= to) {
                throw Error("`from` shouldn't be larger than `to`");
              }
              before = "";
              after = "";
              cut2 = "";
              cur = 0;
              self2._countChars(this._str, function(char, charLength) {
                if (_this.str === "ab<tag>") {
                  console.log(charLength, char);
                }
                if (cur === from && char.match(/^\s+$/) && trimLeft) {
                  return;
                }
                if (cur < from) {
                  before += char;
                } else if (cur < to || cur + charLength <= to) {
                  cut2 += char;
                } else {
                  after += char;
                }
                cur += charLength;
              });
              this._str = before + after;
              this._reset();
              return new SpecialString3(cut2);
            }
          }], [{
            key: "_countChars",
            value: function _countChars(text, cb) {
              var char, charLength, m;
              while (text.length !== 0) {
                if (m = text.match(self2._tagRx)) {
                  char = m[0];
                  charLength = 0;
                  text = text.substr(char.length, text.length);
                } else if (m = text.match(self2._quotedHtmlRx)) {
                  char = m[0];
                  charLength = 1;
                  text = text.substr(char.length, text.length);
                } else if (text.match(self2._tabRx)) {
                  char = "	";
                  charLength = 8;
                  text = text.substr(1, text.length);
                } else {
                  char = text[0];
                  charLength = 1;
                  text = text.substr(1, text.length);
                }
                cb.call(null, char, charLength);
              }
            }
          }]);
          return SpecialString3;
        }();
        ;
        self2 = SpecialString2;
        SpecialString2._tabRx = /^\t/;
        SpecialString2._tagRx = /^<[^>]+>/;
        SpecialString2._quotedHtmlRx = /^&(gt|lt|quot|amp|apos|sp);/;
        return SpecialString2;
      }.call(void 0);
      ref = ["str", "length"];
      for (i = 0, len = ref.length; i < len; i++) {
        prop = ref[i];
        (function() {
          var methodName;
          methodName = "_get" + prop[0].toUpperCase() + prop.substr(1, prop.length);
          return SpecialString.prototype.__defineGetter__(prop, function() {
            return this[methodName]();
          });
        })();
      }
    }
  });

  // node_modules/.pnpm/renderkid@3.0.0/node_modules/renderkid/lib/layout/block/blockPrependor/_BlockPrependor.js
  var require_BlockPrependor = __commonJS({
    "node_modules/.pnpm/renderkid@3.0.0/node_modules/renderkid/lib/layout/block/blockPrependor/_BlockPrependor.js"(exports2, module2) {
      "use strict";
      function _classCallCheck(instance, Constructor) {
        if (!(instance instanceof Constructor)) {
          throw new TypeError("Cannot call a class as a function");
        }
      }
      function _defineProperties(target, props) {
        for (var i = 0; i < props.length; i++) {
          var descriptor = props[i];
          descriptor.enumerable = descriptor.enumerable || false;
          descriptor.configurable = true;
          if ("value" in descriptor)
            descriptor.writable = true;
          Object.defineProperty(target, descriptor.key, descriptor);
        }
      }
      function _createClass(Constructor, protoProps, staticProps) {
        if (protoProps)
          _defineProperties(Constructor.prototype, protoProps);
        if (staticProps)
          _defineProperties(Constructor, staticProps);
        return Constructor;
      }
      var _BlockPrependor;
      module2.exports = _BlockPrependor = /* @__PURE__ */ function() {
        function _BlockPrependor2(_config) {
          _classCallCheck(this, _BlockPrependor2);
          this._config = _config;
        }
        _createClass(_BlockPrependor2, [{
          key: "render",
          value: function render(options) {
            return this._render(options);
          }
        }]);
        return _BlockPrependor2;
      }();
    }
  });

  // node_modules/.pnpm/renderkid@3.0.0/node_modules/renderkid/lib/layout/block/blockPrependor/Default.js
  var require_Default = __commonJS({
    "node_modules/.pnpm/renderkid@3.0.0/node_modules/renderkid/lib/layout/block/blockPrependor/Default.js"(exports2, module2) {
      "use strict";
      function _typeof(obj) {
        "@babel/helpers - typeof";
        if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
          _typeof = function _typeof2(obj2) {
            return typeof obj2;
          };
        } else {
          _typeof = function _typeof2(obj2) {
            return obj2 && typeof Symbol === "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
          };
        }
        return _typeof(obj);
      }
      function _classCallCheck(instance, Constructor) {
        if (!(instance instanceof Constructor)) {
          throw new TypeError("Cannot call a class as a function");
        }
      }
      function _defineProperties(target, props) {
        for (var i = 0; i < props.length; i++) {
          var descriptor = props[i];
          descriptor.enumerable = descriptor.enumerable || false;
          descriptor.configurable = true;
          if ("value" in descriptor)
            descriptor.writable = true;
          Object.defineProperty(target, descriptor.key, descriptor);
        }
      }
      function _createClass(Constructor, protoProps, staticProps) {
        if (protoProps)
          _defineProperties(Constructor.prototype, protoProps);
        if (staticProps)
          _defineProperties(Constructor, staticProps);
        return Constructor;
      }
      function _inherits(subClass, superClass) {
        if (typeof superClass !== "function" && superClass !== null) {
          throw new TypeError("Super expression must either be null or a function");
        }
        subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } });
        if (superClass)
          _setPrototypeOf(subClass, superClass);
      }
      function _setPrototypeOf(o, p) {
        _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf2(o2, p2) {
          o2.__proto__ = p2;
          return o2;
        };
        return _setPrototypeOf(o, p);
      }
      function _createSuper(Derived) {
        var hasNativeReflectConstruct = _isNativeReflectConstruct();
        return function _createSuperInternal() {
          var Super = _getPrototypeOf(Derived), result;
          if (hasNativeReflectConstruct) {
            var NewTarget = _getPrototypeOf(this).constructor;
            result = Reflect.construct(Super, arguments, NewTarget);
          } else {
            result = Super.apply(this, arguments);
          }
          return _possibleConstructorReturn(this, result);
        };
      }
      function _possibleConstructorReturn(self2, call) {
        if (call && (_typeof(call) === "object" || typeof call === "function")) {
          return call;
        }
        return _assertThisInitialized(self2);
      }
      function _assertThisInitialized(self2) {
        if (self2 === void 0) {
          throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
        }
        return self2;
      }
      function _isNativeReflectConstruct() {
        if (typeof Reflect === "undefined" || !Reflect.construct)
          return false;
        if (Reflect.construct.sham)
          return false;
        if (typeof Proxy === "function")
          return true;
        try {
          Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
          }));
          return true;
        } catch (e) {
          return false;
        }
      }
      function _getPrototypeOf(o) {
        _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf2(o2) {
          return o2.__proto__ || Object.getPrototypeOf(o2);
        };
        return _getPrototypeOf(o);
      }
      var DefaultBlockPrependor;
      var tools;
      tools = require_tools();
      module2.exports = DefaultBlockPrependor = /* @__PURE__ */ function(_require) {
        _inherits(DefaultBlockPrependor2, _require);
        var _super = _createSuper(DefaultBlockPrependor2);
        function DefaultBlockPrependor2() {
          _classCallCheck(this, DefaultBlockPrependor2);
          return _super.apply(this, arguments);
        }
        _createClass(DefaultBlockPrependor2, [{
          key: "_render",
          value: function _render(options) {
            return tools.repeatString("\n", this._config.amount);
          }
        }]);
        return DefaultBlockPrependor2;
      }(require_BlockPrependor());
    }
  });

  // node_modules/.pnpm/renderkid@3.0.0/node_modules/renderkid/lib/layout/block/blockAppendor/_BlockAppendor.js
  var require_BlockAppendor = __commonJS({
    "node_modules/.pnpm/renderkid@3.0.0/node_modules/renderkid/lib/layout/block/blockAppendor/_BlockAppendor.js"(exports2, module2) {
      "use strict";
      function _classCallCheck(instance, Constructor) {
        if (!(instance instanceof Constructor)) {
          throw new TypeError("Cannot call a class as a function");
        }
      }
      function _defineProperties(target, props) {
        for (var i = 0; i < props.length; i++) {
          var descriptor = props[i];
          descriptor.enumerable = descriptor.enumerable || false;
          descriptor.configurable = true;
          if ("value" in descriptor)
            descriptor.writable = true;
          Object.defineProperty(target, descriptor.key, descriptor);
        }
      }
      function _createClass(Constructor, protoProps, staticProps) {
        if (protoProps)
          _defineProperties(Constructor.prototype, protoProps);
        if (staticProps)
          _defineProperties(Constructor, staticProps);
        return Constructor;
      }
      var _BlockAppendor;
      module2.exports = _BlockAppendor = /* @__PURE__ */ function() {
        function _BlockAppendor2(_config) {
          _classCallCheck(this, _BlockAppendor2);
          this._config = _config;
        }
        _createClass(_BlockAppendor2, [{
          key: "render",
          value: function render(options) {
            return this._render(options);
          }
        }]);
        return _BlockAppendor2;
      }();
    }
  });

  // node_modules/.pnpm/renderkid@3.0.0/node_modules/renderkid/lib/layout/block/blockAppendor/Default.js
  var require_Default2 = __commonJS({
    "node_modules/.pnpm/renderkid@3.0.0/node_modules/renderkid/lib/layout/block/blockAppendor/Default.js"(exports2, module2) {
      "use strict";
      function _typeof(obj) {
        "@babel/helpers - typeof";
        if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
          _typeof = function _typeof2(obj2) {
            return typeof obj2;
          };
        } else {
          _typeof = function _typeof2(obj2) {
            return obj2 && typeof Symbol === "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
          };
        }
        return _typeof(obj);
      }
      function _classCallCheck(instance, Constructor) {
        if (!(instance instanceof Constructor)) {
          throw new TypeError("Cannot call a class as a function");
        }
      }
      function _defineProperties(target, props) {
        for (var i = 0; i < props.length; i++) {
          var descriptor = props[i];
          descriptor.enumerable = descriptor.enumerable || false;
          descriptor.configurable = true;
          if ("value" in descriptor)
            descriptor.writable = true;
          Object.defineProperty(target, descriptor.key, descriptor);
        }
      }
      function _createClass(Constructor, protoProps, staticProps) {
        if (protoProps)
          _defineProperties(Constructor.prototype, protoProps);
        if (staticProps)
          _defineProperties(Constructor, staticProps);
        return Constructor;
      }
      function _inherits(subClass, superClass) {
        if (typeof superClass !== "function" && superClass !== null) {
          throw new TypeError("Super expression must either be null or a function");
        }
        subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } });
        if (superClass)
          _setPrototypeOf(subClass, superClass);
      }
      function _setPrototypeOf(o, p) {
        _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf2(o2, p2) {
          o2.__proto__ = p2;
          return o2;
        };
        return _setPrototypeOf(o, p);
      }
      function _createSuper(Derived) {
        var hasNativeReflectConstruct = _isNativeReflectConstruct();
        return function _createSuperInternal() {
          var Super = _getPrototypeOf(Derived), result;
          if (hasNativeReflectConstruct) {
            var NewTarget = _getPrototypeOf(this).constructor;
            result = Reflect.construct(Super, arguments, NewTarget);
          } else {
            result = Super.apply(this, arguments);
          }
          return _possibleConstructorReturn(this, result);
        };
      }
      function _possibleConstructorReturn(self2, call) {
        if (call && (_typeof(call) === "object" || typeof call === "function")) {
          return call;
        }
        return _assertThisInitialized(self2);
      }
      function _assertThisInitialized(self2) {
        if (self2 === void 0) {
          throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
        }
        return self2;
      }
      function _isNativeReflectConstruct() {
        if (typeof Reflect === "undefined" || !Reflect.construct)
          return false;
        if (Reflect.construct.sham)
          return false;
        if (typeof Proxy === "function")
          return true;
        try {
          Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
          }));
          return true;
        } catch (e) {
          return false;
        }
      }
      function _getPrototypeOf(o) {
        _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf2(o2) {
          return o2.__proto__ || Object.getPrototypeOf(o2);
        };
        return _getPrototypeOf(o);
      }
      var DefaultBlockAppendor;
      var tools;
      tools = require_tools();
      module2.exports = DefaultBlockAppendor = /* @__PURE__ */ function(_require) {
        _inherits(DefaultBlockAppendor2, _require);
        var _super = _createSuper(DefaultBlockAppendor2);
        function DefaultBlockAppendor2() {
          _classCallCheck(this, DefaultBlockAppendor2);
          return _super.apply(this, arguments);
        }
        _createClass(DefaultBlockAppendor2, [{
          key: "_render",
          value: function _render(options) {
            return tools.repeatString("\n", this._config.amount);
          }
        }]);
        return DefaultBlockAppendor2;
      }(require_BlockAppendor());
    }
  });

  // node_modules/.pnpm/renderkid@3.0.0/node_modules/renderkid/lib/layout/block/linePrependor/_LinePrependor.js
  var require_LinePrependor = __commonJS({
    "node_modules/.pnpm/renderkid@3.0.0/node_modules/renderkid/lib/layout/block/linePrependor/_LinePrependor.js"(exports2, module2) {
      "use strict";
      function _classCallCheck(instance, Constructor) {
        if (!(instance instanceof Constructor)) {
          throw new TypeError("Cannot call a class as a function");
        }
      }
      function _defineProperties(target, props) {
        for (var i = 0; i < props.length; i++) {
          var descriptor = props[i];
          descriptor.enumerable = descriptor.enumerable || false;
          descriptor.configurable = true;
          if ("value" in descriptor)
            descriptor.writable = true;
          Object.defineProperty(target, descriptor.key, descriptor);
        }
      }
      function _createClass(Constructor, protoProps, staticProps) {
        if (protoProps)
          _defineProperties(Constructor.prototype, protoProps);
        if (staticProps)
          _defineProperties(Constructor, staticProps);
        return Constructor;
      }
      var _LinePrependor;
      module2.exports = _LinePrependor = /* @__PURE__ */ function() {
        function _LinePrependor2(_config) {
          _classCallCheck(this, _LinePrependor2);
          this._config = _config;
          this._lineNo = -1;
        }
        _createClass(_LinePrependor2, [{
          key: "render",
          value: function render(inherited, options) {
            this._lineNo++;
            return "<none>" + this._render(inherited, options) + "</none>";
          }
        }]);
        return _LinePrependor2;
      }();
    }
  });

  // node_modules/.pnpm/renderkid@3.0.0/node_modules/renderkid/lib/layout/block/linePrependor/Default.js
  var require_Default3 = __commonJS({
    "node_modules/.pnpm/renderkid@3.0.0/node_modules/renderkid/lib/layout/block/linePrependor/Default.js"(exports2, module2) {
      "use strict";
      function _typeof(obj) {
        "@babel/helpers - typeof";
        if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
          _typeof = function _typeof2(obj2) {
            return typeof obj2;
          };
        } else {
          _typeof = function _typeof2(obj2) {
            return obj2 && typeof Symbol === "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
          };
        }
        return _typeof(obj);
      }
      function _classCallCheck(instance, Constructor) {
        if (!(instance instanceof Constructor)) {
          throw new TypeError("Cannot call a class as a function");
        }
      }
      function _defineProperties(target, props) {
        for (var i = 0; i < props.length; i++) {
          var descriptor = props[i];
          descriptor.enumerable = descriptor.enumerable || false;
          descriptor.configurable = true;
          if ("value" in descriptor)
            descriptor.writable = true;
          Object.defineProperty(target, descriptor.key, descriptor);
        }
      }
      function _createClass(Constructor, protoProps, staticProps) {
        if (protoProps)
          _defineProperties(Constructor.prototype, protoProps);
        if (staticProps)
          _defineProperties(Constructor, staticProps);
        return Constructor;
      }
      function _inherits(subClass, superClass) {
        if (typeof superClass !== "function" && superClass !== null) {
          throw new TypeError("Super expression must either be null or a function");
        }
        subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } });
        if (superClass)
          _setPrototypeOf(subClass, superClass);
      }
      function _setPrototypeOf(o, p) {
        _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf2(o2, p2) {
          o2.__proto__ = p2;
          return o2;
        };
        return _setPrototypeOf(o, p);
      }
      function _createSuper(Derived) {
        var hasNativeReflectConstruct = _isNativeReflectConstruct();
        return function _createSuperInternal() {
          var Super = _getPrototypeOf(Derived), result;
          if (hasNativeReflectConstruct) {
            var NewTarget = _getPrototypeOf(this).constructor;
            result = Reflect.construct(Super, arguments, NewTarget);
          } else {
            result = Super.apply(this, arguments);
          }
          return _possibleConstructorReturn(this, result);
        };
      }
      function _possibleConstructorReturn(self2, call) {
        if (call && (_typeof(call) === "object" || typeof call === "function")) {
          return call;
        }
        return _assertThisInitialized(self2);
      }
      function _assertThisInitialized(self2) {
        if (self2 === void 0) {
          throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
        }
        return self2;
      }
      function _isNativeReflectConstruct() {
        if (typeof Reflect === "undefined" || !Reflect.construct)
          return false;
        if (Reflect.construct.sham)
          return false;
        if (typeof Proxy === "function")
          return true;
        try {
          Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
          }));
          return true;
        } catch (e) {
          return false;
        }
      }
      function _getPrototypeOf(o) {
        _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf2(o2) {
          return o2.__proto__ || Object.getPrototypeOf(o2);
        };
        return _getPrototypeOf(o);
      }
      var DefaultLinePrependor;
      var SpecialString;
      var tools;
      tools = require_tools();
      SpecialString = require_SpecialString();
      module2.exports = DefaultLinePrependor = function() {
        var self2;
        var DefaultLinePrependor2 = /* @__PURE__ */ function(_require) {
          _inherits(DefaultLinePrependor3, _require);
          var _super = _createSuper(DefaultLinePrependor3);
          function DefaultLinePrependor3() {
            _classCallCheck(this, DefaultLinePrependor3);
            return _super.apply(this, arguments);
          }
          _createClass(DefaultLinePrependor3, [{
            key: "_render",
            value: function _render(inherited, options) {
              var addToLeft, addToRight, alignment, bullet, char, charLen, diff, left, output, space, toWrite;
              if (this._lineNo === 0 && (bullet = this._config.bullet)) {
                char = bullet.char;
                charLen = new SpecialString(char).length;
                alignment = bullet.alignment;
                space = this._config.amount;
                toWrite = char;
                addToLeft = "";
                addToRight = "";
                if (space > charLen) {
                  diff = space - charLen;
                  if (alignment === "right") {
                    addToLeft = self2.pad(diff);
                  } else if (alignment === "left") {
                    addToRight = self2.pad(diff);
                  } else if (alignment === "center") {
                    left = Math.round(diff / 2);
                    addToLeft = self2.pad(left);
                    addToRight = self2.pad(diff - left);
                  } else {
                    throw Error("Unknown alignment `".concat(alignment, "`"));
                  }
                }
                output = addToLeft + char + addToRight;
              } else {
                output = self2.pad(this._config.amount);
              }
              return inherited + output;
            }
          }], [{
            key: "pad",
            value: function pad(howMuch) {
              return tools.repeatString(" ", howMuch);
            }
          }]);
          return DefaultLinePrependor3;
        }(require_LinePrependor());
        ;
        self2 = DefaultLinePrependor2;
        return DefaultLinePrependor2;
      }.call(void 0);
    }
  });

  // node_modules/.pnpm/renderkid@3.0.0/node_modules/renderkid/lib/layout/block/lineAppendor/_LineAppendor.js
  var require_LineAppendor = __commonJS({
    "node_modules/.pnpm/renderkid@3.0.0/node_modules/renderkid/lib/layout/block/lineAppendor/_LineAppendor.js"(exports2, module2) {
      "use strict";
      function _classCallCheck(instance, Constructor) {
        if (!(instance instanceof Constructor)) {
          throw new TypeError("Cannot call a class as a function");
        }
      }
      function _defineProperties(target, props) {
        for (var i = 0; i < props.length; i++) {
          var descriptor = props[i];
          descriptor.enumerable = descriptor.enumerable || false;
          descriptor.configurable = true;
          if ("value" in descriptor)
            descriptor.writable = true;
          Object.defineProperty(target, descriptor.key, descriptor);
        }
      }
      function _createClass(Constructor, protoProps, staticProps) {
        if (protoProps)
          _defineProperties(Constructor.prototype, protoProps);
        if (staticProps)
          _defineProperties(Constructor, staticProps);
        return Constructor;
      }
      var _LineAppendor;
      module2.exports = _LineAppendor = /* @__PURE__ */ function() {
        function _LineAppendor2(_config) {
          _classCallCheck(this, _LineAppendor2);
          this._config = _config;
          this._lineNo = 0;
        }
        _createClass(_LineAppendor2, [{
          key: "render",
          value: function render(inherited, options) {
            this._lineNo++;
            return "<none>" + this._render(inherited, options) + "</none>";
          }
        }]);
        return _LineAppendor2;
      }();
    }
  });

  // node_modules/.pnpm/renderkid@3.0.0/node_modules/renderkid/lib/layout/block/lineAppendor/Default.js
  var require_Default4 = __commonJS({
    "node_modules/.pnpm/renderkid@3.0.0/node_modules/renderkid/lib/layout/block/lineAppendor/Default.js"(exports2, module2) {
      "use strict";
      function _typeof(obj) {
        "@babel/helpers - typeof";
        if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
          _typeof = function _typeof2(obj2) {
            return typeof obj2;
          };
        } else {
          _typeof = function _typeof2(obj2) {
            return obj2 && typeof Symbol === "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
          };
        }
        return _typeof(obj);
      }
      function _classCallCheck(instance, Constructor) {
        if (!(instance instanceof Constructor)) {
          throw new TypeError("Cannot call a class as a function");
        }
      }
      function _defineProperties(target, props) {
        for (var i = 0; i < props.length; i++) {
          var descriptor = props[i];
          descriptor.enumerable = descriptor.enumerable || false;
          descriptor.configurable = true;
          if ("value" in descriptor)
            descriptor.writable = true;
          Object.defineProperty(target, descriptor.key, descriptor);
        }
      }
      function _createClass(Constructor, protoProps, staticProps) {
        if (protoProps)
          _defineProperties(Constructor.prototype, protoProps);
        if (staticProps)
          _defineProperties(Constructor, staticProps);
        return Constructor;
      }
      function _inherits(subClass, superClass) {
        if (typeof superClass !== "function" && superClass !== null) {
          throw new TypeError("Super expression must either be null or a function");
        }
        subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } });
        if (superClass)
          _setPrototypeOf(subClass, superClass);
      }
      function _setPrototypeOf(o, p) {
        _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf2(o2, p2) {
          o2.__proto__ = p2;
          return o2;
        };
        return _setPrototypeOf(o, p);
      }
      function _createSuper(Derived) {
        var hasNativeReflectConstruct = _isNativeReflectConstruct();
        return function _createSuperInternal() {
          var Super = _getPrototypeOf(Derived), result;
          if (hasNativeReflectConstruct) {
            var NewTarget = _getPrototypeOf(this).constructor;
            result = Reflect.construct(Super, arguments, NewTarget);
          } else {
            result = Super.apply(this, arguments);
          }
          return _possibleConstructorReturn(this, result);
        };
      }
      function _possibleConstructorReturn(self2, call) {
        if (call && (_typeof(call) === "object" || typeof call === "function")) {
          return call;
        }
        return _assertThisInitialized(self2);
      }
      function _assertThisInitialized(self2) {
        if (self2 === void 0) {
          throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
        }
        return self2;
      }
      function _isNativeReflectConstruct() {
        if (typeof Reflect === "undefined" || !Reflect.construct)
          return false;
        if (Reflect.construct.sham)
          return false;
        if (typeof Proxy === "function")
          return true;
        try {
          Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
          }));
          return true;
        } catch (e) {
          return false;
        }
      }
      function _getPrototypeOf(o) {
        _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf2(o2) {
          return o2.__proto__ || Object.getPrototypeOf(o2);
        };
        return _getPrototypeOf(o);
      }
      var DefaultLineAppendor;
      var tools;
      tools = require_tools();
      module2.exports = DefaultLineAppendor = /* @__PURE__ */ function(_require) {
        _inherits(DefaultLineAppendor2, _require);
        var _super = _createSuper(DefaultLineAppendor2);
        function DefaultLineAppendor2() {
          _classCallCheck(this, DefaultLineAppendor2);
          return _super.apply(this, arguments);
        }
        _createClass(DefaultLineAppendor2, [{
          key: "_render",
          value: function _render(inherited, options) {
            return inherited + tools.repeatString(" ", this._config.amount);
          }
        }]);
        return DefaultLineAppendor2;
      }(require_LineAppendor());
    }
  });

  // node_modules/.pnpm/renderkid@3.0.0/node_modules/renderkid/lib/layout/block/lineWrapper/_LineWrapper.js
  var require_LineWrapper = __commonJS({
    "node_modules/.pnpm/renderkid@3.0.0/node_modules/renderkid/lib/layout/block/lineWrapper/_LineWrapper.js"(exports2, module2) {
      "use strict";
      function _classCallCheck(instance, Constructor) {
        if (!(instance instanceof Constructor)) {
          throw new TypeError("Cannot call a class as a function");
        }
      }
      function _defineProperties(target, props) {
        for (var i = 0; i < props.length; i++) {
          var descriptor = props[i];
          descriptor.enumerable = descriptor.enumerable || false;
          descriptor.configurable = true;
          if ("value" in descriptor)
            descriptor.writable = true;
          Object.defineProperty(target, descriptor.key, descriptor);
        }
      }
      function _createClass(Constructor, protoProps, staticProps) {
        if (protoProps)
          _defineProperties(Constructor.prototype, protoProps);
        if (staticProps)
          _defineProperties(Constructor, staticProps);
        return Constructor;
      }
      var _LineWrapper;
      module2.exports = _LineWrapper = /* @__PURE__ */ function() {
        function _LineWrapper2() {
          _classCallCheck(this, _LineWrapper2);
        }
        _createClass(_LineWrapper2, [{
          key: "render",
          value: function render(str, options) {
            return this._render(str, options);
          }
        }]);
        return _LineWrapper2;
      }();
    }
  });

  // node_modules/.pnpm/renderkid@3.0.0/node_modules/renderkid/lib/layout/block/lineWrapper/Default.js
  var require_Default5 = __commonJS({
    "node_modules/.pnpm/renderkid@3.0.0/node_modules/renderkid/lib/layout/block/lineWrapper/Default.js"(exports2, module2) {
      "use strict";
      function _typeof(obj) {
        "@babel/helpers - typeof";
        if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
          _typeof = function _typeof2(obj2) {
            return typeof obj2;
          };
        } else {
          _typeof = function _typeof2(obj2) {
            return obj2 && typeof Symbol === "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
          };
        }
        return _typeof(obj);
      }
      function _classCallCheck(instance, Constructor) {
        if (!(instance instanceof Constructor)) {
          throw new TypeError("Cannot call a class as a function");
        }
      }
      function _defineProperties(target, props) {
        for (var i = 0; i < props.length; i++) {
          var descriptor = props[i];
          descriptor.enumerable = descriptor.enumerable || false;
          descriptor.configurable = true;
          if ("value" in descriptor)
            descriptor.writable = true;
          Object.defineProperty(target, descriptor.key, descriptor);
        }
      }
      function _createClass(Constructor, protoProps, staticProps) {
        if (protoProps)
          _defineProperties(Constructor.prototype, protoProps);
        if (staticProps)
          _defineProperties(Constructor, staticProps);
        return Constructor;
      }
      function _inherits(subClass, superClass) {
        if (typeof superClass !== "function" && superClass !== null) {
          throw new TypeError("Super expression must either be null or a function");
        }
        subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } });
        if (superClass)
          _setPrototypeOf(subClass, superClass);
      }
      function _setPrototypeOf(o, p) {
        _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf2(o2, p2) {
          o2.__proto__ = p2;
          return o2;
        };
        return _setPrototypeOf(o, p);
      }
      function _createSuper(Derived) {
        var hasNativeReflectConstruct = _isNativeReflectConstruct();
        return function _createSuperInternal() {
          var Super = _getPrototypeOf(Derived), result;
          if (hasNativeReflectConstruct) {
            var NewTarget = _getPrototypeOf(this).constructor;
            result = Reflect.construct(Super, arguments, NewTarget);
          } else {
            result = Super.apply(this, arguments);
          }
          return _possibleConstructorReturn(this, result);
        };
      }
      function _possibleConstructorReturn(self2, call) {
        if (call && (_typeof(call) === "object" || typeof call === "function")) {
          return call;
        }
        return _assertThisInitialized(self2);
      }
      function _assertThisInitialized(self2) {
        if (self2 === void 0) {
          throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
        }
        return self2;
      }
      function _isNativeReflectConstruct() {
        if (typeof Reflect === "undefined" || !Reflect.construct)
          return false;
        if (Reflect.construct.sham)
          return false;
        if (typeof Proxy === "function")
          return true;
        try {
          Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
          }));
          return true;
        } catch (e) {
          return false;
        }
      }
      function _getPrototypeOf(o) {
        _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf2(o2) {
          return o2.__proto__ || Object.getPrototypeOf(o2);
        };
        return _getPrototypeOf(o);
      }
      var DefaultLineWrapper;
      module2.exports = DefaultLineWrapper = /* @__PURE__ */ function(_require) {
        _inherits(DefaultLineWrapper2, _require);
        var _super = _createSuper(DefaultLineWrapper2);
        function DefaultLineWrapper2() {
          _classCallCheck(this, DefaultLineWrapper2);
          return _super.apply(this, arguments);
        }
        _createClass(DefaultLineWrapper2, [{
          key: "_render",
          value: function _render() {
          }
        }]);
        return DefaultLineWrapper2;
      }(require_LineWrapper());
    }
  });

  // node_modules/.pnpm/renderkid@3.0.0/node_modules/renderkid/lib/layout/Block.js
  var require_Block = __commonJS({
    "node_modules/.pnpm/renderkid@3.0.0/node_modules/renderkid/lib/layout/Block.js"(exports2, module2) {
      "use strict";
      function _classCallCheck(instance, Constructor) {
        if (!(instance instanceof Constructor)) {
          throw new TypeError("Cannot call a class as a function");
        }
      }
      function _defineProperties(target, props) {
        for (var i = 0; i < props.length; i++) {
          var descriptor = props[i];
          descriptor.enumerable = descriptor.enumerable || false;
          descriptor.configurable = true;
          if ("value" in descriptor)
            descriptor.writable = true;
          Object.defineProperty(target, descriptor.key, descriptor);
        }
      }
      function _createClass(Constructor, protoProps, staticProps) {
        if (protoProps)
          _defineProperties(Constructor.prototype, protoProps);
        if (staticProps)
          _defineProperties(Constructor, staticProps);
        return Constructor;
      }
      var Block;
      var SpecialString;
      var cloneAndMergeDeep;
      var terminalWidth;
      SpecialString = require_SpecialString();
      terminalWidth = require_tools().getCols();
      var _require = require_tools();
      cloneAndMergeDeep = _require.cloneAndMergeDeep;
      module2.exports = Block = function() {
        var self2;
        var Block2 = /* @__PURE__ */ function() {
          function Block3(_layout, _parent) {
            var config2 = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
            var _name = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : "";
            _classCallCheck(this, Block3);
            this._layout = _layout;
            this._parent = _parent;
            this._name = _name;
            this._config = cloneAndMergeDeep(self2.defaultConfig, config2);
            this._closed = false;
            this._wasOpenOnce = false;
            this._active = false;
            this._buffer = "";
            this._didSeparateBlock = false;
            this._linePrependor = new this._config.linePrependor.fn(this._config.linePrependor.options);
            this._lineAppendor = new this._config.lineAppendor.fn(this._config.lineAppendor.options);
            this._blockPrependor = new this._config.blockPrependor.fn(this._config.blockPrependor.options);
            this._blockAppendor = new this._config.blockAppendor.fn(this._config.blockAppendor.options);
          }
          _createClass(Block3, [{
            key: "_activate",
            value: function _activate() {
              var deactivateParent = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : true;
              if (this._active) {
                throw Error("This block is already active. This is probably a bug in RenderKid itself");
              }
              if (this._closed) {
                throw Error("This block is closed and cannot be activated. This is probably a bug in RenderKid itself");
              }
              this._active = true;
              this._layout._activeBlock = this;
              if (deactivateParent) {
                if (this._parent != null) {
                  this._parent._deactivate(false);
                }
              }
              return this;
            }
          }, {
            key: "_deactivate",
            value: function _deactivate() {
              var activateParent = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : true;
              this._ensureActive();
              this._flushBuffer();
              if (activateParent) {
                if (this._parent != null) {
                  this._parent._activate(false);
                }
              }
              this._active = false;
              return this;
            }
          }, {
            key: "_ensureActive",
            value: function _ensureActive() {
              if (!this._wasOpenOnce) {
                throw Error("This block has never been open before. This is probably a bug in RenderKid itself.");
              }
              if (!this._active) {
                throw Error("This block is not active. This is probably a bug in RenderKid itself.");
              }
              if (this._closed) {
                throw Error("This block is already closed. This is probably a bug in RenderKid itself.");
              }
            }
          }, {
            key: "_open",
            value: function _open() {
              if (this._wasOpenOnce) {
                throw Error("Block._open() has been called twice. This is probably a RenderKid bug.");
              }
              this._wasOpenOnce = true;
              if (this._parent != null) {
                this._parent.write(this._whatToPrependToBlock());
              }
              this._activate();
              return this;
            }
          }, {
            key: "close",
            value: function close() {
              this._deactivate();
              this._closed = true;
              if (this._parent != null) {
                this._parent.write(this._whatToAppendToBlock());
              }
              return this;
            }
          }, {
            key: "isOpen",
            value: function isOpen() {
              return this._wasOpenOnce && !this._closed;
            }
          }, {
            key: "write",
            value: function write(str) {
              this._ensureActive();
              if (str === "") {
                return;
              }
              str = String(str);
              this._buffer += str;
              return this;
            }
          }, {
            key: "openBlock",
            value: function openBlock(config2, name) {
              var block;
              this._ensureActive();
              block = new Block3(this._layout, this, config2, name);
              block._open();
              return block;
            }
          }, {
            key: "_flushBuffer",
            value: function _flushBuffer() {
              var str;
              if (this._buffer === "") {
                return;
              }
              str = this._buffer;
              this._buffer = "";
              this._writeInline(str);
            }
          }, {
            key: "_toPrependToLine",
            value: function _toPrependToLine() {
              var fromParent;
              fromParent = "";
              if (this._parent != null) {
                fromParent = this._parent._toPrependToLine();
              }
              return this._linePrependor.render(fromParent);
            }
          }, {
            key: "_toAppendToLine",
            value: function _toAppendToLine() {
              var fromParent;
              fromParent = "";
              if (this._parent != null) {
                fromParent = this._parent._toAppendToLine();
              }
              return this._lineAppendor.render(fromParent);
            }
          }, {
            key: "_whatToPrependToBlock",
            value: function _whatToPrependToBlock() {
              return this._blockPrependor.render();
            }
          }, {
            key: "_whatToAppendToBlock",
            value: function _whatToAppendToBlock() {
              return this._blockAppendor.render();
            }
          }, {
            key: "_writeInline",
            value: function _writeInline(str) {
              var i, j, k, l, lineBreaksToAppend, m, ref, ref1, ref2, remaining;
              if (new SpecialString(str).isOnlySpecialChars()) {
                this._layout._append(str);
                return;
              }
              remaining = str;
              lineBreaksToAppend = 0;
              if (m = remaining.match(/^\n+/)) {
                for (i = j = 1, ref = m[0].length; 1 <= ref ? j <= ref : j >= ref; i = 1 <= ref ? ++j : --j) {
                  this._writeLine("");
                }
                remaining = remaining.substr(m[0].length, remaining.length);
              }
              if (m = remaining.match(/\n+$/)) {
                lineBreaksToAppend = m[0].length;
                remaining = remaining.substr(0, remaining.length - m[0].length);
              }
              while (remaining.length > 0) {
                if (m = remaining.match(/^[^\n]+/)) {
                  this._writeLine(m[0]);
                  remaining = remaining.substr(m[0].length, remaining.length);
                } else if (m = remaining.match(/^\n+/)) {
                  for (i = k = 1, ref1 = m[0].length; 1 <= ref1 ? k < ref1 : k > ref1; i = 1 <= ref1 ? ++k : --k) {
                    this._writeLine("");
                  }
                  remaining = remaining.substr(m[0].length, remaining.length);
                }
              }
              if (lineBreaksToAppend > 0) {
                for (i = l = 1, ref2 = lineBreaksToAppend; 1 <= ref2 ? l <= ref2 : l >= ref2; i = 1 <= ref2 ? ++l : --l) {
                  this._writeLine("");
                }
              }
            }
            // wraps a line into multiple lines if necessary, adds horizontal margins,
            // etc, and appends it to the layout.
          }, {
            key: "_writeLine",
            value: function _writeLine(str) {
              var line, lineContent, lineContentLength, remaining, roomLeft, toAppend, toAppendLength, toPrepend, toPrependLength;
              remaining = new SpecialString(str);
              while (true) {
                toPrepend = this._toPrependToLine();
                toPrependLength = new SpecialString(toPrepend).length;
                toAppend = this._toAppendToLine();
                toAppendLength = new SpecialString(toAppend).length;
                roomLeft = this._layout._config.terminalWidth - (toPrependLength + toAppendLength);
                lineContentLength = Math.min(this._config.width, roomLeft);
                lineContent = remaining.cut(0, lineContentLength, true);
                line = toPrepend + lineContent.str + toAppend;
                this._layout._appendLine(line);
                if (remaining.isEmpty()) {
                  break;
                }
              }
            }
          }]);
          return Block3;
        }();
        ;
        self2 = Block2;
        Block2.defaultConfig = {
          blockPrependor: {
            fn: require_Default(),
            options: {
              amount: 0
            }
          },
          blockAppendor: {
            fn: require_Default2(),
            options: {
              amount: 0
            }
          },
          linePrependor: {
            fn: require_Default3(),
            options: {
              amount: 0
            }
          },
          lineAppendor: {
            fn: require_Default4(),
            options: {
              amount: 0
            }
          },
          lineWrapper: {
            fn: require_Default5(),
            options: {
              lineWidth: null
            }
          },
          width: terminalWidth,
          prefixRaw: "",
          suffixRaw: ""
        };
        return Block2;
      }.call(void 0);
    }
  });

  // node_modules/.pnpm/renderkid@3.0.0/node_modules/renderkid/lib/Layout.js
  var require_Layout = __commonJS({
    "node_modules/.pnpm/renderkid@3.0.0/node_modules/renderkid/lib/Layout.js"(exports2, module2) {
      "use strict";
      function _classCallCheck(instance, Constructor) {
        if (!(instance instanceof Constructor)) {
          throw new TypeError("Cannot call a class as a function");
        }
      }
      function _defineProperties(target, props) {
        for (var i2 = 0; i2 < props.length; i2++) {
          var descriptor = props[i2];
          descriptor.enumerable = descriptor.enumerable || false;
          descriptor.configurable = true;
          if ("value" in descriptor)
            descriptor.writable = true;
          Object.defineProperty(target, descriptor.key, descriptor);
        }
      }
      function _createClass(Constructor, protoProps, staticProps) {
        if (protoProps)
          _defineProperties(Constructor.prototype, protoProps);
        if (staticProps)
          _defineProperties(Constructor, staticProps);
        return Constructor;
      }
      var Block;
      var Layout;
      var SpecialString;
      var cloneAndMergeDeep;
      var i;
      var len;
      var prop;
      var ref;
      var terminalWidth;
      Block = require_Block();
      var _require = require_tools();
      cloneAndMergeDeep = _require.cloneAndMergeDeep;
      SpecialString = require_SpecialString();
      terminalWidth = require_tools().getCols();
      module2.exports = Layout = function() {
        var self2;
        var Layout2 = /* @__PURE__ */ function() {
          function Layout3() {
            var config2 = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
            var rootBlockConfig = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
            _classCallCheck(this, Layout3);
            var rootConfig;
            this._written = [];
            this._activeBlock = null;
            this._config = cloneAndMergeDeep(self2._defaultConfig, config2);
            rootConfig = cloneAndMergeDeep(self2._rootBlockDefaultConfig, rootBlockConfig);
            this._root = new Block(this, null, rootConfig, "__root");
            this._root._open();
          }
          _createClass(Layout3, [{
            key: "getRootBlock",
            value: function getRootBlock() {
              return this._root;
            }
          }, {
            key: "_append",
            value: function _append(text) {
              return this._written.push(text);
            }
          }, {
            key: "_appendLine",
            value: function _appendLine(text) {
              var s;
              this._append(text);
              s = new SpecialString(text);
              if (s.length < this._config.terminalWidth) {
                this._append("<none>\n</none>");
              }
              return this;
            }
          }, {
            key: "get",
            value: function get4() {
              this._ensureClosed();
              if (this._written[this._written.length - 1] === "<none>\n</none>") {
                this._written.pop();
              }
              return this._written.join("");
            }
          }, {
            key: "_ensureClosed",
            value: function _ensureClosed() {
              if (this._activeBlock !== this._root) {
                throw Error("Not all the blocks have been closed. Please call block.close() on all open blocks.");
              }
              if (this._root.isOpen()) {
                this._root.close();
              }
            }
          }]);
          return Layout3;
        }();
        ;
        self2 = Layout2;
        Layout2._rootBlockDefaultConfig = {
          linePrependor: {
            options: {
              amount: 0
            }
          },
          lineAppendor: {
            options: {
              amount: 0
            }
          },
          blockPrependor: {
            options: {
              amount: 0
            }
          },
          blockAppendor: {
            options: {
              amount: 0
            }
          }
        };
        Layout2._defaultConfig = {
          terminalWidth
        };
        return Layout2;
      }.call(void 0);
      ref = ["openBlock", "write"];
      for (i = 0, len = ref.length; i < len; i++) {
        prop = ref[i];
        (function() {
          var method;
          method = prop;
          return Layout.prototype[method] = function() {
            return this._root[method].apply(this._root, arguments);
          };
        })();
      }
    }
  });

  // node_modules/.pnpm/ansi-regex@5.0.1/node_modules/ansi-regex/index.js
  var require_ansi_regex = __commonJS({
    "node_modules/.pnpm/ansi-regex@5.0.1/node_modules/ansi-regex/index.js"(exports2, module2) {
      "use strict";
      module2.exports = ({ onlyFirst = false } = {}) => {
        const pattern = [
          "[\\u001B\\u009B][[\\]()#;?]*(?:(?:(?:(?:;[-a-zA-Z\\d\\/#&.:=?%@~_]+)*|[a-zA-Z\\d]+(?:;[-a-zA-Z\\d\\/#&.:=?%@~_]*)*)?\\u0007)",
          "(?:(?:\\d{1,4}(?:;\\d{0,4})*)?[\\dA-PR-TZcf-ntqry=><~]))"
        ].join("|");
        return new RegExp(pattern, onlyFirst ? void 0 : "g");
      };
    }
  });

  // node_modules/.pnpm/strip-ansi@6.0.1/node_modules/strip-ansi/index.js
  var require_strip_ansi = __commonJS({
    "node_modules/.pnpm/strip-ansi@6.0.1/node_modules/strip-ansi/index.js"(exports2, module2) {
      "use strict";
      var ansiRegex = require_ansi_regex();
      module2.exports = (string) => typeof string === "string" ? string.replace(ansiRegex(), "") : string;
    }
  });

  // node_modules/.pnpm/renderkid@3.0.0/node_modules/renderkid/lib/RenderKid.js
  var require_RenderKid = __commonJS({
    "node_modules/.pnpm/renderkid@3.0.0/node_modules/renderkid/lib/RenderKid.js"(exports2, module2) {
      "use strict";
      function _classCallCheck(instance, Constructor) {
        if (!(instance instanceof Constructor)) {
          throw new TypeError("Cannot call a class as a function");
        }
      }
      function _defineProperties(target, props) {
        for (var i = 0; i < props.length; i++) {
          var descriptor = props[i];
          descriptor.enumerable = descriptor.enumerable || false;
          descriptor.configurable = true;
          if ("value" in descriptor)
            descriptor.writable = true;
          Object.defineProperty(target, descriptor.key, descriptor);
        }
      }
      function _createClass(Constructor, protoProps, staticProps) {
        if (protoProps)
          _defineProperties(Constructor.prototype, protoProps);
        if (staticProps)
          _defineProperties(Constructor, staticProps);
        return Constructor;
      }
      var AnsiPainter;
      var Layout;
      var RenderKid;
      var Styles;
      var blockStyleApplier;
      var cloneAndMergeDeep;
      var inlineStyleApplier;
      var isPlainObject;
      var stripAnsi;
      var terminalWidth;
      var tools;
      inlineStyleApplier = require_inline();
      blockStyleApplier = require_block();
      isPlainObject = require_isPlainObject();
      var _require = require_tools();
      cloneAndMergeDeep = _require.cloneAndMergeDeep;
      AnsiPainter = require_AnsiPainter();
      Styles = require_Styles();
      Layout = require_Layout();
      tools = require_tools();
      stripAnsi = require_strip_ansi();
      terminalWidth = require_tools().getCols();
      module2.exports = RenderKid = function() {
        var self2;
        var RenderKid2 = /* @__PURE__ */ function() {
          function RenderKid3() {
            var config2 = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
            _classCallCheck(this, RenderKid3);
            this.tools = self2.tools;
            this._config = cloneAndMergeDeep(self2._defaultConfig, config2);
            this._initStyles();
          }
          _createClass(RenderKid3, [{
            key: "_initStyles",
            value: function _initStyles() {
              return this._styles = new Styles();
            }
          }, {
            key: "style",
            value: function style() {
              return this._styles.setRule.apply(this._styles, arguments);
            }
          }, {
            key: "_getStyleFor",
            value: function _getStyleFor(el) {
              return this._styles.getStyleFor(el);
            }
          }, {
            key: "render",
            value: function render(input) {
              var withColors = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : true;
              return this._paint(this._renderDom(this._toDom(input)), withColors);
            }
          }, {
            key: "_toDom",
            value: function _toDom(input) {
              if (typeof input === "string") {
                return this._parse(input);
              } else if (isPlainObject(input) || Array.isArray(input)) {
                return this._objToDom(input);
              } else {
                throw Error("Invalid input type. Only strings, arrays and objects are accepted");
              }
            }
          }, {
            key: "_objToDom",
            value: function _objToDom(o) {
              var injectFakeRoot = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : true;
              if (injectFakeRoot) {
                o = {
                  body: o
                };
              }
              return tools.objectToDom(o);
            }
          }, {
            key: "_paint",
            value: function _paint(text, withColors) {
              var painted;
              painted = AnsiPainter.paint(text);
              if (withColors) {
                return painted;
              } else {
                return stripAnsi(painted);
              }
            }
          }, {
            key: "_parse",
            value: function _parse(string) {
              var injectFakeRoot = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : true;
              if (injectFakeRoot) {
                string = "<body>" + string + "</body>";
              }
              return tools.stringToDom(string);
            }
          }, {
            key: "_renderDom",
            value: function _renderDom(dom) {
              var bodyTag, layout, rootBlock;
              bodyTag = dom[0];
              layout = new Layout(this._config.layout);
              rootBlock = layout.getRootBlock();
              this._renderBlockNode(bodyTag, null, rootBlock);
              return layout.get();
            }
          }, {
            key: "_renderChildrenOf",
            value: function _renderChildrenOf(parentNode, parentBlock) {
              var i, len, node, nodes;
              nodes = parentNode.children;
              for (i = 0, len = nodes.length; i < len; i++) {
                node = nodes[i];
                this._renderNode(node, parentNode, parentBlock);
              }
            }
          }, {
            key: "_renderNode",
            value: function _renderNode(node, parentNode, parentBlock) {
              if (node.type === "text") {
                this._renderText(node, parentNode, parentBlock);
              } else if (node.name === "br") {
                this._renderBr(node, parentNode, parentBlock);
              } else if (this._isBlock(node)) {
                this._renderBlockNode(node, parentNode, parentBlock);
              } else if (this._isNone(node)) {
                return;
              } else {
                this._renderInlineNode(node, parentNode, parentBlock);
              }
            }
          }, {
            key: "_renderText",
            value: function _renderText(node, parentNode, parentBlock) {
              var ref, text;
              text = node.data;
              text = text.replace(/\s+/g, " ");
              if ((parentNode != null ? (ref = parentNode.styles) != null ? ref.display : void 0 : void 0) !== "inline") {
                text = text.trim();
              }
              if (text.length === 0) {
                return;
              }
              text = text.replace(/&nl;/g, "\n");
              return parentBlock.write(text);
            }
          }, {
            key: "_renderBlockNode",
            value: function _renderBlockNode(node, parentNode, parentBlock) {
              var after, before, block, blockConfig;
              var _blockStyleApplier$ap = blockStyleApplier.applyTo(node, this._getStyleFor(node));
              before = _blockStyleApplier$ap.before;
              after = _blockStyleApplier$ap.after;
              blockConfig = _blockStyleApplier$ap.blockConfig;
              block = parentBlock.openBlock(blockConfig);
              if (before !== "") {
                block.write(before);
              }
              this._renderChildrenOf(node, block);
              if (after !== "") {
                block.write(after);
              }
              return block.close();
            }
          }, {
            key: "_renderInlineNode",
            value: function _renderInlineNode(node, parentNode, parentBlock) {
              var after, before;
              var _inlineStyleApplier$a = inlineStyleApplier.applyTo(node, this._getStyleFor(node));
              before = _inlineStyleApplier$a.before;
              after = _inlineStyleApplier$a.after;
              if (before !== "") {
                parentBlock.write(before);
              }
              this._renderChildrenOf(node, parentBlock);
              if (after !== "") {
                return parentBlock.write(after);
              }
            }
          }, {
            key: "_renderBr",
            value: function _renderBr(node, parentNode, parentBlock) {
              return parentBlock.write("\n");
            }
          }, {
            key: "_isBlock",
            value: function _isBlock(node) {
              return !(node.type === "text" || node.name === "br" || this._getStyleFor(node).display !== "block");
            }
          }, {
            key: "_isNone",
            value: function _isNone(node) {
              return !(node.type === "text" || node.name === "br" || this._getStyleFor(node).display !== "none");
            }
          }]);
          return RenderKid3;
        }();
        ;
        self2 = RenderKid2;
        RenderKid2.AnsiPainter = AnsiPainter;
        RenderKid2.Layout = Layout;
        RenderKid2.quote = tools.quote;
        RenderKid2.tools = tools;
        RenderKid2._defaultConfig = {
          layout: {
            terminalWidth
          }
        };
        return RenderKid2;
      }.call(void 0);
    }
  });

  // node_modules/.pnpm/pretty-error@4.0.0/node_modules/pretty-error/lib/PrettyError.js
  var require_PrettyError = __commonJS({
    "node_modules/.pnpm/pretty-error@4.0.0/node_modules/pretty-error/lib/PrettyError.js"(exports2, module2) {
      var ParsedError;
      var PrettyError3;
      var RenderKid;
      var arrayUtils;
      var defaultStyle;
      var instance;
      var isPlainObject;
      var merge;
      var nodePaths;
      var prop;
      var _fn;
      var _i;
      var _len;
      var _ref;
      var __slice = [].slice;
      var __indexOf = [].indexOf || function(item) {
        for (var i = 0, l = this.length; i < l; i++) {
          if (i in this && this[i] === item)
            return i;
        }
        return -1;
      };
      isPlainObject = require_isPlainObject();
      defaultStyle = require_defaultStyle();
      ParsedError = require_ParsedError();
      nodePaths = require_nodePaths();
      RenderKid = require_RenderKid();
      merge = require_merge();
      arrayUtils = {
        pluckByCallback: function(a, cb) {
          var index, removed, value, _i2, _len2;
          if (a.length < 1) {
            return a;
          }
          removed = 0;
          for (index = _i2 = 0, _len2 = a.length; _i2 < _len2; index = ++_i2) {
            value = a[index];
            if (cb(value, index)) {
              removed++;
              continue;
            }
            if (removed !== 0) {
              a[index - removed] = a[index];
            }
          }
          if (removed > 0) {
            a.length = a.length - removed;
          }
          return a;
        },
        pluckOneItem: function(a, item) {
          var index, reached, value, _i2, _len2;
          if (a.length < 1) {
            return a;
          }
          reached = false;
          for (index = _i2 = 0, _len2 = a.length; _i2 < _len2; index = ++_i2) {
            value = a[index];
            if (!reached) {
              if (value === item) {
                reached = true;
                continue;
              }
            } else {
              a[index - 1] = a[index];
            }
          }
          if (reached) {
            a.length = a.length - 1;
          }
          return a;
        }
      };
      instance = null;
      module2.exports = PrettyError3 = function() {
        var self2;
        self2 = PrettyError4;
        PrettyError4._filters = {
          "module.exports": function(item) {
            if (item.what == null) {
              return;
            }
            item.what = item.what.replace(/\.module\.exports\./g, " - ");
          }
        };
        PrettyError4._getDefaultStyle = function() {
          return defaultStyle();
        };
        PrettyError4.start = function() {
          if (instance == null) {
            instance = new self2();
            instance.start();
          }
          return instance;
        };
        PrettyError4.stop = function() {
          return instance != null ? instance.stop() : void 0;
        };
        function PrettyError4() {
          this._useColors = true;
          this._maxItems = 50;
          this._packagesToSkip = [];
          this._pathsToSkip = [];
          this._skipCallbacks = [];
          this._filterCallbacks = [];
          this._parsedErrorFilters = [];
          this._aliases = [];
          this._renderer = new RenderKid();
          this._style = self2._getDefaultStyle();
          this._renderer.style(this._style);
        }
        PrettyError4.prototype.start = function() {
          var prepeare;
          this._oldPrepareStackTrace = Error.prepareStackTrace;
          prepeare = this._oldPrepareStackTrace || function(exc, frames) {
            var result;
            result = exc.toString();
            frames = frames.map(function(frame) {
              return "  at " + frame.toString();
            });
            return result + "\n" + frames.join("\n");
          };
          Error.prepareStackTrace = function(_this) {
            return function(exc, trace) {
              var stack;
              stack = prepeare.apply(null, arguments);
              return _this.render({
                stack,
                message: exc.toString().replace(/^.*: /, "")
              }, false);
            };
          }(this);
          return this;
        };
        PrettyError4.prototype.stop = function() {
          Error.prepareStackTrace = this._oldPrepareStackTrace;
          return this._oldPrepareStackTrace = null;
        };
        PrettyError4.prototype.config = function(c) {
          var alias, path4, _ref2;
          if (c.skipPackages != null) {
            if (c.skipPackages === false) {
              this.unskipAllPackages();
            } else {
              this.skipPackage.apply(this, c.skipPackages);
            }
          }
          if (c.skipPaths != null) {
            if (c.skipPaths === false) {
              this.unskipAllPaths();
            } else {
              this.skipPath.apply(this, c.skipPaths);
            }
          }
          if (c.skip != null) {
            if (c.skip === false) {
              this.unskipAll();
            } else {
              this.skip.apply(this, c.skip);
            }
          }
          if (c.maxItems != null) {
            this.setMaxItems(c.maxItems);
          }
          if (c.skipNodeFiles === true) {
            this.skipNodeFiles();
          } else if (c.skipNodeFiles === false) {
            this.unskipNodeFiles();
          }
          if (c.filters != null) {
            if (c.filters === false) {
              this.removeAllFilters();
            } else {
              this.filter.apply(this, c.filters);
            }
          }
          if (c.parsedErrorFilters != null) {
            if (c.parsedErrorFilters === false) {
              this.removeAllParsedErrorFilters();
            } else {
              this.filterParsedError.apply(this, c.parsedErrorFilters);
            }
          }
          if (c.aliases != null) {
            if (isPlainObject(c.aliases)) {
              _ref2 = c.aliases;
              for (path4 in _ref2) {
                alias = _ref2[path4];
                this.alias(path4, alias);
              }
            } else if (c.aliases === false) {
              this.removeAllAliases();
            }
          }
          return this;
        };
        PrettyError4.prototype.withoutColors = function() {
          this._useColors = false;
          return this;
        };
        PrettyError4.prototype.withColors = function() {
          this._useColors = true;
          return this;
        };
        PrettyError4.prototype.skipPackage = function() {
          var packages, pkg2, _i2, _len2;
          packages = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
          for (_i2 = 0, _len2 = packages.length; _i2 < _len2; _i2++) {
            pkg2 = packages[_i2];
            this._packagesToSkip.push(String(pkg2));
          }
          return this;
        };
        PrettyError4.prototype.unskipPackage = function() {
          var packages, pkg2, _i2, _len2;
          packages = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
          for (_i2 = 0, _len2 = packages.length; _i2 < _len2; _i2++) {
            pkg2 = packages[_i2];
            arrayUtils.pluckOneItem(this._packagesToSkip, pkg2);
          }
          return this;
        };
        PrettyError4.prototype.unskipAllPackages = function() {
          this._packagesToSkip.length = 0;
          return this;
        };
        PrettyError4.prototype.skipPath = function() {
          var path4, paths, _i2, _len2;
          paths = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
          for (_i2 = 0, _len2 = paths.length; _i2 < _len2; _i2++) {
            path4 = paths[_i2];
            this._pathsToSkip.push(path4);
          }
          return this;
        };
        PrettyError4.prototype.unskipPath = function() {
          var path4, paths, _i2, _len2;
          paths = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
          for (_i2 = 0, _len2 = paths.length; _i2 < _len2; _i2++) {
            path4 = paths[_i2];
            arrayUtils.pluckOneItem(this._pathsToSkip, path4);
          }
          return this;
        };
        PrettyError4.prototype.unskipAllPaths = function() {
          this._pathsToSkip.length = 0;
          return this;
        };
        PrettyError4.prototype.skip = function() {
          var callbacks, cb, _i2, _len2;
          callbacks = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
          for (_i2 = 0, _len2 = callbacks.length; _i2 < _len2; _i2++) {
            cb = callbacks[_i2];
            this._skipCallbacks.push(cb);
          }
          return this;
        };
        PrettyError4.prototype.unskip = function() {
          var callbacks, cb, _i2, _len2;
          callbacks = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
          for (_i2 = 0, _len2 = callbacks.length; _i2 < _len2; _i2++) {
            cb = callbacks[_i2];
            arrayUtils.pluckOneItem(this._skipCallbacks, cb);
          }
          return this;
        };
        PrettyError4.prototype.unskipAll = function() {
          this._skipCallbacks.length = 0;
          return this;
        };
        PrettyError4.prototype.skipNodeFiles = function() {
          return this.skipPath.apply(this, nodePaths);
        };
        PrettyError4.prototype.unskipNodeFiles = function() {
          return this.unskipPath.apply(this, nodePaths);
        };
        PrettyError4.prototype.filter = function() {
          var callbacks, cb, _i2, _len2;
          callbacks = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
          for (_i2 = 0, _len2 = callbacks.length; _i2 < _len2; _i2++) {
            cb = callbacks[_i2];
            this._filterCallbacks.push(cb);
          }
          return this;
        };
        PrettyError4.prototype.removeFilter = function() {
          var callbacks, cb, _i2, _len2;
          callbacks = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
          for (_i2 = 0, _len2 = callbacks.length; _i2 < _len2; _i2++) {
            cb = callbacks[_i2];
            arrayUtils.pluckOneItem(this._filterCallbacks, cb);
          }
          return this;
        };
        PrettyError4.prototype.removeAllFilters = function() {
          this._filterCallbacks.length = 0;
          return this;
        };
        PrettyError4.prototype.filterParsedError = function() {
          var callbacks, cb, _i2, _len2;
          callbacks = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
          for (_i2 = 0, _len2 = callbacks.length; _i2 < _len2; _i2++) {
            cb = callbacks[_i2];
            this._parsedErrorFilters.push(cb);
          }
          return this;
        };
        PrettyError4.prototype.removeParsedErrorFilter = function() {
          var callbacks, cb, _i2, _len2;
          callbacks = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
          for (_i2 = 0, _len2 = callbacks.length; _i2 < _len2; _i2++) {
            cb = callbacks[_i2];
            arrayUtils.pluckOneItem(this._parsedErrorFilters, cb);
          }
          return this;
        };
        PrettyError4.prototype.removeAllParsedErrorFilters = function() {
          this._parsedErrorFilters.length = 0;
          return this;
        };
        PrettyError4.prototype.setMaxItems = function(maxItems) {
          if (maxItems == null) {
            maxItems = 50;
          }
          if (maxItems === 0) {
            maxItems = 50;
          }
          this._maxItems = maxItems | 0;
          return this;
        };
        PrettyError4.prototype.alias = function(stringOrRx, alias) {
          this._aliases.push({
            stringOrRx,
            alias
          });
          return this;
        };
        PrettyError4.prototype.removeAlias = function(stringOrRx) {
          arrayUtils.pluckByCallback(this._aliases, function(pair) {
            return pair.stringOrRx === stringOrRx;
          });
          return this;
        };
        PrettyError4.prototype.removeAllAliases = function() {
          this._aliases.length = 0;
          return this;
        };
        PrettyError4.prototype._getStyle = function() {
          return this._style;
        };
        PrettyError4.prototype.appendStyle = function(toAppend) {
          merge(this._style, toAppend);
          this._renderer.style(toAppend);
          return this;
        };
        PrettyError4.prototype._getRenderer = function() {
          return this._renderer;
        };
        PrettyError4.prototype.render = function(e, logIt, useColors) {
          var obj, rendered;
          if (logIt == null) {
            logIt = false;
          }
          if (useColors == null) {
            useColors = this._useColors;
          }
          obj = this.getObject(e);
          rendered = this._renderer.render(obj, useColors);
          if (logIt === true) {
            console.error(rendered);
          }
          return rendered;
        };
        PrettyError4.prototype.getObject = function(e) {
          var count, header, i, item, obj, traceItems, _i2, _len2, _ref2;
          if (!(e instanceof ParsedError)) {
            e = new ParsedError(e);
          }
          this._applyParsedErrorFiltersOn(e);
          header = {
            title: function() {
              var ret;
              ret = {};
              if (e.wrapper !== "") {
                ret.wrapper = "" + e.wrapper;
              }
              ret.kind = e.kind;
              return ret;
            }(),
            colon: ":",
            message: String(e.message).trim()
          };
          traceItems = [];
          count = -1;
          _ref2 = e.trace;
          for (i = _i2 = 0, _len2 = _ref2.length; _i2 < _len2; i = ++_i2) {
            item = _ref2[i];
            if (item == null) {
              continue;
            }
            if (this._skipOrFilter(item, i) === true) {
              continue;
            }
            count++;
            if (count > this._maxItems) {
              break;
            }
            if (typeof item === "string") {
              traceItems.push({
                item: {
                  custom: item
                }
              });
              continue;
            }
            traceItems.push(function() {
              var markupItem;
              markupItem = {
                item: {
                  header: {
                    pointer: function() {
                      if (item.file == null) {
                        return "";
                      }
                      return {
                        file: item.file,
                        colon: ":",
                        line: item.line
                      };
                    }()
                  },
                  footer: function() {
                    var foooter;
                    foooter = {
                      addr: item.shortenedAddr
                    };
                    if (item.extra != null) {
                      foooter.extra = item.extra;
                    }
                    return foooter;
                  }()
                }
              };
              if (typeof item.what === "string" && item.what.trim().length > 0) {
                markupItem.item.header.what = item.what;
              }
              return markupItem;
            }());
          }
          obj = {
            "pretty-error": {
              header
            }
          };
          if (traceItems.length > 0) {
            obj["pretty-error"].trace = traceItems;
          }
          return obj;
        };
        PrettyError4.prototype._skipOrFilter = function(item, itemNumber) {
          var cb, modName, pair, _i2, _j, _k, _l, _len2, _len1, _len22, _len3, _ref2, _ref1, _ref22, _ref3, _ref4, _ref5;
          if (typeof item === "object") {
            if (_ref2 = item.modName, __indexOf.call(this._packagesToSkip, _ref2) >= 0) {
              return true;
            }
            if (_ref1 = item.path, __indexOf.call(this._pathsToSkip, _ref1) >= 0) {
              return true;
            }
            _ref22 = item.packages;
            for (_i2 = 0, _len2 = _ref22.length; _i2 < _len2; _i2++) {
              modName = _ref22[_i2];
              if (__indexOf.call(this._packagesToSkip, modName) >= 0) {
                return true;
              }
            }
            if (typeof item.shortenedAddr === "string") {
              _ref3 = this._aliases;
              for (_j = 0, _len1 = _ref3.length; _j < _len1; _j++) {
                pair = _ref3[_j];
                item.shortenedAddr = item.shortenedAddr.replace(pair.stringOrRx, pair.alias);
              }
            }
          }
          _ref4 = this._skipCallbacks;
          for (_k = 0, _len22 = _ref4.length; _k < _len22; _k++) {
            cb = _ref4[_k];
            if (cb(item, itemNumber) === true) {
              return true;
            }
          }
          _ref5 = this._filterCallbacks;
          for (_l = 0, _len3 = _ref5.length; _l < _len3; _l++) {
            cb = _ref5[_l];
            cb(item, itemNumber);
          }
          return false;
        };
        PrettyError4.prototype._applyParsedErrorFiltersOn = function(error) {
          var cb, _i2, _len2, _ref2;
          _ref2 = this._parsedErrorFilters;
          for (_i2 = 0, _len2 = _ref2.length; _i2 < _len2; _i2++) {
            cb = _ref2[_i2];
            cb(error);
          }
        };
        return PrettyError4;
      }();
      _ref = ["renderer", "style"];
      _fn = function() {
        var methodName;
        methodName = "_get" + prop[0].toUpperCase() + prop.substr(1, prop.length);
        return PrettyError3.prototype.__defineGetter__(prop, function() {
          return this[methodName]();
        });
      };
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        prop = _ref[_i];
        _fn();
      }
    }
  });

  // node_modules/.pnpm/human-signals@2.1.0/node_modules/human-signals/build/src/core.js
  var require_core = __commonJS({
    "node_modules/.pnpm/human-signals@2.1.0/node_modules/human-signals/build/src/core.js"(exports2) {
      "use strict";
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.SIGNALS = void 0;
      var SIGNALS2 = [
        {
          name: "SIGHUP",
          number: 1,
          action: "terminate",
          description: "Terminal closed",
          standard: "posix"
        },
        {
          name: "SIGINT",
          number: 2,
          action: "terminate",
          description: "User interruption with CTRL-C",
          standard: "ansi"
        },
        {
          name: "SIGQUIT",
          number: 3,
          action: "core",
          description: "User interruption with CTRL-\\",
          standard: "posix"
        },
        {
          name: "SIGILL",
          number: 4,
          action: "core",
          description: "Invalid machine instruction",
          standard: "ansi"
        },
        {
          name: "SIGTRAP",
          number: 5,
          action: "core",
          description: "Debugger breakpoint",
          standard: "posix"
        },
        {
          name: "SIGABRT",
          number: 6,
          action: "core",
          description: "Aborted",
          standard: "ansi"
        },
        {
          name: "SIGIOT",
          number: 6,
          action: "core",
          description: "Aborted",
          standard: "bsd"
        },
        {
          name: "SIGBUS",
          number: 7,
          action: "core",
          description: "Bus error due to misaligned, non-existing address or paging error",
          standard: "bsd"
        },
        {
          name: "SIGEMT",
          number: 7,
          action: "terminate",
          description: "Command should be emulated but is not implemented",
          standard: "other"
        },
        {
          name: "SIGFPE",
          number: 8,
          action: "core",
          description: "Floating point arithmetic error",
          standard: "ansi"
        },
        {
          name: "SIGKILL",
          number: 9,
          action: "terminate",
          description: "Forced termination",
          standard: "posix",
          forced: true
        },
        {
          name: "SIGUSR1",
          number: 10,
          action: "terminate",
          description: "Application-specific signal",
          standard: "posix"
        },
        {
          name: "SIGSEGV",
          number: 11,
          action: "core",
          description: "Segmentation fault",
          standard: "ansi"
        },
        {
          name: "SIGUSR2",
          number: 12,
          action: "terminate",
          description: "Application-specific signal",
          standard: "posix"
        },
        {
          name: "SIGPIPE",
          number: 13,
          action: "terminate",
          description: "Broken pipe or socket",
          standard: "posix"
        },
        {
          name: "SIGALRM",
          number: 14,
          action: "terminate",
          description: "Timeout or timer",
          standard: "posix"
        },
        {
          name: "SIGTERM",
          number: 15,
          action: "terminate",
          description: "Termination",
          standard: "ansi"
        },
        {
          name: "SIGSTKFLT",
          number: 16,
          action: "terminate",
          description: "Stack is empty or overflowed",
          standard: "other"
        },
        {
          name: "SIGCHLD",
          number: 17,
          action: "ignore",
          description: "Child process terminated, paused or unpaused",
          standard: "posix"
        },
        {
          name: "SIGCLD",
          number: 17,
          action: "ignore",
          description: "Child process terminated, paused or unpaused",
          standard: "other"
        },
        {
          name: "SIGCONT",
          number: 18,
          action: "unpause",
          description: "Unpaused",
          standard: "posix",
          forced: true
        },
        {
          name: "SIGSTOP",
          number: 19,
          action: "pause",
          description: "Paused",
          standard: "posix",
          forced: true
        },
        {
          name: "SIGTSTP",
          number: 20,
          action: "pause",
          description: 'Paused using CTRL-Z or "suspend"',
          standard: "posix"
        },
        {
          name: "SIGTTIN",
          number: 21,
          action: "pause",
          description: "Background process cannot read terminal input",
          standard: "posix"
        },
        {
          name: "SIGBREAK",
          number: 21,
          action: "terminate",
          description: "User interruption with CTRL-BREAK",
          standard: "other"
        },
        {
          name: "SIGTTOU",
          number: 22,
          action: "pause",
          description: "Background process cannot write to terminal output",
          standard: "posix"
        },
        {
          name: "SIGURG",
          number: 23,
          action: "ignore",
          description: "Socket received out-of-band data",
          standard: "bsd"
        },
        {
          name: "SIGXCPU",
          number: 24,
          action: "core",
          description: "Process timed out",
          standard: "bsd"
        },
        {
          name: "SIGXFSZ",
          number: 25,
          action: "core",
          description: "File too big",
          standard: "bsd"
        },
        {
          name: "SIGVTALRM",
          number: 26,
          action: "terminate",
          description: "Timeout or timer",
          standard: "bsd"
        },
        {
          name: "SIGPROF",
          number: 27,
          action: "terminate",
          description: "Timeout or timer",
          standard: "bsd"
        },
        {
          name: "SIGWINCH",
          number: 28,
          action: "ignore",
          description: "Terminal window size changed",
          standard: "bsd"
        },
        {
          name: "SIGIO",
          number: 29,
          action: "terminate",
          description: "I/O is available",
          standard: "other"
        },
        {
          name: "SIGPOLL",
          number: 29,
          action: "terminate",
          description: "Watched event",
          standard: "other"
        },
        {
          name: "SIGINFO",
          number: 29,
          action: "ignore",
          description: "Request for process information",
          standard: "other"
        },
        {
          name: "SIGPWR",
          number: 30,
          action: "terminate",
          description: "Device running out of power",
          standard: "systemv"
        },
        {
          name: "SIGSYS",
          number: 31,
          action: "core",
          description: "Invalid system call",
          standard: "other"
        },
        {
          name: "SIGUNUSED",
          number: 31,
          action: "terminate",
          description: "Invalid system call",
          standard: "other"
        }
      ];
      exports2.SIGNALS = SIGNALS2;
    }
  });

  // node_modules/.pnpm/human-signals@2.1.0/node_modules/human-signals/build/src/realtime.js
  var require_realtime = __commonJS({
    "node_modules/.pnpm/human-signals@2.1.0/node_modules/human-signals/build/src/realtime.js"(exports2) {
      "use strict";
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.SIGRTMAX = exports2.getRealtimeSignals = void 0;
      var getRealtimeSignals2 = function() {
        const length = SIGRTMAX2 - SIGRTMIN2 + 1;
        return Array.from({ length }, getRealtimeSignal2);
      };
      exports2.getRealtimeSignals = getRealtimeSignals2;
      var getRealtimeSignal2 = function(value, index) {
        return {
          name: `SIGRT${index + 1}`,
          number: SIGRTMIN2 + index,
          action: "terminate",
          description: "Application-specific signal (realtime)",
          standard: "posix"
        };
      };
      var SIGRTMIN2 = 34;
      var SIGRTMAX2 = 64;
      exports2.SIGRTMAX = SIGRTMAX2;
    }
  });

  // node_modules/.pnpm/human-signals@2.1.0/node_modules/human-signals/build/src/signals.js
  var require_signals = __commonJS({
    "node_modules/.pnpm/human-signals@2.1.0/node_modules/human-signals/build/src/signals.js"(exports2) {
      "use strict";
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.getSignals = void 0;
      var _os = __require("os");
      var _core = require_core();
      var _realtime = require_realtime();
      var getSignals2 = function() {
        const realtimeSignals = (0, _realtime.getRealtimeSignals)();
        const signals = [..._core.SIGNALS, ...realtimeSignals].map(normalizeSignal2);
        return signals;
      };
      exports2.getSignals = getSignals2;
      var normalizeSignal2 = function({
        name,
        number: defaultNumber,
        description,
        action: action2,
        forced = false,
        standard
      }) {
        const {
          signals: { [name]: constantSignal }
        } = _os.constants;
        const supported = constantSignal !== void 0;
        const number = supported ? constantSignal : defaultNumber;
        return { name, number, description, supported, action: action2, forced, standard };
      };
    }
  });

  // node_modules/.pnpm/human-signals@2.1.0/node_modules/human-signals/build/src/main.js
  var require_main2 = __commonJS({
    "node_modules/.pnpm/human-signals@2.1.0/node_modules/human-signals/build/src/main.js"(exports2) {
      "use strict";
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.signalsByNumber = exports2.signalsByName = void 0;
      var _os = __require("os");
      var _signals = require_signals();
      var _realtime = require_realtime();
      var getSignalsByName2 = function() {
        const signals = (0, _signals.getSignals)();
        return signals.reduce(getSignalByName2, {});
      };
      var getSignalByName2 = function(signalByNameMemo, { name, number, description, supported, action: action2, forced, standard }) {
        return {
          ...signalByNameMemo,
          [name]: { name, number, description, supported, action: action2, forced, standard }
        };
      };
      var signalsByName2 = getSignalsByName2();
      exports2.signalsByName = signalsByName2;
      var getSignalsByNumber2 = function() {
        const signals = (0, _signals.getSignals)();
        const length = _realtime.SIGRTMAX + 1;
        const signalsA = Array.from({ length }, (value, number) => getSignalByNumber2(number, signals));
        return Object.assign({}, ...signalsA);
      };
      var getSignalByNumber2 = function(number, signals) {
        const signal = findSignalByNumber2(number, signals);
        if (signal === void 0) {
          return {};
        }
        const { name, description, supported, action: action2, forced, standard } = signal;
        return {
          [number]: {
            name,
            number,
            description,
            supported,
            action: action2,
            forced,
            standard
          }
        };
      };
      var findSignalByNumber2 = function(number, signals) {
        const signal = signals.find(({ name }) => _os.constants.signals[name] === number);
        if (signal !== void 0) {
          return signal;
        }
        return signals.find((signalA) => signalA.number === number);
      };
      var signalsByNumber2 = getSignalsByNumber2();
      exports2.signalsByNumber = signalsByNumber2;
    }
  });

  // node_modules/.pnpm/catch-exit@1.2.2/node_modules/catch-exit/dist/index.js
  var require_dist = __commonJS({
    "node_modules/.pnpm/catch-exit@1.2.2/node_modules/catch-exit/dist/index.js"(exports2) {
      "use strict";
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.enableLogging = exports2.setupCatchExit = exports2.registerStringifyError = exports2.catchSignalStrings = exports2.removeExitCallback = exports2.addExitCallback = void 0;
      var async_hooks_1 = __require("async_hooks");
      var fs_1 = __require("fs");
      var human_signals_1 = require_main2();
      function addExitCallback2(callback) {
        setupProcessExitHandling();
        callbacks.push(callback);
        return callback;
      }
      exports2.addExitCallback = addExitCallback2;
      function removeExitCallback(callback) {
        setupProcessExitHandling();
        const index = callbacks.indexOf(callback);
        return index > -1 ? callbacks.splice(index, 1)[0] : void 0;
      }
      exports2.removeExitCallback = removeExitCallback;
      var signals = [
        "SIGHUP",
        // catches ctrl+c event
        "SIGINT",
        // catches "kill pid"
        "SIGTERM",
        "SIGQUIT"
      ];
      exports2.catchSignalStrings = [...signals, "exit", "uncaughtException"];
      function stringifyError(error) {
        if (customStringifyError) {
          return customStringifyError(error);
        }
        if (error instanceof Error) {
          return (error.stack || error.toString()) + "\n";
        } else {
          return String(error);
        }
      }
      function registerStringifyError(errorStringifyFunction) {
        setupProcessExitHandling();
        customStringifyError = errorStringifyFunction;
      }
      exports2.registerStringifyError = registerStringifyError;
      var customStringifyError;
      function setupCatchExit(options) {
        setupProcessExitHandling();
        if (options) {
          const { loggingEnabled: loggingEnabled2, customErrorStringify } = options;
          if (customErrorStringify) {
            registerStringifyError(customErrorStringify);
          }
          if (loggingEnabled2) {
            enableLogging();
          }
        }
      }
      exports2.setupCatchExit = setupCatchExit;
      var loggingEnabled = false;
      function enableLogging(enable = true) {
        setupProcessExitHandling();
        loggingEnabled = enable;
        return enable;
      }
      exports2.enableLogging = enableLogging;
      function log(value) {
        if (loggingEnabled) {
          (0, fs_1.writeSync)(1, value + "\n");
        }
      }
      function logError(value) {
        (0, fs_1.writeSync)(2, value);
      }
      var callbacks = [];
      var ignoredAsyncTypes = ["TTYWRAP", "SIGNALWRAP", "PIPEWRAP"];
      var asyncHook = (0, async_hooks_1.createHook)({
        init(id, type) {
          if (!ignoredAsyncTypes.includes(type)) {
            (0, fs_1.writeSync)(2, `
ERROR: Async operation of type "${type}" was created in "process.exit" callback. This will not run to completion as "process.exit" will not complete async tasks.
`);
          }
        }
      });
      var alreadySetup = false;
      var alreadyExiting = false;
      function setupProcessExitHandling() {
        if (alreadySetup) {
          return;
        }
        function exitHandler(signal, exitCode, inputError) {
          log(`handling signal: ${signal} with code ${exitCode}`);
          if (!alreadyExiting) {
            log("setting alreadyExiting");
            alreadyExiting = true;
            try {
              log(`Firing ${callbacks.length} callbacks`);
              if (signal === "exit") {
                asyncHook.enable();
              }
              callbacks.forEach((callback) => callback(signal, exitCode, inputError));
              asyncHook.disable();
            } catch (callbackError) {
              log("Error in callback");
              exitWithError(callbackError, 7);
            }
            if (inputError instanceof Error) {
              exitWithError(inputError, exitCode);
            } else {
              process.exit(exitCode);
            }
          } else {
            log("Already exiting, not doing anything");
            return;
          }
        }
        function exitWithError(error, code) {
          log(`Exiting with error and code ${code}`);
          logError(stringifyError(error));
          process.exit(code);
        }
        signals.forEach((signal) => process.on(signal, () => {
          var _a2;
          const signalNumber = (_a2 = human_signals_1.signalsByName[signal]) === null || _a2 === void 0 ? void 0 : _a2.number;
          if (signalNumber == void 0) {
            throw new Error(`Failed to find number for signal "${signal}"`);
          }
          exitHandler(signal, 128 + signalNumber);
        }));
        process.on("exit", (code) => {
          log(`exit listener with code ${code}`);
          exitHandler("exit", code);
        });
        process.on("unhandledRejection", (reason) => {
          log("unhandledRejection listener");
          const error = reason instanceof Error ? reason : new Error(reason ? `${reason}` : "");
          error.name = "UnhandledRejection";
          throw error;
        });
        process.on("uncaughtException", (error) => {
          log("uncaughtException listener");
          exitHandler("uncaughtException", 1, error);
        });
        alreadySetup = true;
      }
    }
  });

  // node_modules/.pnpm/@paralleldrive+cuid2@2.2.1/node_modules/@paralleldrive/cuid2/src/index.js
  var require_src2 = __commonJS({
    "node_modules/.pnpm/@paralleldrive+cuid2@2.2.1/node_modules/@paralleldrive/cuid2/src/index.js"(exports2, module2) {
      var { sha3_512: sha3 } = require_sha3();
      var defaultLength = 24;
      var bigLength = 32;
      var createEntropy = (length = 4, random = Math.random) => {
        let entropy = "";
        while (entropy.length < length) {
          entropy = entropy + Math.floor(random() * 36).toString(36);
        }
        return entropy;
      };
      function bufToBigInt(buf) {
        let bits2 = 8n;
        let value = 0n;
        for (const i of buf.values()) {
          const bi = BigInt(i);
          value = (value << bits2) + bi;
        }
        return value;
      }
      var hash = (input = "") => {
        return bufToBigInt(sha3(input)).toString(36).slice(1);
      };
      var alphabet = Array.from(
        { length: 26 },
        (x, i) => String.fromCharCode(i + 97)
      );
      var randomLetter = (random) => alphabet[Math.floor(random() * alphabet.length)];
      var createFingerprint = ({
        globalObj = typeof global !== "undefined" ? global : typeof window !== "undefined" ? window : {},
        random = Math.random
      } = {}) => {
        const globals = Object.keys(globalObj).toString();
        const sourceString = globals.length ? globals + createEntropy(bigLength, random) : createEntropy(bigLength, random);
        return hash(sourceString).substring(0, bigLength);
      };
      var createCounter = (count) => () => {
        return count++;
      };
      var initialCountMax = 476782367;
      var init = ({
        // Fallback if the user does not pass in a CSPRNG. This should be OK
        // because we don't rely solely on the random number generator for entropy.
        // We also use the host fingerprint, current time, and a session counter.
        random = Math.random,
        counter = createCounter(Math.floor(random() * initialCountMax)),
        length = defaultLength,
        fingerprint = createFingerprint({ random })
      } = {}) => {
        return function cuid2() {
          const firstLetter = randomLetter(random);
          const time = Date.now().toString(36);
          const count = counter().toString(36);
          const salt = createEntropy(length, random);
          const hashInput = `${time + salt + count + fingerprint}`;
          return `${firstLetter + hash(hashInput).substring(1, length)}`;
        };
      };
      var createId4 = init();
      var isCuid = (id, { minLength = 2, maxLength = bigLength } = {}) => {
        const length = id.length;
        const regex = /^[0-9a-z]+$/;
        try {
          if (typeof id === "string" && length >= minLength && length <= maxLength && regex.test(id))
            return true;
        } finally {
        }
        return false;
      };
      module2.exports.getConstants = () => ({ defaultLength, bigLength });
      module2.exports.init = init;
      module2.exports.createId = createId4;
      module2.exports.bufToBigInt = bufToBigInt;
      module2.exports.createCounter = createCounter;
      module2.exports.createFingerprint = createFingerprint;
      module2.exports.isCuid = isCuid;
    }
  });

  // node_modules/.pnpm/@paralleldrive+cuid2@2.2.1/node_modules/@paralleldrive/cuid2/index.js
  var require_cuid22 = __commonJS({
    "node_modules/.pnpm/@paralleldrive+cuid2@2.2.1/node_modules/@paralleldrive/cuid2/index.js"(exports2, module2) {
      var { createId: createId4, init, getConstants, isCuid } = require_src2();
      module2.exports.createId = createId4;
      module2.exports.init = init;
      module2.exports.getConstants = getConstants;
      module2.exports.isCuid = isCuid;
    }
  });

  // node_modules/.pnpm/chevrotain@10.5.0/node_modules/chevrotain/lib/src/version.js
  var require_version = __commonJS({
    "node_modules/.pnpm/chevrotain@10.5.0/node_modules/chevrotain/lib/src/version.js"(exports2) {
      "use strict";
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.VERSION = void 0;
      exports2.VERSION = "10.5.0";
    }
  });

  // node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/isEmpty.js
  var require_isEmpty = __commonJS({
    "node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/isEmpty.js"(exports2, module2) {
      var baseKeys = require_baseKeys();
      var getTag = require_getTag();
      var isArguments = require_isArguments();
      var isArray = require_isArray();
      var isArrayLike = require_isArrayLike();
      var isBuffer = require_isBuffer();
      var isPrototype = require_isPrototype();
      var isTypedArray = require_isTypedArray();
      var mapTag = "[object Map]";
      var setTag = "[object Set]";
      var objectProto = Object.prototype;
      var hasOwnProperty = objectProto.hasOwnProperty;
      function isEmpty(value) {
        if (value == null) {
          return true;
        }
        if (isArrayLike(value) && (isArray(value) || typeof value == "string" || typeof value.splice == "function" || isBuffer(value) || isTypedArray(value) || isArguments(value))) {
          return !value.length;
        }
        var tag = getTag(value);
        if (tag == mapTag || tag == setTag) {
          return !value.size;
        }
        if (isPrototype(value)) {
          return !baseKeys(value).length;
        }
        for (var key in value) {
          if (hasOwnProperty.call(value, key)) {
            return false;
          }
        }
        return true;
      }
      module2.exports = isEmpty;
    }
  });

  // node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_arrayMap.js
  var require_arrayMap = __commonJS({
    "node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_arrayMap.js"(exports2, module2) {
      function arrayMap(array, iteratee) {
        var index = -1, length = array == null ? 0 : array.length, result = Array(length);
        while (++index < length) {
          result[index] = iteratee(array[index], index, array);
        }
        return result;
      }
      module2.exports = arrayMap;
    }
  });

  // node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_setCacheAdd.js
  var require_setCacheAdd = __commonJS({
    "node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_setCacheAdd.js"(exports2, module2) {
      var HASH_UNDEFINED = "__lodash_hash_undefined__";
      function setCacheAdd(value) {
        this.__data__.set(value, HASH_UNDEFINED);
        return this;
      }
      module2.exports = setCacheAdd;
    }
  });

  // node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_setCacheHas.js
  var require_setCacheHas = __commonJS({
    "node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_setCacheHas.js"(exports2, module2) {
      function setCacheHas(value) {
        return this.__data__.has(value);
      }
      module2.exports = setCacheHas;
    }
  });

  // node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_SetCache.js
  var require_SetCache = __commonJS({
    "node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_SetCache.js"(exports2, module2) {
      var MapCache = require_MapCache();
      var setCacheAdd = require_setCacheAdd();
      var setCacheHas = require_setCacheHas();
      function SetCache(values) {
        var index = -1, length = values == null ? 0 : values.length;
        this.__data__ = new MapCache();
        while (++index < length) {
          this.add(values[index]);
        }
      }
      SetCache.prototype.add = SetCache.prototype.push = setCacheAdd;
      SetCache.prototype.has = setCacheHas;
      module2.exports = SetCache;
    }
  });

  // node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_arraySome.js
  var require_arraySome = __commonJS({
    "node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_arraySome.js"(exports2, module2) {
      function arraySome(array, predicate) {
        var index = -1, length = array == null ? 0 : array.length;
        while (++index < length) {
          if (predicate(array[index], index, array)) {
            return true;
          }
        }
        return false;
      }
      module2.exports = arraySome;
    }
  });

  // node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_cacheHas.js
  var require_cacheHas = __commonJS({
    "node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_cacheHas.js"(exports2, module2) {
      function cacheHas(cache2, key) {
        return cache2.has(key);
      }
      module2.exports = cacheHas;
    }
  });

  // node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_equalArrays.js
  var require_equalArrays = __commonJS({
    "node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_equalArrays.js"(exports2, module2) {
      var SetCache = require_SetCache();
      var arraySome = require_arraySome();
      var cacheHas = require_cacheHas();
      var COMPARE_PARTIAL_FLAG = 1;
      var COMPARE_UNORDERED_FLAG = 2;
      function equalArrays(array, other, bitmask, customizer, equalFunc, stack) {
        var isPartial = bitmask & COMPARE_PARTIAL_FLAG, arrLength = array.length, othLength = other.length;
        if (arrLength != othLength && !(isPartial && othLength > arrLength)) {
          return false;
        }
        var arrStacked = stack.get(array);
        var othStacked = stack.get(other);
        if (arrStacked && othStacked) {
          return arrStacked == other && othStacked == array;
        }
        var index = -1, result = true, seen = bitmask & COMPARE_UNORDERED_FLAG ? new SetCache() : void 0;
        stack.set(array, other);
        stack.set(other, array);
        while (++index < arrLength) {
          var arrValue = array[index], othValue = other[index];
          if (customizer) {
            var compared = isPartial ? customizer(othValue, arrValue, index, other, array, stack) : customizer(arrValue, othValue, index, array, other, stack);
          }
          if (compared !== void 0) {
            if (compared) {
              continue;
            }
            result = false;
            break;
          }
          if (seen) {
            if (!arraySome(other, function(othValue2, othIndex) {
              if (!cacheHas(seen, othIndex) && (arrValue === othValue2 || equalFunc(arrValue, othValue2, bitmask, customizer, stack))) {
                return seen.push(othIndex);
              }
            })) {
              result = false;
              break;
            }
          } else if (!(arrValue === othValue || equalFunc(arrValue, othValue, bitmask, customizer, stack))) {
            result = false;
            break;
          }
        }
        stack["delete"](array);
        stack["delete"](other);
        return result;
      }
      module2.exports = equalArrays;
    }
  });

  // node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_mapToArray.js
  var require_mapToArray = __commonJS({
    "node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_mapToArray.js"(exports2, module2) {
      function mapToArray(map) {
        var index = -1, result = Array(map.size);
        map.forEach(function(value, key) {
          result[++index] = [key, value];
        });
        return result;
      }
      module2.exports = mapToArray;
    }
  });

  // node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_setToArray.js
  var require_setToArray = __commonJS({
    "node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_setToArray.js"(exports2, module2) {
      function setToArray(set) {
        var index = -1, result = Array(set.size);
        set.forEach(function(value) {
          result[++index] = value;
        });
        return result;
      }
      module2.exports = setToArray;
    }
  });

  // node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_equalByTag.js
  var require_equalByTag = __commonJS({
    "node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_equalByTag.js"(exports2, module2) {
      var Symbol2 = require_Symbol();
      var Uint8Array2 = require_Uint8Array();
      var eq = require_eq();
      var equalArrays = require_equalArrays();
      var mapToArray = require_mapToArray();
      var setToArray = require_setToArray();
      var COMPARE_PARTIAL_FLAG = 1;
      var COMPARE_UNORDERED_FLAG = 2;
      var boolTag = "[object Boolean]";
      var dateTag = "[object Date]";
      var errorTag = "[object Error]";
      var mapTag = "[object Map]";
      var numberTag = "[object Number]";
      var regexpTag = "[object RegExp]";
      var setTag = "[object Set]";
      var stringTag = "[object String]";
      var symbolTag = "[object Symbol]";
      var arrayBufferTag = "[object ArrayBuffer]";
      var dataViewTag = "[object DataView]";
      var symbolProto = Symbol2 ? Symbol2.prototype : void 0;
      var symbolValueOf = symbolProto ? symbolProto.valueOf : void 0;
      function equalByTag(object, other, tag, bitmask, customizer, equalFunc, stack) {
        switch (tag) {
          case dataViewTag:
            if (object.byteLength != other.byteLength || object.byteOffset != other.byteOffset) {
              return false;
            }
            object = object.buffer;
            other = other.buffer;
          case arrayBufferTag:
            if (object.byteLength != other.byteLength || !equalFunc(new Uint8Array2(object), new Uint8Array2(other))) {
              return false;
            }
            return true;
          case boolTag:
          case dateTag:
          case numberTag:
            return eq(+object, +other);
          case errorTag:
            return object.name == other.name && object.message == other.message;
          case regexpTag:
          case stringTag:
            return object == other + "";
          case mapTag:
            var convert = mapToArray;
          case setTag:
            var isPartial = bitmask & COMPARE_PARTIAL_FLAG;
            convert || (convert = setToArray);
            if (object.size != other.size && !isPartial) {
              return false;
            }
            var stacked = stack.get(object);
            if (stacked) {
              return stacked == other;
            }
            bitmask |= COMPARE_UNORDERED_FLAG;
            stack.set(object, other);
            var result = equalArrays(convert(object), convert(other), bitmask, customizer, equalFunc, stack);
            stack["delete"](object);
            return result;
          case symbolTag:
            if (symbolValueOf) {
              return symbolValueOf.call(object) == symbolValueOf.call(other);
            }
        }
        return false;
      }
      module2.exports = equalByTag;
    }
  });

  // node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_equalObjects.js
  var require_equalObjects = __commonJS({
    "node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_equalObjects.js"(exports2, module2) {
      var getAllKeys = require_getAllKeys();
      var COMPARE_PARTIAL_FLAG = 1;
      var objectProto = Object.prototype;
      var hasOwnProperty = objectProto.hasOwnProperty;
      function equalObjects(object, other, bitmask, customizer, equalFunc, stack) {
        var isPartial = bitmask & COMPARE_PARTIAL_FLAG, objProps = getAllKeys(object), objLength = objProps.length, othProps = getAllKeys(other), othLength = othProps.length;
        if (objLength != othLength && !isPartial) {
          return false;
        }
        var index = objLength;
        while (index--) {
          var key = objProps[index];
          if (!(isPartial ? key in other : hasOwnProperty.call(other, key))) {
            return false;
          }
        }
        var objStacked = stack.get(object);
        var othStacked = stack.get(other);
        if (objStacked && othStacked) {
          return objStacked == other && othStacked == object;
        }
        var result = true;
        stack.set(object, other);
        stack.set(other, object);
        var skipCtor = isPartial;
        while (++index < objLength) {
          key = objProps[index];
          var objValue = object[key], othValue = other[key];
          if (customizer) {
            var compared = isPartial ? customizer(othValue, objValue, key, other, object, stack) : customizer(objValue, othValue, key, object, other, stack);
          }
          if (!(compared === void 0 ? objValue === othValue || equalFunc(objValue, othValue, bitmask, customizer, stack) : compared)) {
            result = false;
            break;
          }
          skipCtor || (skipCtor = key == "constructor");
        }
        if (result && !skipCtor) {
          var objCtor = object.constructor, othCtor = other.constructor;
          if (objCtor != othCtor && ("constructor" in object && "constructor" in other) && !(typeof objCtor == "function" && objCtor instanceof objCtor && typeof othCtor == "function" && othCtor instanceof othCtor)) {
            result = false;
          }
        }
        stack["delete"](object);
        stack["delete"](other);
        return result;
      }
      module2.exports = equalObjects;
    }
  });

  // node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_baseIsEqualDeep.js
  var require_baseIsEqualDeep = __commonJS({
    "node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_baseIsEqualDeep.js"(exports2, module2) {
      var Stack = require_Stack();
      var equalArrays = require_equalArrays();
      var equalByTag = require_equalByTag();
      var equalObjects = require_equalObjects();
      var getTag = require_getTag();
      var isArray = require_isArray();
      var isBuffer = require_isBuffer();
      var isTypedArray = require_isTypedArray();
      var COMPARE_PARTIAL_FLAG = 1;
      var argsTag = "[object Arguments]";
      var arrayTag = "[object Array]";
      var objectTag = "[object Object]";
      var objectProto = Object.prototype;
      var hasOwnProperty = objectProto.hasOwnProperty;
      function baseIsEqualDeep(object, other, bitmask, customizer, equalFunc, stack) {
        var objIsArr = isArray(object), othIsArr = isArray(other), objTag = objIsArr ? arrayTag : getTag(object), othTag = othIsArr ? arrayTag : getTag(other);
        objTag = objTag == argsTag ? objectTag : objTag;
        othTag = othTag == argsTag ? objectTag : othTag;
        var objIsObj = objTag == objectTag, othIsObj = othTag == objectTag, isSameTag = objTag == othTag;
        if (isSameTag && isBuffer(object)) {
          if (!isBuffer(other)) {
            return false;
          }
          objIsArr = true;
          objIsObj = false;
        }
        if (isSameTag && !objIsObj) {
          stack || (stack = new Stack());
          return objIsArr || isTypedArray(object) ? equalArrays(object, other, bitmask, customizer, equalFunc, stack) : equalByTag(object, other, objTag, bitmask, customizer, equalFunc, stack);
        }
        if (!(bitmask & COMPARE_PARTIAL_FLAG)) {
          var objIsWrapped = objIsObj && hasOwnProperty.call(object, "__wrapped__"), othIsWrapped = othIsObj && hasOwnProperty.call(other, "__wrapped__");
          if (objIsWrapped || othIsWrapped) {
            var objUnwrapped = objIsWrapped ? object.value() : object, othUnwrapped = othIsWrapped ? other.value() : other;
            stack || (stack = new Stack());
            return equalFunc(objUnwrapped, othUnwrapped, bitmask, customizer, stack);
          }
        }
        if (!isSameTag) {
          return false;
        }
        stack || (stack = new Stack());
        return equalObjects(object, other, bitmask, customizer, equalFunc, stack);
      }
      module2.exports = baseIsEqualDeep;
    }
  });

  // node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_baseIsEqual.js
  var require_baseIsEqual = __commonJS({
    "node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_baseIsEqual.js"(exports2, module2) {
      var baseIsEqualDeep = require_baseIsEqualDeep();
      var isObjectLike = require_isObjectLike();
      function baseIsEqual(value, other, bitmask, customizer, stack) {
        if (value === other) {
          return true;
        }
        if (value == null || other == null || !isObjectLike(value) && !isObjectLike(other)) {
          return value !== value && other !== other;
        }
        return baseIsEqualDeep(value, other, bitmask, customizer, baseIsEqual, stack);
      }
      module2.exports = baseIsEqual;
    }
  });

  // node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_baseIsMatch.js
  var require_baseIsMatch = __commonJS({
    "node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_baseIsMatch.js"(exports2, module2) {
      var Stack = require_Stack();
      var baseIsEqual = require_baseIsEqual();
      var COMPARE_PARTIAL_FLAG = 1;
      var COMPARE_UNORDERED_FLAG = 2;
      function baseIsMatch(object, source, matchData, customizer) {
        var index = matchData.length, length = index, noCustomizer = !customizer;
        if (object == null) {
          return !length;
        }
        object = Object(object);
        while (index--) {
          var data = matchData[index];
          if (noCustomizer && data[2] ? data[1] !== object[data[0]] : !(data[0] in object)) {
            return false;
          }
        }
        while (++index < length) {
          data = matchData[index];
          var key = data[0], objValue = object[key], srcValue = data[1];
          if (noCustomizer && data[2]) {
            if (objValue === void 0 && !(key in object)) {
              return false;
            }
          } else {
            var stack = new Stack();
            if (customizer) {
              var result = customizer(objValue, srcValue, key, object, source, stack);
            }
            if (!(result === void 0 ? baseIsEqual(srcValue, objValue, COMPARE_PARTIAL_FLAG | COMPARE_UNORDERED_FLAG, customizer, stack) : result)) {
              return false;
            }
          }
        }
        return true;
      }
      module2.exports = baseIsMatch;
    }
  });

  // node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_isStrictComparable.js
  var require_isStrictComparable = __commonJS({
    "node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_isStrictComparable.js"(exports2, module2) {
      var isObject = require_isObject();
      function isStrictComparable(value) {
        return value === value && !isObject(value);
      }
      module2.exports = isStrictComparable;
    }
  });

  // node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_getMatchData.js
  var require_getMatchData = __commonJS({
    "node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_getMatchData.js"(exports2, module2) {
      var isStrictComparable = require_isStrictComparable();
      var keys = require_keys();
      function getMatchData(object) {
        var result = keys(object), length = result.length;
        while (length--) {
          var key = result[length], value = object[key];
          result[length] = [key, value, isStrictComparable(value)];
        }
        return result;
      }
      module2.exports = getMatchData;
    }
  });

  // node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_matchesStrictComparable.js
  var require_matchesStrictComparable = __commonJS({
    "node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_matchesStrictComparable.js"(exports2, module2) {
      function matchesStrictComparable(key, srcValue) {
        return function(object) {
          if (object == null) {
            return false;
          }
          return object[key] === srcValue && (srcValue !== void 0 || key in Object(object));
        };
      }
      module2.exports = matchesStrictComparable;
    }
  });

  // node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_baseMatches.js
  var require_baseMatches = __commonJS({
    "node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_baseMatches.js"(exports2, module2) {
      var baseIsMatch = require_baseIsMatch();
      var getMatchData = require_getMatchData();
      var matchesStrictComparable = require_matchesStrictComparable();
      function baseMatches(source) {
        var matchData = getMatchData(source);
        if (matchData.length == 1 && matchData[0][2]) {
          return matchesStrictComparable(matchData[0][0], matchData[0][1]);
        }
        return function(object) {
          return object === source || baseIsMatch(object, source, matchData);
        };
      }
      module2.exports = baseMatches;
    }
  });

  // node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/isSymbol.js
  var require_isSymbol = __commonJS({
    "node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/isSymbol.js"(exports2, module2) {
      var baseGetTag = require_baseGetTag();
      var isObjectLike = require_isObjectLike();
      var symbolTag = "[object Symbol]";
      function isSymbol(value) {
        return typeof value == "symbol" || isObjectLike(value) && baseGetTag(value) == symbolTag;
      }
      module2.exports = isSymbol;
    }
  });

  // node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_isKey.js
  var require_isKey = __commonJS({
    "node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_isKey.js"(exports2, module2) {
      var isArray = require_isArray();
      var isSymbol = require_isSymbol();
      var reIsDeepProp = /\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/;
      var reIsPlainProp = /^\w*$/;
      function isKey(value, object) {
        if (isArray(value)) {
          return false;
        }
        var type = typeof value;
        if (type == "number" || type == "symbol" || type == "boolean" || value == null || isSymbol(value)) {
          return true;
        }
        return reIsPlainProp.test(value) || !reIsDeepProp.test(value) || object != null && value in Object(object);
      }
      module2.exports = isKey;
    }
  });

  // node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/memoize.js
  var require_memoize = __commonJS({
    "node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/memoize.js"(exports2, module2) {
      var MapCache = require_MapCache();
      var FUNC_ERROR_TEXT = "Expected a function";
      function memoize(func, resolver) {
        if (typeof func != "function" || resolver != null && typeof resolver != "function") {
          throw new TypeError(FUNC_ERROR_TEXT);
        }
        var memoized = function() {
          var args2 = arguments, key = resolver ? resolver.apply(this, args2) : args2[0], cache2 = memoized.cache;
          if (cache2.has(key)) {
            return cache2.get(key);
          }
          var result = func.apply(this, args2);
          memoized.cache = cache2.set(key, result) || cache2;
          return result;
        };
        memoized.cache = new (memoize.Cache || MapCache)();
        return memoized;
      }
      memoize.Cache = MapCache;
      module2.exports = memoize;
    }
  });

  // node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_memoizeCapped.js
  var require_memoizeCapped = __commonJS({
    "node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_memoizeCapped.js"(exports2, module2) {
      var memoize = require_memoize();
      var MAX_MEMOIZE_SIZE = 500;
      function memoizeCapped(func) {
        var result = memoize(func, function(key) {
          if (cache2.size === MAX_MEMOIZE_SIZE) {
            cache2.clear();
          }
          return key;
        });
        var cache2 = result.cache;
        return result;
      }
      module2.exports = memoizeCapped;
    }
  });

  // node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_stringToPath.js
  var require_stringToPath = __commonJS({
    "node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_stringToPath.js"(exports2, module2) {
      var memoizeCapped = require_memoizeCapped();
      var rePropName = /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g;
      var reEscapeChar = /\\(\\)?/g;
      var stringToPath = memoizeCapped(function(string) {
        var result = [];
        if (string.charCodeAt(0) === 46) {
          result.push("");
        }
        string.replace(rePropName, function(match, number, quote, subString) {
          result.push(quote ? subString.replace(reEscapeChar, "$1") : number || match);
        });
        return result;
      });
      module2.exports = stringToPath;
    }
  });

  // node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_baseToString.js
  var require_baseToString = __commonJS({
    "node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_baseToString.js"(exports2, module2) {
      var Symbol2 = require_Symbol();
      var arrayMap = require_arrayMap();
      var isArray = require_isArray();
      var isSymbol = require_isSymbol();
      var INFINITY = 1 / 0;
      var symbolProto = Symbol2 ? Symbol2.prototype : void 0;
      var symbolToString = symbolProto ? symbolProto.toString : void 0;
      function baseToString(value) {
        if (typeof value == "string") {
          return value;
        }
        if (isArray(value)) {
          return arrayMap(value, baseToString) + "";
        }
        if (isSymbol(value)) {
          return symbolToString ? symbolToString.call(value) : "";
        }
        var result = value + "";
        return result == "0" && 1 / value == -INFINITY ? "-0" : result;
      }
      module2.exports = baseToString;
    }
  });

  // node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/toString.js
  var require_toString = __commonJS({
    "node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/toString.js"(exports2, module2) {
      var baseToString = require_baseToString();
      function toString(value) {
        return value == null ? "" : baseToString(value);
      }
      module2.exports = toString;
    }
  });

  // node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_castPath.js
  var require_castPath = __commonJS({
    "node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_castPath.js"(exports2, module2) {
      var isArray = require_isArray();
      var isKey = require_isKey();
      var stringToPath = require_stringToPath();
      var toString = require_toString();
      function castPath(value, object) {
        if (isArray(value)) {
          return value;
        }
        return isKey(value, object) ? [value] : stringToPath(toString(value));
      }
      module2.exports = castPath;
    }
  });

  // node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_toKey.js
  var require_toKey = __commonJS({
    "node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_toKey.js"(exports2, module2) {
      var isSymbol = require_isSymbol();
      var INFINITY = 1 / 0;
      function toKey(value) {
        if (typeof value == "string" || isSymbol(value)) {
          return value;
        }
        var result = value + "";
        return result == "0" && 1 / value == -INFINITY ? "-0" : result;
      }
      module2.exports = toKey;
    }
  });

  // node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_baseGet.js
  var require_baseGet = __commonJS({
    "node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_baseGet.js"(exports2, module2) {
      var castPath = require_castPath();
      var toKey = require_toKey();
      function baseGet(object, path4) {
        path4 = castPath(path4, object);
        var index = 0, length = path4.length;
        while (object != null && index < length) {
          object = object[toKey(path4[index++])];
        }
        return index && index == length ? object : void 0;
      }
      module2.exports = baseGet;
    }
  });

  // node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/get.js
  var require_get = __commonJS({
    "node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/get.js"(exports2, module2) {
      var baseGet = require_baseGet();
      function get4(object, path4, defaultValue) {
        var result = object == null ? void 0 : baseGet(object, path4);
        return result === void 0 ? defaultValue : result;
      }
      module2.exports = get4;
    }
  });

  // node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_baseHasIn.js
  var require_baseHasIn = __commonJS({
    "node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_baseHasIn.js"(exports2, module2) {
      function baseHasIn(object, key) {
        return object != null && key in Object(object);
      }
      module2.exports = baseHasIn;
    }
  });

  // node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_hasPath.js
  var require_hasPath = __commonJS({
    "node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_hasPath.js"(exports2, module2) {
      var castPath = require_castPath();
      var isArguments = require_isArguments();
      var isArray = require_isArray();
      var isIndex = require_isIndex();
      var isLength = require_isLength();
      var toKey = require_toKey();
      function hasPath(object, path4, hasFunc) {
        path4 = castPath(path4, object);
        var index = -1, length = path4.length, result = false;
        while (++index < length) {
          var key = toKey(path4[index]);
          if (!(result = object != null && hasFunc(object, key))) {
            break;
          }
          object = object[key];
        }
        if (result || ++index != length) {
          return result;
        }
        length = object == null ? 0 : object.length;
        return !!length && isLength(length) && isIndex(key, length) && (isArray(object) || isArguments(object));
      }
      module2.exports = hasPath;
    }
  });

  // node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/hasIn.js
  var require_hasIn = __commonJS({
    "node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/hasIn.js"(exports2, module2) {
      var baseHasIn = require_baseHasIn();
      var hasPath = require_hasPath();
      function hasIn(object, path4) {
        return object != null && hasPath(object, path4, baseHasIn);
      }
      module2.exports = hasIn;
    }
  });

  // node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_baseMatchesProperty.js
  var require_baseMatchesProperty = __commonJS({
    "node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_baseMatchesProperty.js"(exports2, module2) {
      var baseIsEqual = require_baseIsEqual();
      var get4 = require_get();
      var hasIn = require_hasIn();
      var isKey = require_isKey();
      var isStrictComparable = require_isStrictComparable();
      var matchesStrictComparable = require_matchesStrictComparable();
      var toKey = require_toKey();
      var COMPARE_PARTIAL_FLAG = 1;
      var COMPARE_UNORDERED_FLAG = 2;
      function baseMatchesProperty(path4, srcValue) {
        if (isKey(path4) && isStrictComparable(srcValue)) {
          return matchesStrictComparable(toKey(path4), srcValue);
        }
        return function(object) {
          var objValue = get4(object, path4);
          return objValue === void 0 && objValue === srcValue ? hasIn(object, path4) : baseIsEqual(srcValue, objValue, COMPARE_PARTIAL_FLAG | COMPARE_UNORDERED_FLAG);
        };
      }
      module2.exports = baseMatchesProperty;
    }
  });

  // node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_baseProperty.js
  var require_baseProperty = __commonJS({
    "node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_baseProperty.js"(exports2, module2) {
      function baseProperty(key) {
        return function(object) {
          return object == null ? void 0 : object[key];
        };
      }
      module2.exports = baseProperty;
    }
  });

  // node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_basePropertyDeep.js
  var require_basePropertyDeep = __commonJS({
    "node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_basePropertyDeep.js"(exports2, module2) {
      var baseGet = require_baseGet();
      function basePropertyDeep(path4) {
        return function(object) {
          return baseGet(object, path4);
        };
      }
      module2.exports = basePropertyDeep;
    }
  });

  // node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/property.js
  var require_property = __commonJS({
    "node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/property.js"(exports2, module2) {
      var baseProperty = require_baseProperty();
      var basePropertyDeep = require_basePropertyDeep();
      var isKey = require_isKey();
      var toKey = require_toKey();
      function property(path4) {
        return isKey(path4) ? baseProperty(toKey(path4)) : basePropertyDeep(path4);
      }
      module2.exports = property;
    }
  });

  // node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_baseIteratee.js
  var require_baseIteratee = __commonJS({
    "node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_baseIteratee.js"(exports2, module2) {
      var baseMatches = require_baseMatches();
      var baseMatchesProperty = require_baseMatchesProperty();
      var identity = require_identity();
      var isArray = require_isArray();
      var property = require_property();
      function baseIteratee(value) {
        if (typeof value == "function") {
          return value;
        }
        if (value == null) {
          return identity;
        }
        if (typeof value == "object") {
          return isArray(value) ? baseMatchesProperty(value[0], value[1]) : baseMatches(value);
        }
        return property(value);
      }
      module2.exports = baseIteratee;
    }
  });

  // node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_baseForOwn.js
  var require_baseForOwn = __commonJS({
    "node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_baseForOwn.js"(exports2, module2) {
      var baseFor = require_baseFor();
      var keys = require_keys();
      function baseForOwn(object, iteratee) {
        return object && baseFor(object, iteratee, keys);
      }
      module2.exports = baseForOwn;
    }
  });

  // node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_createBaseEach.js
  var require_createBaseEach = __commonJS({
    "node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_createBaseEach.js"(exports2, module2) {
      var isArrayLike = require_isArrayLike();
      function createBaseEach(eachFunc, fromRight) {
        return function(collection, iteratee) {
          if (collection == null) {
            return collection;
          }
          if (!isArrayLike(collection)) {
            return eachFunc(collection, iteratee);
          }
          var length = collection.length, index = fromRight ? length : -1, iterable = Object(collection);
          while (fromRight ? index-- : ++index < length) {
            if (iteratee(iterable[index], index, iterable) === false) {
              break;
            }
          }
          return collection;
        };
      }
      module2.exports = createBaseEach;
    }
  });

  // node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_baseEach.js
  var require_baseEach = __commonJS({
    "node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_baseEach.js"(exports2, module2) {
      var baseForOwn = require_baseForOwn();
      var createBaseEach = require_createBaseEach();
      var baseEach = createBaseEach(baseForOwn);
      module2.exports = baseEach;
    }
  });

  // node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_baseMap.js
  var require_baseMap = __commonJS({
    "node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_baseMap.js"(exports2, module2) {
      var baseEach = require_baseEach();
      var isArrayLike = require_isArrayLike();
      function baseMap(collection, iteratee) {
        var index = -1, result = isArrayLike(collection) ? Array(collection.length) : [];
        baseEach(collection, function(value, key, collection2) {
          result[++index] = iteratee(value, key, collection2);
        });
        return result;
      }
      module2.exports = baseMap;
    }
  });

  // node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/map.js
  var require_map = __commonJS({
    "node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/map.js"(exports2, module2) {
      var arrayMap = require_arrayMap();
      var baseIteratee = require_baseIteratee();
      var baseMap = require_baseMap();
      var isArray = require_isArray();
      function map(collection, iteratee) {
        var func = isArray(collection) ? arrayMap : baseMap;
        return func(collection, baseIteratee(iteratee, 3));
      }
      module2.exports = map;
    }
  });

  // node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_castFunction.js
  var require_castFunction = __commonJS({
    "node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_castFunction.js"(exports2, module2) {
      var identity = require_identity();
      function castFunction(value) {
        return typeof value == "function" ? value : identity;
      }
      module2.exports = castFunction;
    }
  });

  // node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/forEach.js
  var require_forEach = __commonJS({
    "node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/forEach.js"(exports2, module2) {
      var arrayEach = require_arrayEach();
      var baseEach = require_baseEach();
      var castFunction = require_castFunction();
      var isArray = require_isArray();
      function forEach(collection, iteratee) {
        var func = isArray(collection) ? arrayEach : baseEach;
        return func(collection, castFunction(iteratee));
      }
      module2.exports = forEach;
    }
  });

  // node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_baseValues.js
  var require_baseValues = __commonJS({
    "node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_baseValues.js"(exports2, module2) {
      var arrayMap = require_arrayMap();
      function baseValues(object, props) {
        return arrayMap(props, function(key) {
          return object[key];
        });
      }
      module2.exports = baseValues;
    }
  });

  // node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/values.js
  var require_values = __commonJS({
    "node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/values.js"(exports2, module2) {
      var baseValues = require_baseValues();
      var keys = require_keys();
      function values(object) {
        return object == null ? [] : baseValues(object, keys(object));
      }
      module2.exports = values;
    }
  });

  // node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_baseHas.js
  var require_baseHas = __commonJS({
    "node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_baseHas.js"(exports2, module2) {
      var objectProto = Object.prototype;
      var hasOwnProperty = objectProto.hasOwnProperty;
      function baseHas(object, key) {
        return object != null && hasOwnProperty.call(object, key);
      }
      module2.exports = baseHas;
    }
  });

  // node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/has.js
  var require_has = __commonJS({
    "node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/has.js"(exports2, module2) {
      var baseHas = require_baseHas();
      var hasPath = require_hasPath();
      function has(object, path4) {
        return object != null && hasPath(object, path4, baseHas);
      }
      module2.exports = has;
    }
  });

  // node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/clone.js
  var require_clone = __commonJS({
    "node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/clone.js"(exports2, module2) {
      var baseClone = require_baseClone();
      var CLONE_SYMBOLS_FLAG = 4;
      function clone(value) {
        return baseClone(value, CLONE_SYMBOLS_FLAG);
      }
      module2.exports = clone;
    }
  });

  // node_modules/.pnpm/@chevrotain+utils@10.5.0/node_modules/@chevrotain/utils/lib/src/print.js
  var require_print = __commonJS({
    "node_modules/.pnpm/@chevrotain+utils@10.5.0/node_modules/@chevrotain/utils/lib/src/print.js"(exports2) {
      "use strict";
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.PRINT_WARNING = exports2.PRINT_ERROR = void 0;
      function PRINT_ERROR(msg) {
        if (console && console.error) {
          console.error("Error: ".concat(msg));
        }
      }
      exports2.PRINT_ERROR = PRINT_ERROR;
      function PRINT_WARNING(msg) {
        if (console && console.warn) {
          console.warn("Warning: ".concat(msg));
        }
      }
      exports2.PRINT_WARNING = PRINT_WARNING;
    }
  });

  // node_modules/.pnpm/@chevrotain+utils@10.5.0/node_modules/@chevrotain/utils/lib/src/timer.js
  var require_timer = __commonJS({
    "node_modules/.pnpm/@chevrotain+utils@10.5.0/node_modules/@chevrotain/utils/lib/src/timer.js"(exports2) {
      "use strict";
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.timer = void 0;
      function timer(func) {
        var start = (/* @__PURE__ */ new Date()).getTime();
        var val = func();
        var end = (/* @__PURE__ */ new Date()).getTime();
        var total = end - start;
        return { time: total, value: val };
      }
      exports2.timer = timer;
    }
  });

  // node_modules/.pnpm/@chevrotain+utils@10.5.0/node_modules/@chevrotain/utils/lib/src/to-fast-properties.js
  var require_to_fast_properties = __commonJS({
    "node_modules/.pnpm/@chevrotain+utils@10.5.0/node_modules/@chevrotain/utils/lib/src/to-fast-properties.js"(exports, module) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.toFastProperties = void 0;
      function toFastProperties(toBecomeFast) {
        function FakeConstructor() {
        }
        FakeConstructor.prototype = toBecomeFast;
        var fakeInstance = new FakeConstructor();
        function fakeAccess() {
          return typeof fakeInstance.bar;
        }
        fakeAccess();
        fakeAccess();
        if (1)
          return toBecomeFast;
        eval(toBecomeFast);
      }
      exports.toFastProperties = toFastProperties;
    }
  });

  // node_modules/.pnpm/@chevrotain+utils@10.5.0/node_modules/@chevrotain/utils/lib/src/api.js
  var require_api = __commonJS({
    "node_modules/.pnpm/@chevrotain+utils@10.5.0/node_modules/@chevrotain/utils/lib/src/api.js"(exports2) {
      "use strict";
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.toFastProperties = exports2.timer = exports2.PRINT_ERROR = exports2.PRINT_WARNING = void 0;
      var print_1 = require_print();
      Object.defineProperty(exports2, "PRINT_WARNING", { enumerable: true, get: function() {
        return print_1.PRINT_WARNING;
      } });
      Object.defineProperty(exports2, "PRINT_ERROR", { enumerable: true, get: function() {
        return print_1.PRINT_ERROR;
      } });
      var timer_1 = require_timer();
      Object.defineProperty(exports2, "timer", { enumerable: true, get: function() {
        return timer_1.timer;
      } });
      var to_fast_properties_1 = require_to_fast_properties();
      Object.defineProperty(exports2, "toFastProperties", { enumerable: true, get: function() {
        return to_fast_properties_1.toFastProperties;
      } });
    }
  });

  // node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_baseSlice.js
  var require_baseSlice = __commonJS({
    "node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_baseSlice.js"(exports2, module2) {
      function baseSlice(array, start, end) {
        var index = -1, length = array.length;
        if (start < 0) {
          start = -start > length ? 0 : length + start;
        }
        end = end > length ? length : end;
        if (end < 0) {
          end += length;
        }
        length = start > end ? 0 : end - start >>> 0;
        start >>>= 0;
        var result = Array(length);
        while (++index < length) {
          result[index] = array[index + start];
        }
        return result;
      }
      module2.exports = baseSlice;
    }
  });

  // node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_trimmedEndIndex.js
  var require_trimmedEndIndex = __commonJS({
    "node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_trimmedEndIndex.js"(exports2, module2) {
      var reWhitespace = /\s/;
      function trimmedEndIndex(string) {
        var index = string.length;
        while (index-- && reWhitespace.test(string.charAt(index))) {
        }
        return index;
      }
      module2.exports = trimmedEndIndex;
    }
  });

  // node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_baseTrim.js
  var require_baseTrim = __commonJS({
    "node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_baseTrim.js"(exports2, module2) {
      var trimmedEndIndex = require_trimmedEndIndex();
      var reTrimStart = /^\s+/;
      function baseTrim(string) {
        return string ? string.slice(0, trimmedEndIndex(string) + 1).replace(reTrimStart, "") : string;
      }
      module2.exports = baseTrim;
    }
  });

  // node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/toNumber.js
  var require_toNumber = __commonJS({
    "node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/toNumber.js"(exports2, module2) {
      var baseTrim = require_baseTrim();
      var isObject = require_isObject();
      var isSymbol = require_isSymbol();
      var NAN = 0 / 0;
      var reIsBadHex = /^[-+]0x[0-9a-f]+$/i;
      var reIsBinary = /^0b[01]+$/i;
      var reIsOctal = /^0o[0-7]+$/i;
      var freeParseInt = parseInt;
      function toNumber(value) {
        if (typeof value == "number") {
          return value;
        }
        if (isSymbol(value)) {
          return NAN;
        }
        if (isObject(value)) {
          var other = typeof value.valueOf == "function" ? value.valueOf() : value;
          value = isObject(other) ? other + "" : other;
        }
        if (typeof value != "string") {
          return value === 0 ? value : +value;
        }
        value = baseTrim(value);
        var isBinary = reIsBinary.test(value);
        return isBinary || reIsOctal.test(value) ? freeParseInt(value.slice(2), isBinary ? 2 : 8) : reIsBadHex.test(value) ? NAN : +value;
      }
      module2.exports = toNumber;
    }
  });

  // node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/toFinite.js
  var require_toFinite = __commonJS({
    "node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/toFinite.js"(exports2, module2) {
      var toNumber = require_toNumber();
      var INFINITY = 1 / 0;
      var MAX_INTEGER = 17976931348623157e292;
      function toFinite(value) {
        if (!value) {
          return value === 0 ? value : 0;
        }
        value = toNumber(value);
        if (value === INFINITY || value === -INFINITY) {
          var sign = value < 0 ? -1 : 1;
          return sign * MAX_INTEGER;
        }
        return value === value ? value : 0;
      }
      module2.exports = toFinite;
    }
  });

  // node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/toInteger.js
  var require_toInteger = __commonJS({
    "node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/toInteger.js"(exports2, module2) {
      var toFinite = require_toFinite();
      function toInteger(value) {
        var result = toFinite(value), remainder = result % 1;
        return result === result ? remainder ? result - remainder : result : 0;
      }
      module2.exports = toInteger;
    }
  });

  // node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/drop.js
  var require_drop = __commonJS({
    "node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/drop.js"(exports2, module2) {
      var baseSlice = require_baseSlice();
      var toInteger = require_toInteger();
      function drop(array, n, guard) {
        var length = array == null ? 0 : array.length;
        if (!length) {
          return [];
        }
        n = guard || n === void 0 ? 1 : toInteger(n);
        return baseSlice(array, n < 0 ? 0 : n, length);
      }
      module2.exports = drop;
    }
  });

  // node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/isString.js
  var require_isString = __commonJS({
    "node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/isString.js"(exports2, module2) {
      var baseGetTag = require_baseGetTag();
      var isArray = require_isArray();
      var isObjectLike = require_isObjectLike();
      var stringTag = "[object String]";
      function isString(value) {
        return typeof value == "string" || !isArray(value) && isObjectLike(value) && baseGetTag(value) == stringTag;
      }
      module2.exports = isString;
    }
  });

  // node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_baseIsRegExp.js
  var require_baseIsRegExp = __commonJS({
    "node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_baseIsRegExp.js"(exports2, module2) {
      var baseGetTag = require_baseGetTag();
      var isObjectLike = require_isObjectLike();
      var regexpTag = "[object RegExp]";
      function baseIsRegExp(value) {
        return isObjectLike(value) && baseGetTag(value) == regexpTag;
      }
      module2.exports = baseIsRegExp;
    }
  });

  // node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/isRegExp.js
  var require_isRegExp = __commonJS({
    "node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/isRegExp.js"(exports2, module2) {
      var baseIsRegExp = require_baseIsRegExp();
      var baseUnary = require_baseUnary();
      var nodeUtil = require_nodeUtil();
      var nodeIsRegExp = nodeUtil && nodeUtil.isRegExp;
      var isRegExp = nodeIsRegExp ? baseUnary(nodeIsRegExp) : baseIsRegExp;
      module2.exports = isRegExp;
    }
  });

  // node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_baseSet.js
  var require_baseSet = __commonJS({
    "node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_baseSet.js"(exports2, module2) {
      var assignValue = require_assignValue();
      var castPath = require_castPath();
      var isIndex = require_isIndex();
      var isObject = require_isObject();
      var toKey = require_toKey();
      function baseSet(object, path4, value, customizer) {
        if (!isObject(object)) {
          return object;
        }
        path4 = castPath(path4, object);
        var index = -1, length = path4.length, lastIndex = length - 1, nested = object;
        while (nested != null && ++index < length) {
          var key = toKey(path4[index]), newValue = value;
          if (key === "__proto__" || key === "constructor" || key === "prototype") {
            return object;
          }
          if (index != lastIndex) {
            var objValue = nested[key];
            newValue = customizer ? customizer(objValue, key, nested) : void 0;
            if (newValue === void 0) {
              newValue = isObject(objValue) ? objValue : isIndex(path4[index + 1]) ? [] : {};
            }
          }
          assignValue(nested, key, newValue);
          nested = nested[key];
        }
        return object;
      }
      module2.exports = baseSet;
    }
  });

  // node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_basePickBy.js
  var require_basePickBy = __commonJS({
    "node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_basePickBy.js"(exports2, module2) {
      var baseGet = require_baseGet();
      var baseSet = require_baseSet();
      var castPath = require_castPath();
      function basePickBy(object, paths, predicate) {
        var index = -1, length = paths.length, result = {};
        while (++index < length) {
          var path4 = paths[index], value = baseGet(object, path4);
          if (predicate(value, path4)) {
            baseSet(result, castPath(path4, object), value);
          }
        }
        return result;
      }
      module2.exports = basePickBy;
    }
  });

  // node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/pickBy.js
  var require_pickBy = __commonJS({
    "node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/pickBy.js"(exports2, module2) {
      var arrayMap = require_arrayMap();
      var baseIteratee = require_baseIteratee();
      var basePickBy = require_basePickBy();
      var getAllKeysIn = require_getAllKeysIn();
      function pickBy(object, predicate) {
        if (object == null) {
          return {};
        }
        var props = arrayMap(getAllKeysIn(object), function(prop) {
          return [prop];
        });
        predicate = baseIteratee(predicate);
        return basePickBy(object, props, function(value, path4) {
          return predicate(value, path4[0]);
        });
      }
      module2.exports = pickBy;
    }
  });

  // node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/assign.js
  var require_assign = __commonJS({
    "node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/assign.js"(exports2, module2) {
      var assignValue = require_assignValue();
      var copyObject = require_copyObject();
      var createAssigner = require_createAssigner();
      var isArrayLike = require_isArrayLike();
      var isPrototype = require_isPrototype();
      var keys = require_keys();
      var objectProto = Object.prototype;
      var hasOwnProperty = objectProto.hasOwnProperty;
      var assign = createAssigner(function(object, source) {
        if (isPrototype(source) || isArrayLike(source)) {
          copyObject(source, keys(source), object);
          return;
        }
        for (var key in source) {
          if (hasOwnProperty.call(source, key)) {
            assignValue(object, key, source[key]);
          }
        }
      });
      module2.exports = assign;
    }
  });

  // node_modules/.pnpm/@chevrotain+gast@10.5.0/node_modules/@chevrotain/gast/lib/src/model.js
  var require_model = __commonJS({
    "node_modules/.pnpm/@chevrotain+gast@10.5.0/node_modules/@chevrotain/gast/lib/src/model.js"(exports2) {
      "use strict";
      var __extends = exports2 && exports2.__extends || function() {
        var extendStatics = function(d, b) {
          extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b3) {
            d2.__proto__ = b3;
          } || function(d2, b3) {
            for (var p in b3)
              if (Object.prototype.hasOwnProperty.call(b3, p))
                d2[p] = b3[p];
          };
          return extendStatics(d, b);
        };
        return function(d, b) {
          if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
          extendStatics(d, b);
          function __() {
            this.constructor = d;
          }
          d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
        };
      }();
      var __importDefault = exports2 && exports2.__importDefault || function(mod) {
        return mod && mod.__esModule ? mod : { "default": mod };
      };
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.serializeProduction = exports2.serializeGrammar = exports2.Terminal = exports2.Alternation = exports2.RepetitionWithSeparator = exports2.Repetition = exports2.RepetitionMandatoryWithSeparator = exports2.RepetitionMandatory = exports2.Option = exports2.Alternative = exports2.Rule = exports2.NonTerminal = exports2.AbstractProduction = void 0;
      var map_1 = __importDefault(require_map());
      var forEach_1 = __importDefault(require_forEach());
      var isString_1 = __importDefault(require_isString());
      var isRegExp_1 = __importDefault(require_isRegExp());
      var pickBy_1 = __importDefault(require_pickBy());
      var assign_1 = __importDefault(require_assign());
      function tokenLabel(tokType) {
        if (hasTokenLabel(tokType)) {
          return tokType.LABEL;
        } else {
          return tokType.name;
        }
      }
      function hasTokenLabel(obj) {
        return (0, isString_1.default)(obj.LABEL) && obj.LABEL !== "";
      }
      var AbstractProduction = (
        /** @class */
        function() {
          function AbstractProduction2(_definition) {
            this._definition = _definition;
          }
          Object.defineProperty(AbstractProduction2.prototype, "definition", {
            get: function() {
              return this._definition;
            },
            set: function(value) {
              this._definition = value;
            },
            enumerable: false,
            configurable: true
          });
          AbstractProduction2.prototype.accept = function(visitor) {
            visitor.visit(this);
            (0, forEach_1.default)(this.definition, function(prod) {
              prod.accept(visitor);
            });
          };
          return AbstractProduction2;
        }()
      );
      exports2.AbstractProduction = AbstractProduction;
      var NonTerminal = (
        /** @class */
        function(_super) {
          __extends(NonTerminal2, _super);
          function NonTerminal2(options) {
            var _this = _super.call(this, []) || this;
            _this.idx = 1;
            (0, assign_1.default)(_this, (0, pickBy_1.default)(options, function(v) {
              return v !== void 0;
            }));
            return _this;
          }
          Object.defineProperty(NonTerminal2.prototype, "definition", {
            get: function() {
              if (this.referencedRule !== void 0) {
                return this.referencedRule.definition;
              }
              return [];
            },
            set: function(definition) {
            },
            enumerable: false,
            configurable: true
          });
          NonTerminal2.prototype.accept = function(visitor) {
            visitor.visit(this);
          };
          return NonTerminal2;
        }(AbstractProduction)
      );
      exports2.NonTerminal = NonTerminal;
      var Rule = (
        /** @class */
        function(_super) {
          __extends(Rule2, _super);
          function Rule2(options) {
            var _this = _super.call(this, options.definition) || this;
            _this.orgText = "";
            (0, assign_1.default)(_this, (0, pickBy_1.default)(options, function(v) {
              return v !== void 0;
            }));
            return _this;
          }
          return Rule2;
        }(AbstractProduction)
      );
      exports2.Rule = Rule;
      var Alternative = (
        /** @class */
        function(_super) {
          __extends(Alternative2, _super);
          function Alternative2(options) {
            var _this = _super.call(this, options.definition) || this;
            _this.ignoreAmbiguities = false;
            (0, assign_1.default)(_this, (0, pickBy_1.default)(options, function(v) {
              return v !== void 0;
            }));
            return _this;
          }
          return Alternative2;
        }(AbstractProduction)
      );
      exports2.Alternative = Alternative;
      var Option = (
        /** @class */
        function(_super) {
          __extends(Option2, _super);
          function Option2(options) {
            var _this = _super.call(this, options.definition) || this;
            _this.idx = 1;
            (0, assign_1.default)(_this, (0, pickBy_1.default)(options, function(v) {
              return v !== void 0;
            }));
            return _this;
          }
          return Option2;
        }(AbstractProduction)
      );
      exports2.Option = Option;
      var RepetitionMandatory = (
        /** @class */
        function(_super) {
          __extends(RepetitionMandatory2, _super);
          function RepetitionMandatory2(options) {
            var _this = _super.call(this, options.definition) || this;
            _this.idx = 1;
            (0, assign_1.default)(_this, (0, pickBy_1.default)(options, function(v) {
              return v !== void 0;
            }));
            return _this;
          }
          return RepetitionMandatory2;
        }(AbstractProduction)
      );
      exports2.RepetitionMandatory = RepetitionMandatory;
      var RepetitionMandatoryWithSeparator = (
        /** @class */
        function(_super) {
          __extends(RepetitionMandatoryWithSeparator2, _super);
          function RepetitionMandatoryWithSeparator2(options) {
            var _this = _super.call(this, options.definition) || this;
            _this.idx = 1;
            (0, assign_1.default)(_this, (0, pickBy_1.default)(options, function(v) {
              return v !== void 0;
            }));
            return _this;
          }
          return RepetitionMandatoryWithSeparator2;
        }(AbstractProduction)
      );
      exports2.RepetitionMandatoryWithSeparator = RepetitionMandatoryWithSeparator;
      var Repetition = (
        /** @class */
        function(_super) {
          __extends(Repetition2, _super);
          function Repetition2(options) {
            var _this = _super.call(this, options.definition) || this;
            _this.idx = 1;
            (0, assign_1.default)(_this, (0, pickBy_1.default)(options, function(v) {
              return v !== void 0;
            }));
            return _this;
          }
          return Repetition2;
        }(AbstractProduction)
      );
      exports2.Repetition = Repetition;
      var RepetitionWithSeparator = (
        /** @class */
        function(_super) {
          __extends(RepetitionWithSeparator2, _super);
          function RepetitionWithSeparator2(options) {
            var _this = _super.call(this, options.definition) || this;
            _this.idx = 1;
            (0, assign_1.default)(_this, (0, pickBy_1.default)(options, function(v) {
              return v !== void 0;
            }));
            return _this;
          }
          return RepetitionWithSeparator2;
        }(AbstractProduction)
      );
      exports2.RepetitionWithSeparator = RepetitionWithSeparator;
      var Alternation = (
        /** @class */
        function(_super) {
          __extends(Alternation2, _super);
          function Alternation2(options) {
            var _this = _super.call(this, options.definition) || this;
            _this.idx = 1;
            _this.ignoreAmbiguities = false;
            _this.hasPredicates = false;
            (0, assign_1.default)(_this, (0, pickBy_1.default)(options, function(v) {
              return v !== void 0;
            }));
            return _this;
          }
          Object.defineProperty(Alternation2.prototype, "definition", {
            get: function() {
              return this._definition;
            },
            set: function(value) {
              this._definition = value;
            },
            enumerable: false,
            configurable: true
          });
          return Alternation2;
        }(AbstractProduction)
      );
      exports2.Alternation = Alternation;
      var Terminal = (
        /** @class */
        function() {
          function Terminal2(options) {
            this.idx = 1;
            (0, assign_1.default)(this, (0, pickBy_1.default)(options, function(v) {
              return v !== void 0;
            }));
          }
          Terminal2.prototype.accept = function(visitor) {
            visitor.visit(this);
          };
          return Terminal2;
        }()
      );
      exports2.Terminal = Terminal;
      function serializeGrammar(topRules) {
        return (0, map_1.default)(topRules, serializeProduction);
      }
      exports2.serializeGrammar = serializeGrammar;
      function serializeProduction(node) {
        function convertDefinition(definition) {
          return (0, map_1.default)(definition, serializeProduction);
        }
        if (node instanceof NonTerminal) {
          var serializedNonTerminal = {
            type: "NonTerminal",
            name: node.nonTerminalName,
            idx: node.idx
          };
          if ((0, isString_1.default)(node.label)) {
            serializedNonTerminal.label = node.label;
          }
          return serializedNonTerminal;
        } else if (node instanceof Alternative) {
          return {
            type: "Alternative",
            definition: convertDefinition(node.definition)
          };
        } else if (node instanceof Option) {
          return {
            type: "Option",
            idx: node.idx,
            definition: convertDefinition(node.definition)
          };
        } else if (node instanceof RepetitionMandatory) {
          return {
            type: "RepetitionMandatory",
            idx: node.idx,
            definition: convertDefinition(node.definition)
          };
        } else if (node instanceof RepetitionMandatoryWithSeparator) {
          return {
            type: "RepetitionMandatoryWithSeparator",
            idx: node.idx,
            separator: serializeProduction(new Terminal({ terminalType: node.separator })),
            definition: convertDefinition(node.definition)
          };
        } else if (node instanceof RepetitionWithSeparator) {
          return {
            type: "RepetitionWithSeparator",
            idx: node.idx,
            separator: serializeProduction(new Terminal({ terminalType: node.separator })),
            definition: convertDefinition(node.definition)
          };
        } else if (node instanceof Repetition) {
          return {
            type: "Repetition",
            idx: node.idx,
            definition: convertDefinition(node.definition)
          };
        } else if (node instanceof Alternation) {
          return {
            type: "Alternation",
            idx: node.idx,
            definition: convertDefinition(node.definition)
          };
        } else if (node instanceof Terminal) {
          var serializedTerminal = {
            type: "Terminal",
            name: node.terminalType.name,
            label: tokenLabel(node.terminalType),
            idx: node.idx
          };
          if ((0, isString_1.default)(node.label)) {
            serializedTerminal.terminalLabel = node.label;
          }
          var pattern = node.terminalType.PATTERN;
          if (node.terminalType.PATTERN) {
            serializedTerminal.pattern = (0, isRegExp_1.default)(pattern) ? pattern.source : pattern;
          }
          return serializedTerminal;
        } else if (node instanceof Rule) {
          return {
            type: "Rule",
            name: node.name,
            orgText: node.orgText,
            definition: convertDefinition(node.definition)
          };
        } else {
          throw Error("non exhaustive match");
        }
      }
      exports2.serializeProduction = serializeProduction;
    }
  });

  // node_modules/.pnpm/@chevrotain+gast@10.5.0/node_modules/@chevrotain/gast/lib/src/visitor.js
  var require_visitor = __commonJS({
    "node_modules/.pnpm/@chevrotain+gast@10.5.0/node_modules/@chevrotain/gast/lib/src/visitor.js"(exports2) {
      "use strict";
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.GAstVisitor = void 0;
      var model_1 = require_model();
      var GAstVisitor = (
        /** @class */
        function() {
          function GAstVisitor2() {
          }
          GAstVisitor2.prototype.visit = function(node) {
            var nodeAny = node;
            switch (nodeAny.constructor) {
              case model_1.NonTerminal:
                return this.visitNonTerminal(nodeAny);
              case model_1.Alternative:
                return this.visitAlternative(nodeAny);
              case model_1.Option:
                return this.visitOption(nodeAny);
              case model_1.RepetitionMandatory:
                return this.visitRepetitionMandatory(nodeAny);
              case model_1.RepetitionMandatoryWithSeparator:
                return this.visitRepetitionMandatoryWithSeparator(nodeAny);
              case model_1.RepetitionWithSeparator:
                return this.visitRepetitionWithSeparator(nodeAny);
              case model_1.Repetition:
                return this.visitRepetition(nodeAny);
              case model_1.Alternation:
                return this.visitAlternation(nodeAny);
              case model_1.Terminal:
                return this.visitTerminal(nodeAny);
              case model_1.Rule:
                return this.visitRule(nodeAny);
              default:
                throw Error("non exhaustive match");
            }
          };
          GAstVisitor2.prototype.visitNonTerminal = function(node) {
          };
          GAstVisitor2.prototype.visitAlternative = function(node) {
          };
          GAstVisitor2.prototype.visitOption = function(node) {
          };
          GAstVisitor2.prototype.visitRepetition = function(node) {
          };
          GAstVisitor2.prototype.visitRepetitionMandatory = function(node) {
          };
          GAstVisitor2.prototype.visitRepetitionMandatoryWithSeparator = function(node) {
          };
          GAstVisitor2.prototype.visitRepetitionWithSeparator = function(node) {
          };
          GAstVisitor2.prototype.visitAlternation = function(node) {
          };
          GAstVisitor2.prototype.visitTerminal = function(node) {
          };
          GAstVisitor2.prototype.visitRule = function(node) {
          };
          return GAstVisitor2;
        }()
      );
      exports2.GAstVisitor = GAstVisitor;
    }
  });

  // node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_baseSome.js
  var require_baseSome = __commonJS({
    "node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_baseSome.js"(exports2, module2) {
      var baseEach = require_baseEach();
      function baseSome(collection, predicate) {
        var result;
        baseEach(collection, function(value, index, collection2) {
          result = predicate(value, index, collection2);
          return !result;
        });
        return !!result;
      }
      module2.exports = baseSome;
    }
  });

  // node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/some.js
  var require_some = __commonJS({
    "node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/some.js"(exports2, module2) {
      var arraySome = require_arraySome();
      var baseIteratee = require_baseIteratee();
      var baseSome = require_baseSome();
      var isArray = require_isArray();
      var isIterateeCall = require_isIterateeCall();
      function some(collection, predicate, guard) {
        var func = isArray(collection) ? arraySome : baseSome;
        if (guard && isIterateeCall(collection, predicate, guard)) {
          predicate = void 0;
        }
        return func(collection, baseIteratee(predicate, 3));
      }
      module2.exports = some;
    }
  });

  // node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_arrayEvery.js
  var require_arrayEvery = __commonJS({
    "node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_arrayEvery.js"(exports2, module2) {
      function arrayEvery(array, predicate) {
        var index = -1, length = array == null ? 0 : array.length;
        while (++index < length) {
          if (!predicate(array[index], index, array)) {
            return false;
          }
        }
        return true;
      }
      module2.exports = arrayEvery;
    }
  });

  // node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_baseEvery.js
  var require_baseEvery = __commonJS({
    "node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_baseEvery.js"(exports2, module2) {
      var baseEach = require_baseEach();
      function baseEvery(collection, predicate) {
        var result = true;
        baseEach(collection, function(value, index, collection2) {
          result = !!predicate(value, index, collection2);
          return result;
        });
        return result;
      }
      module2.exports = baseEvery;
    }
  });

  // node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/every.js
  var require_every = __commonJS({
    "node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/every.js"(exports2, module2) {
      var arrayEvery = require_arrayEvery();
      var baseEvery = require_baseEvery();
      var baseIteratee = require_baseIteratee();
      var isArray = require_isArray();
      var isIterateeCall = require_isIterateeCall();
      function every(collection, predicate, guard) {
        var func = isArray(collection) ? arrayEvery : baseEvery;
        if (guard && isIterateeCall(collection, predicate, guard)) {
          predicate = void 0;
        }
        return func(collection, baseIteratee(predicate, 3));
      }
      module2.exports = every;
    }
  });

  // node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_baseFindIndex.js
  var require_baseFindIndex = __commonJS({
    "node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_baseFindIndex.js"(exports2, module2) {
      function baseFindIndex(array, predicate, fromIndex, fromRight) {
        var length = array.length, index = fromIndex + (fromRight ? 1 : -1);
        while (fromRight ? index-- : ++index < length) {
          if (predicate(array[index], index, array)) {
            return index;
          }
        }
        return -1;
      }
      module2.exports = baseFindIndex;
    }
  });

  // node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_baseIsNaN.js
  var require_baseIsNaN = __commonJS({
    "node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_baseIsNaN.js"(exports2, module2) {
      function baseIsNaN(value) {
        return value !== value;
      }
      module2.exports = baseIsNaN;
    }
  });

  // node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_strictIndexOf.js
  var require_strictIndexOf = __commonJS({
    "node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_strictIndexOf.js"(exports2, module2) {
      function strictIndexOf(array, value, fromIndex) {
        var index = fromIndex - 1, length = array.length;
        while (++index < length) {
          if (array[index] === value) {
            return index;
          }
        }
        return -1;
      }
      module2.exports = strictIndexOf;
    }
  });

  // node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_baseIndexOf.js
  var require_baseIndexOf = __commonJS({
    "node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_baseIndexOf.js"(exports2, module2) {
      var baseFindIndex = require_baseFindIndex();
      var baseIsNaN = require_baseIsNaN();
      var strictIndexOf = require_strictIndexOf();
      function baseIndexOf(array, value, fromIndex) {
        return value === value ? strictIndexOf(array, value, fromIndex) : baseFindIndex(array, baseIsNaN, fromIndex);
      }
      module2.exports = baseIndexOf;
    }
  });

  // node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/includes.js
  var require_includes = __commonJS({
    "node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/includes.js"(exports2, module2) {
      var baseIndexOf = require_baseIndexOf();
      var isArrayLike = require_isArrayLike();
      var isString = require_isString();
      var toInteger = require_toInteger();
      var values = require_values();
      var nativeMax = Math.max;
      function includes(collection, value, fromIndex, guard) {
        collection = isArrayLike(collection) ? collection : values(collection);
        fromIndex = fromIndex && !guard ? toInteger(fromIndex) : 0;
        var length = collection.length;
        if (fromIndex < 0) {
          fromIndex = nativeMax(length + fromIndex, 0);
        }
        return isString(collection) ? fromIndex <= length && collection.indexOf(value, fromIndex) > -1 : !!length && baseIndexOf(collection, value, fromIndex) > -1;
      }
      module2.exports = includes;
    }
  });

  // node_modules/.pnpm/@chevrotain+gast@10.5.0/node_modules/@chevrotain/gast/lib/src/helpers.js
  var require_helpers2 = __commonJS({
    "node_modules/.pnpm/@chevrotain+gast@10.5.0/node_modules/@chevrotain/gast/lib/src/helpers.js"(exports2) {
      "use strict";
      var __importDefault = exports2 && exports2.__importDefault || function(mod) {
        return mod && mod.__esModule ? mod : { "default": mod };
      };
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.getProductionDslName = exports2.isBranchingProd = exports2.isOptionalProd = exports2.isSequenceProd = void 0;
      var some_1 = __importDefault(require_some());
      var every_1 = __importDefault(require_every());
      var includes_1 = __importDefault(require_includes());
      var model_1 = require_model();
      function isSequenceProd(prod) {
        return prod instanceof model_1.Alternative || prod instanceof model_1.Option || prod instanceof model_1.Repetition || prod instanceof model_1.RepetitionMandatory || prod instanceof model_1.RepetitionMandatoryWithSeparator || prod instanceof model_1.RepetitionWithSeparator || prod instanceof model_1.Terminal || prod instanceof model_1.Rule;
      }
      exports2.isSequenceProd = isSequenceProd;
      function isOptionalProd(prod, alreadyVisited) {
        if (alreadyVisited === void 0) {
          alreadyVisited = [];
        }
        var isDirectlyOptional = prod instanceof model_1.Option || prod instanceof model_1.Repetition || prod instanceof model_1.RepetitionWithSeparator;
        if (isDirectlyOptional) {
          return true;
        }
        if (prod instanceof model_1.Alternation) {
          return (0, some_1.default)(prod.definition, function(subProd) {
            return isOptionalProd(subProd, alreadyVisited);
          });
        } else if (prod instanceof model_1.NonTerminal && (0, includes_1.default)(alreadyVisited, prod)) {
          return false;
        } else if (prod instanceof model_1.AbstractProduction) {
          if (prod instanceof model_1.NonTerminal) {
            alreadyVisited.push(prod);
          }
          return (0, every_1.default)(prod.definition, function(subProd) {
            return isOptionalProd(subProd, alreadyVisited);
          });
        } else {
          return false;
        }
      }
      exports2.isOptionalProd = isOptionalProd;
      function isBranchingProd(prod) {
        return prod instanceof model_1.Alternation;
      }
      exports2.isBranchingProd = isBranchingProd;
      function getProductionDslName(prod) {
        if (prod instanceof model_1.NonTerminal) {
          return "SUBRULE";
        } else if (prod instanceof model_1.Option) {
          return "OPTION";
        } else if (prod instanceof model_1.Alternation) {
          return "OR";
        } else if (prod instanceof model_1.RepetitionMandatory) {
          return "AT_LEAST_ONE";
        } else if (prod instanceof model_1.RepetitionMandatoryWithSeparator) {
          return "AT_LEAST_ONE_SEP";
        } else if (prod instanceof model_1.RepetitionWithSeparator) {
          return "MANY_SEP";
        } else if (prod instanceof model_1.Repetition) {
          return "MANY";
        } else if (prod instanceof model_1.Terminal) {
          return "CONSUME";
        } else {
          throw Error("non exhaustive match");
        }
      }
      exports2.getProductionDslName = getProductionDslName;
    }
  });

  // node_modules/.pnpm/@chevrotain+gast@10.5.0/node_modules/@chevrotain/gast/lib/src/api.js
  var require_api2 = __commonJS({
    "node_modules/.pnpm/@chevrotain+gast@10.5.0/node_modules/@chevrotain/gast/lib/src/api.js"(exports2) {
      "use strict";
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.isSequenceProd = exports2.isBranchingProd = exports2.isOptionalProd = exports2.getProductionDslName = exports2.GAstVisitor = exports2.serializeProduction = exports2.serializeGrammar = exports2.Alternative = exports2.Alternation = exports2.RepetitionWithSeparator = exports2.RepetitionMandatoryWithSeparator = exports2.RepetitionMandatory = exports2.Repetition = exports2.Option = exports2.NonTerminal = exports2.Terminal = exports2.Rule = void 0;
      var model_1 = require_model();
      Object.defineProperty(exports2, "Rule", { enumerable: true, get: function() {
        return model_1.Rule;
      } });
      Object.defineProperty(exports2, "Terminal", { enumerable: true, get: function() {
        return model_1.Terminal;
      } });
      Object.defineProperty(exports2, "NonTerminal", { enumerable: true, get: function() {
        return model_1.NonTerminal;
      } });
      Object.defineProperty(exports2, "Option", { enumerable: true, get: function() {
        return model_1.Option;
      } });
      Object.defineProperty(exports2, "Repetition", { enumerable: true, get: function() {
        return model_1.Repetition;
      } });
      Object.defineProperty(exports2, "RepetitionMandatory", { enumerable: true, get: function() {
        return model_1.RepetitionMandatory;
      } });
      Object.defineProperty(exports2, "RepetitionMandatoryWithSeparator", { enumerable: true, get: function() {
        return model_1.RepetitionMandatoryWithSeparator;
      } });
      Object.defineProperty(exports2, "RepetitionWithSeparator", { enumerable: true, get: function() {
        return model_1.RepetitionWithSeparator;
      } });
      Object.defineProperty(exports2, "Alternation", { enumerable: true, get: function() {
        return model_1.Alternation;
      } });
      Object.defineProperty(exports2, "Alternative", { enumerable: true, get: function() {
        return model_1.Alternative;
      } });
      Object.defineProperty(exports2, "serializeGrammar", { enumerable: true, get: function() {
        return model_1.serializeGrammar;
      } });
      Object.defineProperty(exports2, "serializeProduction", { enumerable: true, get: function() {
        return model_1.serializeProduction;
      } });
      var visitor_1 = require_visitor();
      Object.defineProperty(exports2, "GAstVisitor", { enumerable: true, get: function() {
        return visitor_1.GAstVisitor;
      } });
      var helpers_1 = require_helpers2();
      Object.defineProperty(exports2, "getProductionDslName", { enumerable: true, get: function() {
        return helpers_1.getProductionDslName;
      } });
      Object.defineProperty(exports2, "isOptionalProd", { enumerable: true, get: function() {
        return helpers_1.isOptionalProd;
      } });
      Object.defineProperty(exports2, "isBranchingProd", { enumerable: true, get: function() {
        return helpers_1.isBranchingProd;
      } });
      Object.defineProperty(exports2, "isSequenceProd", { enumerable: true, get: function() {
        return helpers_1.isSequenceProd;
      } });
    }
  });

  // node_modules/.pnpm/chevrotain@10.5.0/node_modules/chevrotain/lib/src/parse/grammar/rest.js
  var require_rest = __commonJS({
    "node_modules/.pnpm/chevrotain@10.5.0/node_modules/chevrotain/lib/src/parse/grammar/rest.js"(exports2) {
      "use strict";
      var __importDefault = exports2 && exports2.__importDefault || function(mod) {
        return mod && mod.__esModule ? mod : { "default": mod };
      };
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.RestWalker = void 0;
      var drop_1 = __importDefault(require_drop());
      var forEach_1 = __importDefault(require_forEach());
      var gast_1 = require_api2();
      var RestWalker = (
        /** @class */
        function() {
          function RestWalker2() {
          }
          RestWalker2.prototype.walk = function(prod, prevRest) {
            var _this = this;
            if (prevRest === void 0) {
              prevRest = [];
            }
            (0, forEach_1.default)(prod.definition, function(subProd, index) {
              var currRest = (0, drop_1.default)(prod.definition, index + 1);
              if (subProd instanceof gast_1.NonTerminal) {
                _this.walkProdRef(subProd, currRest, prevRest);
              } else if (subProd instanceof gast_1.Terminal) {
                _this.walkTerminal(subProd, currRest, prevRest);
              } else if (subProd instanceof gast_1.Alternative) {
                _this.walkFlat(subProd, currRest, prevRest);
              } else if (subProd instanceof gast_1.Option) {
                _this.walkOption(subProd, currRest, prevRest);
              } else if (subProd instanceof gast_1.RepetitionMandatory) {
                _this.walkAtLeastOne(subProd, currRest, prevRest);
              } else if (subProd instanceof gast_1.RepetitionMandatoryWithSeparator) {
                _this.walkAtLeastOneSep(subProd, currRest, prevRest);
              } else if (subProd instanceof gast_1.RepetitionWithSeparator) {
                _this.walkManySep(subProd, currRest, prevRest);
              } else if (subProd instanceof gast_1.Repetition) {
                _this.walkMany(subProd, currRest, prevRest);
              } else if (subProd instanceof gast_1.Alternation) {
                _this.walkOr(subProd, currRest, prevRest);
              } else {
                throw Error("non exhaustive match");
              }
            });
          };
          RestWalker2.prototype.walkTerminal = function(terminal, currRest, prevRest) {
          };
          RestWalker2.prototype.walkProdRef = function(refProd, currRest, prevRest) {
          };
          RestWalker2.prototype.walkFlat = function(flatProd, currRest, prevRest) {
            var fullOrRest = currRest.concat(prevRest);
            this.walk(flatProd, fullOrRest);
          };
          RestWalker2.prototype.walkOption = function(optionProd, currRest, prevRest) {
            var fullOrRest = currRest.concat(prevRest);
            this.walk(optionProd, fullOrRest);
          };
          RestWalker2.prototype.walkAtLeastOne = function(atLeastOneProd, currRest, prevRest) {
            var fullAtLeastOneRest = [
              new gast_1.Option({ definition: atLeastOneProd.definition })
            ].concat(currRest, prevRest);
            this.walk(atLeastOneProd, fullAtLeastOneRest);
          };
          RestWalker2.prototype.walkAtLeastOneSep = function(atLeastOneSepProd, currRest, prevRest) {
            var fullAtLeastOneSepRest = restForRepetitionWithSeparator(atLeastOneSepProd, currRest, prevRest);
            this.walk(atLeastOneSepProd, fullAtLeastOneSepRest);
          };
          RestWalker2.prototype.walkMany = function(manyProd, currRest, prevRest) {
            var fullManyRest = [
              new gast_1.Option({ definition: manyProd.definition })
            ].concat(currRest, prevRest);
            this.walk(manyProd, fullManyRest);
          };
          RestWalker2.prototype.walkManySep = function(manySepProd, currRest, prevRest) {
            var fullManySepRest = restForRepetitionWithSeparator(manySepProd, currRest, prevRest);
            this.walk(manySepProd, fullManySepRest);
          };
          RestWalker2.prototype.walkOr = function(orProd, currRest, prevRest) {
            var _this = this;
            var fullOrRest = currRest.concat(prevRest);
            (0, forEach_1.default)(orProd.definition, function(alt) {
              var prodWrapper = new gast_1.Alternative({ definition: [alt] });
              _this.walk(prodWrapper, fullOrRest);
            });
          };
          return RestWalker2;
        }()
      );
      exports2.RestWalker = RestWalker;
      function restForRepetitionWithSeparator(repSepProd, currRest, prevRest) {
        var repSepRest = [
          new gast_1.Option({
            definition: [
              new gast_1.Terminal({ terminalType: repSepProd.separator })
            ].concat(repSepProd.definition)
          })
        ];
        var fullRepSepRest = repSepRest.concat(currRest, prevRest);
        return fullRepSepRest;
      }
    }
  });

  // node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_isFlattenable.js
  var require_isFlattenable = __commonJS({
    "node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_isFlattenable.js"(exports2, module2) {
      var Symbol2 = require_Symbol();
      var isArguments = require_isArguments();
      var isArray = require_isArray();
      var spreadableSymbol = Symbol2 ? Symbol2.isConcatSpreadable : void 0;
      function isFlattenable(value) {
        return isArray(value) || isArguments(value) || !!(spreadableSymbol && value && value[spreadableSymbol]);
      }
      module2.exports = isFlattenable;
    }
  });

  // node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_baseFlatten.js
  var require_baseFlatten = __commonJS({
    "node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_baseFlatten.js"(exports2, module2) {
      var arrayPush = require_arrayPush();
      var isFlattenable = require_isFlattenable();
      function baseFlatten(array, depth, predicate, isStrict, result) {
        var index = -1, length = array.length;
        predicate || (predicate = isFlattenable);
        result || (result = []);
        while (++index < length) {
          var value = array[index];
          if (depth > 0 && predicate(value)) {
            if (depth > 1) {
              baseFlatten(value, depth - 1, predicate, isStrict, result);
            } else {
              arrayPush(result, value);
            }
          } else if (!isStrict) {
            result[result.length] = value;
          }
        }
        return result;
      }
      module2.exports = baseFlatten;
    }
  });

  // node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/flatten.js
  var require_flatten = __commonJS({
    "node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/flatten.js"(exports2, module2) {
      var baseFlatten = require_baseFlatten();
      function flatten(array) {
        var length = array == null ? 0 : array.length;
        return length ? baseFlatten(array, 1) : [];
      }
      module2.exports = flatten;
    }
  });

  // node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_arrayIncludes.js
  var require_arrayIncludes = __commonJS({
    "node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_arrayIncludes.js"(exports2, module2) {
      var baseIndexOf = require_baseIndexOf();
      function arrayIncludes(array, value) {
        var length = array == null ? 0 : array.length;
        return !!length && baseIndexOf(array, value, 0) > -1;
      }
      module2.exports = arrayIncludes;
    }
  });

  // node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_arrayIncludesWith.js
  var require_arrayIncludesWith = __commonJS({
    "node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_arrayIncludesWith.js"(exports2, module2) {
      function arrayIncludesWith(array, value, comparator) {
        var index = -1, length = array == null ? 0 : array.length;
        while (++index < length) {
          if (comparator(value, array[index])) {
            return true;
          }
        }
        return false;
      }
      module2.exports = arrayIncludesWith;
    }
  });

  // node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/noop.js
  var require_noop = __commonJS({
    "node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/noop.js"(exports2, module2) {
      function noop() {
      }
      module2.exports = noop;
    }
  });

  // node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_createSet.js
  var require_createSet = __commonJS({
    "node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_createSet.js"(exports2, module2) {
      var Set2 = require_Set();
      var noop = require_noop();
      var setToArray = require_setToArray();
      var INFINITY = 1 / 0;
      var createSet = !(Set2 && 1 / setToArray(new Set2([, -0]))[1] == INFINITY) ? noop : function(values) {
        return new Set2(values);
      };
      module2.exports = createSet;
    }
  });

  // node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_baseUniq.js
  var require_baseUniq = __commonJS({
    "node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_baseUniq.js"(exports2, module2) {
      var SetCache = require_SetCache();
      var arrayIncludes = require_arrayIncludes();
      var arrayIncludesWith = require_arrayIncludesWith();
      var cacheHas = require_cacheHas();
      var createSet = require_createSet();
      var setToArray = require_setToArray();
      var LARGE_ARRAY_SIZE = 200;
      function baseUniq(array, iteratee, comparator) {
        var index = -1, includes = arrayIncludes, length = array.length, isCommon = true, result = [], seen = result;
        if (comparator) {
          isCommon = false;
          includes = arrayIncludesWith;
        } else if (length >= LARGE_ARRAY_SIZE) {
          var set = iteratee ? null : createSet(array);
          if (set) {
            return setToArray(set);
          }
          isCommon = false;
          includes = cacheHas;
          seen = new SetCache();
        } else {
          seen = iteratee ? [] : result;
        }
        outer:
          while (++index < length) {
            var value = array[index], computed = iteratee ? iteratee(value) : value;
            value = comparator || value !== 0 ? value : 0;
            if (isCommon && computed === computed) {
              var seenIndex = seen.length;
              while (seenIndex--) {
                if (seen[seenIndex] === computed) {
                  continue outer;
                }
              }
              if (iteratee) {
                seen.push(computed);
              }
              result.push(value);
            } else if (!includes(seen, computed, comparator)) {
              if (seen !== result) {
                seen.push(computed);
              }
              result.push(value);
            }
          }
        return result;
      }
      module2.exports = baseUniq;
    }
  });

  // node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/uniq.js
  var require_uniq = __commonJS({
    "node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/uniq.js"(exports2, module2) {
      var baseUniq = require_baseUniq();
      function uniq(array) {
        return array && array.length ? baseUniq(array) : [];
      }
      module2.exports = uniq;
    }
  });

  // node_modules/.pnpm/chevrotain@10.5.0/node_modules/chevrotain/lib/src/parse/grammar/first.js
  var require_first = __commonJS({
    "node_modules/.pnpm/chevrotain@10.5.0/node_modules/chevrotain/lib/src/parse/grammar/first.js"(exports2) {
      "use strict";
      var __importDefault = exports2 && exports2.__importDefault || function(mod) {
        return mod && mod.__esModule ? mod : { "default": mod };
      };
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.firstForTerminal = exports2.firstForBranching = exports2.firstForSequence = exports2.first = void 0;
      var flatten_1 = __importDefault(require_flatten());
      var uniq_1 = __importDefault(require_uniq());
      var map_1 = __importDefault(require_map());
      var gast_1 = require_api2();
      var gast_2 = require_api2();
      function first(prod) {
        if (prod instanceof gast_1.NonTerminal) {
          return first(prod.referencedRule);
        } else if (prod instanceof gast_1.Terminal) {
          return firstForTerminal(prod);
        } else if ((0, gast_2.isSequenceProd)(prod)) {
          return firstForSequence(prod);
        } else if ((0, gast_2.isBranchingProd)(prod)) {
          return firstForBranching(prod);
        } else {
          throw Error("non exhaustive match");
        }
      }
      exports2.first = first;
      function firstForSequence(prod) {
        var firstSet = [];
        var seq = prod.definition;
        var nextSubProdIdx = 0;
        var hasInnerProdsRemaining = seq.length > nextSubProdIdx;
        var currSubProd;
        var isLastInnerProdOptional = true;
        while (hasInnerProdsRemaining && isLastInnerProdOptional) {
          currSubProd = seq[nextSubProdIdx];
          isLastInnerProdOptional = (0, gast_2.isOptionalProd)(currSubProd);
          firstSet = firstSet.concat(first(currSubProd));
          nextSubProdIdx = nextSubProdIdx + 1;
          hasInnerProdsRemaining = seq.length > nextSubProdIdx;
        }
        return (0, uniq_1.default)(firstSet);
      }
      exports2.firstForSequence = firstForSequence;
      function firstForBranching(prod) {
        var allAlternativesFirsts = (0, map_1.default)(prod.definition, function(innerProd) {
          return first(innerProd);
        });
        return (0, uniq_1.default)((0, flatten_1.default)(allAlternativesFirsts));
      }
      exports2.firstForBranching = firstForBranching;
      function firstForTerminal(terminal) {
        return [terminal.terminalType];
      }
      exports2.firstForTerminal = firstForTerminal;
    }
  });

  // node_modules/.pnpm/chevrotain@10.5.0/node_modules/chevrotain/lib/src/parse/constants.js
  var require_constants2 = __commonJS({
    "node_modules/.pnpm/chevrotain@10.5.0/node_modules/chevrotain/lib/src/parse/constants.js"(exports2) {
      "use strict";
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.IN = void 0;
      exports2.IN = "_~IN~_";
    }
  });

  // node_modules/.pnpm/chevrotain@10.5.0/node_modules/chevrotain/lib/src/parse/grammar/follow.js
  var require_follow = __commonJS({
    "node_modules/.pnpm/chevrotain@10.5.0/node_modules/chevrotain/lib/src/parse/grammar/follow.js"(exports2) {
      "use strict";
      var __extends = exports2 && exports2.__extends || function() {
        var extendStatics = function(d, b) {
          extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b3) {
            d2.__proto__ = b3;
          } || function(d2, b3) {
            for (var p in b3)
              if (Object.prototype.hasOwnProperty.call(b3, p))
                d2[p] = b3[p];
          };
          return extendStatics(d, b);
        };
        return function(d, b) {
          if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
          extendStatics(d, b);
          function __() {
            this.constructor = d;
          }
          d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
        };
      }();
      var __importDefault = exports2 && exports2.__importDefault || function(mod) {
        return mod && mod.__esModule ? mod : { "default": mod };
      };
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.buildInProdFollowPrefix = exports2.buildBetweenProdsFollowPrefix = exports2.computeAllProdsFollows = exports2.ResyncFollowsWalker = void 0;
      var rest_1 = require_rest();
      var first_1 = require_first();
      var forEach_1 = __importDefault(require_forEach());
      var assign_1 = __importDefault(require_assign());
      var constants_1 = require_constants2();
      var gast_1 = require_api2();
      var ResyncFollowsWalker = (
        /** @class */
        function(_super) {
          __extends(ResyncFollowsWalker2, _super);
          function ResyncFollowsWalker2(topProd) {
            var _this = _super.call(this) || this;
            _this.topProd = topProd;
            _this.follows = {};
            return _this;
          }
          ResyncFollowsWalker2.prototype.startWalking = function() {
            this.walk(this.topProd);
            return this.follows;
          };
          ResyncFollowsWalker2.prototype.walkTerminal = function(terminal, currRest, prevRest) {
          };
          ResyncFollowsWalker2.prototype.walkProdRef = function(refProd, currRest, prevRest) {
            var followName = buildBetweenProdsFollowPrefix(refProd.referencedRule, refProd.idx) + this.topProd.name;
            var fullRest = currRest.concat(prevRest);
            var restProd = new gast_1.Alternative({ definition: fullRest });
            var t_in_topProd_follows = (0, first_1.first)(restProd);
            this.follows[followName] = t_in_topProd_follows;
          };
          return ResyncFollowsWalker2;
        }(rest_1.RestWalker)
      );
      exports2.ResyncFollowsWalker = ResyncFollowsWalker;
      function computeAllProdsFollows(topProductions) {
        var reSyncFollows = {};
        (0, forEach_1.default)(topProductions, function(topProd) {
          var currRefsFollow = new ResyncFollowsWalker(topProd).startWalking();
          (0, assign_1.default)(reSyncFollows, currRefsFollow);
        });
        return reSyncFollows;
      }
      exports2.computeAllProdsFollows = computeAllProdsFollows;
      function buildBetweenProdsFollowPrefix(inner, occurenceInParent) {
        return inner.name + occurenceInParent + constants_1.IN;
      }
      exports2.buildBetweenProdsFollowPrefix = buildBetweenProdsFollowPrefix;
      function buildInProdFollowPrefix(terminal) {
        var terminalName = terminal.terminalType.name;
        return terminalName + terminal.idx + constants_1.IN;
      }
      exports2.buildInProdFollowPrefix = buildInProdFollowPrefix;
    }
  });

  // node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/isUndefined.js
  var require_isUndefined = __commonJS({
    "node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/isUndefined.js"(exports2, module2) {
      function isUndefined(value) {
        return value === void 0;
      }
      module2.exports = isUndefined;
    }
  });

  // node_modules/.pnpm/regexp-to-ast@0.5.0/node_modules/regexp-to-ast/lib/regexp-to-ast.js
  var require_regexp_to_ast = __commonJS({
    "node_modules/.pnpm/regexp-to-ast@0.5.0/node_modules/regexp-to-ast/lib/regexp-to-ast.js"(exports2, module2) {
      (function(root, factory) {
        if (typeof define === "function" && define.amd) {
          define([], factory);
        } else if (typeof module2 === "object" && module2.exports) {
          module2.exports = factory();
        } else {
          root.regexpToAst = factory();
        }
      })(
        typeof self !== "undefined" ? (
          // istanbul ignore next
          self
        ) : exports2,
        function() {
          function RegExpParser() {
          }
          RegExpParser.prototype.saveState = function() {
            return {
              idx: this.idx,
              input: this.input,
              groupIdx: this.groupIdx
            };
          };
          RegExpParser.prototype.restoreState = function(newState) {
            this.idx = newState.idx;
            this.input = newState.input;
            this.groupIdx = newState.groupIdx;
          };
          RegExpParser.prototype.pattern = function(input) {
            this.idx = 0;
            this.input = input;
            this.groupIdx = 0;
            this.consumeChar("/");
            var value = this.disjunction();
            this.consumeChar("/");
            var flags = {
              type: "Flags",
              loc: { begin: this.idx, end: input.length },
              global: false,
              ignoreCase: false,
              multiLine: false,
              unicode: false,
              sticky: false
            };
            while (this.isRegExpFlag()) {
              switch (this.popChar()) {
                case "g":
                  addFlag(flags, "global");
                  break;
                case "i":
                  addFlag(flags, "ignoreCase");
                  break;
                case "m":
                  addFlag(flags, "multiLine");
                  break;
                case "u":
                  addFlag(flags, "unicode");
                  break;
                case "y":
                  addFlag(flags, "sticky");
                  break;
              }
            }
            if (this.idx !== this.input.length) {
              throw Error(
                "Redundant input: " + this.input.substring(this.idx)
              );
            }
            return {
              type: "Pattern",
              flags,
              value,
              loc: this.loc(0)
            };
          };
          RegExpParser.prototype.disjunction = function() {
            var alts = [];
            var begin = this.idx;
            alts.push(this.alternative());
            while (this.peekChar() === "|") {
              this.consumeChar("|");
              alts.push(this.alternative());
            }
            return { type: "Disjunction", value: alts, loc: this.loc(begin) };
          };
          RegExpParser.prototype.alternative = function() {
            var terms = [];
            var begin = this.idx;
            while (this.isTerm()) {
              terms.push(this.term());
            }
            return { type: "Alternative", value: terms, loc: this.loc(begin) };
          };
          RegExpParser.prototype.term = function() {
            if (this.isAssertion()) {
              return this.assertion();
            } else {
              return this.atom();
            }
          };
          RegExpParser.prototype.assertion = function() {
            var begin = this.idx;
            switch (this.popChar()) {
              case "^":
                return {
                  type: "StartAnchor",
                  loc: this.loc(begin)
                };
              case "$":
                return { type: "EndAnchor", loc: this.loc(begin) };
              case "\\":
                switch (this.popChar()) {
                  case "b":
                    return {
                      type: "WordBoundary",
                      loc: this.loc(begin)
                    };
                  case "B":
                    return {
                      type: "NonWordBoundary",
                      loc: this.loc(begin)
                    };
                }
                throw Error("Invalid Assertion Escape");
              case "(":
                this.consumeChar("?");
                var type;
                switch (this.popChar()) {
                  case "=":
                    type = "Lookahead";
                    break;
                  case "!":
                    type = "NegativeLookahead";
                    break;
                }
                ASSERT_EXISTS(type);
                var disjunction = this.disjunction();
                this.consumeChar(")");
                return {
                  type,
                  value: disjunction,
                  loc: this.loc(begin)
                };
            }
            ASSERT_NEVER_REACH_HERE();
          };
          RegExpParser.prototype.quantifier = function(isBacktracking) {
            var range;
            var begin = this.idx;
            switch (this.popChar()) {
              case "*":
                range = {
                  atLeast: 0,
                  atMost: Infinity
                };
                break;
              case "+":
                range = {
                  atLeast: 1,
                  atMost: Infinity
                };
                break;
              case "?":
                range = {
                  atLeast: 0,
                  atMost: 1
                };
                break;
              case "{":
                var atLeast = this.integerIncludingZero();
                switch (this.popChar()) {
                  case "}":
                    range = {
                      atLeast,
                      atMost: atLeast
                    };
                    break;
                  case ",":
                    var atMost;
                    if (this.isDigit()) {
                      atMost = this.integerIncludingZero();
                      range = {
                        atLeast,
                        atMost
                      };
                    } else {
                      range = {
                        atLeast,
                        atMost: Infinity
                      };
                    }
                    this.consumeChar("}");
                    break;
                }
                if (isBacktracking === true && range === void 0) {
                  return void 0;
                }
                ASSERT_EXISTS(range);
                break;
            }
            if (isBacktracking === true && range === void 0) {
              return void 0;
            }
            ASSERT_EXISTS(range);
            if (this.peekChar(0) === "?") {
              this.consumeChar("?");
              range.greedy = false;
            } else {
              range.greedy = true;
            }
            range.type = "Quantifier";
            range.loc = this.loc(begin);
            return range;
          };
          RegExpParser.prototype.atom = function() {
            var atom;
            var begin = this.idx;
            switch (this.peekChar()) {
              case ".":
                atom = this.dotAll();
                break;
              case "\\":
                atom = this.atomEscape();
                break;
              case "[":
                atom = this.characterClass();
                break;
              case "(":
                atom = this.group();
                break;
            }
            if (atom === void 0 && this.isPatternCharacter()) {
              atom = this.patternCharacter();
            }
            ASSERT_EXISTS(atom);
            atom.loc = this.loc(begin);
            if (this.isQuantifier()) {
              atom.quantifier = this.quantifier();
            }
            return atom;
          };
          RegExpParser.prototype.dotAll = function() {
            this.consumeChar(".");
            return {
              type: "Set",
              complement: true,
              value: [cc("\n"), cc("\r"), cc("\u2028"), cc("\u2029")]
            };
          };
          RegExpParser.prototype.atomEscape = function() {
            this.consumeChar("\\");
            switch (this.peekChar()) {
              case "1":
              case "2":
              case "3":
              case "4":
              case "5":
              case "6":
              case "7":
              case "8":
              case "9":
                return this.decimalEscapeAtom();
              case "d":
              case "D":
              case "s":
              case "S":
              case "w":
              case "W":
                return this.characterClassEscape();
              case "f":
              case "n":
              case "r":
              case "t":
              case "v":
                return this.controlEscapeAtom();
              case "c":
                return this.controlLetterEscapeAtom();
              case "0":
                return this.nulCharacterAtom();
              case "x":
                return this.hexEscapeSequenceAtom();
              case "u":
                return this.regExpUnicodeEscapeSequenceAtom();
              default:
                return this.identityEscapeAtom();
            }
          };
          RegExpParser.prototype.decimalEscapeAtom = function() {
            var value = this.positiveInteger();
            return { type: "GroupBackReference", value };
          };
          RegExpParser.prototype.characterClassEscape = function() {
            var set;
            var complement = false;
            switch (this.popChar()) {
              case "d":
                set = digitsCharCodes;
                break;
              case "D":
                set = digitsCharCodes;
                complement = true;
                break;
              case "s":
                set = whitespaceCodes;
                break;
              case "S":
                set = whitespaceCodes;
                complement = true;
                break;
              case "w":
                set = wordCharCodes;
                break;
              case "W":
                set = wordCharCodes;
                complement = true;
                break;
            }
            ASSERT_EXISTS(set);
            return { type: "Set", value: set, complement };
          };
          RegExpParser.prototype.controlEscapeAtom = function() {
            var escapeCode;
            switch (this.popChar()) {
              case "f":
                escapeCode = cc("\f");
                break;
              case "n":
                escapeCode = cc("\n");
                break;
              case "r":
                escapeCode = cc("\r");
                break;
              case "t":
                escapeCode = cc("	");
                break;
              case "v":
                escapeCode = cc("\v");
                break;
            }
            ASSERT_EXISTS(escapeCode);
            return { type: "Character", value: escapeCode };
          };
          RegExpParser.prototype.controlLetterEscapeAtom = function() {
            this.consumeChar("c");
            var letter = this.popChar();
            if (/[a-zA-Z]/.test(letter) === false) {
              throw Error("Invalid ");
            }
            var letterCode = letter.toUpperCase().charCodeAt(0) - 64;
            return { type: "Character", value: letterCode };
          };
          RegExpParser.prototype.nulCharacterAtom = function() {
            this.consumeChar("0");
            return { type: "Character", value: cc("\0") };
          };
          RegExpParser.prototype.hexEscapeSequenceAtom = function() {
            this.consumeChar("x");
            return this.parseHexDigits(2);
          };
          RegExpParser.prototype.regExpUnicodeEscapeSequenceAtom = function() {
            this.consumeChar("u");
            return this.parseHexDigits(4);
          };
          RegExpParser.prototype.identityEscapeAtom = function() {
            var escapedChar = this.popChar();
            return { type: "Character", value: cc(escapedChar) };
          };
          RegExpParser.prototype.classPatternCharacterAtom = function() {
            switch (this.peekChar()) {
              case "\n":
              case "\r":
              case "\u2028":
              case "\u2029":
              case "\\":
              case "]":
                throw Error("TBD");
              default:
                var nextChar = this.popChar();
                return { type: "Character", value: cc(nextChar) };
            }
          };
          RegExpParser.prototype.characterClass = function() {
            var set = [];
            var complement = false;
            this.consumeChar("[");
            if (this.peekChar(0) === "^") {
              this.consumeChar("^");
              complement = true;
            }
            while (this.isClassAtom()) {
              var from = this.classAtom();
              var isFromSingleChar = from.type === "Character";
              if (isFromSingleChar && this.isRangeDash()) {
                this.consumeChar("-");
                var to = this.classAtom();
                var isToSingleChar = to.type === "Character";
                if (isToSingleChar) {
                  if (to.value < from.value) {
                    throw Error("Range out of order in character class");
                  }
                  set.push({ from: from.value, to: to.value });
                } else {
                  insertToSet(from.value, set);
                  set.push(cc("-"));
                  insertToSet(to.value, set);
                }
              } else {
                insertToSet(from.value, set);
              }
            }
            this.consumeChar("]");
            return { type: "Set", complement, value: set };
          };
          RegExpParser.prototype.classAtom = function() {
            switch (this.peekChar()) {
              case "]":
              case "\n":
              case "\r":
              case "\u2028":
              case "\u2029":
                throw Error("TBD");
              case "\\":
                return this.classEscape();
              default:
                return this.classPatternCharacterAtom();
            }
          };
          RegExpParser.prototype.classEscape = function() {
            this.consumeChar("\\");
            switch (this.peekChar()) {
              case "b":
                this.consumeChar("b");
                return { type: "Character", value: cc("\b") };
              case "d":
              case "D":
              case "s":
              case "S":
              case "w":
              case "W":
                return this.characterClassEscape();
              case "f":
              case "n":
              case "r":
              case "t":
              case "v":
                return this.controlEscapeAtom();
              case "c":
                return this.controlLetterEscapeAtom();
              case "0":
                return this.nulCharacterAtom();
              case "x":
                return this.hexEscapeSequenceAtom();
              case "u":
                return this.regExpUnicodeEscapeSequenceAtom();
              default:
                return this.identityEscapeAtom();
            }
          };
          RegExpParser.prototype.group = function() {
            var capturing = true;
            this.consumeChar("(");
            switch (this.peekChar(0)) {
              case "?":
                this.consumeChar("?");
                this.consumeChar(":");
                capturing = false;
                break;
              default:
                this.groupIdx++;
                break;
            }
            var value = this.disjunction();
            this.consumeChar(")");
            var groupAst = {
              type: "Group",
              capturing,
              value
            };
            if (capturing) {
              groupAst.idx = this.groupIdx;
            }
            return groupAst;
          };
          RegExpParser.prototype.positiveInteger = function() {
            var number = this.popChar();
            if (decimalPatternNoZero.test(number) === false) {
              throw Error("Expecting a positive integer");
            }
            while (decimalPattern.test(this.peekChar(0))) {
              number += this.popChar();
            }
            return parseInt(number, 10);
          };
          RegExpParser.prototype.integerIncludingZero = function() {
            var number = this.popChar();
            if (decimalPattern.test(number) === false) {
              throw Error("Expecting an integer");
            }
            while (decimalPattern.test(this.peekChar(0))) {
              number += this.popChar();
            }
            return parseInt(number, 10);
          };
          RegExpParser.prototype.patternCharacter = function() {
            var nextChar = this.popChar();
            switch (nextChar) {
              case "\n":
              case "\r":
              case "\u2028":
              case "\u2029":
              case "^":
              case "$":
              case "\\":
              case ".":
              case "*":
              case "+":
              case "?":
              case "(":
              case ")":
              case "[":
              case "|":
                throw Error("TBD");
              default:
                return { type: "Character", value: cc(nextChar) };
            }
          };
          RegExpParser.prototype.isRegExpFlag = function() {
            switch (this.peekChar(0)) {
              case "g":
              case "i":
              case "m":
              case "u":
              case "y":
                return true;
              default:
                return false;
            }
          };
          RegExpParser.prototype.isRangeDash = function() {
            return this.peekChar() === "-" && this.isClassAtom(1);
          };
          RegExpParser.prototype.isDigit = function() {
            return decimalPattern.test(this.peekChar(0));
          };
          RegExpParser.prototype.isClassAtom = function(howMuch) {
            if (howMuch === void 0) {
              howMuch = 0;
            }
            switch (this.peekChar(howMuch)) {
              case "]":
              case "\n":
              case "\r":
              case "\u2028":
              case "\u2029":
                return false;
              default:
                return true;
            }
          };
          RegExpParser.prototype.isTerm = function() {
            return this.isAtom() || this.isAssertion();
          };
          RegExpParser.prototype.isAtom = function() {
            if (this.isPatternCharacter()) {
              return true;
            }
            switch (this.peekChar(0)) {
              case ".":
              case "\\":
              case "[":
              case "(":
                return true;
              default:
                return false;
            }
          };
          RegExpParser.prototype.isAssertion = function() {
            switch (this.peekChar(0)) {
              case "^":
              case "$":
                return true;
              case "\\":
                switch (this.peekChar(1)) {
                  case "b":
                  case "B":
                    return true;
                  default:
                    return false;
                }
              case "(":
                return this.peekChar(1) === "?" && (this.peekChar(2) === "=" || this.peekChar(2) === "!");
              default:
                return false;
            }
          };
          RegExpParser.prototype.isQuantifier = function() {
            var prevState = this.saveState();
            try {
              return this.quantifier(true) !== void 0;
            } catch (e) {
              return false;
            } finally {
              this.restoreState(prevState);
            }
          };
          RegExpParser.prototype.isPatternCharacter = function() {
            switch (this.peekChar()) {
              case "^":
              case "$":
              case "\\":
              case ".":
              case "*":
              case "+":
              case "?":
              case "(":
              case ")":
              case "[":
              case "|":
              case "/":
              case "\n":
              case "\r":
              case "\u2028":
              case "\u2029":
                return false;
              default:
                return true;
            }
          };
          RegExpParser.prototype.parseHexDigits = function(howMany) {
            var hexString = "";
            for (var i2 = 0; i2 < howMany; i2++) {
              var hexChar = this.popChar();
              if (hexDigitPattern.test(hexChar) === false) {
                throw Error("Expecting a HexDecimal digits");
              }
              hexString += hexChar;
            }
            var charCode = parseInt(hexString, 16);
            return { type: "Character", value: charCode };
          };
          RegExpParser.prototype.peekChar = function(howMuch) {
            if (howMuch === void 0) {
              howMuch = 0;
            }
            return this.input[this.idx + howMuch];
          };
          RegExpParser.prototype.popChar = function() {
            var nextChar = this.peekChar(0);
            this.consumeChar();
            return nextChar;
          };
          RegExpParser.prototype.consumeChar = function(char) {
            if (char !== void 0 && this.input[this.idx] !== char) {
              throw Error(
                "Expected: '" + char + "' but found: '" + this.input[this.idx] + "' at offset: " + this.idx
              );
            }
            if (this.idx >= this.input.length) {
              throw Error("Unexpected end of input");
            }
            this.idx++;
          };
          RegExpParser.prototype.loc = function(begin) {
            return { begin, end: this.idx };
          };
          var hexDigitPattern = /[0-9a-fA-F]/;
          var decimalPattern = /[0-9]/;
          var decimalPatternNoZero = /[1-9]/;
          function cc(char) {
            return char.charCodeAt(0);
          }
          function insertToSet(item, set) {
            if (item.length !== void 0) {
              item.forEach(function(subItem) {
                set.push(subItem);
              });
            } else {
              set.push(item);
            }
          }
          function addFlag(flagObj, flagKey) {
            if (flagObj[flagKey] === true) {
              throw "duplicate flag " + flagKey;
            }
            flagObj[flagKey] = true;
          }
          function ASSERT_EXISTS(obj) {
            if (obj === void 0) {
              throw Error("Internal Error - Should never get here!");
            }
          }
          function ASSERT_NEVER_REACH_HERE() {
            throw Error("Internal Error - Should never get here!");
          }
          var i;
          var digitsCharCodes = [];
          for (i = cc("0"); i <= cc("9"); i++) {
            digitsCharCodes.push(i);
          }
          var wordCharCodes = [cc("_")].concat(digitsCharCodes);
          for (i = cc("a"); i <= cc("z"); i++) {
            wordCharCodes.push(i);
          }
          for (i = cc("A"); i <= cc("Z"); i++) {
            wordCharCodes.push(i);
          }
          var whitespaceCodes = [
            cc(" "),
            cc("\f"),
            cc("\n"),
            cc("\r"),
            cc("	"),
            cc("\v"),
            cc("	"),
            cc("\xA0"),
            cc("\u1680"),
            cc("\u2000"),
            cc("\u2001"),
            cc("\u2002"),
            cc("\u2003"),
            cc("\u2004"),
            cc("\u2005"),
            cc("\u2006"),
            cc("\u2007"),
            cc("\u2008"),
            cc("\u2009"),
            cc("\u200A"),
            cc("\u2028"),
            cc("\u2029"),
            cc("\u202F"),
            cc("\u205F"),
            cc("\u3000"),
            cc("\uFEFF")
          ];
          function BaseRegExpVisitor() {
          }
          BaseRegExpVisitor.prototype.visitChildren = function(node) {
            for (var key in node) {
              var child = node[key];
              if (node.hasOwnProperty(key)) {
                if (child.type !== void 0) {
                  this.visit(child);
                } else if (Array.isArray(child)) {
                  child.forEach(function(subChild) {
                    this.visit(subChild);
                  }, this);
                }
              }
            }
          };
          BaseRegExpVisitor.prototype.visit = function(node) {
            switch (node.type) {
              case "Pattern":
                this.visitPattern(node);
                break;
              case "Flags":
                this.visitFlags(node);
                break;
              case "Disjunction":
                this.visitDisjunction(node);
                break;
              case "Alternative":
                this.visitAlternative(node);
                break;
              case "StartAnchor":
                this.visitStartAnchor(node);
                break;
              case "EndAnchor":
                this.visitEndAnchor(node);
                break;
              case "WordBoundary":
                this.visitWordBoundary(node);
                break;
              case "NonWordBoundary":
                this.visitNonWordBoundary(node);
                break;
              case "Lookahead":
                this.visitLookahead(node);
                break;
              case "NegativeLookahead":
                this.visitNegativeLookahead(node);
                break;
              case "Character":
                this.visitCharacter(node);
                break;
              case "Set":
                this.visitSet(node);
                break;
              case "Group":
                this.visitGroup(node);
                break;
              case "GroupBackReference":
                this.visitGroupBackReference(node);
                break;
              case "Quantifier":
                this.visitQuantifier(node);
                break;
            }
            this.visitChildren(node);
          };
          BaseRegExpVisitor.prototype.visitPattern = function(node) {
          };
          BaseRegExpVisitor.prototype.visitFlags = function(node) {
          };
          BaseRegExpVisitor.prototype.visitDisjunction = function(node) {
          };
          BaseRegExpVisitor.prototype.visitAlternative = function(node) {
          };
          BaseRegExpVisitor.prototype.visitStartAnchor = function(node) {
          };
          BaseRegExpVisitor.prototype.visitEndAnchor = function(node) {
          };
          BaseRegExpVisitor.prototype.visitWordBoundary = function(node) {
          };
          BaseRegExpVisitor.prototype.visitNonWordBoundary = function(node) {
          };
          BaseRegExpVisitor.prototype.visitLookahead = function(node) {
          };
          BaseRegExpVisitor.prototype.visitNegativeLookahead = function(node) {
          };
          BaseRegExpVisitor.prototype.visitCharacter = function(node) {
          };
          BaseRegExpVisitor.prototype.visitSet = function(node) {
          };
          BaseRegExpVisitor.prototype.visitGroup = function(node) {
          };
          BaseRegExpVisitor.prototype.visitGroupBackReference = function(node) {
          };
          BaseRegExpVisitor.prototype.visitQuantifier = function(node) {
          };
          return {
            RegExpParser,
            BaseRegExpVisitor,
            VERSION: "0.5.0"
          };
        }
      );
    }
  });

  // node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/head.js
  var require_head = __commonJS({
    "node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/head.js"(exports2, module2) {
      function head(array) {
        return array && array.length ? array[0] : void 0;
      }
      module2.exports = head;
    }
  });

  // node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/first.js
  var require_first2 = __commonJS({
    "node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/first.js"(exports2, module2) {
      module2.exports = require_head();
    }
  });

  // node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/compact.js
  var require_compact = __commonJS({
    "node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/compact.js"(exports2, module2) {
      function compact(array) {
        var index = -1, length = array == null ? 0 : array.length, resIndex = 0, result = [];
        while (++index < length) {
          var value = array[index];
          if (value) {
            result[resIndex++] = value;
          }
        }
        return result;
      }
      module2.exports = compact;
    }
  });

  // node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_baseFilter.js
  var require_baseFilter = __commonJS({
    "node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_baseFilter.js"(exports2, module2) {
      var baseEach = require_baseEach();
      function baseFilter(collection, predicate) {
        var result = [];
        baseEach(collection, function(value, index, collection2) {
          if (predicate(value, index, collection2)) {
            result.push(value);
          }
        });
        return result;
      }
      module2.exports = baseFilter;
    }
  });

  // node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/negate.js
  var require_negate = __commonJS({
    "node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/negate.js"(exports2, module2) {
      var FUNC_ERROR_TEXT = "Expected a function";
      function negate(predicate) {
        if (typeof predicate != "function") {
          throw new TypeError(FUNC_ERROR_TEXT);
        }
        return function() {
          var args2 = arguments;
          switch (args2.length) {
            case 0:
              return !predicate.call(this);
            case 1:
              return !predicate.call(this, args2[0]);
            case 2:
              return !predicate.call(this, args2[0], args2[1]);
            case 3:
              return !predicate.call(this, args2[0], args2[1], args2[2]);
          }
          return !predicate.apply(this, args2);
        };
      }
      module2.exports = negate;
    }
  });

  // node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/reject.js
  var require_reject = __commonJS({
    "node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/reject.js"(exports2, module2) {
      var arrayFilter = require_arrayFilter();
      var baseFilter = require_baseFilter();
      var baseIteratee = require_baseIteratee();
      var isArray = require_isArray();
      var negate = require_negate();
      function reject(collection, predicate) {
        var func = isArray(collection) ? arrayFilter : baseFilter;
        return func(collection, negate(baseIteratee(predicate, 3)));
      }
      module2.exports = reject;
    }
  });

  // node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_baseDifference.js
  var require_baseDifference = __commonJS({
    "node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_baseDifference.js"(exports2, module2) {
      var SetCache = require_SetCache();
      var arrayIncludes = require_arrayIncludes();
      var arrayIncludesWith = require_arrayIncludesWith();
      var arrayMap = require_arrayMap();
      var baseUnary = require_baseUnary();
      var cacheHas = require_cacheHas();
      var LARGE_ARRAY_SIZE = 200;
      function baseDifference(array, values, iteratee, comparator) {
        var index = -1, includes = arrayIncludes, isCommon = true, length = array.length, result = [], valuesLength = values.length;
        if (!length) {
          return result;
        }
        if (iteratee) {
          values = arrayMap(values, baseUnary(iteratee));
        }
        if (comparator) {
          includes = arrayIncludesWith;
          isCommon = false;
        } else if (values.length >= LARGE_ARRAY_SIZE) {
          includes = cacheHas;
          isCommon = false;
          values = new SetCache(values);
        }
        outer:
          while (++index < length) {
            var value = array[index], computed = iteratee == null ? value : iteratee(value);
            value = comparator || value !== 0 ? value : 0;
            if (isCommon && computed === computed) {
              var valuesIndex = valuesLength;
              while (valuesIndex--) {
                if (values[valuesIndex] === computed) {
                  continue outer;
                }
              }
              result.push(value);
            } else if (!includes(values, computed, comparator)) {
              result.push(value);
            }
          }
        return result;
      }
      module2.exports = baseDifference;
    }
  });

  // node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/difference.js
  var require_difference = __commonJS({
    "node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/difference.js"(exports2, module2) {
      var baseDifference = require_baseDifference();
      var baseFlatten = require_baseFlatten();
      var baseRest = require_baseRest();
      var isArrayLikeObject = require_isArrayLikeObject();
      var difference = baseRest(function(array, values) {
        return isArrayLikeObject(array) ? baseDifference(array, baseFlatten(values, 1, isArrayLikeObject, true)) : [];
      });
      module2.exports = difference;
    }
  });

  // node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/indexOf.js
  var require_indexOf = __commonJS({
    "node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/indexOf.js"(exports2, module2) {
      var baseIndexOf = require_baseIndexOf();
      var toInteger = require_toInteger();
      var nativeMax = Math.max;
      function indexOf(array, value, fromIndex) {
        var length = array == null ? 0 : array.length;
        if (!length) {
          return -1;
        }
        var index = fromIndex == null ? 0 : toInteger(fromIndex);
        if (index < 0) {
          index = nativeMax(length + index, 0);
        }
        return baseIndexOf(array, value, index);
      }
      module2.exports = indexOf;
    }
  });

  // node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_createFind.js
  var require_createFind = __commonJS({
    "node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_createFind.js"(exports2, module2) {
      var baseIteratee = require_baseIteratee();
      var isArrayLike = require_isArrayLike();
      var keys = require_keys();
      function createFind(findIndexFunc) {
        return function(collection, predicate, fromIndex) {
          var iterable = Object(collection);
          if (!isArrayLike(collection)) {
            var iteratee = baseIteratee(predicate, 3);
            collection = keys(collection);
            predicate = function(key) {
              return iteratee(iterable[key], key, iterable);
            };
          }
          var index = findIndexFunc(collection, predicate, fromIndex);
          return index > -1 ? iterable[iteratee ? collection[index] : index] : void 0;
        };
      }
      module2.exports = createFind;
    }
  });

  // node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/findIndex.js
  var require_findIndex = __commonJS({
    "node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/findIndex.js"(exports2, module2) {
      var baseFindIndex = require_baseFindIndex();
      var baseIteratee = require_baseIteratee();
      var toInteger = require_toInteger();
      var nativeMax = Math.max;
      function findIndex(array, predicate, fromIndex) {
        var length = array == null ? 0 : array.length;
        if (!length) {
          return -1;
        }
        var index = fromIndex == null ? 0 : toInteger(fromIndex);
        if (index < 0) {
          index = nativeMax(length + index, 0);
        }
        return baseFindIndex(array, baseIteratee(predicate, 3), index);
      }
      module2.exports = findIndex;
    }
  });

  // node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/find.js
  var require_find2 = __commonJS({
    "node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/find.js"(exports2, module2) {
      var createFind = require_createFind();
      var findIndex = require_findIndex();
      var find = createFind(findIndex);
      module2.exports = find;
    }
  });

  // node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/filter.js
  var require_filter = __commonJS({
    "node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/filter.js"(exports2, module2) {
      var arrayFilter = require_arrayFilter();
      var baseFilter = require_baseFilter();
      var baseIteratee = require_baseIteratee();
      var isArray = require_isArray();
      function filter(collection, predicate) {
        var func = isArray(collection) ? arrayFilter : baseFilter;
        return func(collection, baseIteratee(predicate, 3));
      }
      module2.exports = filter;
    }
  });

  // node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/defaults.js
  var require_defaults = __commonJS({
    "node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/defaults.js"(exports2, module2) {
      var baseRest = require_baseRest();
      var eq = require_eq();
      var isIterateeCall = require_isIterateeCall();
      var keysIn = require_keysIn();
      var objectProto = Object.prototype;
      var hasOwnProperty = objectProto.hasOwnProperty;
      var defaults = baseRest(function(object, sources) {
        object = Object(object);
        var index = -1;
        var length = sources.length;
        var guard = length > 2 ? sources[2] : void 0;
        if (guard && isIterateeCall(sources[0], sources[1], guard)) {
          length = 1;
        }
        while (++index < length) {
          var source = sources[index];
          var props = keysIn(source);
          var propsIndex = -1;
          var propsLength = props.length;
          while (++propsIndex < propsLength) {
            var key = props[propsIndex];
            var value = object[key];
            if (value === void 0 || eq(value, objectProto[key]) && !hasOwnProperty.call(object, key)) {
              object[key] = source[key];
            }
          }
        }
        return object;
      });
      module2.exports = defaults;
    }
  });

  // node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_arrayReduce.js
  var require_arrayReduce = __commonJS({
    "node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_arrayReduce.js"(exports2, module2) {
      function arrayReduce(array, iteratee, accumulator, initAccum) {
        var index = -1, length = array == null ? 0 : array.length;
        if (initAccum && length) {
          accumulator = array[++index];
        }
        while (++index < length) {
          accumulator = iteratee(accumulator, array[index], index, array);
        }
        return accumulator;
      }
      module2.exports = arrayReduce;
    }
  });

  // node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_baseReduce.js
  var require_baseReduce = __commonJS({
    "node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_baseReduce.js"(exports2, module2) {
      function baseReduce(collection, iteratee, accumulator, initAccum, eachFunc) {
        eachFunc(collection, function(value, index, collection2) {
          accumulator = initAccum ? (initAccum = false, value) : iteratee(accumulator, value, index, collection2);
        });
        return accumulator;
      }
      module2.exports = baseReduce;
    }
  });

  // node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/reduce.js
  var require_reduce = __commonJS({
    "node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/reduce.js"(exports2, module2) {
      var arrayReduce = require_arrayReduce();
      var baseEach = require_baseEach();
      var baseIteratee = require_baseIteratee();
      var baseReduce = require_baseReduce();
      var isArray = require_isArray();
      function reduce(collection, iteratee, accumulator) {
        var func = isArray(collection) ? arrayReduce : baseReduce, initAccum = arguments.length < 3;
        return func(collection, baseIteratee(iteratee, 4), accumulator, initAccum, baseEach);
      }
      module2.exports = reduce;
    }
  });

  // node_modules/.pnpm/chevrotain@10.5.0/node_modules/chevrotain/lib/src/scan/reg_exp_parser.js
  var require_reg_exp_parser = __commonJS({
    "node_modules/.pnpm/chevrotain@10.5.0/node_modules/chevrotain/lib/src/scan/reg_exp_parser.js"(exports2) {
      "use strict";
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.clearRegExpParserCache = exports2.getRegExpAst = void 0;
      var regexp_to_ast_1 = require_regexp_to_ast();
      var regExpAstCache = {};
      var regExpParser = new regexp_to_ast_1.RegExpParser();
      function getRegExpAst(regExp) {
        var regExpStr = regExp.toString();
        if (regExpAstCache.hasOwnProperty(regExpStr)) {
          return regExpAstCache[regExpStr];
        } else {
          var regExpAst = regExpParser.pattern(regExpStr);
          regExpAstCache[regExpStr] = regExpAst;
          return regExpAst;
        }
      }
      exports2.getRegExpAst = getRegExpAst;
      function clearRegExpParserCache() {
        regExpAstCache = {};
      }
      exports2.clearRegExpParserCache = clearRegExpParserCache;
    }
  });

  // node_modules/.pnpm/chevrotain@10.5.0/node_modules/chevrotain/lib/src/scan/reg_exp.js
  var require_reg_exp = __commonJS({
    "node_modules/.pnpm/chevrotain@10.5.0/node_modules/chevrotain/lib/src/scan/reg_exp.js"(exports2) {
      "use strict";
      var __extends = exports2 && exports2.__extends || function() {
        var extendStatics = function(d, b) {
          extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b3) {
            d2.__proto__ = b3;
          } || function(d2, b3) {
            for (var p in b3)
              if (Object.prototype.hasOwnProperty.call(b3, p))
                d2[p] = b3[p];
          };
          return extendStatics(d, b);
        };
        return function(d, b) {
          if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
          extendStatics(d, b);
          function __() {
            this.constructor = d;
          }
          d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
        };
      }();
      var __importDefault = exports2 && exports2.__importDefault || function(mod) {
        return mod && mod.__esModule ? mod : { "default": mod };
      };
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.canMatchCharCode = exports2.firstCharOptimizedIndices = exports2.getOptimizedStartCodesIndices = exports2.failedOptimizationPrefixMsg = void 0;
      var regexp_to_ast_1 = require_regexp_to_ast();
      var isArray_1 = __importDefault(require_isArray());
      var every_1 = __importDefault(require_every());
      var forEach_1 = __importDefault(require_forEach());
      var find_1 = __importDefault(require_find2());
      var values_1 = __importDefault(require_values());
      var includes_1 = __importDefault(require_includes());
      var utils_1 = require_api();
      var reg_exp_parser_1 = require_reg_exp_parser();
      var lexer_1 = require_lexer();
      var complementErrorMessage = "Complement Sets are not supported for first char optimization";
      exports2.failedOptimizationPrefixMsg = 'Unable to use "first char" lexer optimizations:\n';
      function getOptimizedStartCodesIndices(regExp, ensureOptimizations) {
        if (ensureOptimizations === void 0) {
          ensureOptimizations = false;
        }
        try {
          var ast = (0, reg_exp_parser_1.getRegExpAst)(regExp);
          var firstChars = firstCharOptimizedIndices(ast.value, {}, ast.flags.ignoreCase);
          return firstChars;
        } catch (e) {
          if (e.message === complementErrorMessage) {
            if (ensureOptimizations) {
              (0, utils_1.PRINT_WARNING)("".concat(exports2.failedOptimizationPrefixMsg) + "	Unable to optimize: < ".concat(regExp.toString(), " >\n") + "	Complement Sets cannot be automatically optimized.\n	This will disable the lexer's first char optimizations.\n	See: https://chevrotain.io/docs/guide/resolving_lexer_errors.html#COMPLEMENT for details.");
            }
          } else {
            var msgSuffix = "";
            if (ensureOptimizations) {
              msgSuffix = "\n	This will disable the lexer's first char optimizations.\n	See: https://chevrotain.io/docs/guide/resolving_lexer_errors.html#REGEXP_PARSING for details.";
            }
            (0, utils_1.PRINT_ERROR)("".concat(exports2.failedOptimizationPrefixMsg, "\n") + "	Failed parsing: < ".concat(regExp.toString(), " >\n") + "	Using the regexp-to-ast library version: ".concat(regexp_to_ast_1.VERSION, "\n") + "	Please open an issue at: https://github.com/bd82/regexp-to-ast/issues" + msgSuffix);
          }
        }
        return [];
      }
      exports2.getOptimizedStartCodesIndices = getOptimizedStartCodesIndices;
      function firstCharOptimizedIndices(ast, result, ignoreCase) {
        switch (ast.type) {
          case "Disjunction":
            for (var i = 0; i < ast.value.length; i++) {
              firstCharOptimizedIndices(ast.value[i], result, ignoreCase);
            }
            break;
          case "Alternative":
            var terms = ast.value;
            for (var i = 0; i < terms.length; i++) {
              var term = terms[i];
              switch (term.type) {
                case "EndAnchor":
                case "GroupBackReference":
                case "Lookahead":
                case "NegativeLookahead":
                case "StartAnchor":
                case "WordBoundary":
                case "NonWordBoundary":
                  continue;
              }
              var atom = term;
              switch (atom.type) {
                case "Character":
                  addOptimizedIdxToResult(atom.value, result, ignoreCase);
                  break;
                case "Set":
                  if (atom.complement === true) {
                    throw Error(complementErrorMessage);
                  }
                  (0, forEach_1.default)(atom.value, function(code) {
                    if (typeof code === "number") {
                      addOptimizedIdxToResult(code, result, ignoreCase);
                    } else {
                      var range = code;
                      if (ignoreCase === true) {
                        for (var rangeCode = range.from; rangeCode <= range.to; rangeCode++) {
                          addOptimizedIdxToResult(rangeCode, result, ignoreCase);
                        }
                      } else {
                        for (var rangeCode = range.from; rangeCode <= range.to && rangeCode < lexer_1.minOptimizationVal; rangeCode++) {
                          addOptimizedIdxToResult(rangeCode, result, ignoreCase);
                        }
                        if (range.to >= lexer_1.minOptimizationVal) {
                          var minUnOptVal = range.from >= lexer_1.minOptimizationVal ? range.from : lexer_1.minOptimizationVal;
                          var maxUnOptVal = range.to;
                          var minOptIdx = (0, lexer_1.charCodeToOptimizedIndex)(minUnOptVal);
                          var maxOptIdx = (0, lexer_1.charCodeToOptimizedIndex)(maxUnOptVal);
                          for (var currOptIdx = minOptIdx; currOptIdx <= maxOptIdx; currOptIdx++) {
                            result[currOptIdx] = currOptIdx;
                          }
                        }
                      }
                    }
                  });
                  break;
                case "Group":
                  firstCharOptimizedIndices(atom.value, result, ignoreCase);
                  break;
                default:
                  throw Error("Non Exhaustive Match");
              }
              var isOptionalQuantifier = atom.quantifier !== void 0 && atom.quantifier.atLeast === 0;
              if (
                // A group may be optional due to empty contents /(?:)/
                // or if everything inside it is optional /((a)?)/
                atom.type === "Group" && isWholeOptional(atom) === false || // If this term is not a group it may only be optional if it has an optional quantifier
                atom.type !== "Group" && isOptionalQuantifier === false
              ) {
                break;
              }
            }
            break;
          default:
            throw Error("non exhaustive match!");
        }
        return (0, values_1.default)(result);
      }
      exports2.firstCharOptimizedIndices = firstCharOptimizedIndices;
      function addOptimizedIdxToResult(code, result, ignoreCase) {
        var optimizedCharIdx = (0, lexer_1.charCodeToOptimizedIndex)(code);
        result[optimizedCharIdx] = optimizedCharIdx;
        if (ignoreCase === true) {
          handleIgnoreCase(code, result);
        }
      }
      function handleIgnoreCase(code, result) {
        var char = String.fromCharCode(code);
        var upperChar = char.toUpperCase();
        if (upperChar !== char) {
          var optimizedCharIdx = (0, lexer_1.charCodeToOptimizedIndex)(upperChar.charCodeAt(0));
          result[optimizedCharIdx] = optimizedCharIdx;
        } else {
          var lowerChar = char.toLowerCase();
          if (lowerChar !== char) {
            var optimizedCharIdx = (0, lexer_1.charCodeToOptimizedIndex)(lowerChar.charCodeAt(0));
            result[optimizedCharIdx] = optimizedCharIdx;
          }
        }
      }
      function findCode(setNode, targetCharCodes) {
        return (0, find_1.default)(setNode.value, function(codeOrRange) {
          if (typeof codeOrRange === "number") {
            return (0, includes_1.default)(targetCharCodes, codeOrRange);
          } else {
            var range_1 = codeOrRange;
            return (0, find_1.default)(targetCharCodes, function(targetCode) {
              return range_1.from <= targetCode && targetCode <= range_1.to;
            }) !== void 0;
          }
        });
      }
      function isWholeOptional(ast) {
        var quantifier = ast.quantifier;
        if (quantifier && quantifier.atLeast === 0) {
          return true;
        }
        if (!ast.value) {
          return false;
        }
        return (0, isArray_1.default)(ast.value) ? (0, every_1.default)(ast.value, isWholeOptional) : isWholeOptional(ast.value);
      }
      var CharCodeFinder = (
        /** @class */
        function(_super) {
          __extends(CharCodeFinder2, _super);
          function CharCodeFinder2(targetCharCodes) {
            var _this = _super.call(this) || this;
            _this.targetCharCodes = targetCharCodes;
            _this.found = false;
            return _this;
          }
          CharCodeFinder2.prototype.visitChildren = function(node) {
            if (this.found === true) {
              return;
            }
            switch (node.type) {
              case "Lookahead":
                this.visitLookahead(node);
                return;
              case "NegativeLookahead":
                this.visitNegativeLookahead(node);
                return;
            }
            _super.prototype.visitChildren.call(this, node);
          };
          CharCodeFinder2.prototype.visitCharacter = function(node) {
            if ((0, includes_1.default)(this.targetCharCodes, node.value)) {
              this.found = true;
            }
          };
          CharCodeFinder2.prototype.visitSet = function(node) {
            if (node.complement) {
              if (findCode(node, this.targetCharCodes) === void 0) {
                this.found = true;
              }
            } else {
              if (findCode(node, this.targetCharCodes) !== void 0) {
                this.found = true;
              }
            }
          };
          return CharCodeFinder2;
        }(regexp_to_ast_1.BaseRegExpVisitor)
      );
      function canMatchCharCode(charCodes, pattern) {
        if (pattern instanceof RegExp) {
          var ast = (0, reg_exp_parser_1.getRegExpAst)(pattern);
          var charCodeFinder = new CharCodeFinder(charCodes);
          charCodeFinder.visit(ast);
          return charCodeFinder.found;
        } else {
          return (0, find_1.default)(pattern, function(char) {
            return (0, includes_1.default)(charCodes, char.charCodeAt(0));
          }) !== void 0;
        }
      }
      exports2.canMatchCharCode = canMatchCharCode;
    }
  });

  // node_modules/.pnpm/chevrotain@10.5.0/node_modules/chevrotain/lib/src/scan/lexer.js
  var require_lexer = __commonJS({
    "node_modules/.pnpm/chevrotain@10.5.0/node_modules/chevrotain/lib/src/scan/lexer.js"(exports2) {
      "use strict";
      var __extends = exports2 && exports2.__extends || function() {
        var extendStatics = function(d, b) {
          extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b3) {
            d2.__proto__ = b3;
          } || function(d2, b3) {
            for (var p in b3)
              if (Object.prototype.hasOwnProperty.call(b3, p))
                d2[p] = b3[p];
          };
          return extendStatics(d, b);
        };
        return function(d, b) {
          if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
          extendStatics(d, b);
          function __() {
            this.constructor = d;
          }
          d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
        };
      }();
      var __importDefault = exports2 && exports2.__importDefault || function(mod) {
        return mod && mod.__esModule ? mod : { "default": mod };
      };
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.charCodeToOptimizedIndex = exports2.minOptimizationVal = exports2.buildLineBreakIssueMessage = exports2.LineTerminatorOptimizedTester = exports2.isShortPattern = exports2.isCustomPattern = exports2.cloneEmptyGroups = exports2.performWarningRuntimeChecks = exports2.performRuntimeChecks = exports2.addStickyFlag = exports2.addStartOfInput = exports2.findUnreachablePatterns = exports2.findModesThatDoNotExist = exports2.findInvalidGroupType = exports2.findDuplicatePatterns = exports2.findUnsupportedFlags = exports2.findStartOfInputAnchor = exports2.findEmptyMatchRegExps = exports2.findEndOfInputAnchor = exports2.findInvalidPatterns = exports2.findMissingPatterns = exports2.validatePatterns = exports2.analyzeTokenTypes = exports2.enableSticky = exports2.disableSticky = exports2.SUPPORT_STICKY = exports2.MODES = exports2.DEFAULT_MODE = void 0;
      var regexp_to_ast_1 = require_regexp_to_ast();
      var lexer_public_1 = require_lexer_public();
      var first_1 = __importDefault(require_first2());
      var isEmpty_1 = __importDefault(require_isEmpty());
      var compact_1 = __importDefault(require_compact());
      var isArray_1 = __importDefault(require_isArray());
      var values_1 = __importDefault(require_values());
      var flatten_1 = __importDefault(require_flatten());
      var reject_1 = __importDefault(require_reject());
      var difference_1 = __importDefault(require_difference());
      var indexOf_1 = __importDefault(require_indexOf());
      var map_1 = __importDefault(require_map());
      var forEach_1 = __importDefault(require_forEach());
      var isString_1 = __importDefault(require_isString());
      var isFunction_1 = __importDefault(require_isFunction());
      var isUndefined_1 = __importDefault(require_isUndefined());
      var find_1 = __importDefault(require_find2());
      var has_1 = __importDefault(require_has());
      var keys_1 = __importDefault(require_keys());
      var isRegExp_1 = __importDefault(require_isRegExp());
      var filter_1 = __importDefault(require_filter());
      var defaults_1 = __importDefault(require_defaults());
      var reduce_1 = __importDefault(require_reduce());
      var includes_1 = __importDefault(require_includes());
      var utils_1 = require_api();
      var reg_exp_1 = require_reg_exp();
      var reg_exp_parser_1 = require_reg_exp_parser();
      var PATTERN = "PATTERN";
      exports2.DEFAULT_MODE = "defaultMode";
      exports2.MODES = "modes";
      exports2.SUPPORT_STICKY = typeof new RegExp("(?:)").sticky === "boolean";
      function disableSticky() {
        exports2.SUPPORT_STICKY = false;
      }
      exports2.disableSticky = disableSticky;
      function enableSticky() {
        exports2.SUPPORT_STICKY = true;
      }
      exports2.enableSticky = enableSticky;
      function analyzeTokenTypes(tokenTypes, options) {
        options = (0, defaults_1.default)(options, {
          useSticky: exports2.SUPPORT_STICKY,
          debug: false,
          safeMode: false,
          positionTracking: "full",
          lineTerminatorCharacters: ["\r", "\n"],
          tracer: function(msg, action2) {
            return action2();
          }
        });
        var tracer = options.tracer;
        tracer("initCharCodeToOptimizedIndexMap", function() {
          initCharCodeToOptimizedIndexMap();
        });
        var onlyRelevantTypes;
        tracer("Reject Lexer.NA", function() {
          onlyRelevantTypes = (0, reject_1.default)(tokenTypes, function(currType) {
            return currType[PATTERN] === lexer_public_1.Lexer.NA;
          });
        });
        var hasCustom = false;
        var allTransformedPatterns;
        tracer("Transform Patterns", function() {
          hasCustom = false;
          allTransformedPatterns = (0, map_1.default)(onlyRelevantTypes, function(currType) {
            var currPattern = currType[PATTERN];
            if ((0, isRegExp_1.default)(currPattern)) {
              var regExpSource = currPattern.source;
              if (regExpSource.length === 1 && // only these regExp meta characters which can appear in a length one regExp
              regExpSource !== "^" && regExpSource !== "$" && regExpSource !== "." && !currPattern.ignoreCase) {
                return regExpSource;
              } else if (regExpSource.length === 2 && regExpSource[0] === "\\" && // not a meta character
              !(0, includes_1.default)([
                "d",
                "D",
                "s",
                "S",
                "t",
                "r",
                "n",
                "t",
                "0",
                "c",
                "b",
                "B",
                "f",
                "v",
                "w",
                "W"
              ], regExpSource[1])) {
                return regExpSource[1];
              } else {
                return options.useSticky ? addStickyFlag(currPattern) : addStartOfInput(currPattern);
              }
            } else if ((0, isFunction_1.default)(currPattern)) {
              hasCustom = true;
              return { exec: currPattern };
            } else if (typeof currPattern === "object") {
              hasCustom = true;
              return currPattern;
            } else if (typeof currPattern === "string") {
              if (currPattern.length === 1) {
                return currPattern;
              } else {
                var escapedRegExpString = currPattern.replace(/[\\^$.*+?()[\]{}|]/g, "\\$&");
                var wrappedRegExp = new RegExp(escapedRegExpString);
                return options.useSticky ? addStickyFlag(wrappedRegExp) : addStartOfInput(wrappedRegExp);
              }
            } else {
              throw Error("non exhaustive match");
            }
          });
        });
        var patternIdxToType;
        var patternIdxToGroup;
        var patternIdxToLongerAltIdxArr;
        var patternIdxToPushMode;
        var patternIdxToPopMode;
        tracer("misc mapping", function() {
          patternIdxToType = (0, map_1.default)(onlyRelevantTypes, function(currType) {
            return currType.tokenTypeIdx;
          });
          patternIdxToGroup = (0, map_1.default)(onlyRelevantTypes, function(clazz) {
            var groupName = clazz.GROUP;
            if (groupName === lexer_public_1.Lexer.SKIPPED) {
              return void 0;
            } else if ((0, isString_1.default)(groupName)) {
              return groupName;
            } else if ((0, isUndefined_1.default)(groupName)) {
              return false;
            } else {
              throw Error("non exhaustive match");
            }
          });
          patternIdxToLongerAltIdxArr = (0, map_1.default)(onlyRelevantTypes, function(clazz) {
            var longerAltType = clazz.LONGER_ALT;
            if (longerAltType) {
              var longerAltIdxArr = (0, isArray_1.default)(longerAltType) ? (0, map_1.default)(longerAltType, function(type) {
                return (0, indexOf_1.default)(onlyRelevantTypes, type);
              }) : [(0, indexOf_1.default)(onlyRelevantTypes, longerAltType)];
              return longerAltIdxArr;
            }
          });
          patternIdxToPushMode = (0, map_1.default)(onlyRelevantTypes, function(clazz) {
            return clazz.PUSH_MODE;
          });
          patternIdxToPopMode = (0, map_1.default)(onlyRelevantTypes, function(clazz) {
            return (0, has_1.default)(clazz, "POP_MODE");
          });
        });
        var patternIdxToCanLineTerminator;
        tracer("Line Terminator Handling", function() {
          var lineTerminatorCharCodes = getCharCodes(options.lineTerminatorCharacters);
          patternIdxToCanLineTerminator = (0, map_1.default)(onlyRelevantTypes, function(tokType) {
            return false;
          });
          if (options.positionTracking !== "onlyOffset") {
            patternIdxToCanLineTerminator = (0, map_1.default)(onlyRelevantTypes, function(tokType) {
              if ((0, has_1.default)(tokType, "LINE_BREAKS")) {
                return !!tokType.LINE_BREAKS;
              } else {
                return checkLineBreaksIssues(tokType, lineTerminatorCharCodes) === false && (0, reg_exp_1.canMatchCharCode)(lineTerminatorCharCodes, tokType.PATTERN);
              }
            });
          }
        });
        var patternIdxToIsCustom;
        var patternIdxToShort;
        var emptyGroups;
        var patternIdxToConfig;
        tracer("Misc Mapping #2", function() {
          patternIdxToIsCustom = (0, map_1.default)(onlyRelevantTypes, isCustomPattern);
          patternIdxToShort = (0, map_1.default)(allTransformedPatterns, isShortPattern);
          emptyGroups = (0, reduce_1.default)(onlyRelevantTypes, function(acc, clazz) {
            var groupName = clazz.GROUP;
            if ((0, isString_1.default)(groupName) && !(groupName === lexer_public_1.Lexer.SKIPPED)) {
              acc[groupName] = [];
            }
            return acc;
          }, {});
          patternIdxToConfig = (0, map_1.default)(allTransformedPatterns, function(x, idx) {
            return {
              pattern: allTransformedPatterns[idx],
              longerAlt: patternIdxToLongerAltIdxArr[idx],
              canLineTerminator: patternIdxToCanLineTerminator[idx],
              isCustom: patternIdxToIsCustom[idx],
              short: patternIdxToShort[idx],
              group: patternIdxToGroup[idx],
              push: patternIdxToPushMode[idx],
              pop: patternIdxToPopMode[idx],
              tokenTypeIdx: patternIdxToType[idx],
              tokenType: onlyRelevantTypes[idx]
            };
          });
        });
        var canBeOptimized = true;
        var charCodeToPatternIdxToConfig = [];
        if (!options.safeMode) {
          tracer("First Char Optimization", function() {
            charCodeToPatternIdxToConfig = (0, reduce_1.default)(onlyRelevantTypes, function(result, currTokType, idx) {
              if (typeof currTokType.PATTERN === "string") {
                var charCode = currTokType.PATTERN.charCodeAt(0);
                var optimizedIdx = charCodeToOptimizedIndex(charCode);
                addToMapOfArrays(result, optimizedIdx, patternIdxToConfig[idx]);
              } else if ((0, isArray_1.default)(currTokType.START_CHARS_HINT)) {
                var lastOptimizedIdx_1;
                (0, forEach_1.default)(currTokType.START_CHARS_HINT, function(charOrInt) {
                  var charCode2 = typeof charOrInt === "string" ? charOrInt.charCodeAt(0) : charOrInt;
                  var currOptimizedIdx = charCodeToOptimizedIndex(charCode2);
                  if (lastOptimizedIdx_1 !== currOptimizedIdx) {
                    lastOptimizedIdx_1 = currOptimizedIdx;
                    addToMapOfArrays(result, currOptimizedIdx, patternIdxToConfig[idx]);
                  }
                });
              } else if ((0, isRegExp_1.default)(currTokType.PATTERN)) {
                if (currTokType.PATTERN.unicode) {
                  canBeOptimized = false;
                  if (options.ensureOptimizations) {
                    (0, utils_1.PRINT_ERROR)("".concat(reg_exp_1.failedOptimizationPrefixMsg) + "	Unable to analyze < ".concat(currTokType.PATTERN.toString(), " > pattern.\n") + "	The regexp unicode flag is not currently supported by the regexp-to-ast library.\n	This will disable the lexer's first char optimizations.\n	For details See: https://chevrotain.io/docs/guide/resolving_lexer_errors.html#UNICODE_OPTIMIZE");
                  }
                } else {
                  var optimizedCodes = (0, reg_exp_1.getOptimizedStartCodesIndices)(currTokType.PATTERN, options.ensureOptimizations);
                  if ((0, isEmpty_1.default)(optimizedCodes)) {
                    canBeOptimized = false;
                  }
                  (0, forEach_1.default)(optimizedCodes, function(code) {
                    addToMapOfArrays(result, code, patternIdxToConfig[idx]);
                  });
                }
              } else {
                if (options.ensureOptimizations) {
                  (0, utils_1.PRINT_ERROR)("".concat(reg_exp_1.failedOptimizationPrefixMsg) + "	TokenType: <".concat(currTokType.name, "> is using a custom token pattern without providing <start_chars_hint> parameter.\n") + "	This will disable the lexer's first char optimizations.\n	For details See: https://chevrotain.io/docs/guide/resolving_lexer_errors.html#CUSTOM_OPTIMIZE");
                }
                canBeOptimized = false;
              }
              return result;
            }, []);
          });
        }
        return {
          emptyGroups,
          patternIdxToConfig,
          charCodeToPatternIdxToConfig,
          hasCustom,
          canBeOptimized
        };
      }
      exports2.analyzeTokenTypes = analyzeTokenTypes;
      function validatePatterns(tokenTypes, validModesNames) {
        var errors = [];
        var missingResult = findMissingPatterns(tokenTypes);
        errors = errors.concat(missingResult.errors);
        var invalidResult = findInvalidPatterns(missingResult.valid);
        var validTokenTypes = invalidResult.valid;
        errors = errors.concat(invalidResult.errors);
        errors = errors.concat(validateRegExpPattern(validTokenTypes));
        errors = errors.concat(findInvalidGroupType(validTokenTypes));
        errors = errors.concat(findModesThatDoNotExist(validTokenTypes, validModesNames));
        errors = errors.concat(findUnreachablePatterns(validTokenTypes));
        return errors;
      }
      exports2.validatePatterns = validatePatterns;
      function validateRegExpPattern(tokenTypes) {
        var errors = [];
        var withRegExpPatterns = (0, filter_1.default)(tokenTypes, function(currTokType) {
          return (0, isRegExp_1.default)(currTokType[PATTERN]);
        });
        errors = errors.concat(findEndOfInputAnchor(withRegExpPatterns));
        errors = errors.concat(findStartOfInputAnchor(withRegExpPatterns));
        errors = errors.concat(findUnsupportedFlags(withRegExpPatterns));
        errors = errors.concat(findDuplicatePatterns(withRegExpPatterns));
        errors = errors.concat(findEmptyMatchRegExps(withRegExpPatterns));
        return errors;
      }
      function findMissingPatterns(tokenTypes) {
        var tokenTypesWithMissingPattern = (0, filter_1.default)(tokenTypes, function(currType) {
          return !(0, has_1.default)(currType, PATTERN);
        });
        var errors = (0, map_1.default)(tokenTypesWithMissingPattern, function(currType) {
          return {
            message: "Token Type: ->" + currType.name + "<- missing static 'PATTERN' property",
            type: lexer_public_1.LexerDefinitionErrorType.MISSING_PATTERN,
            tokenTypes: [currType]
          };
        });
        var valid = (0, difference_1.default)(tokenTypes, tokenTypesWithMissingPattern);
        return { errors, valid };
      }
      exports2.findMissingPatterns = findMissingPatterns;
      function findInvalidPatterns(tokenTypes) {
        var tokenTypesWithInvalidPattern = (0, filter_1.default)(tokenTypes, function(currType) {
          var pattern = currType[PATTERN];
          return !(0, isRegExp_1.default)(pattern) && !(0, isFunction_1.default)(pattern) && !(0, has_1.default)(pattern, "exec") && !(0, isString_1.default)(pattern);
        });
        var errors = (0, map_1.default)(tokenTypesWithInvalidPattern, function(currType) {
          return {
            message: "Token Type: ->" + currType.name + "<- static 'PATTERN' can only be a RegExp, a Function matching the {CustomPatternMatcherFunc} type or an Object matching the {ICustomPattern} interface.",
            type: lexer_public_1.LexerDefinitionErrorType.INVALID_PATTERN,
            tokenTypes: [currType]
          };
        });
        var valid = (0, difference_1.default)(tokenTypes, tokenTypesWithInvalidPattern);
        return { errors, valid };
      }
      exports2.findInvalidPatterns = findInvalidPatterns;
      var end_of_input = /[^\\][$]/;
      function findEndOfInputAnchor(tokenTypes) {
        var EndAnchorFinder = (
          /** @class */
          function(_super) {
            __extends(EndAnchorFinder2, _super);
            function EndAnchorFinder2() {
              var _this = _super !== null && _super.apply(this, arguments) || this;
              _this.found = false;
              return _this;
            }
            EndAnchorFinder2.prototype.visitEndAnchor = function(node) {
              this.found = true;
            };
            return EndAnchorFinder2;
          }(regexp_to_ast_1.BaseRegExpVisitor)
        );
        var invalidRegex = (0, filter_1.default)(tokenTypes, function(currType) {
          var pattern = currType.PATTERN;
          try {
            var regexpAst = (0, reg_exp_parser_1.getRegExpAst)(pattern);
            var endAnchorVisitor = new EndAnchorFinder();
            endAnchorVisitor.visit(regexpAst);
            return endAnchorVisitor.found;
          } catch (e) {
            return end_of_input.test(pattern.source);
          }
        });
        var errors = (0, map_1.default)(invalidRegex, function(currType) {
          return {
            message: "Unexpected RegExp Anchor Error:\n	Token Type: ->" + currType.name + "<- static 'PATTERN' cannot contain end of input anchor '$'\n	See chevrotain.io/docs/guide/resolving_lexer_errors.html#ANCHORS	for details.",
            type: lexer_public_1.LexerDefinitionErrorType.EOI_ANCHOR_FOUND,
            tokenTypes: [currType]
          };
        });
        return errors;
      }
      exports2.findEndOfInputAnchor = findEndOfInputAnchor;
      function findEmptyMatchRegExps(tokenTypes) {
        var matchesEmptyString = (0, filter_1.default)(tokenTypes, function(currType) {
          var pattern = currType.PATTERN;
          return pattern.test("");
        });
        var errors = (0, map_1.default)(matchesEmptyString, function(currType) {
          return {
            message: "Token Type: ->" + currType.name + "<- static 'PATTERN' must not match an empty string",
            type: lexer_public_1.LexerDefinitionErrorType.EMPTY_MATCH_PATTERN,
            tokenTypes: [currType]
          };
        });
        return errors;
      }
      exports2.findEmptyMatchRegExps = findEmptyMatchRegExps;
      var start_of_input = /[^\\[][\^]|^\^/;
      function findStartOfInputAnchor(tokenTypes) {
        var StartAnchorFinder = (
          /** @class */
          function(_super) {
            __extends(StartAnchorFinder2, _super);
            function StartAnchorFinder2() {
              var _this = _super !== null && _super.apply(this, arguments) || this;
              _this.found = false;
              return _this;
            }
            StartAnchorFinder2.prototype.visitStartAnchor = function(node) {
              this.found = true;
            };
            return StartAnchorFinder2;
          }(regexp_to_ast_1.BaseRegExpVisitor)
        );
        var invalidRegex = (0, filter_1.default)(tokenTypes, function(currType) {
          var pattern = currType.PATTERN;
          try {
            var regexpAst = (0, reg_exp_parser_1.getRegExpAst)(pattern);
            var startAnchorVisitor = new StartAnchorFinder();
            startAnchorVisitor.visit(regexpAst);
            return startAnchorVisitor.found;
          } catch (e) {
            return start_of_input.test(pattern.source);
          }
        });
        var errors = (0, map_1.default)(invalidRegex, function(currType) {
          return {
            message: "Unexpected RegExp Anchor Error:\n	Token Type: ->" + currType.name + "<- static 'PATTERN' cannot contain start of input anchor '^'\n	See https://chevrotain.io/docs/guide/resolving_lexer_errors.html#ANCHORS	for details.",
            type: lexer_public_1.LexerDefinitionErrorType.SOI_ANCHOR_FOUND,
            tokenTypes: [currType]
          };
        });
        return errors;
      }
      exports2.findStartOfInputAnchor = findStartOfInputAnchor;
      function findUnsupportedFlags(tokenTypes) {
        var invalidFlags = (0, filter_1.default)(tokenTypes, function(currType) {
          var pattern = currType[PATTERN];
          return pattern instanceof RegExp && (pattern.multiline || pattern.global);
        });
        var errors = (0, map_1.default)(invalidFlags, function(currType) {
          return {
            message: "Token Type: ->" + currType.name + "<- static 'PATTERN' may NOT contain global('g') or multiline('m')",
            type: lexer_public_1.LexerDefinitionErrorType.UNSUPPORTED_FLAGS_FOUND,
            tokenTypes: [currType]
          };
        });
        return errors;
      }
      exports2.findUnsupportedFlags = findUnsupportedFlags;
      function findDuplicatePatterns(tokenTypes) {
        var found = [];
        var identicalPatterns = (0, map_1.default)(tokenTypes, function(outerType) {
          return (0, reduce_1.default)(tokenTypes, function(result, innerType) {
            if (outerType.PATTERN.source === innerType.PATTERN.source && !(0, includes_1.default)(found, innerType) && innerType.PATTERN !== lexer_public_1.Lexer.NA) {
              found.push(innerType);
              result.push(innerType);
              return result;
            }
            return result;
          }, []);
        });
        identicalPatterns = (0, compact_1.default)(identicalPatterns);
        var duplicatePatterns = (0, filter_1.default)(identicalPatterns, function(currIdenticalSet) {
          return currIdenticalSet.length > 1;
        });
        var errors = (0, map_1.default)(duplicatePatterns, function(setOfIdentical) {
          var tokenTypeNames = (0, map_1.default)(setOfIdentical, function(currType) {
            return currType.name;
          });
          var dupPatternSrc = (0, first_1.default)(setOfIdentical).PATTERN;
          return {
            message: "The same RegExp pattern ->".concat(dupPatternSrc, "<-") + "has been used in all of the following Token Types: ".concat(tokenTypeNames.join(", "), " <-"),
            type: lexer_public_1.LexerDefinitionErrorType.DUPLICATE_PATTERNS_FOUND,
            tokenTypes: setOfIdentical
          };
        });
        return errors;
      }
      exports2.findDuplicatePatterns = findDuplicatePatterns;
      function findInvalidGroupType(tokenTypes) {
        var invalidTypes = (0, filter_1.default)(tokenTypes, function(clazz) {
          if (!(0, has_1.default)(clazz, "GROUP")) {
            return false;
          }
          var group = clazz.GROUP;
          return group !== lexer_public_1.Lexer.SKIPPED && group !== lexer_public_1.Lexer.NA && !(0, isString_1.default)(group);
        });
        var errors = (0, map_1.default)(invalidTypes, function(currType) {
          return {
            message: "Token Type: ->" + currType.name + "<- static 'GROUP' can only be Lexer.SKIPPED/Lexer.NA/A String",
            type: lexer_public_1.LexerDefinitionErrorType.INVALID_GROUP_TYPE_FOUND,
            tokenTypes: [currType]
          };
        });
        return errors;
      }
      exports2.findInvalidGroupType = findInvalidGroupType;
      function findModesThatDoNotExist(tokenTypes, validModes) {
        var invalidModes = (0, filter_1.default)(tokenTypes, function(clazz) {
          return clazz.PUSH_MODE !== void 0 && !(0, includes_1.default)(validModes, clazz.PUSH_MODE);
        });
        var errors = (0, map_1.default)(invalidModes, function(tokType) {
          var msg = "Token Type: ->".concat(tokType.name, "<- static 'PUSH_MODE' value cannot refer to a Lexer Mode ->").concat(tokType.PUSH_MODE, "<-") + "which does not exist";
          return {
            message: msg,
            type: lexer_public_1.LexerDefinitionErrorType.PUSH_MODE_DOES_NOT_EXIST,
            tokenTypes: [tokType]
          };
        });
        return errors;
      }
      exports2.findModesThatDoNotExist = findModesThatDoNotExist;
      function findUnreachablePatterns(tokenTypes) {
        var errors = [];
        var canBeTested = (0, reduce_1.default)(tokenTypes, function(result, tokType, idx) {
          var pattern = tokType.PATTERN;
          if (pattern === lexer_public_1.Lexer.NA) {
            return result;
          }
          if ((0, isString_1.default)(pattern)) {
            result.push({ str: pattern, idx, tokenType: tokType });
          } else if ((0, isRegExp_1.default)(pattern) && noMetaChar(pattern)) {
            result.push({ str: pattern.source, idx, tokenType: tokType });
          }
          return result;
        }, []);
        (0, forEach_1.default)(tokenTypes, function(tokType, testIdx) {
          (0, forEach_1.default)(canBeTested, function(_a2) {
            var str = _a2.str, idx = _a2.idx, tokenType = _a2.tokenType;
            if (testIdx < idx && testTokenType(str, tokType.PATTERN)) {
              var msg = "Token: ->".concat(tokenType.name, "<- can never be matched.\n") + "Because it appears AFTER the Token Type ->".concat(tokType.name, "<-") + "in the lexer's definition.\nSee https://chevrotain.io/docs/guide/resolving_lexer_errors.html#UNREACHABLE";
              errors.push({
                message: msg,
                type: lexer_public_1.LexerDefinitionErrorType.UNREACHABLE_PATTERN,
                tokenTypes: [tokType, tokenType]
              });
            }
          });
        });
        return errors;
      }
      exports2.findUnreachablePatterns = findUnreachablePatterns;
      function testTokenType(str, pattern) {
        if ((0, isRegExp_1.default)(pattern)) {
          var regExpArray = pattern.exec(str);
          return regExpArray !== null && regExpArray.index === 0;
        } else if ((0, isFunction_1.default)(pattern)) {
          return pattern(str, 0, [], {});
        } else if ((0, has_1.default)(pattern, "exec")) {
          return pattern.exec(str, 0, [], {});
        } else if (typeof pattern === "string") {
          return pattern === str;
        } else {
          throw Error("non exhaustive match");
        }
      }
      function noMetaChar(regExp) {
        var metaChars = [
          ".",
          "\\",
          "[",
          "]",
          "|",
          "^",
          "$",
          "(",
          ")",
          "?",
          "*",
          "+",
          "{"
        ];
        return (0, find_1.default)(metaChars, function(char) {
          return regExp.source.indexOf(char) !== -1;
        }) === void 0;
      }
      function addStartOfInput(pattern) {
        var flags = pattern.ignoreCase ? "i" : "";
        return new RegExp("^(?:".concat(pattern.source, ")"), flags);
      }
      exports2.addStartOfInput = addStartOfInput;
      function addStickyFlag(pattern) {
        var flags = pattern.ignoreCase ? "iy" : "y";
        return new RegExp("".concat(pattern.source), flags);
      }
      exports2.addStickyFlag = addStickyFlag;
      function performRuntimeChecks(lexerDefinition, trackLines, lineTerminatorCharacters) {
        var errors = [];
        if (!(0, has_1.default)(lexerDefinition, exports2.DEFAULT_MODE)) {
          errors.push({
            message: "A MultiMode Lexer cannot be initialized without a <" + exports2.DEFAULT_MODE + "> property in its definition\n",
            type: lexer_public_1.LexerDefinitionErrorType.MULTI_MODE_LEXER_WITHOUT_DEFAULT_MODE
          });
        }
        if (!(0, has_1.default)(lexerDefinition, exports2.MODES)) {
          errors.push({
            message: "A MultiMode Lexer cannot be initialized without a <" + exports2.MODES + "> property in its definition\n",
            type: lexer_public_1.LexerDefinitionErrorType.MULTI_MODE_LEXER_WITHOUT_MODES_PROPERTY
          });
        }
        if ((0, has_1.default)(lexerDefinition, exports2.MODES) && (0, has_1.default)(lexerDefinition, exports2.DEFAULT_MODE) && !(0, has_1.default)(lexerDefinition.modes, lexerDefinition.defaultMode)) {
          errors.push({
            message: "A MultiMode Lexer cannot be initialized with a ".concat(exports2.DEFAULT_MODE, ": <").concat(lexerDefinition.defaultMode, ">") + "which does not exist\n",
            type: lexer_public_1.LexerDefinitionErrorType.MULTI_MODE_LEXER_DEFAULT_MODE_VALUE_DOES_NOT_EXIST
          });
        }
        if ((0, has_1.default)(lexerDefinition, exports2.MODES)) {
          (0, forEach_1.default)(lexerDefinition.modes, function(currModeValue, currModeName) {
            (0, forEach_1.default)(currModeValue, function(currTokType, currIdx) {
              if ((0, isUndefined_1.default)(currTokType)) {
                errors.push({
                  message: "A Lexer cannot be initialized using an undefined Token Type. Mode:" + "<".concat(currModeName, "> at index: <").concat(currIdx, ">\n"),
                  type: lexer_public_1.LexerDefinitionErrorType.LEXER_DEFINITION_CANNOT_CONTAIN_UNDEFINED
                });
              } else if ((0, has_1.default)(currTokType, "LONGER_ALT")) {
                var longerAlt = (0, isArray_1.default)(currTokType.LONGER_ALT) ? currTokType.LONGER_ALT : [currTokType.LONGER_ALT];
                (0, forEach_1.default)(longerAlt, function(currLongerAlt) {
                  if (!(0, isUndefined_1.default)(currLongerAlt) && !(0, includes_1.default)(currModeValue, currLongerAlt)) {
                    errors.push({
                      message: "A MultiMode Lexer cannot be initialized with a longer_alt <".concat(currLongerAlt.name, "> on token <").concat(currTokType.name, "> outside of mode <").concat(currModeName, ">\n"),
                      type: lexer_public_1.LexerDefinitionErrorType.MULTI_MODE_LEXER_LONGER_ALT_NOT_IN_CURRENT_MODE
                    });
                  }
                });
              }
            });
          });
        }
        return errors;
      }
      exports2.performRuntimeChecks = performRuntimeChecks;
      function performWarningRuntimeChecks(lexerDefinition, trackLines, lineTerminatorCharacters) {
        var warnings = [];
        var hasAnyLineBreak = false;
        var allTokenTypes = (0, compact_1.default)((0, flatten_1.default)((0, values_1.default)(lexerDefinition.modes)));
        var concreteTokenTypes = (0, reject_1.default)(allTokenTypes, function(currType) {
          return currType[PATTERN] === lexer_public_1.Lexer.NA;
        });
        var terminatorCharCodes = getCharCodes(lineTerminatorCharacters);
        if (trackLines) {
          (0, forEach_1.default)(concreteTokenTypes, function(tokType) {
            var currIssue = checkLineBreaksIssues(tokType, terminatorCharCodes);
            if (currIssue !== false) {
              var message = buildLineBreakIssueMessage(tokType, currIssue);
              var warningDescriptor = {
                message,
                type: currIssue.issue,
                tokenType: tokType
              };
              warnings.push(warningDescriptor);
            } else {
              if ((0, has_1.default)(tokType, "LINE_BREAKS")) {
                if (tokType.LINE_BREAKS === true) {
                  hasAnyLineBreak = true;
                }
              } else {
                if ((0, reg_exp_1.canMatchCharCode)(terminatorCharCodes, tokType.PATTERN)) {
                  hasAnyLineBreak = true;
                }
              }
            }
          });
        }
        if (trackLines && !hasAnyLineBreak) {
          warnings.push({
            message: "Warning: No LINE_BREAKS Found.\n	This Lexer has been defined to track line and column information,\n	But none of the Token Types can be identified as matching a line terminator.\n	See https://chevrotain.io/docs/guide/resolving_lexer_errors.html#LINE_BREAKS \n	for details.",
            type: lexer_public_1.LexerDefinitionErrorType.NO_LINE_BREAKS_FLAGS
          });
        }
        return warnings;
      }
      exports2.performWarningRuntimeChecks = performWarningRuntimeChecks;
      function cloneEmptyGroups(emptyGroups) {
        var clonedResult = {};
        var groupKeys = (0, keys_1.default)(emptyGroups);
        (0, forEach_1.default)(groupKeys, function(currKey) {
          var currGroupValue = emptyGroups[currKey];
          if ((0, isArray_1.default)(currGroupValue)) {
            clonedResult[currKey] = [];
          } else {
            throw Error("non exhaustive match");
          }
        });
        return clonedResult;
      }
      exports2.cloneEmptyGroups = cloneEmptyGroups;
      function isCustomPattern(tokenType) {
        var pattern = tokenType.PATTERN;
        if ((0, isRegExp_1.default)(pattern)) {
          return false;
        } else if ((0, isFunction_1.default)(pattern)) {
          return true;
        } else if ((0, has_1.default)(pattern, "exec")) {
          return true;
        } else if ((0, isString_1.default)(pattern)) {
          return false;
        } else {
          throw Error("non exhaustive match");
        }
      }
      exports2.isCustomPattern = isCustomPattern;
      function isShortPattern(pattern) {
        if ((0, isString_1.default)(pattern) && pattern.length === 1) {
          return pattern.charCodeAt(0);
        } else {
          return false;
        }
      }
      exports2.isShortPattern = isShortPattern;
      exports2.LineTerminatorOptimizedTester = {
        // implements /\n|\r\n?/g.test
        test: function(text) {
          var len = text.length;
          for (var i = this.lastIndex; i < len; i++) {
            var c = text.charCodeAt(i);
            if (c === 10) {
              this.lastIndex = i + 1;
              return true;
            } else if (c === 13) {
              if (text.charCodeAt(i + 1) === 10) {
                this.lastIndex = i + 2;
              } else {
                this.lastIndex = i + 1;
              }
              return true;
            }
          }
          return false;
        },
        lastIndex: 0
      };
      function checkLineBreaksIssues(tokType, lineTerminatorCharCodes) {
        if ((0, has_1.default)(tokType, "LINE_BREAKS")) {
          return false;
        } else {
          if ((0, isRegExp_1.default)(tokType.PATTERN)) {
            try {
              (0, reg_exp_1.canMatchCharCode)(lineTerminatorCharCodes, tokType.PATTERN);
            } catch (e) {
              return {
                issue: lexer_public_1.LexerDefinitionErrorType.IDENTIFY_TERMINATOR,
                errMsg: e.message
              };
            }
            return false;
          } else if ((0, isString_1.default)(tokType.PATTERN)) {
            return false;
          } else if (isCustomPattern(tokType)) {
            return { issue: lexer_public_1.LexerDefinitionErrorType.CUSTOM_LINE_BREAK };
          } else {
            throw Error("non exhaustive match");
          }
        }
      }
      function buildLineBreakIssueMessage(tokType, details) {
        if (details.issue === lexer_public_1.LexerDefinitionErrorType.IDENTIFY_TERMINATOR) {
          return "Warning: unable to identify line terminator usage in pattern.\n" + "	The problem is in the <".concat(tokType.name, "> Token Type\n") + "	 Root cause: ".concat(details.errMsg, ".\n") + "	For details See: https://chevrotain.io/docs/guide/resolving_lexer_errors.html#IDENTIFY_TERMINATOR";
        } else if (details.issue === lexer_public_1.LexerDefinitionErrorType.CUSTOM_LINE_BREAK) {
          return "Warning: A Custom Token Pattern should specify the <line_breaks> option.\n" + "	The problem is in the <".concat(tokType.name, "> Token Type\n") + "	For details See: https://chevrotain.io/docs/guide/resolving_lexer_errors.html#CUSTOM_LINE_BREAK";
        } else {
          throw Error("non exhaustive match");
        }
      }
      exports2.buildLineBreakIssueMessage = buildLineBreakIssueMessage;
      function getCharCodes(charsOrCodes) {
        var charCodes = (0, map_1.default)(charsOrCodes, function(numOrString) {
          if ((0, isString_1.default)(numOrString)) {
            return numOrString.charCodeAt(0);
          } else {
            return numOrString;
          }
        });
        return charCodes;
      }
      function addToMapOfArrays(map, key, value) {
        if (map[key] === void 0) {
          map[key] = [value];
        } else {
          map[key].push(value);
        }
      }
      exports2.minOptimizationVal = 256;
      var charCodeToOptimizedIdxMap = [];
      function charCodeToOptimizedIndex(charCode) {
        return charCode < exports2.minOptimizationVal ? charCode : charCodeToOptimizedIdxMap[charCode];
      }
      exports2.charCodeToOptimizedIndex = charCodeToOptimizedIndex;
      function initCharCodeToOptimizedIndexMap() {
        if ((0, isEmpty_1.default)(charCodeToOptimizedIdxMap)) {
          charCodeToOptimizedIdxMap = new Array(65536);
          for (var i = 0; i < 65536; i++) {
            charCodeToOptimizedIdxMap[i] = i > 255 ? 255 + ~~(i / 255) : i;
          }
        }
      }
    }
  });

  // node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/last.js
  var require_last = __commonJS({
    "node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/last.js"(exports2, module2) {
      function last(array) {
        var length = array == null ? 0 : array.length;
        return length ? array[length - 1] : void 0;
      }
      module2.exports = last;
    }
  });

  // node_modules/.pnpm/chevrotain@10.5.0/node_modules/chevrotain/lib/src/scan/tokens.js
  var require_tokens = __commonJS({
    "node_modules/.pnpm/chevrotain@10.5.0/node_modules/chevrotain/lib/src/scan/tokens.js"(exports2) {
      "use strict";
      var __importDefault = exports2 && exports2.__importDefault || function(mod) {
        return mod && mod.__esModule ? mod : { "default": mod };
      };
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.isTokenType = exports2.hasExtendingTokensTypesMapProperty = exports2.hasExtendingTokensTypesProperty = exports2.hasCategoriesProperty = exports2.hasShortKeyProperty = exports2.singleAssignCategoriesToksMap = exports2.assignCategoriesMapProp = exports2.assignCategoriesTokensProp = exports2.assignTokenDefaultProps = exports2.expandCategories = exports2.augmentTokenTypes = exports2.tokenIdxToClass = exports2.tokenShortNameIdx = exports2.tokenStructuredMatcherNoCategories = exports2.tokenStructuredMatcher = void 0;
      var isEmpty_1 = __importDefault(require_isEmpty());
      var compact_1 = __importDefault(require_compact());
      var isArray_1 = __importDefault(require_isArray());
      var flatten_1 = __importDefault(require_flatten());
      var difference_1 = __importDefault(require_difference());
      var map_1 = __importDefault(require_map());
      var forEach_1 = __importDefault(require_forEach());
      var has_1 = __importDefault(require_has());
      var includes_1 = __importDefault(require_includes());
      var clone_1 = __importDefault(require_clone());
      function tokenStructuredMatcher(tokInstance, tokConstructor) {
        var instanceType = tokInstance.tokenTypeIdx;
        if (instanceType === tokConstructor.tokenTypeIdx) {
          return true;
        } else {
          return tokConstructor.isParent === true && tokConstructor.categoryMatchesMap[instanceType] === true;
        }
      }
      exports2.tokenStructuredMatcher = tokenStructuredMatcher;
      function tokenStructuredMatcherNoCategories(token, tokType) {
        return token.tokenTypeIdx === tokType.tokenTypeIdx;
      }
      exports2.tokenStructuredMatcherNoCategories = tokenStructuredMatcherNoCategories;
      exports2.tokenShortNameIdx = 1;
      exports2.tokenIdxToClass = {};
      function augmentTokenTypes(tokenTypes) {
        var tokenTypesAndParents = expandCategories(tokenTypes);
        assignTokenDefaultProps(tokenTypesAndParents);
        assignCategoriesMapProp(tokenTypesAndParents);
        assignCategoriesTokensProp(tokenTypesAndParents);
        (0, forEach_1.default)(tokenTypesAndParents, function(tokType) {
          tokType.isParent = tokType.categoryMatches.length > 0;
        });
      }
      exports2.augmentTokenTypes = augmentTokenTypes;
      function expandCategories(tokenTypes) {
        var result = (0, clone_1.default)(tokenTypes);
        var categories = tokenTypes;
        var searching = true;
        while (searching) {
          categories = (0, compact_1.default)((0, flatten_1.default)((0, map_1.default)(categories, function(currTokType) {
            return currTokType.CATEGORIES;
          })));
          var newCategories = (0, difference_1.default)(categories, result);
          result = result.concat(newCategories);
          if ((0, isEmpty_1.default)(newCategories)) {
            searching = false;
          } else {
            categories = newCategories;
          }
        }
        return result;
      }
      exports2.expandCategories = expandCategories;
      function assignTokenDefaultProps(tokenTypes) {
        (0, forEach_1.default)(tokenTypes, function(currTokType) {
          if (!hasShortKeyProperty(currTokType)) {
            exports2.tokenIdxToClass[exports2.tokenShortNameIdx] = currTokType;
            currTokType.tokenTypeIdx = exports2.tokenShortNameIdx++;
          }
          if (hasCategoriesProperty(currTokType) && !(0, isArray_1.default)(currTokType.CATEGORIES)) {
            currTokType.CATEGORIES = [currTokType.CATEGORIES];
          }
          if (!hasCategoriesProperty(currTokType)) {
            currTokType.CATEGORIES = [];
          }
          if (!hasExtendingTokensTypesProperty(currTokType)) {
            currTokType.categoryMatches = [];
          }
          if (!hasExtendingTokensTypesMapProperty(currTokType)) {
            currTokType.categoryMatchesMap = {};
          }
        });
      }
      exports2.assignTokenDefaultProps = assignTokenDefaultProps;
      function assignCategoriesTokensProp(tokenTypes) {
        (0, forEach_1.default)(tokenTypes, function(currTokType) {
          currTokType.categoryMatches = [];
          (0, forEach_1.default)(currTokType.categoryMatchesMap, function(val, key) {
            currTokType.categoryMatches.push(exports2.tokenIdxToClass[key].tokenTypeIdx);
          });
        });
      }
      exports2.assignCategoriesTokensProp = assignCategoriesTokensProp;
      function assignCategoriesMapProp(tokenTypes) {
        (0, forEach_1.default)(tokenTypes, function(currTokType) {
          singleAssignCategoriesToksMap([], currTokType);
        });
      }
      exports2.assignCategoriesMapProp = assignCategoriesMapProp;
      function singleAssignCategoriesToksMap(path4, nextNode) {
        (0, forEach_1.default)(path4, function(pathNode) {
          nextNode.categoryMatchesMap[pathNode.tokenTypeIdx] = true;
        });
        (0, forEach_1.default)(nextNode.CATEGORIES, function(nextCategory) {
          var newPath = path4.concat(nextNode);
          if (!(0, includes_1.default)(newPath, nextCategory)) {
            singleAssignCategoriesToksMap(newPath, nextCategory);
          }
        });
      }
      exports2.singleAssignCategoriesToksMap = singleAssignCategoriesToksMap;
      function hasShortKeyProperty(tokType) {
        return (0, has_1.default)(tokType, "tokenTypeIdx");
      }
      exports2.hasShortKeyProperty = hasShortKeyProperty;
      function hasCategoriesProperty(tokType) {
        return (0, has_1.default)(tokType, "CATEGORIES");
      }
      exports2.hasCategoriesProperty = hasCategoriesProperty;
      function hasExtendingTokensTypesProperty(tokType) {
        return (0, has_1.default)(tokType, "categoryMatches");
      }
      exports2.hasExtendingTokensTypesProperty = hasExtendingTokensTypesProperty;
      function hasExtendingTokensTypesMapProperty(tokType) {
        return (0, has_1.default)(tokType, "categoryMatchesMap");
      }
      exports2.hasExtendingTokensTypesMapProperty = hasExtendingTokensTypesMapProperty;
      function isTokenType(tokType) {
        return (0, has_1.default)(tokType, "tokenTypeIdx");
      }
      exports2.isTokenType = isTokenType;
    }
  });

  // node_modules/.pnpm/chevrotain@10.5.0/node_modules/chevrotain/lib/src/scan/lexer_errors_public.js
  var require_lexer_errors_public = __commonJS({
    "node_modules/.pnpm/chevrotain@10.5.0/node_modules/chevrotain/lib/src/scan/lexer_errors_public.js"(exports2) {
      "use strict";
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.defaultLexerErrorProvider = void 0;
      exports2.defaultLexerErrorProvider = {
        buildUnableToPopLexerModeMessage: function(token) {
          return "Unable to pop Lexer Mode after encountering Token ->".concat(token.image, "<- The Mode Stack is empty");
        },
        buildUnexpectedCharactersMessage: function(fullText, startOffset, length, line, column) {
          return "unexpected character: ->".concat(fullText.charAt(startOffset), "<- at offset: ").concat(startOffset, ",") + " skipped ".concat(length, " characters.");
        }
      };
    }
  });

  // node_modules/.pnpm/chevrotain@10.5.0/node_modules/chevrotain/lib/src/scan/lexer_public.js
  var require_lexer_public = __commonJS({
    "node_modules/.pnpm/chevrotain@10.5.0/node_modules/chevrotain/lib/src/scan/lexer_public.js"(exports2) {
      "use strict";
      var __importDefault = exports2 && exports2.__importDefault || function(mod) {
        return mod && mod.__esModule ? mod : { "default": mod };
      };
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.Lexer = exports2.LexerDefinitionErrorType = void 0;
      var lexer_1 = require_lexer();
      var noop_1 = __importDefault(require_noop());
      var isEmpty_1 = __importDefault(require_isEmpty());
      var isArray_1 = __importDefault(require_isArray());
      var last_1 = __importDefault(require_last());
      var reject_1 = __importDefault(require_reject());
      var map_1 = __importDefault(require_map());
      var forEach_1 = __importDefault(require_forEach());
      var keys_1 = __importDefault(require_keys());
      var isUndefined_1 = __importDefault(require_isUndefined());
      var identity_1 = __importDefault(require_identity());
      var assign_1 = __importDefault(require_assign());
      var reduce_1 = __importDefault(require_reduce());
      var clone_1 = __importDefault(require_clone());
      var utils_1 = require_api();
      var tokens_1 = require_tokens();
      var lexer_errors_public_1 = require_lexer_errors_public();
      var reg_exp_parser_1 = require_reg_exp_parser();
      var LexerDefinitionErrorType;
      (function(LexerDefinitionErrorType2) {
        LexerDefinitionErrorType2[LexerDefinitionErrorType2["MISSING_PATTERN"] = 0] = "MISSING_PATTERN";
        LexerDefinitionErrorType2[LexerDefinitionErrorType2["INVALID_PATTERN"] = 1] = "INVALID_PATTERN";
        LexerDefinitionErrorType2[LexerDefinitionErrorType2["EOI_ANCHOR_FOUND"] = 2] = "EOI_ANCHOR_FOUND";
        LexerDefinitionErrorType2[LexerDefinitionErrorType2["UNSUPPORTED_FLAGS_FOUND"] = 3] = "UNSUPPORTED_FLAGS_FOUND";
        LexerDefinitionErrorType2[LexerDefinitionErrorType2["DUPLICATE_PATTERNS_FOUND"] = 4] = "DUPLICATE_PATTERNS_FOUND";
        LexerDefinitionErrorType2[LexerDefinitionErrorType2["INVALID_GROUP_TYPE_FOUND"] = 5] = "INVALID_GROUP_TYPE_FOUND";
        LexerDefinitionErrorType2[LexerDefinitionErrorType2["PUSH_MODE_DOES_NOT_EXIST"] = 6] = "PUSH_MODE_DOES_NOT_EXIST";
        LexerDefinitionErrorType2[LexerDefinitionErrorType2["MULTI_MODE_LEXER_WITHOUT_DEFAULT_MODE"] = 7] = "MULTI_MODE_LEXER_WITHOUT_DEFAULT_MODE";
        LexerDefinitionErrorType2[LexerDefinitionErrorType2["MULTI_MODE_LEXER_WITHOUT_MODES_PROPERTY"] = 8] = "MULTI_MODE_LEXER_WITHOUT_MODES_PROPERTY";
        LexerDefinitionErrorType2[LexerDefinitionErrorType2["MULTI_MODE_LEXER_DEFAULT_MODE_VALUE_DOES_NOT_EXIST"] = 9] = "MULTI_MODE_LEXER_DEFAULT_MODE_VALUE_DOES_NOT_EXIST";
        LexerDefinitionErrorType2[LexerDefinitionErrorType2["LEXER_DEFINITION_CANNOT_CONTAIN_UNDEFINED"] = 10] = "LEXER_DEFINITION_CANNOT_CONTAIN_UNDEFINED";
        LexerDefinitionErrorType2[LexerDefinitionErrorType2["SOI_ANCHOR_FOUND"] = 11] = "SOI_ANCHOR_FOUND";
        LexerDefinitionErrorType2[LexerDefinitionErrorType2["EMPTY_MATCH_PATTERN"] = 12] = "EMPTY_MATCH_PATTERN";
        LexerDefinitionErrorType2[LexerDefinitionErrorType2["NO_LINE_BREAKS_FLAGS"] = 13] = "NO_LINE_BREAKS_FLAGS";
        LexerDefinitionErrorType2[LexerDefinitionErrorType2["UNREACHABLE_PATTERN"] = 14] = "UNREACHABLE_PATTERN";
        LexerDefinitionErrorType2[LexerDefinitionErrorType2["IDENTIFY_TERMINATOR"] = 15] = "IDENTIFY_TERMINATOR";
        LexerDefinitionErrorType2[LexerDefinitionErrorType2["CUSTOM_LINE_BREAK"] = 16] = "CUSTOM_LINE_BREAK";
        LexerDefinitionErrorType2[LexerDefinitionErrorType2["MULTI_MODE_LEXER_LONGER_ALT_NOT_IN_CURRENT_MODE"] = 17] = "MULTI_MODE_LEXER_LONGER_ALT_NOT_IN_CURRENT_MODE";
      })(LexerDefinitionErrorType = exports2.LexerDefinitionErrorType || (exports2.LexerDefinitionErrorType = {}));
      var DEFAULT_LEXER_CONFIG = {
        deferDefinitionErrorsHandling: false,
        positionTracking: "full",
        lineTerminatorsPattern: /\n|\r\n?/g,
        lineTerminatorCharacters: ["\n", "\r"],
        ensureOptimizations: false,
        safeMode: false,
        errorMessageProvider: lexer_errors_public_1.defaultLexerErrorProvider,
        traceInitPerf: false,
        skipValidations: false,
        recoveryEnabled: true
      };
      Object.freeze(DEFAULT_LEXER_CONFIG);
      var Lexer = (
        /** @class */
        function() {
          function Lexer2(lexerDefinition, config2) {
            if (config2 === void 0) {
              config2 = DEFAULT_LEXER_CONFIG;
            }
            var _this = this;
            this.lexerDefinition = lexerDefinition;
            this.lexerDefinitionErrors = [];
            this.lexerDefinitionWarning = [];
            this.patternIdxToConfig = {};
            this.charCodeToPatternIdxToConfig = {};
            this.modes = [];
            this.emptyGroups = {};
            this.trackStartLines = true;
            this.trackEndLines = true;
            this.hasCustom = false;
            this.canModeBeOptimized = {};
            this.TRACE_INIT = function(phaseDesc, phaseImpl) {
              if (_this.traceInitPerf === true) {
                _this.traceInitIndent++;
                var indent = new Array(_this.traceInitIndent + 1).join("	");
                if (_this.traceInitIndent < _this.traceInitMaxIdent) {
                  console.log("".concat(indent, "--> <").concat(phaseDesc, ">"));
                }
                var _a2 = (0, utils_1.timer)(phaseImpl), time = _a2.time, value = _a2.value;
                var traceMethod = time > 10 ? console.warn : console.log;
                if (_this.traceInitIndent < _this.traceInitMaxIdent) {
                  traceMethod("".concat(indent, "<-- <").concat(phaseDesc, "> time: ").concat(time, "ms"));
                }
                _this.traceInitIndent--;
                return value;
              } else {
                return phaseImpl();
              }
            };
            if (typeof config2 === "boolean") {
              throw Error("The second argument to the Lexer constructor is now an ILexerConfig Object.\na boolean 2nd argument is no longer supported");
            }
            this.config = (0, assign_1.default)({}, DEFAULT_LEXER_CONFIG, config2);
            var traceInitVal = this.config.traceInitPerf;
            if (traceInitVal === true) {
              this.traceInitMaxIdent = Infinity;
              this.traceInitPerf = true;
            } else if (typeof traceInitVal === "number") {
              this.traceInitMaxIdent = traceInitVal;
              this.traceInitPerf = true;
            }
            this.traceInitIndent = -1;
            this.TRACE_INIT("Lexer Constructor", function() {
              var actualDefinition;
              var hasOnlySingleMode = true;
              _this.TRACE_INIT("Lexer Config handling", function() {
                if (_this.config.lineTerminatorsPattern === DEFAULT_LEXER_CONFIG.lineTerminatorsPattern) {
                  _this.config.lineTerminatorsPattern = lexer_1.LineTerminatorOptimizedTester;
                } else {
                  if (_this.config.lineTerminatorCharacters === DEFAULT_LEXER_CONFIG.lineTerminatorCharacters) {
                    throw Error("Error: Missing <lineTerminatorCharacters> property on the Lexer config.\n	For details See: https://chevrotain.io/docs/guide/resolving_lexer_errors.html#MISSING_LINE_TERM_CHARS");
                  }
                }
                if (config2.safeMode && config2.ensureOptimizations) {
                  throw Error('"safeMode" and "ensureOptimizations" flags are mutually exclusive.');
                }
                _this.trackStartLines = /full|onlyStart/i.test(_this.config.positionTracking);
                _this.trackEndLines = /full/i.test(_this.config.positionTracking);
                if ((0, isArray_1.default)(lexerDefinition)) {
                  actualDefinition = {
                    modes: { defaultMode: (0, clone_1.default)(lexerDefinition) },
                    defaultMode: lexer_1.DEFAULT_MODE
                  };
                } else {
                  hasOnlySingleMode = false;
                  actualDefinition = (0, clone_1.default)(lexerDefinition);
                }
              });
              if (_this.config.skipValidations === false) {
                _this.TRACE_INIT("performRuntimeChecks", function() {
                  _this.lexerDefinitionErrors = _this.lexerDefinitionErrors.concat((0, lexer_1.performRuntimeChecks)(actualDefinition, _this.trackStartLines, _this.config.lineTerminatorCharacters));
                });
                _this.TRACE_INIT("performWarningRuntimeChecks", function() {
                  _this.lexerDefinitionWarning = _this.lexerDefinitionWarning.concat((0, lexer_1.performWarningRuntimeChecks)(actualDefinition, _this.trackStartLines, _this.config.lineTerminatorCharacters));
                });
              }
              actualDefinition.modes = actualDefinition.modes ? actualDefinition.modes : {};
              (0, forEach_1.default)(actualDefinition.modes, function(currModeValue, currModeName) {
                actualDefinition.modes[currModeName] = (0, reject_1.default)(currModeValue, function(currTokType) {
                  return (0, isUndefined_1.default)(currTokType);
                });
              });
              var allModeNames = (0, keys_1.default)(actualDefinition.modes);
              (0, forEach_1.default)(actualDefinition.modes, function(currModDef, currModName) {
                _this.TRACE_INIT("Mode: <".concat(currModName, "> processing"), function() {
                  _this.modes.push(currModName);
                  if (_this.config.skipValidations === false) {
                    _this.TRACE_INIT("validatePatterns", function() {
                      _this.lexerDefinitionErrors = _this.lexerDefinitionErrors.concat((0, lexer_1.validatePatterns)(currModDef, allModeNames));
                    });
                  }
                  if ((0, isEmpty_1.default)(_this.lexerDefinitionErrors)) {
                    (0, tokens_1.augmentTokenTypes)(currModDef);
                    var currAnalyzeResult_1;
                    _this.TRACE_INIT("analyzeTokenTypes", function() {
                      currAnalyzeResult_1 = (0, lexer_1.analyzeTokenTypes)(currModDef, {
                        lineTerminatorCharacters: _this.config.lineTerminatorCharacters,
                        positionTracking: config2.positionTracking,
                        ensureOptimizations: config2.ensureOptimizations,
                        safeMode: config2.safeMode,
                        tracer: _this.TRACE_INIT
                      });
                    });
                    _this.patternIdxToConfig[currModName] = currAnalyzeResult_1.patternIdxToConfig;
                    _this.charCodeToPatternIdxToConfig[currModName] = currAnalyzeResult_1.charCodeToPatternIdxToConfig;
                    _this.emptyGroups = (0, assign_1.default)({}, _this.emptyGroups, currAnalyzeResult_1.emptyGroups);
                    _this.hasCustom = currAnalyzeResult_1.hasCustom || _this.hasCustom;
                    _this.canModeBeOptimized[currModName] = currAnalyzeResult_1.canBeOptimized;
                  }
                });
              });
              _this.defaultMode = actualDefinition.defaultMode;
              if (!(0, isEmpty_1.default)(_this.lexerDefinitionErrors) && !_this.config.deferDefinitionErrorsHandling) {
                var allErrMessages = (0, map_1.default)(_this.lexerDefinitionErrors, function(error) {
                  return error.message;
                });
                var allErrMessagesString = allErrMessages.join("-----------------------\n");
                throw new Error("Errors detected in definition of Lexer:\n" + allErrMessagesString);
              }
              (0, forEach_1.default)(_this.lexerDefinitionWarning, function(warningDescriptor) {
                (0, utils_1.PRINT_WARNING)(warningDescriptor.message);
              });
              _this.TRACE_INIT("Choosing sub-methods implementations", function() {
                if (lexer_1.SUPPORT_STICKY) {
                  _this.chopInput = identity_1.default;
                  _this.match = _this.matchWithTest;
                } else {
                  _this.updateLastIndex = noop_1.default;
                  _this.match = _this.matchWithExec;
                }
                if (hasOnlySingleMode) {
                  _this.handleModes = noop_1.default;
                }
                if (_this.trackStartLines === false) {
                  _this.computeNewColumn = identity_1.default;
                }
                if (_this.trackEndLines === false) {
                  _this.updateTokenEndLineColumnLocation = noop_1.default;
                }
                if (/full/i.test(_this.config.positionTracking)) {
                  _this.createTokenInstance = _this.createFullToken;
                } else if (/onlyStart/i.test(_this.config.positionTracking)) {
                  _this.createTokenInstance = _this.createStartOnlyToken;
                } else if (/onlyOffset/i.test(_this.config.positionTracking)) {
                  _this.createTokenInstance = _this.createOffsetOnlyToken;
                } else {
                  throw Error('Invalid <positionTracking> config option: "'.concat(_this.config.positionTracking, '"'));
                }
                if (_this.hasCustom) {
                  _this.addToken = _this.addTokenUsingPush;
                  _this.handlePayload = _this.handlePayloadWithCustom;
                } else {
                  _this.addToken = _this.addTokenUsingMemberAccess;
                  _this.handlePayload = _this.handlePayloadNoCustom;
                }
              });
              _this.TRACE_INIT("Failed Optimization Warnings", function() {
                var unOptimizedModes = (0, reduce_1.default)(_this.canModeBeOptimized, function(cannotBeOptimized, canBeOptimized, modeName) {
                  if (canBeOptimized === false) {
                    cannotBeOptimized.push(modeName);
                  }
                  return cannotBeOptimized;
                }, []);
                if (config2.ensureOptimizations && !(0, isEmpty_1.default)(unOptimizedModes)) {
                  throw Error("Lexer Modes: < ".concat(unOptimizedModes.join(", "), " > cannot be optimized.\n") + '	 Disable the "ensureOptimizations" lexer config flag to silently ignore this and run the lexer in an un-optimized mode.\n	 Or inspect the console log for details on how to resolve these issues.');
                }
              });
              _this.TRACE_INIT("clearRegExpParserCache", function() {
                (0, reg_exp_parser_1.clearRegExpParserCache)();
              });
              _this.TRACE_INIT("toFastProperties", function() {
                (0, utils_1.toFastProperties)(_this);
              });
            });
          }
          Lexer2.prototype.tokenize = function(text, initialMode) {
            if (initialMode === void 0) {
              initialMode = this.defaultMode;
            }
            if (!(0, isEmpty_1.default)(this.lexerDefinitionErrors)) {
              var allErrMessages = (0, map_1.default)(this.lexerDefinitionErrors, function(error) {
                return error.message;
              });
              var allErrMessagesString = allErrMessages.join("-----------------------\n");
              throw new Error("Unable to Tokenize because Errors detected in definition of Lexer:\n" + allErrMessagesString);
            }
            return this.tokenizeInternal(text, initialMode);
          };
          Lexer2.prototype.tokenizeInternal = function(text, initialMode) {
            var _this = this;
            var i, j, k, matchAltImage, longerAlt, matchedImage, payload, altPayload, imageLength, group, tokType, newToken, errLength, droppedChar, msg, match;
            var orgText = text;
            var orgLength = orgText.length;
            var offset = 0;
            var matchedTokensIndex = 0;
            var guessedNumberOfTokens = this.hasCustom ? 0 : Math.floor(text.length / 10);
            var matchedTokens = new Array(guessedNumberOfTokens);
            var errors = [];
            var line = this.trackStartLines ? 1 : void 0;
            var column = this.trackStartLines ? 1 : void 0;
            var groups = (0, lexer_1.cloneEmptyGroups)(this.emptyGroups);
            var trackLines = this.trackStartLines;
            var lineTerminatorPattern = this.config.lineTerminatorsPattern;
            var currModePatternsLength = 0;
            var patternIdxToConfig = [];
            var currCharCodeToPatternIdxToConfig = [];
            var modeStack = [];
            var emptyArray = [];
            Object.freeze(emptyArray);
            var getPossiblePatterns;
            function getPossiblePatternsSlow() {
              return patternIdxToConfig;
            }
            function getPossiblePatternsOptimized(charCode) {
              var optimizedCharIdx = (0, lexer_1.charCodeToOptimizedIndex)(charCode);
              var possiblePatterns = currCharCodeToPatternIdxToConfig[optimizedCharIdx];
              if (possiblePatterns === void 0) {
                return emptyArray;
              } else {
                return possiblePatterns;
              }
            }
            var pop_mode = function(popToken) {
              if (modeStack.length === 1 && // if we have both a POP_MODE and a PUSH_MODE this is in-fact a "transition"
              // So no error should occur.
              popToken.tokenType.PUSH_MODE === void 0) {
                var msg_1 = _this.config.errorMessageProvider.buildUnableToPopLexerModeMessage(popToken);
                errors.push({
                  offset: popToken.startOffset,
                  line: popToken.startLine,
                  column: popToken.startColumn,
                  length: popToken.image.length,
                  message: msg_1
                });
              } else {
                modeStack.pop();
                var newMode = (0, last_1.default)(modeStack);
                patternIdxToConfig = _this.patternIdxToConfig[newMode];
                currCharCodeToPatternIdxToConfig = _this.charCodeToPatternIdxToConfig[newMode];
                currModePatternsLength = patternIdxToConfig.length;
                var modeCanBeOptimized = _this.canModeBeOptimized[newMode] && _this.config.safeMode === false;
                if (currCharCodeToPatternIdxToConfig && modeCanBeOptimized) {
                  getPossiblePatterns = getPossiblePatternsOptimized;
                } else {
                  getPossiblePatterns = getPossiblePatternsSlow;
                }
              }
            };
            function push_mode(newMode) {
              modeStack.push(newMode);
              currCharCodeToPatternIdxToConfig = this.charCodeToPatternIdxToConfig[newMode];
              patternIdxToConfig = this.patternIdxToConfig[newMode];
              currModePatternsLength = patternIdxToConfig.length;
              currModePatternsLength = patternIdxToConfig.length;
              var modeCanBeOptimized = this.canModeBeOptimized[newMode] && this.config.safeMode === false;
              if (currCharCodeToPatternIdxToConfig && modeCanBeOptimized) {
                getPossiblePatterns = getPossiblePatternsOptimized;
              } else {
                getPossiblePatterns = getPossiblePatternsSlow;
              }
            }
            push_mode.call(this, initialMode);
            var currConfig;
            var recoveryEnabled = this.config.recoveryEnabled;
            while (offset < orgLength) {
              matchedImage = null;
              var nextCharCode = orgText.charCodeAt(offset);
              var chosenPatternIdxToConfig = getPossiblePatterns(nextCharCode);
              var chosenPatternsLength = chosenPatternIdxToConfig.length;
              for (i = 0; i < chosenPatternsLength; i++) {
                currConfig = chosenPatternIdxToConfig[i];
                var currPattern = currConfig.pattern;
                payload = null;
                var singleCharCode = currConfig.short;
                if (singleCharCode !== false) {
                  if (nextCharCode === singleCharCode) {
                    matchedImage = currPattern;
                  }
                } else if (currConfig.isCustom === true) {
                  match = currPattern.exec(orgText, offset, matchedTokens, groups);
                  if (match !== null) {
                    matchedImage = match[0];
                    if (match.payload !== void 0) {
                      payload = match.payload;
                    }
                  } else {
                    matchedImage = null;
                  }
                } else {
                  this.updateLastIndex(currPattern, offset);
                  matchedImage = this.match(currPattern, text, offset);
                }
                if (matchedImage !== null) {
                  longerAlt = currConfig.longerAlt;
                  if (longerAlt !== void 0) {
                    var longerAltLength = longerAlt.length;
                    for (k = 0; k < longerAltLength; k++) {
                      var longerAltConfig = patternIdxToConfig[longerAlt[k]];
                      var longerAltPattern = longerAltConfig.pattern;
                      altPayload = null;
                      if (longerAltConfig.isCustom === true) {
                        match = longerAltPattern.exec(orgText, offset, matchedTokens, groups);
                        if (match !== null) {
                          matchAltImage = match[0];
                          if (match.payload !== void 0) {
                            altPayload = match.payload;
                          }
                        } else {
                          matchAltImage = null;
                        }
                      } else {
                        this.updateLastIndex(longerAltPattern, offset);
                        matchAltImage = this.match(longerAltPattern, text, offset);
                      }
                      if (matchAltImage && matchAltImage.length > matchedImage.length) {
                        matchedImage = matchAltImage;
                        payload = altPayload;
                        currConfig = longerAltConfig;
                        break;
                      }
                    }
                  }
                  break;
                }
              }
              if (matchedImage !== null) {
                imageLength = matchedImage.length;
                group = currConfig.group;
                if (group !== void 0) {
                  tokType = currConfig.tokenTypeIdx;
                  newToken = this.createTokenInstance(matchedImage, offset, tokType, currConfig.tokenType, line, column, imageLength);
                  this.handlePayload(newToken, payload);
                  if (group === false) {
                    matchedTokensIndex = this.addToken(matchedTokens, matchedTokensIndex, newToken);
                  } else {
                    groups[group].push(newToken);
                  }
                }
                text = this.chopInput(text, imageLength);
                offset = offset + imageLength;
                column = this.computeNewColumn(column, imageLength);
                if (trackLines === true && currConfig.canLineTerminator === true) {
                  var numOfLTsInMatch = 0;
                  var foundTerminator = void 0;
                  var lastLTEndOffset = void 0;
                  lineTerminatorPattern.lastIndex = 0;
                  do {
                    foundTerminator = lineTerminatorPattern.test(matchedImage);
                    if (foundTerminator === true) {
                      lastLTEndOffset = lineTerminatorPattern.lastIndex - 1;
                      numOfLTsInMatch++;
                    }
                  } while (foundTerminator === true);
                  if (numOfLTsInMatch !== 0) {
                    line = line + numOfLTsInMatch;
                    column = imageLength - lastLTEndOffset;
                    this.updateTokenEndLineColumnLocation(newToken, group, lastLTEndOffset, numOfLTsInMatch, line, column, imageLength);
                  }
                }
                this.handleModes(currConfig, pop_mode, push_mode, newToken);
              } else {
                var errorStartOffset = offset;
                var errorLine = line;
                var errorColumn = column;
                var foundResyncPoint = recoveryEnabled === false;
                while (foundResyncPoint === false && offset < orgLength) {
                  text = this.chopInput(text, 1);
                  offset++;
                  for (j = 0; j < currModePatternsLength; j++) {
                    var currConfig_1 = patternIdxToConfig[j];
                    var currPattern = currConfig_1.pattern;
                    var singleCharCode = currConfig_1.short;
                    if (singleCharCode !== false) {
                      if (orgText.charCodeAt(offset) === singleCharCode) {
                        foundResyncPoint = true;
                      }
                    } else if (currConfig_1.isCustom === true) {
                      foundResyncPoint = currPattern.exec(orgText, offset, matchedTokens, groups) !== null;
                    } else {
                      this.updateLastIndex(currPattern, offset);
                      foundResyncPoint = currPattern.exec(text) !== null;
                    }
                    if (foundResyncPoint === true) {
                      break;
                    }
                  }
                }
                errLength = offset - errorStartOffset;
                msg = this.config.errorMessageProvider.buildUnexpectedCharactersMessage(orgText, errorStartOffset, errLength, errorLine, errorColumn);
                errors.push({
                  offset: errorStartOffset,
                  line: errorLine,
                  column: errorColumn,
                  length: errLength,
                  message: msg
                });
                if (recoveryEnabled === false) {
                  break;
                }
              }
            }
            if (!this.hasCustom) {
              matchedTokens.length = matchedTokensIndex;
            }
            return {
              tokens: matchedTokens,
              groups,
              errors
            };
          };
          Lexer2.prototype.handleModes = function(config2, pop_mode, push_mode, newToken) {
            if (config2.pop === true) {
              var pushMode = config2.push;
              pop_mode(newToken);
              if (pushMode !== void 0) {
                push_mode.call(this, pushMode);
              }
            } else if (config2.push !== void 0) {
              push_mode.call(this, config2.push);
            }
          };
          Lexer2.prototype.chopInput = function(text, length) {
            return text.substring(length);
          };
          Lexer2.prototype.updateLastIndex = function(regExp, newLastIndex) {
            regExp.lastIndex = newLastIndex;
          };
          Lexer2.prototype.updateTokenEndLineColumnLocation = function(newToken, group, lastLTIdx, numOfLTsInMatch, line, column, imageLength) {
            var lastCharIsLT, fixForEndingInLT;
            if (group !== void 0) {
              lastCharIsLT = lastLTIdx === imageLength - 1;
              fixForEndingInLT = lastCharIsLT ? -1 : 0;
              if (!(numOfLTsInMatch === 1 && lastCharIsLT === true)) {
                newToken.endLine = line + fixForEndingInLT;
                newToken.endColumn = column - 1 + -fixForEndingInLT;
              }
            }
          };
          Lexer2.prototype.computeNewColumn = function(oldColumn, imageLength) {
            return oldColumn + imageLength;
          };
          Lexer2.prototype.createOffsetOnlyToken = function(image, startOffset, tokenTypeIdx, tokenType) {
            return {
              image,
              startOffset,
              tokenTypeIdx,
              tokenType
            };
          };
          Lexer2.prototype.createStartOnlyToken = function(image, startOffset, tokenTypeIdx, tokenType, startLine, startColumn) {
            return {
              image,
              startOffset,
              startLine,
              startColumn,
              tokenTypeIdx,
              tokenType
            };
          };
          Lexer2.prototype.createFullToken = function(image, startOffset, tokenTypeIdx, tokenType, startLine, startColumn, imageLength) {
            return {
              image,
              startOffset,
              endOffset: startOffset + imageLength - 1,
              startLine,
              endLine: startLine,
              startColumn,
              endColumn: startColumn + imageLength - 1,
              tokenTypeIdx,
              tokenType
            };
          };
          Lexer2.prototype.addTokenUsingPush = function(tokenVector, index, tokenToAdd) {
            tokenVector.push(tokenToAdd);
            return index;
          };
          Lexer2.prototype.addTokenUsingMemberAccess = function(tokenVector, index, tokenToAdd) {
            tokenVector[index] = tokenToAdd;
            index++;
            return index;
          };
          Lexer2.prototype.handlePayloadNoCustom = function(token, payload) {
          };
          Lexer2.prototype.handlePayloadWithCustom = function(token, payload) {
            if (payload !== null) {
              token.payload = payload;
            }
          };
          Lexer2.prototype.matchWithTest = function(pattern, text, offset) {
            var found = pattern.test(text);
            if (found === true) {
              return text.substring(offset, pattern.lastIndex);
            }
            return null;
          };
          Lexer2.prototype.matchWithExec = function(pattern, text) {
            var regExpArray = pattern.exec(text);
            return regExpArray !== null ? regExpArray[0] : null;
          };
          Lexer2.SKIPPED = "This marks a skipped Token pattern, this means each token identified by it willbe consumed and then thrown into oblivion, this can be used to for example to completely ignore whitespace.";
          Lexer2.NA = /NOT_APPLICABLE/;
          return Lexer2;
        }()
      );
      exports2.Lexer = Lexer;
    }
  });

  // node_modules/.pnpm/chevrotain@10.5.0/node_modules/chevrotain/lib/src/scan/tokens_public.js
  var require_tokens_public = __commonJS({
    "node_modules/.pnpm/chevrotain@10.5.0/node_modules/chevrotain/lib/src/scan/tokens_public.js"(exports2) {
      "use strict";
      var __importDefault = exports2 && exports2.__importDefault || function(mod) {
        return mod && mod.__esModule ? mod : { "default": mod };
      };
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.tokenMatcher = exports2.createTokenInstance = exports2.EOF = exports2.createToken = exports2.hasTokenLabel = exports2.tokenName = exports2.tokenLabel = void 0;
      var isString_1 = __importDefault(require_isString());
      var has_1 = __importDefault(require_has());
      var isUndefined_1 = __importDefault(require_isUndefined());
      var lexer_public_1 = require_lexer_public();
      var tokens_1 = require_tokens();
      function tokenLabel(tokType) {
        if (hasTokenLabel(tokType)) {
          return tokType.LABEL;
        } else {
          return tokType.name;
        }
      }
      exports2.tokenLabel = tokenLabel;
      function tokenName(tokType) {
        return tokType.name;
      }
      exports2.tokenName = tokenName;
      function hasTokenLabel(obj) {
        return (0, isString_1.default)(obj.LABEL) && obj.LABEL !== "";
      }
      exports2.hasTokenLabel = hasTokenLabel;
      var PARENT = "parent";
      var CATEGORIES = "categories";
      var LABEL = "label";
      var GROUP = "group";
      var PUSH_MODE = "push_mode";
      var POP_MODE = "pop_mode";
      var LONGER_ALT = "longer_alt";
      var LINE_BREAKS = "line_breaks";
      var START_CHARS_HINT = "start_chars_hint";
      function createToken(config2) {
        return createTokenInternal(config2);
      }
      exports2.createToken = createToken;
      function createTokenInternal(config2) {
        var pattern = config2.pattern;
        var tokenType = {};
        tokenType.name = config2.name;
        if (!(0, isUndefined_1.default)(pattern)) {
          tokenType.PATTERN = pattern;
        }
        if ((0, has_1.default)(config2, PARENT)) {
          throw "The parent property is no longer supported.\nSee: https://github.com/chevrotain/chevrotain/issues/564#issuecomment-349062346 for details.";
        }
        if ((0, has_1.default)(config2, CATEGORIES)) {
          tokenType.CATEGORIES = config2[CATEGORIES];
        }
        (0, tokens_1.augmentTokenTypes)([tokenType]);
        if ((0, has_1.default)(config2, LABEL)) {
          tokenType.LABEL = config2[LABEL];
        }
        if ((0, has_1.default)(config2, GROUP)) {
          tokenType.GROUP = config2[GROUP];
        }
        if ((0, has_1.default)(config2, POP_MODE)) {
          tokenType.POP_MODE = config2[POP_MODE];
        }
        if ((0, has_1.default)(config2, PUSH_MODE)) {
          tokenType.PUSH_MODE = config2[PUSH_MODE];
        }
        if ((0, has_1.default)(config2, LONGER_ALT)) {
          tokenType.LONGER_ALT = config2[LONGER_ALT];
        }
        if ((0, has_1.default)(config2, LINE_BREAKS)) {
          tokenType.LINE_BREAKS = config2[LINE_BREAKS];
        }
        if ((0, has_1.default)(config2, START_CHARS_HINT)) {
          tokenType.START_CHARS_HINT = config2[START_CHARS_HINT];
        }
        return tokenType;
      }
      exports2.EOF = createToken({ name: "EOF", pattern: lexer_public_1.Lexer.NA });
      (0, tokens_1.augmentTokenTypes)([exports2.EOF]);
      function createTokenInstance(tokType, image, startOffset, endOffset, startLine, endLine, startColumn, endColumn) {
        return {
          image,
          startOffset,
          endOffset,
          startLine,
          endLine,
          startColumn,
          endColumn,
          tokenTypeIdx: tokType.tokenTypeIdx,
          tokenType: tokType
        };
      }
      exports2.createTokenInstance = createTokenInstance;
      function tokenMatcher(token, tokType) {
        return (0, tokens_1.tokenStructuredMatcher)(token, tokType);
      }
      exports2.tokenMatcher = tokenMatcher;
    }
  });

  // node_modules/.pnpm/chevrotain@10.5.0/node_modules/chevrotain/lib/src/parse/errors_public.js
  var require_errors_public = __commonJS({
    "node_modules/.pnpm/chevrotain@10.5.0/node_modules/chevrotain/lib/src/parse/errors_public.js"(exports2) {
      "use strict";
      var __importDefault = exports2 && exports2.__importDefault || function(mod) {
        return mod && mod.__esModule ? mod : { "default": mod };
      };
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.defaultGrammarValidatorErrorProvider = exports2.defaultGrammarResolverErrorProvider = exports2.defaultParserErrorProvider = void 0;
      var tokens_public_1 = require_tokens_public();
      var first_1 = __importDefault(require_first2());
      var map_1 = __importDefault(require_map());
      var reduce_1 = __importDefault(require_reduce());
      var gast_1 = require_api2();
      var gast_2 = require_api2();
      exports2.defaultParserErrorProvider = {
        buildMismatchTokenMessage: function(_a2) {
          var expected = _a2.expected, actual = _a2.actual, previous = _a2.previous, ruleName = _a2.ruleName;
          var hasLabel = (0, tokens_public_1.hasTokenLabel)(expected);
          var expectedMsg = hasLabel ? "--> ".concat((0, tokens_public_1.tokenLabel)(expected), " <--") : "token of type --> ".concat(expected.name, " <--");
          var msg = "Expecting ".concat(expectedMsg, " but found --> '").concat(actual.image, "' <--");
          return msg;
        },
        buildNotAllInputParsedMessage: function(_a2) {
          var firstRedundant = _a2.firstRedundant, ruleName = _a2.ruleName;
          return "Redundant input, expecting EOF but found: " + firstRedundant.image;
        },
        buildNoViableAltMessage: function(_a2) {
          var expectedPathsPerAlt = _a2.expectedPathsPerAlt, actual = _a2.actual, previous = _a2.previous, customUserDescription = _a2.customUserDescription, ruleName = _a2.ruleName;
          var errPrefix = "Expecting: ";
          var actualText = (0, first_1.default)(actual).image;
          var errSuffix = "\nbut found: '" + actualText + "'";
          if (customUserDescription) {
            return errPrefix + customUserDescription + errSuffix;
          } else {
            var allLookAheadPaths = (0, reduce_1.default)(expectedPathsPerAlt, function(result, currAltPaths) {
              return result.concat(currAltPaths);
            }, []);
            var nextValidTokenSequences = (0, map_1.default)(allLookAheadPaths, function(currPath) {
              return "[".concat((0, map_1.default)(currPath, function(currTokenType) {
                return (0, tokens_public_1.tokenLabel)(currTokenType);
              }).join(", "), "]");
            });
            var nextValidSequenceItems = (0, map_1.default)(nextValidTokenSequences, function(itemMsg, idx) {
              return "  ".concat(idx + 1, ". ").concat(itemMsg);
            });
            var calculatedDescription = "one of these possible Token sequences:\n".concat(nextValidSequenceItems.join("\n"));
            return errPrefix + calculatedDescription + errSuffix;
          }
        },
        buildEarlyExitMessage: function(_a2) {
          var expectedIterationPaths = _a2.expectedIterationPaths, actual = _a2.actual, customUserDescription = _a2.customUserDescription, ruleName = _a2.ruleName;
          var errPrefix = "Expecting: ";
          var actualText = (0, first_1.default)(actual).image;
          var errSuffix = "\nbut found: '" + actualText + "'";
          if (customUserDescription) {
            return errPrefix + customUserDescription + errSuffix;
          } else {
            var nextValidTokenSequences = (0, map_1.default)(expectedIterationPaths, function(currPath) {
              return "[".concat((0, map_1.default)(currPath, function(currTokenType) {
                return (0, tokens_public_1.tokenLabel)(currTokenType);
              }).join(","), "]");
            });
            var calculatedDescription = "expecting at least one iteration which starts with one of these possible Token sequences::\n  " + "<".concat(nextValidTokenSequences.join(" ,"), ">");
            return errPrefix + calculatedDescription + errSuffix;
          }
        }
      };
      Object.freeze(exports2.defaultParserErrorProvider);
      exports2.defaultGrammarResolverErrorProvider = {
        buildRuleNotFoundError: function(topLevelRule, undefinedRule) {
          var msg = "Invalid grammar, reference to a rule which is not defined: ->" + undefinedRule.nonTerminalName + "<-\ninside top level rule: ->" + topLevelRule.name + "<-";
          return msg;
        }
      };
      exports2.defaultGrammarValidatorErrorProvider = {
        buildDuplicateFoundError: function(topLevelRule, duplicateProds) {
          function getExtraProductionArgument(prod) {
            if (prod instanceof gast_1.Terminal) {
              return prod.terminalType.name;
            } else if (prod instanceof gast_1.NonTerminal) {
              return prod.nonTerminalName;
            } else {
              return "";
            }
          }
          var topLevelName = topLevelRule.name;
          var duplicateProd = (0, first_1.default)(duplicateProds);
          var index = duplicateProd.idx;
          var dslName = (0, gast_2.getProductionDslName)(duplicateProd);
          var extraArgument = getExtraProductionArgument(duplicateProd);
          var hasExplicitIndex = index > 0;
          var msg = "->".concat(dslName).concat(hasExplicitIndex ? index : "", "<- ").concat(extraArgument ? "with argument: ->".concat(extraArgument, "<-") : "", "\n                  appears more than once (").concat(duplicateProds.length, " times) in the top level rule: ->").concat(topLevelName, "<-.                  \n                  For further details see: https://chevrotain.io/docs/FAQ.html#NUMERICAL_SUFFIXES \n                  ");
          msg = msg.replace(/[ \t]+/g, " ");
          msg = msg.replace(/\s\s+/g, "\n");
          return msg;
        },
        buildNamespaceConflictError: function(rule) {
          var errMsg = "Namespace conflict found in grammar.\n" + "The grammar has both a Terminal(Token) and a Non-Terminal(Rule) named: <".concat(rule.name, ">.\n") + "To resolve this make sure each Terminal and Non-Terminal names are unique\nThis is easy to accomplish by using the convention that Terminal names start with an uppercase letter\nand Non-Terminal names start with a lower case letter.";
          return errMsg;
        },
        buildAlternationPrefixAmbiguityError: function(options) {
          var pathMsg = (0, map_1.default)(options.prefixPath, function(currTok) {
            return (0, tokens_public_1.tokenLabel)(currTok);
          }).join(", ");
          var occurrence = options.alternation.idx === 0 ? "" : options.alternation.idx;
          var errMsg = "Ambiguous alternatives: <".concat(options.ambiguityIndices.join(" ,"), "> due to common lookahead prefix\n") + "in <OR".concat(occurrence, "> inside <").concat(options.topLevelRule.name, "> Rule,\n") + "<".concat(pathMsg, "> may appears as a prefix path in all these alternatives.\n") + "See: https://chevrotain.io/docs/guide/resolving_grammar_errors.html#COMMON_PREFIX\nFor Further details.";
          return errMsg;
        },
        buildAlternationAmbiguityError: function(options) {
          var pathMsg = (0, map_1.default)(options.prefixPath, function(currtok) {
            return (0, tokens_public_1.tokenLabel)(currtok);
          }).join(", ");
          var occurrence = options.alternation.idx === 0 ? "" : options.alternation.idx;
          var currMessage = "Ambiguous Alternatives Detected: <".concat(options.ambiguityIndices.join(" ,"), "> in <OR").concat(occurrence, ">") + " inside <".concat(options.topLevelRule.name, "> Rule,\n") + "<".concat(pathMsg, "> may appears as a prefix path in all these alternatives.\n");
          currMessage = currMessage + "See: https://chevrotain.io/docs/guide/resolving_grammar_errors.html#AMBIGUOUS_ALTERNATIVES\nFor Further details.";
          return currMessage;
        },
        buildEmptyRepetitionError: function(options) {
          var dslName = (0, gast_2.getProductionDslName)(options.repetition);
          if (options.repetition.idx !== 0) {
            dslName += options.repetition.idx;
          }
          var errMsg = "The repetition <".concat(dslName, "> within Rule <").concat(options.topLevelRule.name, "> can never consume any tokens.\n") + "This could lead to an infinite loop.";
          return errMsg;
        },
        // TODO: remove - `errors_public` from nyc.config.js exclude
        //       once this method is fully removed from this file
        buildTokenNameError: function(options) {
          return "deprecated";
        },
        buildEmptyAlternationError: function(options) {
          var errMsg = "Ambiguous empty alternative: <".concat(options.emptyChoiceIdx + 1, ">") + " in <OR".concat(options.alternation.idx, "> inside <").concat(options.topLevelRule.name, "> Rule.\n") + "Only the last alternative may be an empty alternative.";
          return errMsg;
        },
        buildTooManyAlternativesError: function(options) {
          var errMsg = "An Alternation cannot have more than 256 alternatives:\n" + "<OR".concat(options.alternation.idx, "> inside <").concat(options.topLevelRule.name, "> Rule.\n has ").concat(options.alternation.definition.length + 1, " alternatives.");
          return errMsg;
        },
        buildLeftRecursionError: function(options) {
          var ruleName = options.topLevelRule.name;
          var pathNames = (0, map_1.default)(options.leftRecursionPath, function(currRule) {
            return currRule.name;
          });
          var leftRecursivePath = "".concat(ruleName, " --> ").concat(pathNames.concat([ruleName]).join(" --> "));
          var errMsg = "Left Recursion found in grammar.\n" + "rule: <".concat(ruleName, "> can be invoked from itself (directly or indirectly)\n") + "without consuming any Tokens. The grammar path that causes this is: \n ".concat(leftRecursivePath, "\n") + " To fix this refactor your grammar to remove the left recursion.\nsee: https://en.wikipedia.org/wiki/LL_parser#Left_factoring.";
          return errMsg;
        },
        // TODO: remove - `errors_public` from nyc.config.js exclude
        //       once this method is fully removed from this file
        buildInvalidRuleNameError: function(options) {
          return "deprecated";
        },
        buildDuplicateRuleNameError: function(options) {
          var ruleName;
          if (options.topLevelRule instanceof gast_1.Rule) {
            ruleName = options.topLevelRule.name;
          } else {
            ruleName = options.topLevelRule;
          }
          var errMsg = "Duplicate definition, rule: ->".concat(ruleName, "<- is already defined in the grammar: ->").concat(options.grammarName, "<-");
          return errMsg;
        }
      };
    }
  });

  // node_modules/.pnpm/chevrotain@10.5.0/node_modules/chevrotain/lib/src/parse/grammar/resolver.js
  var require_resolver = __commonJS({
    "node_modules/.pnpm/chevrotain@10.5.0/node_modules/chevrotain/lib/src/parse/grammar/resolver.js"(exports2) {
      "use strict";
      var __extends = exports2 && exports2.__extends || function() {
        var extendStatics = function(d, b) {
          extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b3) {
            d2.__proto__ = b3;
          } || function(d2, b3) {
            for (var p in b3)
              if (Object.prototype.hasOwnProperty.call(b3, p))
                d2[p] = b3[p];
          };
          return extendStatics(d, b);
        };
        return function(d, b) {
          if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
          extendStatics(d, b);
          function __() {
            this.constructor = d;
          }
          d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
        };
      }();
      var __importDefault = exports2 && exports2.__importDefault || function(mod) {
        return mod && mod.__esModule ? mod : { "default": mod };
      };
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.GastRefResolverVisitor = exports2.resolveGrammar = void 0;
      var parser_1 = require_parser();
      var forEach_1 = __importDefault(require_forEach());
      var values_1 = __importDefault(require_values());
      var gast_1 = require_api2();
      function resolveGrammar(topLevels, errMsgProvider) {
        var refResolver = new GastRefResolverVisitor(topLevels, errMsgProvider);
        refResolver.resolveRefs();
        return refResolver.errors;
      }
      exports2.resolveGrammar = resolveGrammar;
      var GastRefResolverVisitor = (
        /** @class */
        function(_super) {
          __extends(GastRefResolverVisitor2, _super);
          function GastRefResolverVisitor2(nameToTopRule, errMsgProvider) {
            var _this = _super.call(this) || this;
            _this.nameToTopRule = nameToTopRule;
            _this.errMsgProvider = errMsgProvider;
            _this.errors = [];
            return _this;
          }
          GastRefResolverVisitor2.prototype.resolveRefs = function() {
            var _this = this;
            (0, forEach_1.default)((0, values_1.default)(this.nameToTopRule), function(prod) {
              _this.currTopLevel = prod;
              prod.accept(_this);
            });
          };
          GastRefResolverVisitor2.prototype.visitNonTerminal = function(node) {
            var ref = this.nameToTopRule[node.nonTerminalName];
            if (!ref) {
              var msg = this.errMsgProvider.buildRuleNotFoundError(this.currTopLevel, node);
              this.errors.push({
                message: msg,
                type: parser_1.ParserDefinitionErrorType.UNRESOLVED_SUBRULE_REF,
                ruleName: this.currTopLevel.name,
                unresolvedRefName: node.nonTerminalName
              });
            } else {
              node.referencedRule = ref;
            }
          };
          return GastRefResolverVisitor2;
        }(gast_1.GAstVisitor)
      );
      exports2.GastRefResolverVisitor = GastRefResolverVisitor;
    }
  });

  // node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_arrayAggregator.js
  var require_arrayAggregator = __commonJS({
    "node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_arrayAggregator.js"(exports2, module2) {
      function arrayAggregator(array, setter, iteratee, accumulator) {
        var index = -1, length = array == null ? 0 : array.length;
        while (++index < length) {
          var value = array[index];
          setter(accumulator, value, iteratee(value), array);
        }
        return accumulator;
      }
      module2.exports = arrayAggregator;
    }
  });

  // node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_baseAggregator.js
  var require_baseAggregator = __commonJS({
    "node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_baseAggregator.js"(exports2, module2) {
      var baseEach = require_baseEach();
      function baseAggregator(collection, setter, iteratee, accumulator) {
        baseEach(collection, function(value, key, collection2) {
          setter(accumulator, value, iteratee(value), collection2);
        });
        return accumulator;
      }
      module2.exports = baseAggregator;
    }
  });

  // node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_createAggregator.js
  var require_createAggregator = __commonJS({
    "node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_createAggregator.js"(exports2, module2) {
      var arrayAggregator = require_arrayAggregator();
      var baseAggregator = require_baseAggregator();
      var baseIteratee = require_baseIteratee();
      var isArray = require_isArray();
      function createAggregator(setter, initializer) {
        return function(collection, iteratee) {
          var func = isArray(collection) ? arrayAggregator : baseAggregator, accumulator = initializer ? initializer() : {};
          return func(collection, setter, baseIteratee(iteratee, 2), accumulator);
        };
      }
      module2.exports = createAggregator;
    }
  });

  // node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/groupBy.js
  var require_groupBy = __commonJS({
    "node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/groupBy.js"(exports2, module2) {
      var baseAssignValue = require_baseAssignValue();
      var createAggregator = require_createAggregator();
      var objectProto = Object.prototype;
      var hasOwnProperty = objectProto.hasOwnProperty;
      var groupBy = createAggregator(function(result, value, key) {
        if (hasOwnProperty.call(result, key)) {
          result[key].push(value);
        } else {
          baseAssignValue(result, key, [value]);
        }
      });
      module2.exports = groupBy;
    }
  });

  // node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/flatMap.js
  var require_flatMap = __commonJS({
    "node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/flatMap.js"(exports2, module2) {
      var baseFlatten = require_baseFlatten();
      var map = require_map();
      function flatMap(collection, iteratee) {
        return baseFlatten(map(collection, iteratee), 1);
      }
      module2.exports = flatMap;
    }
  });

  // node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/dropRight.js
  var require_dropRight = __commonJS({
    "node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/dropRight.js"(exports2, module2) {
      var baseSlice = require_baseSlice();
      var toInteger = require_toInteger();
      function dropRight(array, n, guard) {
        var length = array == null ? 0 : array.length;
        if (!length) {
          return [];
        }
        n = guard || n === void 0 ? 1 : toInteger(n);
        n = length - n;
        return baseSlice(array, 0, n < 0 ? 0 : n);
      }
      module2.exports = dropRight;
    }
  });

  // node_modules/.pnpm/chevrotain@10.5.0/node_modules/chevrotain/lib/src/parse/grammar/interpreter.js
  var require_interpreter = __commonJS({
    "node_modules/.pnpm/chevrotain@10.5.0/node_modules/chevrotain/lib/src/parse/grammar/interpreter.js"(exports2) {
      "use strict";
      var __extends = exports2 && exports2.__extends || function() {
        var extendStatics = function(d, b) {
          extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b3) {
            d2.__proto__ = b3;
          } || function(d2, b3) {
            for (var p in b3)
              if (Object.prototype.hasOwnProperty.call(b3, p))
                d2[p] = b3[p];
          };
          return extendStatics(d, b);
        };
        return function(d, b) {
          if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
          extendStatics(d, b);
          function __() {
            this.constructor = d;
          }
          d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
        };
      }();
      var __importDefault = exports2 && exports2.__importDefault || function(mod) {
        return mod && mod.__esModule ? mod : { "default": mod };
      };
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.nextPossibleTokensAfter = exports2.possiblePathsFrom = exports2.NextTerminalAfterAtLeastOneSepWalker = exports2.NextTerminalAfterAtLeastOneWalker = exports2.NextTerminalAfterManySepWalker = exports2.NextTerminalAfterManyWalker = exports2.AbstractNextTerminalAfterProductionWalker = exports2.NextAfterTokenWalker = exports2.AbstractNextPossibleTokensWalker = void 0;
      var rest_1 = require_rest();
      var first_1 = __importDefault(require_first2());
      var isEmpty_1 = __importDefault(require_isEmpty());
      var dropRight_1 = __importDefault(require_dropRight());
      var drop_1 = __importDefault(require_drop());
      var last_1 = __importDefault(require_last());
      var forEach_1 = __importDefault(require_forEach());
      var clone_1 = __importDefault(require_clone());
      var first_2 = require_first();
      var gast_1 = require_api2();
      var AbstractNextPossibleTokensWalker = (
        /** @class */
        function(_super) {
          __extends(AbstractNextPossibleTokensWalker2, _super);
          function AbstractNextPossibleTokensWalker2(topProd, path4) {
            var _this = _super.call(this) || this;
            _this.topProd = topProd;
            _this.path = path4;
            _this.possibleTokTypes = [];
            _this.nextProductionName = "";
            _this.nextProductionOccurrence = 0;
            _this.found = false;
            _this.isAtEndOfPath = false;
            return _this;
          }
          AbstractNextPossibleTokensWalker2.prototype.startWalking = function() {
            this.found = false;
            if (this.path.ruleStack[0] !== this.topProd.name) {
              throw Error("The path does not start with the walker's top Rule!");
            }
            this.ruleStack = (0, clone_1.default)(this.path.ruleStack).reverse();
            this.occurrenceStack = (0, clone_1.default)(this.path.occurrenceStack).reverse();
            this.ruleStack.pop();
            this.occurrenceStack.pop();
            this.updateExpectedNext();
            this.walk(this.topProd);
            return this.possibleTokTypes;
          };
          AbstractNextPossibleTokensWalker2.prototype.walk = function(prod, prevRest) {
            if (prevRest === void 0) {
              prevRest = [];
            }
            if (!this.found) {
              _super.prototype.walk.call(this, prod, prevRest);
            }
          };
          AbstractNextPossibleTokensWalker2.prototype.walkProdRef = function(refProd, currRest, prevRest) {
            if (refProd.referencedRule.name === this.nextProductionName && refProd.idx === this.nextProductionOccurrence) {
              var fullRest = currRest.concat(prevRest);
              this.updateExpectedNext();
              this.walk(refProd.referencedRule, fullRest);
            }
          };
          AbstractNextPossibleTokensWalker2.prototype.updateExpectedNext = function() {
            if ((0, isEmpty_1.default)(this.ruleStack)) {
              this.nextProductionName = "";
              this.nextProductionOccurrence = 0;
              this.isAtEndOfPath = true;
            } else {
              this.nextProductionName = this.ruleStack.pop();
              this.nextProductionOccurrence = this.occurrenceStack.pop();
            }
          };
          return AbstractNextPossibleTokensWalker2;
        }(rest_1.RestWalker)
      );
      exports2.AbstractNextPossibleTokensWalker = AbstractNextPossibleTokensWalker;
      var NextAfterTokenWalker = (
        /** @class */
        function(_super) {
          __extends(NextAfterTokenWalker2, _super);
          function NextAfterTokenWalker2(topProd, path4) {
            var _this = _super.call(this, topProd, path4) || this;
            _this.path = path4;
            _this.nextTerminalName = "";
            _this.nextTerminalOccurrence = 0;
            _this.nextTerminalName = _this.path.lastTok.name;
            _this.nextTerminalOccurrence = _this.path.lastTokOccurrence;
            return _this;
          }
          NextAfterTokenWalker2.prototype.walkTerminal = function(terminal, currRest, prevRest) {
            if (this.isAtEndOfPath && terminal.terminalType.name === this.nextTerminalName && terminal.idx === this.nextTerminalOccurrence && !this.found) {
              var fullRest = currRest.concat(prevRest);
              var restProd = new gast_1.Alternative({ definition: fullRest });
              this.possibleTokTypes = (0, first_2.first)(restProd);
              this.found = true;
            }
          };
          return NextAfterTokenWalker2;
        }(AbstractNextPossibleTokensWalker)
      );
      exports2.NextAfterTokenWalker = NextAfterTokenWalker;
      var AbstractNextTerminalAfterProductionWalker = (
        /** @class */
        function(_super) {
          __extends(AbstractNextTerminalAfterProductionWalker2, _super);
          function AbstractNextTerminalAfterProductionWalker2(topRule, occurrence) {
            var _this = _super.call(this) || this;
            _this.topRule = topRule;
            _this.occurrence = occurrence;
            _this.result = {
              token: void 0,
              occurrence: void 0,
              isEndOfRule: void 0
            };
            return _this;
          }
          AbstractNextTerminalAfterProductionWalker2.prototype.startWalking = function() {
            this.walk(this.topRule);
            return this.result;
          };
          return AbstractNextTerminalAfterProductionWalker2;
        }(rest_1.RestWalker)
      );
      exports2.AbstractNextTerminalAfterProductionWalker = AbstractNextTerminalAfterProductionWalker;
      var NextTerminalAfterManyWalker = (
        /** @class */
        function(_super) {
          __extends(NextTerminalAfterManyWalker2, _super);
          function NextTerminalAfterManyWalker2() {
            return _super !== null && _super.apply(this, arguments) || this;
          }
          NextTerminalAfterManyWalker2.prototype.walkMany = function(manyProd, currRest, prevRest) {
            if (manyProd.idx === this.occurrence) {
              var firstAfterMany = (0, first_1.default)(currRest.concat(prevRest));
              this.result.isEndOfRule = firstAfterMany === void 0;
              if (firstAfterMany instanceof gast_1.Terminal) {
                this.result.token = firstAfterMany.terminalType;
                this.result.occurrence = firstAfterMany.idx;
              }
            } else {
              _super.prototype.walkMany.call(this, manyProd, currRest, prevRest);
            }
          };
          return NextTerminalAfterManyWalker2;
        }(AbstractNextTerminalAfterProductionWalker)
      );
      exports2.NextTerminalAfterManyWalker = NextTerminalAfterManyWalker;
      var NextTerminalAfterManySepWalker = (
        /** @class */
        function(_super) {
          __extends(NextTerminalAfterManySepWalker2, _super);
          function NextTerminalAfterManySepWalker2() {
            return _super !== null && _super.apply(this, arguments) || this;
          }
          NextTerminalAfterManySepWalker2.prototype.walkManySep = function(manySepProd, currRest, prevRest) {
            if (manySepProd.idx === this.occurrence) {
              var firstAfterManySep = (0, first_1.default)(currRest.concat(prevRest));
              this.result.isEndOfRule = firstAfterManySep === void 0;
              if (firstAfterManySep instanceof gast_1.Terminal) {
                this.result.token = firstAfterManySep.terminalType;
                this.result.occurrence = firstAfterManySep.idx;
              }
            } else {
              _super.prototype.walkManySep.call(this, manySepProd, currRest, prevRest);
            }
          };
          return NextTerminalAfterManySepWalker2;
        }(AbstractNextTerminalAfterProductionWalker)
      );
      exports2.NextTerminalAfterManySepWalker = NextTerminalAfterManySepWalker;
      var NextTerminalAfterAtLeastOneWalker = (
        /** @class */
        function(_super) {
          __extends(NextTerminalAfterAtLeastOneWalker2, _super);
          function NextTerminalAfterAtLeastOneWalker2() {
            return _super !== null && _super.apply(this, arguments) || this;
          }
          NextTerminalAfterAtLeastOneWalker2.prototype.walkAtLeastOne = function(atLeastOneProd, currRest, prevRest) {
            if (atLeastOneProd.idx === this.occurrence) {
              var firstAfterAtLeastOne = (0, first_1.default)(currRest.concat(prevRest));
              this.result.isEndOfRule = firstAfterAtLeastOne === void 0;
              if (firstAfterAtLeastOne instanceof gast_1.Terminal) {
                this.result.token = firstAfterAtLeastOne.terminalType;
                this.result.occurrence = firstAfterAtLeastOne.idx;
              }
            } else {
              _super.prototype.walkAtLeastOne.call(this, atLeastOneProd, currRest, prevRest);
            }
          };
          return NextTerminalAfterAtLeastOneWalker2;
        }(AbstractNextTerminalAfterProductionWalker)
      );
      exports2.NextTerminalAfterAtLeastOneWalker = NextTerminalAfterAtLeastOneWalker;
      var NextTerminalAfterAtLeastOneSepWalker = (
        /** @class */
        function(_super) {
          __extends(NextTerminalAfterAtLeastOneSepWalker2, _super);
          function NextTerminalAfterAtLeastOneSepWalker2() {
            return _super !== null && _super.apply(this, arguments) || this;
          }
          NextTerminalAfterAtLeastOneSepWalker2.prototype.walkAtLeastOneSep = function(atleastOneSepProd, currRest, prevRest) {
            if (atleastOneSepProd.idx === this.occurrence) {
              var firstAfterfirstAfterAtLeastOneSep = (0, first_1.default)(currRest.concat(prevRest));
              this.result.isEndOfRule = firstAfterfirstAfterAtLeastOneSep === void 0;
              if (firstAfterfirstAfterAtLeastOneSep instanceof gast_1.Terminal) {
                this.result.token = firstAfterfirstAfterAtLeastOneSep.terminalType;
                this.result.occurrence = firstAfterfirstAfterAtLeastOneSep.idx;
              }
            } else {
              _super.prototype.walkAtLeastOneSep.call(this, atleastOneSepProd, currRest, prevRest);
            }
          };
          return NextTerminalAfterAtLeastOneSepWalker2;
        }(AbstractNextTerminalAfterProductionWalker)
      );
      exports2.NextTerminalAfterAtLeastOneSepWalker = NextTerminalAfterAtLeastOneSepWalker;
      function possiblePathsFrom(targetDef, maxLength, currPath) {
        if (currPath === void 0) {
          currPath = [];
        }
        currPath = (0, clone_1.default)(currPath);
        var result = [];
        var i = 0;
        function remainingPathWith(nextDef) {
          return nextDef.concat((0, drop_1.default)(targetDef, i + 1));
        }
        function getAlternativesForProd(definition) {
          var alternatives = possiblePathsFrom(remainingPathWith(definition), maxLength, currPath);
          return result.concat(alternatives);
        }
        while (currPath.length < maxLength && i < targetDef.length) {
          var prod = targetDef[i];
          if (prod instanceof gast_1.Alternative) {
            return getAlternativesForProd(prod.definition);
          } else if (prod instanceof gast_1.NonTerminal) {
            return getAlternativesForProd(prod.definition);
          } else if (prod instanceof gast_1.Option) {
            result = getAlternativesForProd(prod.definition);
          } else if (prod instanceof gast_1.RepetitionMandatory) {
            var newDef = prod.definition.concat([
              new gast_1.Repetition({
                definition: prod.definition
              })
            ]);
            return getAlternativesForProd(newDef);
          } else if (prod instanceof gast_1.RepetitionMandatoryWithSeparator) {
            var newDef = [
              new gast_1.Alternative({ definition: prod.definition }),
              new gast_1.Repetition({
                definition: [new gast_1.Terminal({ terminalType: prod.separator })].concat(prod.definition)
              })
            ];
            return getAlternativesForProd(newDef);
          } else if (prod instanceof gast_1.RepetitionWithSeparator) {
            var newDef = prod.definition.concat([
              new gast_1.Repetition({
                definition: [new gast_1.Terminal({ terminalType: prod.separator })].concat(prod.definition)
              })
            ]);
            result = getAlternativesForProd(newDef);
          } else if (prod instanceof gast_1.Repetition) {
            var newDef = prod.definition.concat([
              new gast_1.Repetition({
                definition: prod.definition
              })
            ]);
            result = getAlternativesForProd(newDef);
          } else if (prod instanceof gast_1.Alternation) {
            (0, forEach_1.default)(prod.definition, function(currAlt) {
              if ((0, isEmpty_1.default)(currAlt.definition) === false) {
                result = getAlternativesForProd(currAlt.definition);
              }
            });
            return result;
          } else if (prod instanceof gast_1.Terminal) {
            currPath.push(prod.terminalType);
          } else {
            throw Error("non exhaustive match");
          }
          i++;
        }
        result.push({
          partialPath: currPath,
          suffixDef: (0, drop_1.default)(targetDef, i)
        });
        return result;
      }
      exports2.possiblePathsFrom = possiblePathsFrom;
      function nextPossibleTokensAfter(initialDef, tokenVector, tokMatcher, maxLookAhead) {
        var EXIT_NON_TERMINAL = "EXIT_NONE_TERMINAL";
        var EXIT_NON_TERMINAL_ARR = [EXIT_NON_TERMINAL];
        var EXIT_ALTERNATIVE = "EXIT_ALTERNATIVE";
        var foundCompletePath = false;
        var tokenVectorLength = tokenVector.length;
        var minimalAlternativesIndex = tokenVectorLength - maxLookAhead - 1;
        var result = [];
        var possiblePaths = [];
        possiblePaths.push({
          idx: -1,
          def: initialDef,
          ruleStack: [],
          occurrenceStack: []
        });
        while (!(0, isEmpty_1.default)(possiblePaths)) {
          var currPath = possiblePaths.pop();
          if (currPath === EXIT_ALTERNATIVE) {
            if (foundCompletePath && (0, last_1.default)(possiblePaths).idx <= minimalAlternativesIndex) {
              possiblePaths.pop();
            }
            continue;
          }
          var currDef = currPath.def;
          var currIdx = currPath.idx;
          var currRuleStack = currPath.ruleStack;
          var currOccurrenceStack = currPath.occurrenceStack;
          if ((0, isEmpty_1.default)(currDef)) {
            continue;
          }
          var prod = currDef[0];
          if (prod === EXIT_NON_TERMINAL) {
            var nextPath = {
              idx: currIdx,
              def: (0, drop_1.default)(currDef),
              ruleStack: (0, dropRight_1.default)(currRuleStack),
              occurrenceStack: (0, dropRight_1.default)(currOccurrenceStack)
            };
            possiblePaths.push(nextPath);
          } else if (prod instanceof gast_1.Terminal) {
            if (currIdx < tokenVectorLength - 1) {
              var nextIdx = currIdx + 1;
              var actualToken = tokenVector[nextIdx];
              if (tokMatcher(actualToken, prod.terminalType)) {
                var nextPath = {
                  idx: nextIdx,
                  def: (0, drop_1.default)(currDef),
                  ruleStack: currRuleStack,
                  occurrenceStack: currOccurrenceStack
                };
                possiblePaths.push(nextPath);
              }
            } else if (currIdx === tokenVectorLength - 1) {
              result.push({
                nextTokenType: prod.terminalType,
                nextTokenOccurrence: prod.idx,
                ruleStack: currRuleStack,
                occurrenceStack: currOccurrenceStack
              });
              foundCompletePath = true;
            } else {
              throw Error("non exhaustive match");
            }
          } else if (prod instanceof gast_1.NonTerminal) {
            var newRuleStack = (0, clone_1.default)(currRuleStack);
            newRuleStack.push(prod.nonTerminalName);
            var newOccurrenceStack = (0, clone_1.default)(currOccurrenceStack);
            newOccurrenceStack.push(prod.idx);
            var nextPath = {
              idx: currIdx,
              def: prod.definition.concat(EXIT_NON_TERMINAL_ARR, (0, drop_1.default)(currDef)),
              ruleStack: newRuleStack,
              occurrenceStack: newOccurrenceStack
            };
            possiblePaths.push(nextPath);
          } else if (prod instanceof gast_1.Option) {
            var nextPathWithout = {
              idx: currIdx,
              def: (0, drop_1.default)(currDef),
              ruleStack: currRuleStack,
              occurrenceStack: currOccurrenceStack
            };
            possiblePaths.push(nextPathWithout);
            possiblePaths.push(EXIT_ALTERNATIVE);
            var nextPathWith = {
              idx: currIdx,
              def: prod.definition.concat((0, drop_1.default)(currDef)),
              ruleStack: currRuleStack,
              occurrenceStack: currOccurrenceStack
            };
            possiblePaths.push(nextPathWith);
          } else if (prod instanceof gast_1.RepetitionMandatory) {
            var secondIteration = new gast_1.Repetition({
              definition: prod.definition,
              idx: prod.idx
            });
            var nextDef = prod.definition.concat([secondIteration], (0, drop_1.default)(currDef));
            var nextPath = {
              idx: currIdx,
              def: nextDef,
              ruleStack: currRuleStack,
              occurrenceStack: currOccurrenceStack
            };
            possiblePaths.push(nextPath);
          } else if (prod instanceof gast_1.RepetitionMandatoryWithSeparator) {
            var separatorGast = new gast_1.Terminal({
              terminalType: prod.separator
            });
            var secondIteration = new gast_1.Repetition({
              definition: [separatorGast].concat(prod.definition),
              idx: prod.idx
            });
            var nextDef = prod.definition.concat([secondIteration], (0, drop_1.default)(currDef));
            var nextPath = {
              idx: currIdx,
              def: nextDef,
              ruleStack: currRuleStack,
              occurrenceStack: currOccurrenceStack
            };
            possiblePaths.push(nextPath);
          } else if (prod instanceof gast_1.RepetitionWithSeparator) {
            var nextPathWithout = {
              idx: currIdx,
              def: (0, drop_1.default)(currDef),
              ruleStack: currRuleStack,
              occurrenceStack: currOccurrenceStack
            };
            possiblePaths.push(nextPathWithout);
            possiblePaths.push(EXIT_ALTERNATIVE);
            var separatorGast = new gast_1.Terminal({
              terminalType: prod.separator
            });
            var nthRepetition = new gast_1.Repetition({
              definition: [separatorGast].concat(prod.definition),
              idx: prod.idx
            });
            var nextDef = prod.definition.concat([nthRepetition], (0, drop_1.default)(currDef));
            var nextPathWith = {
              idx: currIdx,
              def: nextDef,
              ruleStack: currRuleStack,
              occurrenceStack: currOccurrenceStack
            };
            possiblePaths.push(nextPathWith);
          } else if (prod instanceof gast_1.Repetition) {
            var nextPathWithout = {
              idx: currIdx,
              def: (0, drop_1.default)(currDef),
              ruleStack: currRuleStack,
              occurrenceStack: currOccurrenceStack
            };
            possiblePaths.push(nextPathWithout);
            possiblePaths.push(EXIT_ALTERNATIVE);
            var nthRepetition = new gast_1.Repetition({
              definition: prod.definition,
              idx: prod.idx
            });
            var nextDef = prod.definition.concat([nthRepetition], (0, drop_1.default)(currDef));
            var nextPathWith = {
              idx: currIdx,
              def: nextDef,
              ruleStack: currRuleStack,
              occurrenceStack: currOccurrenceStack
            };
            possiblePaths.push(nextPathWith);
          } else if (prod instanceof gast_1.Alternation) {
            for (var i = prod.definition.length - 1; i >= 0; i--) {
              var currAlt = prod.definition[i];
              var currAltPath = {
                idx: currIdx,
                def: currAlt.definition.concat((0, drop_1.default)(currDef)),
                ruleStack: currRuleStack,
                occurrenceStack: currOccurrenceStack
              };
              possiblePaths.push(currAltPath);
              possiblePaths.push(EXIT_ALTERNATIVE);
            }
          } else if (prod instanceof gast_1.Alternative) {
            possiblePaths.push({
              idx: currIdx,
              def: prod.definition.concat((0, drop_1.default)(currDef)),
              ruleStack: currRuleStack,
              occurrenceStack: currOccurrenceStack
            });
          } else if (prod instanceof gast_1.Rule) {
            possiblePaths.push(expandTopLevelRule(prod, currIdx, currRuleStack, currOccurrenceStack));
          } else {
            throw Error("non exhaustive match");
          }
        }
        return result;
      }
      exports2.nextPossibleTokensAfter = nextPossibleTokensAfter;
      function expandTopLevelRule(topRule, currIdx, currRuleStack, currOccurrenceStack) {
        var newRuleStack = (0, clone_1.default)(currRuleStack);
        newRuleStack.push(topRule.name);
        var newCurrOccurrenceStack = (0, clone_1.default)(currOccurrenceStack);
        newCurrOccurrenceStack.push(1);
        return {
          idx: currIdx,
          def: topRule.definition,
          ruleStack: newRuleStack,
          occurrenceStack: newCurrOccurrenceStack
        };
      }
    }
  });

  // node_modules/.pnpm/chevrotain@10.5.0/node_modules/chevrotain/lib/src/parse/grammar/lookahead.js
  var require_lookahead = __commonJS({
    "node_modules/.pnpm/chevrotain@10.5.0/node_modules/chevrotain/lib/src/parse/grammar/lookahead.js"(exports2) {
      "use strict";
      var __extends = exports2 && exports2.__extends || function() {
        var extendStatics = function(d, b) {
          extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b3) {
            d2.__proto__ = b3;
          } || function(d2, b3) {
            for (var p in b3)
              if (Object.prototype.hasOwnProperty.call(b3, p))
                d2[p] = b3[p];
          };
          return extendStatics(d, b);
        };
        return function(d, b) {
          if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
          extendStatics(d, b);
          function __() {
            this.constructor = d;
          }
          d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
        };
      }();
      var __importDefault = exports2 && exports2.__importDefault || function(mod) {
        return mod && mod.__esModule ? mod : { "default": mod };
      };
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.areTokenCategoriesNotUsed = exports2.isStrictPrefixOfPath = exports2.containsPath = exports2.getLookaheadPathsForOptionalProd = exports2.getLookaheadPathsForOr = exports2.lookAheadSequenceFromAlternatives = exports2.buildSingleAlternativeLookaheadFunction = exports2.buildAlternativesLookAheadFunc = exports2.buildLookaheadFuncForOptionalProd = exports2.buildLookaheadFuncForOr = exports2.getLookaheadPaths = exports2.getProdType = exports2.PROD_TYPE = void 0;
      var isEmpty_1 = __importDefault(require_isEmpty());
      var flatten_1 = __importDefault(require_flatten());
      var every_1 = __importDefault(require_every());
      var map_1 = __importDefault(require_map());
      var forEach_1 = __importDefault(require_forEach());
      var has_1 = __importDefault(require_has());
      var reduce_1 = __importDefault(require_reduce());
      var interpreter_1 = require_interpreter();
      var rest_1 = require_rest();
      var tokens_1 = require_tokens();
      var gast_1 = require_api2();
      var gast_2 = require_api2();
      var PROD_TYPE;
      (function(PROD_TYPE2) {
        PROD_TYPE2[PROD_TYPE2["OPTION"] = 0] = "OPTION";
        PROD_TYPE2[PROD_TYPE2["REPETITION"] = 1] = "REPETITION";
        PROD_TYPE2[PROD_TYPE2["REPETITION_MANDATORY"] = 2] = "REPETITION_MANDATORY";
        PROD_TYPE2[PROD_TYPE2["REPETITION_MANDATORY_WITH_SEPARATOR"] = 3] = "REPETITION_MANDATORY_WITH_SEPARATOR";
        PROD_TYPE2[PROD_TYPE2["REPETITION_WITH_SEPARATOR"] = 4] = "REPETITION_WITH_SEPARATOR";
        PROD_TYPE2[PROD_TYPE2["ALTERNATION"] = 5] = "ALTERNATION";
      })(PROD_TYPE = exports2.PROD_TYPE || (exports2.PROD_TYPE = {}));
      function getProdType(prod) {
        if (prod instanceof gast_1.Option || prod === "Option") {
          return PROD_TYPE.OPTION;
        } else if (prod instanceof gast_1.Repetition || prod === "Repetition") {
          return PROD_TYPE.REPETITION;
        } else if (prod instanceof gast_1.RepetitionMandatory || prod === "RepetitionMandatory") {
          return PROD_TYPE.REPETITION_MANDATORY;
        } else if (prod instanceof gast_1.RepetitionMandatoryWithSeparator || prod === "RepetitionMandatoryWithSeparator") {
          return PROD_TYPE.REPETITION_MANDATORY_WITH_SEPARATOR;
        } else if (prod instanceof gast_1.RepetitionWithSeparator || prod === "RepetitionWithSeparator") {
          return PROD_TYPE.REPETITION_WITH_SEPARATOR;
        } else if (prod instanceof gast_1.Alternation || prod === "Alternation") {
          return PROD_TYPE.ALTERNATION;
        } else {
          throw Error("non exhaustive match");
        }
      }
      exports2.getProdType = getProdType;
      function getLookaheadPaths(options) {
        var occurrence = options.occurrence, rule = options.rule, prodType = options.prodType, maxLookahead = options.maxLookahead;
        var type = getProdType(prodType);
        if (type === PROD_TYPE.ALTERNATION) {
          return getLookaheadPathsForOr(occurrence, rule, maxLookahead);
        } else {
          return getLookaheadPathsForOptionalProd(occurrence, rule, type, maxLookahead);
        }
      }
      exports2.getLookaheadPaths = getLookaheadPaths;
      function buildLookaheadFuncForOr(occurrence, ruleGrammar, maxLookahead, hasPredicates, dynamicTokensEnabled, laFuncBuilder) {
        var lookAheadPaths = getLookaheadPathsForOr(occurrence, ruleGrammar, maxLookahead);
        var tokenMatcher = areTokenCategoriesNotUsed(lookAheadPaths) ? tokens_1.tokenStructuredMatcherNoCategories : tokens_1.tokenStructuredMatcher;
        return laFuncBuilder(lookAheadPaths, hasPredicates, tokenMatcher, dynamicTokensEnabled);
      }
      exports2.buildLookaheadFuncForOr = buildLookaheadFuncForOr;
      function buildLookaheadFuncForOptionalProd(occurrence, ruleGrammar, k, dynamicTokensEnabled, prodType, lookaheadBuilder) {
        var lookAheadPaths = getLookaheadPathsForOptionalProd(occurrence, ruleGrammar, prodType, k);
        var tokenMatcher = areTokenCategoriesNotUsed(lookAheadPaths) ? tokens_1.tokenStructuredMatcherNoCategories : tokens_1.tokenStructuredMatcher;
        return lookaheadBuilder(lookAheadPaths[0], tokenMatcher, dynamicTokensEnabled);
      }
      exports2.buildLookaheadFuncForOptionalProd = buildLookaheadFuncForOptionalProd;
      function buildAlternativesLookAheadFunc(alts, hasPredicates, tokenMatcher, dynamicTokensEnabled) {
        var numOfAlts = alts.length;
        var areAllOneTokenLookahead = (0, every_1.default)(alts, function(currAlt) {
          return (0, every_1.default)(currAlt, function(currPath) {
            return currPath.length === 1;
          });
        });
        if (hasPredicates) {
          return function(orAlts) {
            var predicates = (0, map_1.default)(orAlts, function(currAlt2) {
              return currAlt2.GATE;
            });
            for (var t = 0; t < numOfAlts; t++) {
              var currAlt = alts[t];
              var currNumOfPaths = currAlt.length;
              var currPredicate = predicates[t];
              if (currPredicate !== void 0 && currPredicate.call(this) === false) {
                continue;
              }
              nextPath:
                for (var j = 0; j < currNumOfPaths; j++) {
                  var currPath = currAlt[j];
                  var currPathLength = currPath.length;
                  for (var i = 0; i < currPathLength; i++) {
                    var nextToken = this.LA(i + 1);
                    if (tokenMatcher(nextToken, currPath[i]) === false) {
                      continue nextPath;
                    }
                  }
                  return t;
                }
            }
            return void 0;
          };
        } else if (areAllOneTokenLookahead && !dynamicTokensEnabled) {
          var singleTokenAlts = (0, map_1.default)(alts, function(currAlt) {
            return (0, flatten_1.default)(currAlt);
          });
          var choiceToAlt_1 = (0, reduce_1.default)(singleTokenAlts, function(result, currAlt, idx) {
            (0, forEach_1.default)(currAlt, function(currTokType) {
              if (!(0, has_1.default)(result, currTokType.tokenTypeIdx)) {
                result[currTokType.tokenTypeIdx] = idx;
              }
              (0, forEach_1.default)(currTokType.categoryMatches, function(currExtendingType) {
                if (!(0, has_1.default)(result, currExtendingType)) {
                  result[currExtendingType] = idx;
                }
              });
            });
            return result;
          }, {});
          return function() {
            var nextToken = this.LA(1);
            return choiceToAlt_1[nextToken.tokenTypeIdx];
          };
        } else {
          return function() {
            for (var t = 0; t < numOfAlts; t++) {
              var currAlt = alts[t];
              var currNumOfPaths = currAlt.length;
              nextPath:
                for (var j = 0; j < currNumOfPaths; j++) {
                  var currPath = currAlt[j];
                  var currPathLength = currPath.length;
                  for (var i = 0; i < currPathLength; i++) {
                    var nextToken = this.LA(i + 1);
                    if (tokenMatcher(nextToken, currPath[i]) === false) {
                      continue nextPath;
                    }
                  }
                  return t;
                }
            }
            return void 0;
          };
        }
      }
      exports2.buildAlternativesLookAheadFunc = buildAlternativesLookAheadFunc;
      function buildSingleAlternativeLookaheadFunction(alt, tokenMatcher, dynamicTokensEnabled) {
        var areAllOneTokenLookahead = (0, every_1.default)(alt, function(currPath) {
          return currPath.length === 1;
        });
        var numOfPaths = alt.length;
        if (areAllOneTokenLookahead && !dynamicTokensEnabled) {
          var singleTokensTypes = (0, flatten_1.default)(alt);
          if (singleTokensTypes.length === 1 && (0, isEmpty_1.default)(singleTokensTypes[0].categoryMatches)) {
            var expectedTokenType = singleTokensTypes[0];
            var expectedTokenUniqueKey_1 = expectedTokenType.tokenTypeIdx;
            return function() {
              return this.LA(1).tokenTypeIdx === expectedTokenUniqueKey_1;
            };
          } else {
            var choiceToAlt_2 = (0, reduce_1.default)(singleTokensTypes, function(result, currTokType, idx) {
              result[currTokType.tokenTypeIdx] = true;
              (0, forEach_1.default)(currTokType.categoryMatches, function(currExtendingType) {
                result[currExtendingType] = true;
              });
              return result;
            }, []);
            return function() {
              var nextToken = this.LA(1);
              return choiceToAlt_2[nextToken.tokenTypeIdx] === true;
            };
          }
        } else {
          return function() {
            nextPath:
              for (var j = 0; j < numOfPaths; j++) {
                var currPath = alt[j];
                var currPathLength = currPath.length;
                for (var i = 0; i < currPathLength; i++) {
                  var nextToken = this.LA(i + 1);
                  if (tokenMatcher(nextToken, currPath[i]) === false) {
                    continue nextPath;
                  }
                }
                return true;
              }
            return false;
          };
        }
      }
      exports2.buildSingleAlternativeLookaheadFunction = buildSingleAlternativeLookaheadFunction;
      var RestDefinitionFinderWalker = (
        /** @class */
        function(_super) {
          __extends(RestDefinitionFinderWalker2, _super);
          function RestDefinitionFinderWalker2(topProd, targetOccurrence, targetProdType) {
            var _this = _super.call(this) || this;
            _this.topProd = topProd;
            _this.targetOccurrence = targetOccurrence;
            _this.targetProdType = targetProdType;
            return _this;
          }
          RestDefinitionFinderWalker2.prototype.startWalking = function() {
            this.walk(this.topProd);
            return this.restDef;
          };
          RestDefinitionFinderWalker2.prototype.checkIsTarget = function(node, expectedProdType, currRest, prevRest) {
            if (node.idx === this.targetOccurrence && this.targetProdType === expectedProdType) {
              this.restDef = currRest.concat(prevRest);
              return true;
            }
            return false;
          };
          RestDefinitionFinderWalker2.prototype.walkOption = function(optionProd, currRest, prevRest) {
            if (!this.checkIsTarget(optionProd, PROD_TYPE.OPTION, currRest, prevRest)) {
              _super.prototype.walkOption.call(this, optionProd, currRest, prevRest);
            }
          };
          RestDefinitionFinderWalker2.prototype.walkAtLeastOne = function(atLeastOneProd, currRest, prevRest) {
            if (!this.checkIsTarget(atLeastOneProd, PROD_TYPE.REPETITION_MANDATORY, currRest, prevRest)) {
              _super.prototype.walkOption.call(this, atLeastOneProd, currRest, prevRest);
            }
          };
          RestDefinitionFinderWalker2.prototype.walkAtLeastOneSep = function(atLeastOneSepProd, currRest, prevRest) {
            if (!this.checkIsTarget(atLeastOneSepProd, PROD_TYPE.REPETITION_MANDATORY_WITH_SEPARATOR, currRest, prevRest)) {
              _super.prototype.walkOption.call(this, atLeastOneSepProd, currRest, prevRest);
            }
          };
          RestDefinitionFinderWalker2.prototype.walkMany = function(manyProd, currRest, prevRest) {
            if (!this.checkIsTarget(manyProd, PROD_TYPE.REPETITION, currRest, prevRest)) {
              _super.prototype.walkOption.call(this, manyProd, currRest, prevRest);
            }
          };
          RestDefinitionFinderWalker2.prototype.walkManySep = function(manySepProd, currRest, prevRest) {
            if (!this.checkIsTarget(manySepProd, PROD_TYPE.REPETITION_WITH_SEPARATOR, currRest, prevRest)) {
              _super.prototype.walkOption.call(this, manySepProd, currRest, prevRest);
            }
          };
          return RestDefinitionFinderWalker2;
        }(rest_1.RestWalker)
      );
      var InsideDefinitionFinderVisitor = (
        /** @class */
        function(_super) {
          __extends(InsideDefinitionFinderVisitor2, _super);
          function InsideDefinitionFinderVisitor2(targetOccurrence, targetProdType, targetRef) {
            var _this = _super.call(this) || this;
            _this.targetOccurrence = targetOccurrence;
            _this.targetProdType = targetProdType;
            _this.targetRef = targetRef;
            _this.result = [];
            return _this;
          }
          InsideDefinitionFinderVisitor2.prototype.checkIsTarget = function(node, expectedProdName) {
            if (node.idx === this.targetOccurrence && this.targetProdType === expectedProdName && (this.targetRef === void 0 || node === this.targetRef)) {
              this.result = node.definition;
            }
          };
          InsideDefinitionFinderVisitor2.prototype.visitOption = function(node) {
            this.checkIsTarget(node, PROD_TYPE.OPTION);
          };
          InsideDefinitionFinderVisitor2.prototype.visitRepetition = function(node) {
            this.checkIsTarget(node, PROD_TYPE.REPETITION);
          };
          InsideDefinitionFinderVisitor2.prototype.visitRepetitionMandatory = function(node) {
            this.checkIsTarget(node, PROD_TYPE.REPETITION_MANDATORY);
          };
          InsideDefinitionFinderVisitor2.prototype.visitRepetitionMandatoryWithSeparator = function(node) {
            this.checkIsTarget(node, PROD_TYPE.REPETITION_MANDATORY_WITH_SEPARATOR);
          };
          InsideDefinitionFinderVisitor2.prototype.visitRepetitionWithSeparator = function(node) {
            this.checkIsTarget(node, PROD_TYPE.REPETITION_WITH_SEPARATOR);
          };
          InsideDefinitionFinderVisitor2.prototype.visitAlternation = function(node) {
            this.checkIsTarget(node, PROD_TYPE.ALTERNATION);
          };
          return InsideDefinitionFinderVisitor2;
        }(gast_2.GAstVisitor)
      );
      function initializeArrayOfArrays(size) {
        var result = new Array(size);
        for (var i = 0; i < size; i++) {
          result[i] = [];
        }
        return result;
      }
      function pathToHashKeys(path4) {
        var keys = [""];
        for (var i = 0; i < path4.length; i++) {
          var tokType = path4[i];
          var longerKeys = [];
          for (var j = 0; j < keys.length; j++) {
            var currShorterKey = keys[j];
            longerKeys.push(currShorterKey + "_" + tokType.tokenTypeIdx);
            for (var t = 0; t < tokType.categoryMatches.length; t++) {
              var categoriesKeySuffix = "_" + tokType.categoryMatches[t];
              longerKeys.push(currShorterKey + categoriesKeySuffix);
            }
          }
          keys = longerKeys;
        }
        return keys;
      }
      function isUniquePrefixHash(altKnownPathsKeys, searchPathKeys, idx) {
        for (var currAltIdx = 0; currAltIdx < altKnownPathsKeys.length; currAltIdx++) {
          if (currAltIdx === idx) {
            continue;
          }
          var otherAltKnownPathsKeys = altKnownPathsKeys[currAltIdx];
          for (var searchIdx = 0; searchIdx < searchPathKeys.length; searchIdx++) {
            var searchKey = searchPathKeys[searchIdx];
            if (otherAltKnownPathsKeys[searchKey] === true) {
              return false;
            }
          }
        }
        return true;
      }
      function lookAheadSequenceFromAlternatives(altsDefs, k) {
        var partialAlts = (0, map_1.default)(altsDefs, function(currAlt) {
          return (0, interpreter_1.possiblePathsFrom)([currAlt], 1);
        });
        var finalResult = initializeArrayOfArrays(partialAlts.length);
        var altsHashes = (0, map_1.default)(partialAlts, function(currAltPaths) {
          var dict = {};
          (0, forEach_1.default)(currAltPaths, function(item) {
            var keys = pathToHashKeys(item.partialPath);
            (0, forEach_1.default)(keys, function(currKey) {
              dict[currKey] = true;
            });
          });
          return dict;
        });
        var newData = partialAlts;
        for (var pathLength = 1; pathLength <= k; pathLength++) {
          var currDataset = newData;
          newData = initializeArrayOfArrays(currDataset.length);
          var _loop_1 = function(altIdx2) {
            var currAltPathsAndSuffixes = currDataset[altIdx2];
            for (var currPathIdx = 0; currPathIdx < currAltPathsAndSuffixes.length; currPathIdx++) {
              var currPathPrefix = currAltPathsAndSuffixes[currPathIdx].partialPath;
              var suffixDef = currAltPathsAndSuffixes[currPathIdx].suffixDef;
              var prefixKeys = pathToHashKeys(currPathPrefix);
              var isUnique = isUniquePrefixHash(altsHashes, prefixKeys, altIdx2);
              if (isUnique || (0, isEmpty_1.default)(suffixDef) || currPathPrefix.length === k) {
                var currAltResult = finalResult[altIdx2];
                if (containsPath(currAltResult, currPathPrefix) === false) {
                  currAltResult.push(currPathPrefix);
                  for (var j = 0; j < prefixKeys.length; j++) {
                    var currKey = prefixKeys[j];
                    altsHashes[altIdx2][currKey] = true;
                  }
                }
              } else {
                var newPartialPathsAndSuffixes = (0, interpreter_1.possiblePathsFrom)(suffixDef, pathLength + 1, currPathPrefix);
                newData[altIdx2] = newData[altIdx2].concat(newPartialPathsAndSuffixes);
                (0, forEach_1.default)(newPartialPathsAndSuffixes, function(item) {
                  var prefixKeys2 = pathToHashKeys(item.partialPath);
                  (0, forEach_1.default)(prefixKeys2, function(key) {
                    altsHashes[altIdx2][key] = true;
                  });
                });
              }
            }
          };
          for (var altIdx = 0; altIdx < currDataset.length; altIdx++) {
            _loop_1(altIdx);
          }
        }
        return finalResult;
      }
      exports2.lookAheadSequenceFromAlternatives = lookAheadSequenceFromAlternatives;
      function getLookaheadPathsForOr(occurrence, ruleGrammar, k, orProd) {
        var visitor = new InsideDefinitionFinderVisitor(occurrence, PROD_TYPE.ALTERNATION, orProd);
        ruleGrammar.accept(visitor);
        return lookAheadSequenceFromAlternatives(visitor.result, k);
      }
      exports2.getLookaheadPathsForOr = getLookaheadPathsForOr;
      function getLookaheadPathsForOptionalProd(occurrence, ruleGrammar, prodType, k) {
        var insideDefVisitor = new InsideDefinitionFinderVisitor(occurrence, prodType);
        ruleGrammar.accept(insideDefVisitor);
        var insideDef = insideDefVisitor.result;
        var afterDefWalker = new RestDefinitionFinderWalker(ruleGrammar, occurrence, prodType);
        var afterDef = afterDefWalker.startWalking();
        var insideFlat = new gast_1.Alternative({ definition: insideDef });
        var afterFlat = new gast_1.Alternative({ definition: afterDef });
        return lookAheadSequenceFromAlternatives([insideFlat, afterFlat], k);
      }
      exports2.getLookaheadPathsForOptionalProd = getLookaheadPathsForOptionalProd;
      function containsPath(alternative, searchPath) {
        compareOtherPath:
          for (var i = 0; i < alternative.length; i++) {
            var otherPath = alternative[i];
            if (otherPath.length !== searchPath.length) {
              continue;
            }
            for (var j = 0; j < otherPath.length; j++) {
              var searchTok = searchPath[j];
              var otherTok = otherPath[j];
              var matchingTokens = searchTok === otherTok || otherTok.categoryMatchesMap[searchTok.tokenTypeIdx] !== void 0;
              if (matchingTokens === false) {
                continue compareOtherPath;
              }
            }
            return true;
          }
        return false;
      }
      exports2.containsPath = containsPath;
      function isStrictPrefixOfPath(prefix, other) {
        return prefix.length < other.length && (0, every_1.default)(prefix, function(tokType, idx) {
          var otherTokType = other[idx];
          return tokType === otherTokType || otherTokType.categoryMatchesMap[tokType.tokenTypeIdx];
        });
      }
      exports2.isStrictPrefixOfPath = isStrictPrefixOfPath;
      function areTokenCategoriesNotUsed(lookAheadPaths) {
        return (0, every_1.default)(lookAheadPaths, function(singleAltPaths) {
          return (0, every_1.default)(singleAltPaths, function(singlePath) {
            return (0, every_1.default)(singlePath, function(token) {
              return (0, isEmpty_1.default)(token.categoryMatches);
            });
          });
        });
      }
      exports2.areTokenCategoriesNotUsed = areTokenCategoriesNotUsed;
    }
  });

  // node_modules/.pnpm/chevrotain@10.5.0/node_modules/chevrotain/lib/src/parse/grammar/checks.js
  var require_checks = __commonJS({
    "node_modules/.pnpm/chevrotain@10.5.0/node_modules/chevrotain/lib/src/parse/grammar/checks.js"(exports2) {
      "use strict";
      var __extends = exports2 && exports2.__extends || function() {
        var extendStatics = function(d, b) {
          extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b3) {
            d2.__proto__ = b3;
          } || function(d2, b3) {
            for (var p in b3)
              if (Object.prototype.hasOwnProperty.call(b3, p))
                d2[p] = b3[p];
          };
          return extendStatics(d, b);
        };
        return function(d, b) {
          if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
          extendStatics(d, b);
          function __() {
            this.constructor = d;
          }
          d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
        };
      }();
      var __assign = exports2 && exports2.__assign || function() {
        __assign = Object.assign || function(t) {
          for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s)
              if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
          }
          return t;
        };
        return __assign.apply(this, arguments);
      };
      var __importDefault = exports2 && exports2.__importDefault || function(mod) {
        return mod && mod.__esModule ? mod : { "default": mod };
      };
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.checkPrefixAlternativesAmbiguities = exports2.validateSomeNonEmptyLookaheadPath = exports2.validateTooManyAlts = exports2.RepetitionCollector = exports2.validateAmbiguousAlternationAlternatives = exports2.validateEmptyOrAlternative = exports2.getFirstNoneTerminal = exports2.validateNoLeftRecursion = exports2.validateRuleIsOverridden = exports2.validateRuleDoesNotAlreadyExist = exports2.OccurrenceValidationCollector = exports2.identifyProductionForDuplicates = exports2.validateGrammar = exports2.validateLookahead = void 0;
      var first_1 = __importDefault(require_first2());
      var isEmpty_1 = __importDefault(require_isEmpty());
      var drop_1 = __importDefault(require_drop());
      var flatten_1 = __importDefault(require_flatten());
      var filter_1 = __importDefault(require_filter());
      var reject_1 = __importDefault(require_reject());
      var difference_1 = __importDefault(require_difference());
      var map_1 = __importDefault(require_map());
      var forEach_1 = __importDefault(require_forEach());
      var groupBy_1 = __importDefault(require_groupBy());
      var reduce_1 = __importDefault(require_reduce());
      var pickBy_1 = __importDefault(require_pickBy());
      var values_1 = __importDefault(require_values());
      var includes_1 = __importDefault(require_includes());
      var flatMap_1 = __importDefault(require_flatMap());
      var clone_1 = __importDefault(require_clone());
      var parser_1 = require_parser();
      var gast_1 = require_api2();
      var lookahead_1 = require_lookahead();
      var interpreter_1 = require_interpreter();
      var gast_2 = require_api2();
      var gast_3 = require_api2();
      var dropRight_1 = __importDefault(require_dropRight());
      var compact_1 = __importDefault(require_compact());
      var tokens_1 = require_tokens();
      function validateLookahead(options) {
        var lookaheadValidationErrorMessages = options.lookaheadStrategy.validate({
          rules: options.rules,
          tokenTypes: options.tokenTypes,
          grammarName: options.grammarName
        });
        return (0, map_1.default)(lookaheadValidationErrorMessages, function(errorMessage) {
          return __assign({ type: parser_1.ParserDefinitionErrorType.CUSTOM_LOOKAHEAD_VALIDATION }, errorMessage);
        });
      }
      exports2.validateLookahead = validateLookahead;
      function validateGrammar(topLevels, tokenTypes, errMsgProvider, grammarName) {
        var duplicateErrors = (0, flatMap_1.default)(topLevels, function(currTopLevel) {
          return validateDuplicateProductions(currTopLevel, errMsgProvider);
        });
        var termsNamespaceConflictErrors = checkTerminalAndNoneTerminalsNameSpace(topLevels, tokenTypes, errMsgProvider);
        var tooManyAltsErrors = (0, flatMap_1.default)(topLevels, function(curRule) {
          return validateTooManyAlts(curRule, errMsgProvider);
        });
        var duplicateRulesError = (0, flatMap_1.default)(topLevels, function(curRule) {
          return validateRuleDoesNotAlreadyExist(curRule, topLevels, grammarName, errMsgProvider);
        });
        return duplicateErrors.concat(termsNamespaceConflictErrors, tooManyAltsErrors, duplicateRulesError);
      }
      exports2.validateGrammar = validateGrammar;
      function validateDuplicateProductions(topLevelRule, errMsgProvider) {
        var collectorVisitor = new OccurrenceValidationCollector();
        topLevelRule.accept(collectorVisitor);
        var allRuleProductions = collectorVisitor.allProductions;
        var productionGroups = (0, groupBy_1.default)(allRuleProductions, identifyProductionForDuplicates);
        var duplicates = (0, pickBy_1.default)(productionGroups, function(currGroup) {
          return currGroup.length > 1;
        });
        var errors = (0, map_1.default)((0, values_1.default)(duplicates), function(currDuplicates) {
          var firstProd = (0, first_1.default)(currDuplicates);
          var msg = errMsgProvider.buildDuplicateFoundError(topLevelRule, currDuplicates);
          var dslName = (0, gast_1.getProductionDslName)(firstProd);
          var defError = {
            message: msg,
            type: parser_1.ParserDefinitionErrorType.DUPLICATE_PRODUCTIONS,
            ruleName: topLevelRule.name,
            dslName,
            occurrence: firstProd.idx
          };
          var param = getExtraProductionArgument(firstProd);
          if (param) {
            defError.parameter = param;
          }
          return defError;
        });
        return errors;
      }
      function identifyProductionForDuplicates(prod) {
        return "".concat((0, gast_1.getProductionDslName)(prod), "_#_").concat(prod.idx, "_#_").concat(getExtraProductionArgument(prod));
      }
      exports2.identifyProductionForDuplicates = identifyProductionForDuplicates;
      function getExtraProductionArgument(prod) {
        if (prod instanceof gast_2.Terminal) {
          return prod.terminalType.name;
        } else if (prod instanceof gast_2.NonTerminal) {
          return prod.nonTerminalName;
        } else {
          return "";
        }
      }
      var OccurrenceValidationCollector = (
        /** @class */
        function(_super) {
          __extends(OccurrenceValidationCollector2, _super);
          function OccurrenceValidationCollector2() {
            var _this = _super !== null && _super.apply(this, arguments) || this;
            _this.allProductions = [];
            return _this;
          }
          OccurrenceValidationCollector2.prototype.visitNonTerminal = function(subrule) {
            this.allProductions.push(subrule);
          };
          OccurrenceValidationCollector2.prototype.visitOption = function(option) {
            this.allProductions.push(option);
          };
          OccurrenceValidationCollector2.prototype.visitRepetitionWithSeparator = function(manySep) {
            this.allProductions.push(manySep);
          };
          OccurrenceValidationCollector2.prototype.visitRepetitionMandatory = function(atLeastOne) {
            this.allProductions.push(atLeastOne);
          };
          OccurrenceValidationCollector2.prototype.visitRepetitionMandatoryWithSeparator = function(atLeastOneSep) {
            this.allProductions.push(atLeastOneSep);
          };
          OccurrenceValidationCollector2.prototype.visitRepetition = function(many) {
            this.allProductions.push(many);
          };
          OccurrenceValidationCollector2.prototype.visitAlternation = function(or) {
            this.allProductions.push(or);
          };
          OccurrenceValidationCollector2.prototype.visitTerminal = function(terminal) {
            this.allProductions.push(terminal);
          };
          return OccurrenceValidationCollector2;
        }(gast_3.GAstVisitor)
      );
      exports2.OccurrenceValidationCollector = OccurrenceValidationCollector;
      function validateRuleDoesNotAlreadyExist(rule, allRules, className, errMsgProvider) {
        var errors = [];
        var occurrences = (0, reduce_1.default)(allRules, function(result, curRule) {
          if (curRule.name === rule.name) {
            return result + 1;
          }
          return result;
        }, 0);
        if (occurrences > 1) {
          var errMsg = errMsgProvider.buildDuplicateRuleNameError({
            topLevelRule: rule,
            grammarName: className
          });
          errors.push({
            message: errMsg,
            type: parser_1.ParserDefinitionErrorType.DUPLICATE_RULE_NAME,
            ruleName: rule.name
          });
        }
        return errors;
      }
      exports2.validateRuleDoesNotAlreadyExist = validateRuleDoesNotAlreadyExist;
      function validateRuleIsOverridden(ruleName, definedRulesNames, className) {
        var errors = [];
        var errMsg;
        if (!(0, includes_1.default)(definedRulesNames, ruleName)) {
          errMsg = "Invalid rule override, rule: ->".concat(ruleName, "<- cannot be overridden in the grammar: ->").concat(className, "<-") + "as it is not defined in any of the super grammars ";
          errors.push({
            message: errMsg,
            type: parser_1.ParserDefinitionErrorType.INVALID_RULE_OVERRIDE,
            ruleName
          });
        }
        return errors;
      }
      exports2.validateRuleIsOverridden = validateRuleIsOverridden;
      function validateNoLeftRecursion(topRule, currRule, errMsgProvider, path4) {
        if (path4 === void 0) {
          path4 = [];
        }
        var errors = [];
        var nextNonTerminals = getFirstNoneTerminal(currRule.definition);
        if ((0, isEmpty_1.default)(nextNonTerminals)) {
          return [];
        } else {
          var ruleName = topRule.name;
          var foundLeftRecursion = (0, includes_1.default)(nextNonTerminals, topRule);
          if (foundLeftRecursion) {
            errors.push({
              message: errMsgProvider.buildLeftRecursionError({
                topLevelRule: topRule,
                leftRecursionPath: path4
              }),
              type: parser_1.ParserDefinitionErrorType.LEFT_RECURSION,
              ruleName
            });
          }
          var validNextSteps = (0, difference_1.default)(nextNonTerminals, path4.concat([topRule]));
          var errorsFromNextSteps = (0, flatMap_1.default)(validNextSteps, function(currRefRule) {
            var newPath = (0, clone_1.default)(path4);
            newPath.push(currRefRule);
            return validateNoLeftRecursion(topRule, currRefRule, errMsgProvider, newPath);
          });
          return errors.concat(errorsFromNextSteps);
        }
      }
      exports2.validateNoLeftRecursion = validateNoLeftRecursion;
      function getFirstNoneTerminal(definition) {
        var result = [];
        if ((0, isEmpty_1.default)(definition)) {
          return result;
        }
        var firstProd = (0, first_1.default)(definition);
        if (firstProd instanceof gast_2.NonTerminal) {
          result.push(firstProd.referencedRule);
        } else if (firstProd instanceof gast_2.Alternative || firstProd instanceof gast_2.Option || firstProd instanceof gast_2.RepetitionMandatory || firstProd instanceof gast_2.RepetitionMandatoryWithSeparator || firstProd instanceof gast_2.RepetitionWithSeparator || firstProd instanceof gast_2.Repetition) {
          result = result.concat(getFirstNoneTerminal(firstProd.definition));
        } else if (firstProd instanceof gast_2.Alternation) {
          result = (0, flatten_1.default)((0, map_1.default)(firstProd.definition, function(currSubDef) {
            return getFirstNoneTerminal(currSubDef.definition);
          }));
        } else if (firstProd instanceof gast_2.Terminal) {
        } else {
          throw Error("non exhaustive match");
        }
        var isFirstOptional = (0, gast_1.isOptionalProd)(firstProd);
        var hasMore = definition.length > 1;
        if (isFirstOptional && hasMore) {
          var rest = (0, drop_1.default)(definition);
          return result.concat(getFirstNoneTerminal(rest));
        } else {
          return result;
        }
      }
      exports2.getFirstNoneTerminal = getFirstNoneTerminal;
      var OrCollector = (
        /** @class */
        function(_super) {
          __extends(OrCollector2, _super);
          function OrCollector2() {
            var _this = _super !== null && _super.apply(this, arguments) || this;
            _this.alternations = [];
            return _this;
          }
          OrCollector2.prototype.visitAlternation = function(node) {
            this.alternations.push(node);
          };
          return OrCollector2;
        }(gast_3.GAstVisitor)
      );
      function validateEmptyOrAlternative(topLevelRule, errMsgProvider) {
        var orCollector = new OrCollector();
        topLevelRule.accept(orCollector);
        var ors = orCollector.alternations;
        var errors = (0, flatMap_1.default)(ors, function(currOr) {
          var exceptLast = (0, dropRight_1.default)(currOr.definition);
          return (0, flatMap_1.default)(exceptLast, function(currAlternative, currAltIdx) {
            var possibleFirstInAlt = (0, interpreter_1.nextPossibleTokensAfter)([currAlternative], [], tokens_1.tokenStructuredMatcher, 1);
            if ((0, isEmpty_1.default)(possibleFirstInAlt)) {
              return [
                {
                  message: errMsgProvider.buildEmptyAlternationError({
                    topLevelRule,
                    alternation: currOr,
                    emptyChoiceIdx: currAltIdx
                  }),
                  type: parser_1.ParserDefinitionErrorType.NONE_LAST_EMPTY_ALT,
                  ruleName: topLevelRule.name,
                  occurrence: currOr.idx,
                  alternative: currAltIdx + 1
                }
              ];
            } else {
              return [];
            }
          });
        });
        return errors;
      }
      exports2.validateEmptyOrAlternative = validateEmptyOrAlternative;
      function validateAmbiguousAlternationAlternatives(topLevelRule, globalMaxLookahead, errMsgProvider) {
        var orCollector = new OrCollector();
        topLevelRule.accept(orCollector);
        var ors = orCollector.alternations;
        ors = (0, reject_1.default)(ors, function(currOr) {
          return currOr.ignoreAmbiguities === true;
        });
        var errors = (0, flatMap_1.default)(ors, function(currOr) {
          var currOccurrence = currOr.idx;
          var actualMaxLookahead = currOr.maxLookahead || globalMaxLookahead;
          var alternatives = (0, lookahead_1.getLookaheadPathsForOr)(currOccurrence, topLevelRule, actualMaxLookahead, currOr);
          var altsAmbiguityErrors = checkAlternativesAmbiguities(alternatives, currOr, topLevelRule, errMsgProvider);
          var altsPrefixAmbiguityErrors = checkPrefixAlternativesAmbiguities(alternatives, currOr, topLevelRule, errMsgProvider);
          return altsAmbiguityErrors.concat(altsPrefixAmbiguityErrors);
        });
        return errors;
      }
      exports2.validateAmbiguousAlternationAlternatives = validateAmbiguousAlternationAlternatives;
      var RepetitionCollector = (
        /** @class */
        function(_super) {
          __extends(RepetitionCollector2, _super);
          function RepetitionCollector2() {
            var _this = _super !== null && _super.apply(this, arguments) || this;
            _this.allProductions = [];
            return _this;
          }
          RepetitionCollector2.prototype.visitRepetitionWithSeparator = function(manySep) {
            this.allProductions.push(manySep);
          };
          RepetitionCollector2.prototype.visitRepetitionMandatory = function(atLeastOne) {
            this.allProductions.push(atLeastOne);
          };
          RepetitionCollector2.prototype.visitRepetitionMandatoryWithSeparator = function(atLeastOneSep) {
            this.allProductions.push(atLeastOneSep);
          };
          RepetitionCollector2.prototype.visitRepetition = function(many) {
            this.allProductions.push(many);
          };
          return RepetitionCollector2;
        }(gast_3.GAstVisitor)
      );
      exports2.RepetitionCollector = RepetitionCollector;
      function validateTooManyAlts(topLevelRule, errMsgProvider) {
        var orCollector = new OrCollector();
        topLevelRule.accept(orCollector);
        var ors = orCollector.alternations;
        var errors = (0, flatMap_1.default)(ors, function(currOr) {
          if (currOr.definition.length > 255) {
            return [
              {
                message: errMsgProvider.buildTooManyAlternativesError({
                  topLevelRule,
                  alternation: currOr
                }),
                type: parser_1.ParserDefinitionErrorType.TOO_MANY_ALTS,
                ruleName: topLevelRule.name,
                occurrence: currOr.idx
              }
            ];
          } else {
            return [];
          }
        });
        return errors;
      }
      exports2.validateTooManyAlts = validateTooManyAlts;
      function validateSomeNonEmptyLookaheadPath(topLevelRules, maxLookahead, errMsgProvider) {
        var errors = [];
        (0, forEach_1.default)(topLevelRules, function(currTopRule) {
          var collectorVisitor = new RepetitionCollector();
          currTopRule.accept(collectorVisitor);
          var allRuleProductions = collectorVisitor.allProductions;
          (0, forEach_1.default)(allRuleProductions, function(currProd) {
            var prodType = (0, lookahead_1.getProdType)(currProd);
            var actualMaxLookahead = currProd.maxLookahead || maxLookahead;
            var currOccurrence = currProd.idx;
            var paths = (0, lookahead_1.getLookaheadPathsForOptionalProd)(currOccurrence, currTopRule, prodType, actualMaxLookahead);
            var pathsInsideProduction = paths[0];
            if ((0, isEmpty_1.default)((0, flatten_1.default)(pathsInsideProduction))) {
              var errMsg = errMsgProvider.buildEmptyRepetitionError({
                topLevelRule: currTopRule,
                repetition: currProd
              });
              errors.push({
                message: errMsg,
                type: parser_1.ParserDefinitionErrorType.NO_NON_EMPTY_LOOKAHEAD,
                ruleName: currTopRule.name
              });
            }
          });
        });
        return errors;
      }
      exports2.validateSomeNonEmptyLookaheadPath = validateSomeNonEmptyLookaheadPath;
      function checkAlternativesAmbiguities(alternatives, alternation, rule, errMsgProvider) {
        var foundAmbiguousPaths = [];
        var identicalAmbiguities = (0, reduce_1.default)(alternatives, function(result, currAlt, currAltIdx) {
          if (alternation.definition[currAltIdx].ignoreAmbiguities === true) {
            return result;
          }
          (0, forEach_1.default)(currAlt, function(currPath) {
            var altsCurrPathAppearsIn = [currAltIdx];
            (0, forEach_1.default)(alternatives, function(currOtherAlt, currOtherAltIdx) {
              if (currAltIdx !== currOtherAltIdx && (0, lookahead_1.containsPath)(currOtherAlt, currPath) && // ignore (skip) ambiguities with this "other" alternative
              alternation.definition[currOtherAltIdx].ignoreAmbiguities !== true) {
                altsCurrPathAppearsIn.push(currOtherAltIdx);
              }
            });
            if (altsCurrPathAppearsIn.length > 1 && !(0, lookahead_1.containsPath)(foundAmbiguousPaths, currPath)) {
              foundAmbiguousPaths.push(currPath);
              result.push({
                alts: altsCurrPathAppearsIn,
                path: currPath
              });
            }
          });
          return result;
        }, []);
        var currErrors = (0, map_1.default)(identicalAmbiguities, function(currAmbDescriptor) {
          var ambgIndices = (0, map_1.default)(currAmbDescriptor.alts, function(currAltIdx) {
            return currAltIdx + 1;
          });
          var currMessage = errMsgProvider.buildAlternationAmbiguityError({
            topLevelRule: rule,
            alternation,
            ambiguityIndices: ambgIndices,
            prefixPath: currAmbDescriptor.path
          });
          return {
            message: currMessage,
            type: parser_1.ParserDefinitionErrorType.AMBIGUOUS_ALTS,
            ruleName: rule.name,
            occurrence: alternation.idx,
            alternatives: currAmbDescriptor.alts
          };
        });
        return currErrors;
      }
      function checkPrefixAlternativesAmbiguities(alternatives, alternation, rule, errMsgProvider) {
        var pathsAndIndices = (0, reduce_1.default)(alternatives, function(result, currAlt, idx) {
          var currPathsAndIdx = (0, map_1.default)(currAlt, function(currPath) {
            return { idx, path: currPath };
          });
          return result.concat(currPathsAndIdx);
        }, []);
        var errors = (0, compact_1.default)((0, flatMap_1.default)(pathsAndIndices, function(currPathAndIdx) {
          var alternativeGast = alternation.definition[currPathAndIdx.idx];
          if (alternativeGast.ignoreAmbiguities === true) {
            return [];
          }
          var targetIdx = currPathAndIdx.idx;
          var targetPath = currPathAndIdx.path;
          var prefixAmbiguitiesPathsAndIndices = (0, filter_1.default)(pathsAndIndices, function(searchPathAndIdx) {
            return (
              // ignore (skip) ambiguities with this "other" alternative
              alternation.definition[searchPathAndIdx.idx].ignoreAmbiguities !== true && searchPathAndIdx.idx < targetIdx && // checking for strict prefix because identical lookaheads
              // will be be detected using a different validation.
              (0, lookahead_1.isStrictPrefixOfPath)(searchPathAndIdx.path, targetPath)
            );
          });
          var currPathPrefixErrors = (0, map_1.default)(prefixAmbiguitiesPathsAndIndices, function(currAmbPathAndIdx) {
            var ambgIndices = [currAmbPathAndIdx.idx + 1, targetIdx + 1];
            var occurrence = alternation.idx === 0 ? "" : alternation.idx;
            var message = errMsgProvider.buildAlternationPrefixAmbiguityError({
              topLevelRule: rule,
              alternation,
              ambiguityIndices: ambgIndices,
              prefixPath: currAmbPathAndIdx.path
            });
            return {
              message,
              type: parser_1.ParserDefinitionErrorType.AMBIGUOUS_PREFIX_ALTS,
              ruleName: rule.name,
              occurrence,
              alternatives: ambgIndices
            };
          });
          return currPathPrefixErrors;
        }));
        return errors;
      }
      exports2.checkPrefixAlternativesAmbiguities = checkPrefixAlternativesAmbiguities;
      function checkTerminalAndNoneTerminalsNameSpace(topLevels, tokenTypes, errMsgProvider) {
        var errors = [];
        var tokenNames = (0, map_1.default)(tokenTypes, function(currToken) {
          return currToken.name;
        });
        (0, forEach_1.default)(topLevels, function(currRule) {
          var currRuleName = currRule.name;
          if ((0, includes_1.default)(tokenNames, currRuleName)) {
            var errMsg = errMsgProvider.buildNamespaceConflictError(currRule);
            errors.push({
              message: errMsg,
              type: parser_1.ParserDefinitionErrorType.CONFLICT_TOKENS_RULES_NAMESPACE,
              ruleName: currRuleName
            });
          }
        });
        return errors;
      }
    }
  });

  // node_modules/.pnpm/chevrotain@10.5.0/node_modules/chevrotain/lib/src/parse/grammar/gast/gast_resolver_public.js
  var require_gast_resolver_public = __commonJS({
    "node_modules/.pnpm/chevrotain@10.5.0/node_modules/chevrotain/lib/src/parse/grammar/gast/gast_resolver_public.js"(exports2) {
      "use strict";
      var __importDefault = exports2 && exports2.__importDefault || function(mod) {
        return mod && mod.__esModule ? mod : { "default": mod };
      };
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.validateGrammar = exports2.resolveGrammar = void 0;
      var forEach_1 = __importDefault(require_forEach());
      var defaults_1 = __importDefault(require_defaults());
      var resolver_1 = require_resolver();
      var checks_1 = require_checks();
      var errors_public_1 = require_errors_public();
      function resolveGrammar(options) {
        var actualOptions = (0, defaults_1.default)(options, {
          errMsgProvider: errors_public_1.defaultGrammarResolverErrorProvider
        });
        var topRulesTable = {};
        (0, forEach_1.default)(options.rules, function(rule) {
          topRulesTable[rule.name] = rule;
        });
        return (0, resolver_1.resolveGrammar)(topRulesTable, actualOptions.errMsgProvider);
      }
      exports2.resolveGrammar = resolveGrammar;
      function validateGrammar(options) {
        options = (0, defaults_1.default)(options, {
          errMsgProvider: errors_public_1.defaultGrammarValidatorErrorProvider
        });
        return (0, checks_1.validateGrammar)(options.rules, options.tokenTypes, options.errMsgProvider, options.grammarName);
      }
      exports2.validateGrammar = validateGrammar;
    }
  });

  // node_modules/.pnpm/chevrotain@10.5.0/node_modules/chevrotain/lib/src/parse/exceptions_public.js
  var require_exceptions_public = __commonJS({
    "node_modules/.pnpm/chevrotain@10.5.0/node_modules/chevrotain/lib/src/parse/exceptions_public.js"(exports2) {
      "use strict";
      var __extends = exports2 && exports2.__extends || function() {
        var extendStatics = function(d, b) {
          extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b3) {
            d2.__proto__ = b3;
          } || function(d2, b3) {
            for (var p in b3)
              if (Object.prototype.hasOwnProperty.call(b3, p))
                d2[p] = b3[p];
          };
          return extendStatics(d, b);
        };
        return function(d, b) {
          if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
          extendStatics(d, b);
          function __() {
            this.constructor = d;
          }
          d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
        };
      }();
      var __importDefault = exports2 && exports2.__importDefault || function(mod) {
        return mod && mod.__esModule ? mod : { "default": mod };
      };
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.EarlyExitException = exports2.NotAllInputParsedException = exports2.NoViableAltException = exports2.MismatchedTokenException = exports2.isRecognitionException = void 0;
      var includes_1 = __importDefault(require_includes());
      var MISMATCHED_TOKEN_EXCEPTION = "MismatchedTokenException";
      var NO_VIABLE_ALT_EXCEPTION = "NoViableAltException";
      var EARLY_EXIT_EXCEPTION = "EarlyExitException";
      var NOT_ALL_INPUT_PARSED_EXCEPTION = "NotAllInputParsedException";
      var RECOGNITION_EXCEPTION_NAMES = [
        MISMATCHED_TOKEN_EXCEPTION,
        NO_VIABLE_ALT_EXCEPTION,
        EARLY_EXIT_EXCEPTION,
        NOT_ALL_INPUT_PARSED_EXCEPTION
      ];
      Object.freeze(RECOGNITION_EXCEPTION_NAMES);
      function isRecognitionException(error) {
        return (0, includes_1.default)(RECOGNITION_EXCEPTION_NAMES, error.name);
      }
      exports2.isRecognitionException = isRecognitionException;
      var RecognitionException = (
        /** @class */
        function(_super) {
          __extends(RecognitionException2, _super);
          function RecognitionException2(message, token) {
            var _newTarget = this.constructor;
            var _this = _super.call(this, message) || this;
            _this.token = token;
            _this.resyncedTokens = [];
            Object.setPrototypeOf(_this, _newTarget.prototype);
            if (Error.captureStackTrace) {
              Error.captureStackTrace(_this, _this.constructor);
            }
            return _this;
          }
          return RecognitionException2;
        }(Error)
      );
      var MismatchedTokenException = (
        /** @class */
        function(_super) {
          __extends(MismatchedTokenException2, _super);
          function MismatchedTokenException2(message, token, previousToken) {
            var _this = _super.call(this, message, token) || this;
            _this.previousToken = previousToken;
            _this.name = MISMATCHED_TOKEN_EXCEPTION;
            return _this;
          }
          return MismatchedTokenException2;
        }(RecognitionException)
      );
      exports2.MismatchedTokenException = MismatchedTokenException;
      var NoViableAltException = (
        /** @class */
        function(_super) {
          __extends(NoViableAltException2, _super);
          function NoViableAltException2(message, token, previousToken) {
            var _this = _super.call(this, message, token) || this;
            _this.previousToken = previousToken;
            _this.name = NO_VIABLE_ALT_EXCEPTION;
            return _this;
          }
          return NoViableAltException2;
        }(RecognitionException)
      );
      exports2.NoViableAltException = NoViableAltException;
      var NotAllInputParsedException = (
        /** @class */
        function(_super) {
          __extends(NotAllInputParsedException2, _super);
          function NotAllInputParsedException2(message, token) {
            var _this = _super.call(this, message, token) || this;
            _this.name = NOT_ALL_INPUT_PARSED_EXCEPTION;
            return _this;
          }
          return NotAllInputParsedException2;
        }(RecognitionException)
      );
      exports2.NotAllInputParsedException = NotAllInputParsedException;
      var EarlyExitException = (
        /** @class */
        function(_super) {
          __extends(EarlyExitException2, _super);
          function EarlyExitException2(message, token, previousToken) {
            var _this = _super.call(this, message, token) || this;
            _this.previousToken = previousToken;
            _this.name = EARLY_EXIT_EXCEPTION;
            return _this;
          }
          return EarlyExitException2;
        }(RecognitionException)
      );
      exports2.EarlyExitException = EarlyExitException;
    }
  });

  // node_modules/.pnpm/chevrotain@10.5.0/node_modules/chevrotain/lib/src/parse/parser/traits/recoverable.js
  var require_recoverable = __commonJS({
    "node_modules/.pnpm/chevrotain@10.5.0/node_modules/chevrotain/lib/src/parse/parser/traits/recoverable.js"(exports2) {
      "use strict";
      var __extends = exports2 && exports2.__extends || function() {
        var extendStatics = function(d, b) {
          extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b3) {
            d2.__proto__ = b3;
          } || function(d2, b3) {
            for (var p in b3)
              if (Object.prototype.hasOwnProperty.call(b3, p))
                d2[p] = b3[p];
          };
          return extendStatics(d, b);
        };
        return function(d, b) {
          if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
          extendStatics(d, b);
          function __() {
            this.constructor = d;
          }
          d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
        };
      }();
      var __importDefault = exports2 && exports2.__importDefault || function(mod) {
        return mod && mod.__esModule ? mod : { "default": mod };
      };
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.attemptInRepetitionRecovery = exports2.Recoverable = exports2.InRuleRecoveryException = exports2.IN_RULE_RECOVERY_EXCEPTION = exports2.EOF_FOLLOW_KEY = void 0;
      var tokens_public_1 = require_tokens_public();
      var isEmpty_1 = __importDefault(require_isEmpty());
      var dropRight_1 = __importDefault(require_dropRight());
      var flatten_1 = __importDefault(require_flatten());
      var map_1 = __importDefault(require_map());
      var find_1 = __importDefault(require_find2());
      var has_1 = __importDefault(require_has());
      var includes_1 = __importDefault(require_includes());
      var clone_1 = __importDefault(require_clone());
      var exceptions_public_1 = require_exceptions_public();
      var constants_1 = require_constants2();
      var parser_1 = require_parser();
      exports2.EOF_FOLLOW_KEY = {};
      exports2.IN_RULE_RECOVERY_EXCEPTION = "InRuleRecoveryException";
      var InRuleRecoveryException = (
        /** @class */
        function(_super) {
          __extends(InRuleRecoveryException2, _super);
          function InRuleRecoveryException2(message) {
            var _this = _super.call(this, message) || this;
            _this.name = exports2.IN_RULE_RECOVERY_EXCEPTION;
            return _this;
          }
          return InRuleRecoveryException2;
        }(Error)
      );
      exports2.InRuleRecoveryException = InRuleRecoveryException;
      var Recoverable = (
        /** @class */
        function() {
          function Recoverable2() {
          }
          Recoverable2.prototype.initRecoverable = function(config2) {
            this.firstAfterRepMap = {};
            this.resyncFollows = {};
            this.recoveryEnabled = (0, has_1.default)(config2, "recoveryEnabled") ? config2.recoveryEnabled : parser_1.DEFAULT_PARSER_CONFIG.recoveryEnabled;
            if (this.recoveryEnabled) {
              this.attemptInRepetitionRecovery = attemptInRepetitionRecovery;
            }
          };
          Recoverable2.prototype.getTokenToInsert = function(tokType) {
            var tokToInsert = (0, tokens_public_1.createTokenInstance)(tokType, "", NaN, NaN, NaN, NaN, NaN, NaN);
            tokToInsert.isInsertedInRecovery = true;
            return tokToInsert;
          };
          Recoverable2.prototype.canTokenTypeBeInsertedInRecovery = function(tokType) {
            return true;
          };
          Recoverable2.prototype.canTokenTypeBeDeletedInRecovery = function(tokType) {
            return true;
          };
          Recoverable2.prototype.tryInRepetitionRecovery = function(grammarRule, grammarRuleArgs, lookAheadFunc, expectedTokType) {
            var _this = this;
            var reSyncTokType = this.findReSyncTokenType();
            var savedLexerState = this.exportLexerState();
            var resyncedTokens = [];
            var passedResyncPoint = false;
            var nextTokenWithoutResync = this.LA(1);
            var currToken = this.LA(1);
            var generateErrorMessage = function() {
              var previousToken = _this.LA(0);
              var msg = _this.errorMessageProvider.buildMismatchTokenMessage({
                expected: expectedTokType,
                actual: nextTokenWithoutResync,
                previous: previousToken,
                ruleName: _this.getCurrRuleFullName()
              });
              var error = new exceptions_public_1.MismatchedTokenException(msg, nextTokenWithoutResync, _this.LA(0));
              error.resyncedTokens = (0, dropRight_1.default)(resyncedTokens);
              _this.SAVE_ERROR(error);
            };
            while (!passedResyncPoint) {
              if (this.tokenMatcher(currToken, expectedTokType)) {
                generateErrorMessage();
                return;
              } else if (lookAheadFunc.call(this)) {
                generateErrorMessage();
                grammarRule.apply(this, grammarRuleArgs);
                return;
              } else if (this.tokenMatcher(currToken, reSyncTokType)) {
                passedResyncPoint = true;
              } else {
                currToken = this.SKIP_TOKEN();
                this.addToResyncTokens(currToken, resyncedTokens);
              }
            }
            this.importLexerState(savedLexerState);
          };
          Recoverable2.prototype.shouldInRepetitionRecoveryBeTried = function(expectTokAfterLastMatch, nextTokIdx, notStuck) {
            if (notStuck === false) {
              return false;
            }
            if (this.tokenMatcher(this.LA(1), expectTokAfterLastMatch)) {
              return false;
            }
            if (this.isBackTracking()) {
              return false;
            }
            if (this.canPerformInRuleRecovery(expectTokAfterLastMatch, this.getFollowsForInRuleRecovery(expectTokAfterLastMatch, nextTokIdx))) {
              return false;
            }
            return true;
          };
          Recoverable2.prototype.getFollowsForInRuleRecovery = function(tokType, tokIdxInRule) {
            var grammarPath = this.getCurrentGrammarPath(tokType, tokIdxInRule);
            var follows = this.getNextPossibleTokenTypes(grammarPath);
            return follows;
          };
          Recoverable2.prototype.tryInRuleRecovery = function(expectedTokType, follows) {
            if (this.canRecoverWithSingleTokenInsertion(expectedTokType, follows)) {
              var tokToInsert = this.getTokenToInsert(expectedTokType);
              return tokToInsert;
            }
            if (this.canRecoverWithSingleTokenDeletion(expectedTokType)) {
              var nextTok = this.SKIP_TOKEN();
              this.consumeToken();
              return nextTok;
            }
            throw new InRuleRecoveryException("sad sad panda");
          };
          Recoverable2.prototype.canPerformInRuleRecovery = function(expectedToken, follows) {
            return this.canRecoverWithSingleTokenInsertion(expectedToken, follows) || this.canRecoverWithSingleTokenDeletion(expectedToken);
          };
          Recoverable2.prototype.canRecoverWithSingleTokenInsertion = function(expectedTokType, follows) {
            var _this = this;
            if (!this.canTokenTypeBeInsertedInRecovery(expectedTokType)) {
              return false;
            }
            if ((0, isEmpty_1.default)(follows)) {
              return false;
            }
            var mismatchedTok = this.LA(1);
            var isMisMatchedTokInFollows = (0, find_1.default)(follows, function(possibleFollowsTokType) {
              return _this.tokenMatcher(mismatchedTok, possibleFollowsTokType);
            }) !== void 0;
            return isMisMatchedTokInFollows;
          };
          Recoverable2.prototype.canRecoverWithSingleTokenDeletion = function(expectedTokType) {
            if (!this.canTokenTypeBeDeletedInRecovery(expectedTokType)) {
              return false;
            }
            var isNextTokenWhatIsExpected = this.tokenMatcher(this.LA(2), expectedTokType);
            return isNextTokenWhatIsExpected;
          };
          Recoverable2.prototype.isInCurrentRuleReSyncSet = function(tokenTypeIdx) {
            var followKey = this.getCurrFollowKey();
            var currentRuleReSyncSet = this.getFollowSetFromFollowKey(followKey);
            return (0, includes_1.default)(currentRuleReSyncSet, tokenTypeIdx);
          };
          Recoverable2.prototype.findReSyncTokenType = function() {
            var allPossibleReSyncTokTypes = this.flattenFollowSet();
            var nextToken = this.LA(1);
            var k = 2;
            while (true) {
              var foundMatch = (0, find_1.default)(allPossibleReSyncTokTypes, function(resyncTokType) {
                var canMatch = (0, tokens_public_1.tokenMatcher)(nextToken, resyncTokType);
                return canMatch;
              });
              if (foundMatch !== void 0) {
                return foundMatch;
              }
              nextToken = this.LA(k);
              k++;
            }
          };
          Recoverable2.prototype.getCurrFollowKey = function() {
            if (this.RULE_STACK.length === 1) {
              return exports2.EOF_FOLLOW_KEY;
            }
            var currRuleShortName = this.getLastExplicitRuleShortName();
            var currRuleIdx = this.getLastExplicitRuleOccurrenceIndex();
            var prevRuleShortName = this.getPreviousExplicitRuleShortName();
            return {
              ruleName: this.shortRuleNameToFullName(currRuleShortName),
              idxInCallingRule: currRuleIdx,
              inRule: this.shortRuleNameToFullName(prevRuleShortName)
            };
          };
          Recoverable2.prototype.buildFullFollowKeyStack = function() {
            var _this = this;
            var explicitRuleStack = this.RULE_STACK;
            var explicitOccurrenceStack = this.RULE_OCCURRENCE_STACK;
            return (0, map_1.default)(explicitRuleStack, function(ruleName, idx) {
              if (idx === 0) {
                return exports2.EOF_FOLLOW_KEY;
              }
              return {
                ruleName: _this.shortRuleNameToFullName(ruleName),
                idxInCallingRule: explicitOccurrenceStack[idx],
                inRule: _this.shortRuleNameToFullName(explicitRuleStack[idx - 1])
              };
            });
          };
          Recoverable2.prototype.flattenFollowSet = function() {
            var _this = this;
            var followStack = (0, map_1.default)(this.buildFullFollowKeyStack(), function(currKey) {
              return _this.getFollowSetFromFollowKey(currKey);
            });
            return (0, flatten_1.default)(followStack);
          };
          Recoverable2.prototype.getFollowSetFromFollowKey = function(followKey) {
            if (followKey === exports2.EOF_FOLLOW_KEY) {
              return [tokens_public_1.EOF];
            }
            var followName = followKey.ruleName + followKey.idxInCallingRule + constants_1.IN + followKey.inRule;
            return this.resyncFollows[followName];
          };
          Recoverable2.prototype.addToResyncTokens = function(token, resyncTokens) {
            if (!this.tokenMatcher(token, tokens_public_1.EOF)) {
              resyncTokens.push(token);
            }
            return resyncTokens;
          };
          Recoverable2.prototype.reSyncTo = function(tokType) {
            var resyncedTokens = [];
            var nextTok = this.LA(1);
            while (this.tokenMatcher(nextTok, tokType) === false) {
              nextTok = this.SKIP_TOKEN();
              this.addToResyncTokens(nextTok, resyncedTokens);
            }
            return (0, dropRight_1.default)(resyncedTokens);
          };
          Recoverable2.prototype.attemptInRepetitionRecovery = function(prodFunc, args2, lookaheadFunc, dslMethodIdx, prodOccurrence, nextToksWalker, notStuck) {
          };
          Recoverable2.prototype.getCurrentGrammarPath = function(tokType, tokIdxInRule) {
            var pathRuleStack = this.getHumanReadableRuleStack();
            var pathOccurrenceStack = (0, clone_1.default)(this.RULE_OCCURRENCE_STACK);
            var grammarPath = {
              ruleStack: pathRuleStack,
              occurrenceStack: pathOccurrenceStack,
              lastTok: tokType,
              lastTokOccurrence: tokIdxInRule
            };
            return grammarPath;
          };
          Recoverable2.prototype.getHumanReadableRuleStack = function() {
            var _this = this;
            return (0, map_1.default)(this.RULE_STACK, function(currShortName) {
              return _this.shortRuleNameToFullName(currShortName);
            });
          };
          return Recoverable2;
        }()
      );
      exports2.Recoverable = Recoverable;
      function attemptInRepetitionRecovery(prodFunc, args2, lookaheadFunc, dslMethodIdx, prodOccurrence, nextToksWalker, notStuck) {
        var key = this.getKeyForAutomaticLookahead(dslMethodIdx, prodOccurrence);
        var firstAfterRepInfo = this.firstAfterRepMap[key];
        if (firstAfterRepInfo === void 0) {
          var currRuleName = this.getCurrRuleFullName();
          var ruleGrammar = this.getGAstProductions()[currRuleName];
          var walker = new nextToksWalker(ruleGrammar, prodOccurrence);
          firstAfterRepInfo = walker.startWalking();
          this.firstAfterRepMap[key] = firstAfterRepInfo;
        }
        var expectTokAfterLastMatch = firstAfterRepInfo.token;
        var nextTokIdx = firstAfterRepInfo.occurrence;
        var isEndOfRule = firstAfterRepInfo.isEndOfRule;
        if (this.RULE_STACK.length === 1 && isEndOfRule && expectTokAfterLastMatch === void 0) {
          expectTokAfterLastMatch = tokens_public_1.EOF;
          nextTokIdx = 1;
        }
        if (expectTokAfterLastMatch === void 0 || nextTokIdx === void 0) {
          return;
        }
        if (this.shouldInRepetitionRecoveryBeTried(expectTokAfterLastMatch, nextTokIdx, notStuck)) {
          this.tryInRepetitionRecovery(prodFunc, args2, lookaheadFunc, expectTokAfterLastMatch);
        }
      }
      exports2.attemptInRepetitionRecovery = attemptInRepetitionRecovery;
    }
  });

  // node_modules/.pnpm/chevrotain@10.5.0/node_modules/chevrotain/lib/src/parse/grammar/keys.js
  var require_keys2 = __commonJS({
    "node_modules/.pnpm/chevrotain@10.5.0/node_modules/chevrotain/lib/src/parse/grammar/keys.js"(exports2) {
      "use strict";
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.getKeyForAutomaticLookahead = exports2.AT_LEAST_ONE_SEP_IDX = exports2.MANY_SEP_IDX = exports2.AT_LEAST_ONE_IDX = exports2.MANY_IDX = exports2.OPTION_IDX = exports2.OR_IDX = exports2.BITS_FOR_ALT_IDX = exports2.BITS_FOR_RULE_IDX = exports2.BITS_FOR_OCCURRENCE_IDX = exports2.BITS_FOR_METHOD_TYPE = void 0;
      exports2.BITS_FOR_METHOD_TYPE = 4;
      exports2.BITS_FOR_OCCURRENCE_IDX = 8;
      exports2.BITS_FOR_RULE_IDX = 12;
      exports2.BITS_FOR_ALT_IDX = 8;
      exports2.OR_IDX = 1 << exports2.BITS_FOR_OCCURRENCE_IDX;
      exports2.OPTION_IDX = 2 << exports2.BITS_FOR_OCCURRENCE_IDX;
      exports2.MANY_IDX = 3 << exports2.BITS_FOR_OCCURRENCE_IDX;
      exports2.AT_LEAST_ONE_IDX = 4 << exports2.BITS_FOR_OCCURRENCE_IDX;
      exports2.MANY_SEP_IDX = 5 << exports2.BITS_FOR_OCCURRENCE_IDX;
      exports2.AT_LEAST_ONE_SEP_IDX = 6 << exports2.BITS_FOR_OCCURRENCE_IDX;
      function getKeyForAutomaticLookahead(ruleIdx, dslMethodIdx, occurrence) {
        return occurrence | dslMethodIdx | ruleIdx;
      }
      exports2.getKeyForAutomaticLookahead = getKeyForAutomaticLookahead;
      var BITS_START_FOR_ALT_IDX = 32 - exports2.BITS_FOR_ALT_IDX;
    }
  });

  // node_modules/.pnpm/chevrotain@10.5.0/node_modules/chevrotain/lib/src/parse/grammar/llk_lookahead.js
  var require_llk_lookahead = __commonJS({
    "node_modules/.pnpm/chevrotain@10.5.0/node_modules/chevrotain/lib/src/parse/grammar/llk_lookahead.js"(exports2) {
      "use strict";
      var __spreadArray = exports2 && exports2.__spreadArray || function(to, from, pack) {
        if (pack || arguments.length === 2)
          for (var i = 0, l = from.length, ar; i < l; i++) {
            if (ar || !(i in from)) {
              if (!ar)
                ar = Array.prototype.slice.call(from, 0, i);
              ar[i] = from[i];
            }
          }
        return to.concat(ar || Array.prototype.slice.call(from));
      };
      var __importDefault = exports2 && exports2.__importDefault || function(mod) {
        return mod && mod.__esModule ? mod : { "default": mod };
      };
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.LLkLookaheadStrategy = void 0;
      var flatMap_1 = __importDefault(require_flatMap());
      var isEmpty_1 = __importDefault(require_isEmpty());
      var errors_public_1 = require_errors_public();
      var parser_1 = require_parser();
      var checks_1 = require_checks();
      var lookahead_1 = require_lookahead();
      var LLkLookaheadStrategy = (
        /** @class */
        function() {
          function LLkLookaheadStrategy2(options) {
            var _a2;
            this.maxLookahead = (_a2 = options === null || options === void 0 ? void 0 : options.maxLookahead) !== null && _a2 !== void 0 ? _a2 : parser_1.DEFAULT_PARSER_CONFIG.maxLookahead;
          }
          LLkLookaheadStrategy2.prototype.validate = function(options) {
            var leftRecursionErrors = this.validateNoLeftRecursion(options.rules);
            if ((0, isEmpty_1.default)(leftRecursionErrors)) {
              var emptyAltErrors = this.validateEmptyOrAlternatives(options.rules);
              var ambiguousAltsErrors = this.validateAmbiguousAlternationAlternatives(options.rules, this.maxLookahead);
              var emptyRepetitionErrors = this.validateSomeNonEmptyLookaheadPath(options.rules, this.maxLookahead);
              var allErrors = __spreadArray(__spreadArray(__spreadArray(__spreadArray([], leftRecursionErrors, true), emptyAltErrors, true), ambiguousAltsErrors, true), emptyRepetitionErrors, true);
              return allErrors;
            }
            return leftRecursionErrors;
          };
          LLkLookaheadStrategy2.prototype.validateNoLeftRecursion = function(rules) {
            return (0, flatMap_1.default)(rules, function(currTopRule) {
              return (0, checks_1.validateNoLeftRecursion)(currTopRule, currTopRule, errors_public_1.defaultGrammarValidatorErrorProvider);
            });
          };
          LLkLookaheadStrategy2.prototype.validateEmptyOrAlternatives = function(rules) {
            return (0, flatMap_1.default)(rules, function(currTopRule) {
              return (0, checks_1.validateEmptyOrAlternative)(currTopRule, errors_public_1.defaultGrammarValidatorErrorProvider);
            });
          };
          LLkLookaheadStrategy2.prototype.validateAmbiguousAlternationAlternatives = function(rules, maxLookahead) {
            return (0, flatMap_1.default)(rules, function(currTopRule) {
              return (0, checks_1.validateAmbiguousAlternationAlternatives)(currTopRule, maxLookahead, errors_public_1.defaultGrammarValidatorErrorProvider);
            });
          };
          LLkLookaheadStrategy2.prototype.validateSomeNonEmptyLookaheadPath = function(rules, maxLookahead) {
            return (0, checks_1.validateSomeNonEmptyLookaheadPath)(rules, maxLookahead, errors_public_1.defaultGrammarValidatorErrorProvider);
          };
          LLkLookaheadStrategy2.prototype.buildLookaheadForAlternation = function(options) {
            return (0, lookahead_1.buildLookaheadFuncForOr)(options.prodOccurrence, options.rule, options.maxLookahead, options.hasPredicates, options.dynamicTokensEnabled, lookahead_1.buildAlternativesLookAheadFunc);
          };
          LLkLookaheadStrategy2.prototype.buildLookaheadForOptional = function(options) {
            return (0, lookahead_1.buildLookaheadFuncForOptionalProd)(options.prodOccurrence, options.rule, options.maxLookahead, options.dynamicTokensEnabled, (0, lookahead_1.getProdType)(options.prodType), lookahead_1.buildSingleAlternativeLookaheadFunction);
          };
          return LLkLookaheadStrategy2;
        }()
      );
      exports2.LLkLookaheadStrategy = LLkLookaheadStrategy;
    }
  });

  // node_modules/.pnpm/chevrotain@10.5.0/node_modules/chevrotain/lib/src/parse/parser/traits/looksahead.js
  var require_looksahead = __commonJS({
    "node_modules/.pnpm/chevrotain@10.5.0/node_modules/chevrotain/lib/src/parse/parser/traits/looksahead.js"(exports2) {
      "use strict";
      var __extends = exports2 && exports2.__extends || function() {
        var extendStatics = function(d, b) {
          extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b3) {
            d2.__proto__ = b3;
          } || function(d2, b3) {
            for (var p in b3)
              if (Object.prototype.hasOwnProperty.call(b3, p))
                d2[p] = b3[p];
          };
          return extendStatics(d, b);
        };
        return function(d, b) {
          if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
          extendStatics(d, b);
          function __() {
            this.constructor = d;
          }
          d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
        };
      }();
      var __importDefault = exports2 && exports2.__importDefault || function(mod) {
        return mod && mod.__esModule ? mod : { "default": mod };
      };
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.collectMethods = exports2.LooksAhead = void 0;
      var forEach_1 = __importDefault(require_forEach());
      var has_1 = __importDefault(require_has());
      var parser_1 = require_parser();
      var keys_1 = require_keys2();
      var gast_1 = require_api2();
      var gast_2 = require_api2();
      var llk_lookahead_1 = require_llk_lookahead();
      var LooksAhead = (
        /** @class */
        function() {
          function LooksAhead2() {
          }
          LooksAhead2.prototype.initLooksAhead = function(config2) {
            this.dynamicTokensEnabled = (0, has_1.default)(config2, "dynamicTokensEnabled") ? config2.dynamicTokensEnabled : parser_1.DEFAULT_PARSER_CONFIG.dynamicTokensEnabled;
            this.maxLookahead = (0, has_1.default)(config2, "maxLookahead") ? config2.maxLookahead : parser_1.DEFAULT_PARSER_CONFIG.maxLookahead;
            this.lookaheadStrategy = (0, has_1.default)(config2, "lookaheadStrategy") ? config2.lookaheadStrategy : new llk_lookahead_1.LLkLookaheadStrategy({ maxLookahead: this.maxLookahead });
            this.lookAheadFuncsCache = /* @__PURE__ */ new Map();
          };
          LooksAhead2.prototype.preComputeLookaheadFunctions = function(rules) {
            var _this = this;
            (0, forEach_1.default)(rules, function(currRule) {
              _this.TRACE_INIT("".concat(currRule.name, " Rule Lookahead"), function() {
                var _a2 = collectMethods(currRule), alternation = _a2.alternation, repetition = _a2.repetition, option = _a2.option, repetitionMandatory = _a2.repetitionMandatory, repetitionMandatoryWithSeparator = _a2.repetitionMandatoryWithSeparator, repetitionWithSeparator = _a2.repetitionWithSeparator;
                (0, forEach_1.default)(alternation, function(currProd) {
                  var prodIdx = currProd.idx === 0 ? "" : currProd.idx;
                  _this.TRACE_INIT("".concat((0, gast_2.getProductionDslName)(currProd)).concat(prodIdx), function() {
                    var laFunc = _this.lookaheadStrategy.buildLookaheadForAlternation({
                      prodOccurrence: currProd.idx,
                      rule: currRule,
                      maxLookahead: currProd.maxLookahead || _this.maxLookahead,
                      hasPredicates: currProd.hasPredicates,
                      dynamicTokensEnabled: _this.dynamicTokensEnabled
                    });
                    var key = (0, keys_1.getKeyForAutomaticLookahead)(_this.fullRuleNameToShort[currRule.name], keys_1.OR_IDX, currProd.idx);
                    _this.setLaFuncCache(key, laFunc);
                  });
                });
                (0, forEach_1.default)(repetition, function(currProd) {
                  _this.computeLookaheadFunc(currRule, currProd.idx, keys_1.MANY_IDX, "Repetition", currProd.maxLookahead, (0, gast_2.getProductionDslName)(currProd));
                });
                (0, forEach_1.default)(option, function(currProd) {
                  _this.computeLookaheadFunc(currRule, currProd.idx, keys_1.OPTION_IDX, "Option", currProd.maxLookahead, (0, gast_2.getProductionDslName)(currProd));
                });
                (0, forEach_1.default)(repetitionMandatory, function(currProd) {
                  _this.computeLookaheadFunc(currRule, currProd.idx, keys_1.AT_LEAST_ONE_IDX, "RepetitionMandatory", currProd.maxLookahead, (0, gast_2.getProductionDslName)(currProd));
                });
                (0, forEach_1.default)(repetitionMandatoryWithSeparator, function(currProd) {
                  _this.computeLookaheadFunc(currRule, currProd.idx, keys_1.AT_LEAST_ONE_SEP_IDX, "RepetitionMandatoryWithSeparator", currProd.maxLookahead, (0, gast_2.getProductionDslName)(currProd));
                });
                (0, forEach_1.default)(repetitionWithSeparator, function(currProd) {
                  _this.computeLookaheadFunc(currRule, currProd.idx, keys_1.MANY_SEP_IDX, "RepetitionWithSeparator", currProd.maxLookahead, (0, gast_2.getProductionDslName)(currProd));
                });
              });
            });
          };
          LooksAhead2.prototype.computeLookaheadFunc = function(rule, prodOccurrence, prodKey, prodType, prodMaxLookahead, dslMethodName) {
            var _this = this;
            this.TRACE_INIT("".concat(dslMethodName).concat(prodOccurrence === 0 ? "" : prodOccurrence), function() {
              var laFunc = _this.lookaheadStrategy.buildLookaheadForOptional({
                prodOccurrence,
                rule,
                maxLookahead: prodMaxLookahead || _this.maxLookahead,
                dynamicTokensEnabled: _this.dynamicTokensEnabled,
                prodType
              });
              var key = (0, keys_1.getKeyForAutomaticLookahead)(_this.fullRuleNameToShort[rule.name], prodKey, prodOccurrence);
              _this.setLaFuncCache(key, laFunc);
            });
          };
          LooksAhead2.prototype.getKeyForAutomaticLookahead = function(dslMethodIdx, occurrence) {
            var currRuleShortName = this.getLastExplicitRuleShortName();
            return (0, keys_1.getKeyForAutomaticLookahead)(currRuleShortName, dslMethodIdx, occurrence);
          };
          LooksAhead2.prototype.getLaFuncFromCache = function(key) {
            return this.lookAheadFuncsCache.get(key);
          };
          LooksAhead2.prototype.setLaFuncCache = function(key, value) {
            this.lookAheadFuncsCache.set(key, value);
          };
          return LooksAhead2;
        }()
      );
      exports2.LooksAhead = LooksAhead;
      var DslMethodsCollectorVisitor = (
        /** @class */
        function(_super) {
          __extends(DslMethodsCollectorVisitor2, _super);
          function DslMethodsCollectorVisitor2() {
            var _this = _super !== null && _super.apply(this, arguments) || this;
            _this.dslMethods = {
              option: [],
              alternation: [],
              repetition: [],
              repetitionWithSeparator: [],
              repetitionMandatory: [],
              repetitionMandatoryWithSeparator: []
            };
            return _this;
          }
          DslMethodsCollectorVisitor2.prototype.reset = function() {
            this.dslMethods = {
              option: [],
              alternation: [],
              repetition: [],
              repetitionWithSeparator: [],
              repetitionMandatory: [],
              repetitionMandatoryWithSeparator: []
            };
          };
          DslMethodsCollectorVisitor2.prototype.visitOption = function(option) {
            this.dslMethods.option.push(option);
          };
          DslMethodsCollectorVisitor2.prototype.visitRepetitionWithSeparator = function(manySep) {
            this.dslMethods.repetitionWithSeparator.push(manySep);
          };
          DslMethodsCollectorVisitor2.prototype.visitRepetitionMandatory = function(atLeastOne) {
            this.dslMethods.repetitionMandatory.push(atLeastOne);
          };
          DslMethodsCollectorVisitor2.prototype.visitRepetitionMandatoryWithSeparator = function(atLeastOneSep) {
            this.dslMethods.repetitionMandatoryWithSeparator.push(atLeastOneSep);
          };
          DslMethodsCollectorVisitor2.prototype.visitRepetition = function(many) {
            this.dslMethods.repetition.push(many);
          };
          DslMethodsCollectorVisitor2.prototype.visitAlternation = function(or) {
            this.dslMethods.alternation.push(or);
          };
          return DslMethodsCollectorVisitor2;
        }(gast_1.GAstVisitor)
      );
      var collectorVisitor = new DslMethodsCollectorVisitor();
      function collectMethods(rule) {
        collectorVisitor.reset();
        rule.accept(collectorVisitor);
        var dslMethods = collectorVisitor.dslMethods;
        collectorVisitor.reset();
        return dslMethods;
      }
      exports2.collectMethods = collectMethods;
    }
  });

  // node_modules/.pnpm/chevrotain@10.5.0/node_modules/chevrotain/lib/src/parse/cst/cst.js
  var require_cst = __commonJS({
    "node_modules/.pnpm/chevrotain@10.5.0/node_modules/chevrotain/lib/src/parse/cst/cst.js"(exports2) {
      "use strict";
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.addNoneTerminalToCst = exports2.addTerminalToCst = exports2.setNodeLocationFull = exports2.setNodeLocationOnlyOffset = void 0;
      function setNodeLocationOnlyOffset(currNodeLocation, newLocationInfo) {
        if (isNaN(currNodeLocation.startOffset) === true) {
          currNodeLocation.startOffset = newLocationInfo.startOffset;
          currNodeLocation.endOffset = newLocationInfo.endOffset;
        } else if (currNodeLocation.endOffset < newLocationInfo.endOffset === true) {
          currNodeLocation.endOffset = newLocationInfo.endOffset;
        }
      }
      exports2.setNodeLocationOnlyOffset = setNodeLocationOnlyOffset;
      function setNodeLocationFull(currNodeLocation, newLocationInfo) {
        if (isNaN(currNodeLocation.startOffset) === true) {
          currNodeLocation.startOffset = newLocationInfo.startOffset;
          currNodeLocation.startColumn = newLocationInfo.startColumn;
          currNodeLocation.startLine = newLocationInfo.startLine;
          currNodeLocation.endOffset = newLocationInfo.endOffset;
          currNodeLocation.endColumn = newLocationInfo.endColumn;
          currNodeLocation.endLine = newLocationInfo.endLine;
        } else if (currNodeLocation.endOffset < newLocationInfo.endOffset === true) {
          currNodeLocation.endOffset = newLocationInfo.endOffset;
          currNodeLocation.endColumn = newLocationInfo.endColumn;
          currNodeLocation.endLine = newLocationInfo.endLine;
        }
      }
      exports2.setNodeLocationFull = setNodeLocationFull;
      function addTerminalToCst(node, token, tokenTypeName) {
        if (node.children[tokenTypeName] === void 0) {
          node.children[tokenTypeName] = [token];
        } else {
          node.children[tokenTypeName].push(token);
        }
      }
      exports2.addTerminalToCst = addTerminalToCst;
      function addNoneTerminalToCst(node, ruleName, ruleResult) {
        if (node.children[ruleName] === void 0) {
          node.children[ruleName] = [ruleResult];
        } else {
          node.children[ruleName].push(ruleResult);
        }
      }
      exports2.addNoneTerminalToCst = addNoneTerminalToCst;
    }
  });

  // node_modules/.pnpm/chevrotain@10.5.0/node_modules/chevrotain/lib/src/lang/lang_extensions.js
  var require_lang_extensions = __commonJS({
    "node_modules/.pnpm/chevrotain@10.5.0/node_modules/chevrotain/lib/src/lang/lang_extensions.js"(exports2) {
      "use strict";
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.defineNameProp = void 0;
      var NAME = "name";
      function defineNameProp(obj, nameValue) {
        Object.defineProperty(obj, NAME, {
          enumerable: false,
          configurable: true,
          writable: false,
          value: nameValue
        });
      }
      exports2.defineNameProp = defineNameProp;
    }
  });

  // node_modules/.pnpm/chevrotain@10.5.0/node_modules/chevrotain/lib/src/parse/cst/cst_visitor.js
  var require_cst_visitor = __commonJS({
    "node_modules/.pnpm/chevrotain@10.5.0/node_modules/chevrotain/lib/src/parse/cst/cst_visitor.js"(exports2) {
      "use strict";
      var __importDefault = exports2 && exports2.__importDefault || function(mod) {
        return mod && mod.__esModule ? mod : { "default": mod };
      };
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.validateMissingCstMethods = exports2.validateVisitor = exports2.CstVisitorDefinitionError = exports2.createBaseVisitorConstructorWithDefaults = exports2.createBaseSemanticVisitorConstructor = exports2.defaultVisit = void 0;
      var isEmpty_1 = __importDefault(require_isEmpty());
      var compact_1 = __importDefault(require_compact());
      var isArray_1 = __importDefault(require_isArray());
      var map_1 = __importDefault(require_map());
      var forEach_1 = __importDefault(require_forEach());
      var filter_1 = __importDefault(require_filter());
      var keys_1 = __importDefault(require_keys());
      var isFunction_1 = __importDefault(require_isFunction());
      var isUndefined_1 = __importDefault(require_isUndefined());
      var lang_extensions_1 = require_lang_extensions();
      function defaultVisit(ctx, param) {
        var childrenNames = (0, keys_1.default)(ctx);
        var childrenNamesLength = childrenNames.length;
        for (var i = 0; i < childrenNamesLength; i++) {
          var currChildName = childrenNames[i];
          var currChildArray = ctx[currChildName];
          var currChildArrayLength = currChildArray.length;
          for (var j = 0; j < currChildArrayLength; j++) {
            var currChild = currChildArray[j];
            if (currChild.tokenTypeIdx === void 0) {
              this[currChild.name](currChild.children, param);
            }
          }
        }
      }
      exports2.defaultVisit = defaultVisit;
      function createBaseSemanticVisitorConstructor(grammarName, ruleNames) {
        var derivedConstructor = function() {
        };
        (0, lang_extensions_1.defineNameProp)(derivedConstructor, grammarName + "BaseSemantics");
        var semanticProto = {
          visit: function(cstNode, param) {
            if ((0, isArray_1.default)(cstNode)) {
              cstNode = cstNode[0];
            }
            if ((0, isUndefined_1.default)(cstNode)) {
              return void 0;
            }
            return this[cstNode.name](cstNode.children, param);
          },
          validateVisitor: function() {
            var semanticDefinitionErrors = validateVisitor(this, ruleNames);
            if (!(0, isEmpty_1.default)(semanticDefinitionErrors)) {
              var errorMessages = (0, map_1.default)(semanticDefinitionErrors, function(currDefError) {
                return currDefError.msg;
              });
              throw Error("Errors Detected in CST Visitor <".concat(this.constructor.name, ">:\n	") + "".concat(errorMessages.join("\n\n").replace(/\n/g, "\n	")));
            }
          }
        };
        derivedConstructor.prototype = semanticProto;
        derivedConstructor.prototype.constructor = derivedConstructor;
        derivedConstructor._RULE_NAMES = ruleNames;
        return derivedConstructor;
      }
      exports2.createBaseSemanticVisitorConstructor = createBaseSemanticVisitorConstructor;
      function createBaseVisitorConstructorWithDefaults(grammarName, ruleNames, baseConstructor) {
        var derivedConstructor = function() {
        };
        (0, lang_extensions_1.defineNameProp)(derivedConstructor, grammarName + "BaseSemanticsWithDefaults");
        var withDefaultsProto = Object.create(baseConstructor.prototype);
        (0, forEach_1.default)(ruleNames, function(ruleName) {
          withDefaultsProto[ruleName] = defaultVisit;
        });
        derivedConstructor.prototype = withDefaultsProto;
        derivedConstructor.prototype.constructor = derivedConstructor;
        return derivedConstructor;
      }
      exports2.createBaseVisitorConstructorWithDefaults = createBaseVisitorConstructorWithDefaults;
      var CstVisitorDefinitionError;
      (function(CstVisitorDefinitionError2) {
        CstVisitorDefinitionError2[CstVisitorDefinitionError2["REDUNDANT_METHOD"] = 0] = "REDUNDANT_METHOD";
        CstVisitorDefinitionError2[CstVisitorDefinitionError2["MISSING_METHOD"] = 1] = "MISSING_METHOD";
      })(CstVisitorDefinitionError = exports2.CstVisitorDefinitionError || (exports2.CstVisitorDefinitionError = {}));
      function validateVisitor(visitorInstance, ruleNames) {
        var missingErrors = validateMissingCstMethods(visitorInstance, ruleNames);
        return missingErrors;
      }
      exports2.validateVisitor = validateVisitor;
      function validateMissingCstMethods(visitorInstance, ruleNames) {
        var missingRuleNames = (0, filter_1.default)(ruleNames, function(currRuleName) {
          return (0, isFunction_1.default)(visitorInstance[currRuleName]) === false;
        });
        var errors = (0, map_1.default)(missingRuleNames, function(currRuleName) {
          return {
            msg: "Missing visitor method: <".concat(currRuleName, "> on ").concat(visitorInstance.constructor.name, " CST Visitor."),
            type: CstVisitorDefinitionError.MISSING_METHOD,
            methodName: currRuleName
          };
        });
        return (0, compact_1.default)(errors);
      }
      exports2.validateMissingCstMethods = validateMissingCstMethods;
    }
  });

  // node_modules/.pnpm/chevrotain@10.5.0/node_modules/chevrotain/lib/src/parse/parser/traits/tree_builder.js
  var require_tree_builder = __commonJS({
    "node_modules/.pnpm/chevrotain@10.5.0/node_modules/chevrotain/lib/src/parse/parser/traits/tree_builder.js"(exports2) {
      "use strict";
      var __importDefault = exports2 && exports2.__importDefault || function(mod) {
        return mod && mod.__esModule ? mod : { "default": mod };
      };
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.TreeBuilder = void 0;
      var cst_1 = require_cst();
      var noop_1 = __importDefault(require_noop());
      var has_1 = __importDefault(require_has());
      var keys_1 = __importDefault(require_keys());
      var isUndefined_1 = __importDefault(require_isUndefined());
      var cst_visitor_1 = require_cst_visitor();
      var parser_1 = require_parser();
      var TreeBuilder = (
        /** @class */
        function() {
          function TreeBuilder2() {
          }
          TreeBuilder2.prototype.initTreeBuilder = function(config2) {
            this.CST_STACK = [];
            this.outputCst = config2.outputCst;
            this.nodeLocationTracking = (0, has_1.default)(config2, "nodeLocationTracking") ? config2.nodeLocationTracking : parser_1.DEFAULT_PARSER_CONFIG.nodeLocationTracking;
            if (!this.outputCst) {
              this.cstInvocationStateUpdate = noop_1.default;
              this.cstFinallyStateUpdate = noop_1.default;
              this.cstPostTerminal = noop_1.default;
              this.cstPostNonTerminal = noop_1.default;
              this.cstPostRule = noop_1.default;
            } else {
              if (/full/i.test(this.nodeLocationTracking)) {
                if (this.recoveryEnabled) {
                  this.setNodeLocationFromToken = cst_1.setNodeLocationFull;
                  this.setNodeLocationFromNode = cst_1.setNodeLocationFull;
                  this.cstPostRule = noop_1.default;
                  this.setInitialNodeLocation = this.setInitialNodeLocationFullRecovery;
                } else {
                  this.setNodeLocationFromToken = noop_1.default;
                  this.setNodeLocationFromNode = noop_1.default;
                  this.cstPostRule = this.cstPostRuleFull;
                  this.setInitialNodeLocation = this.setInitialNodeLocationFullRegular;
                }
              } else if (/onlyOffset/i.test(this.nodeLocationTracking)) {
                if (this.recoveryEnabled) {
                  this.setNodeLocationFromToken = cst_1.setNodeLocationOnlyOffset;
                  this.setNodeLocationFromNode = cst_1.setNodeLocationOnlyOffset;
                  this.cstPostRule = noop_1.default;
                  this.setInitialNodeLocation = this.setInitialNodeLocationOnlyOffsetRecovery;
                } else {
                  this.setNodeLocationFromToken = noop_1.default;
                  this.setNodeLocationFromNode = noop_1.default;
                  this.cstPostRule = this.cstPostRuleOnlyOffset;
                  this.setInitialNodeLocation = this.setInitialNodeLocationOnlyOffsetRegular;
                }
              } else if (/none/i.test(this.nodeLocationTracking)) {
                this.setNodeLocationFromToken = noop_1.default;
                this.setNodeLocationFromNode = noop_1.default;
                this.cstPostRule = noop_1.default;
                this.setInitialNodeLocation = noop_1.default;
              } else {
                throw Error('Invalid <nodeLocationTracking> config option: "'.concat(config2.nodeLocationTracking, '"'));
              }
            }
          };
          TreeBuilder2.prototype.setInitialNodeLocationOnlyOffsetRecovery = function(cstNode) {
            cstNode.location = {
              startOffset: NaN,
              endOffset: NaN
            };
          };
          TreeBuilder2.prototype.setInitialNodeLocationOnlyOffsetRegular = function(cstNode) {
            cstNode.location = {
              // without error recovery the starting Location of a new CstNode is guaranteed
              // To be the next Token's startOffset (for valid inputs).
              // For invalid inputs there won't be any CSTOutput so this potential
              // inaccuracy does not matter
              startOffset: this.LA(1).startOffset,
              endOffset: NaN
            };
          };
          TreeBuilder2.prototype.setInitialNodeLocationFullRecovery = function(cstNode) {
            cstNode.location = {
              startOffset: NaN,
              startLine: NaN,
              startColumn: NaN,
              endOffset: NaN,
              endLine: NaN,
              endColumn: NaN
            };
          };
          TreeBuilder2.prototype.setInitialNodeLocationFullRegular = function(cstNode) {
            var nextToken = this.LA(1);
            cstNode.location = {
              startOffset: nextToken.startOffset,
              startLine: nextToken.startLine,
              startColumn: nextToken.startColumn,
              endOffset: NaN,
              endLine: NaN,
              endColumn: NaN
            };
          };
          TreeBuilder2.prototype.cstInvocationStateUpdate = function(fullRuleName) {
            var cstNode = {
              name: fullRuleName,
              children: /* @__PURE__ */ Object.create(null)
            };
            this.setInitialNodeLocation(cstNode);
            this.CST_STACK.push(cstNode);
          };
          TreeBuilder2.prototype.cstFinallyStateUpdate = function() {
            this.CST_STACK.pop();
          };
          TreeBuilder2.prototype.cstPostRuleFull = function(ruleCstNode) {
            var prevToken = this.LA(0);
            var loc = ruleCstNode.location;
            if (loc.startOffset <= prevToken.startOffset === true) {
              loc.endOffset = prevToken.endOffset;
              loc.endLine = prevToken.endLine;
              loc.endColumn = prevToken.endColumn;
            } else {
              loc.startOffset = NaN;
              loc.startLine = NaN;
              loc.startColumn = NaN;
            }
          };
          TreeBuilder2.prototype.cstPostRuleOnlyOffset = function(ruleCstNode) {
            var prevToken = this.LA(0);
            var loc = ruleCstNode.location;
            if (loc.startOffset <= prevToken.startOffset === true) {
              loc.endOffset = prevToken.endOffset;
            } else {
              loc.startOffset = NaN;
            }
          };
          TreeBuilder2.prototype.cstPostTerminal = function(key, consumedToken) {
            var rootCst = this.CST_STACK[this.CST_STACK.length - 1];
            (0, cst_1.addTerminalToCst)(rootCst, consumedToken, key);
            this.setNodeLocationFromToken(rootCst.location, consumedToken);
          };
          TreeBuilder2.prototype.cstPostNonTerminal = function(ruleCstResult, ruleName) {
            var preCstNode = this.CST_STACK[this.CST_STACK.length - 1];
            (0, cst_1.addNoneTerminalToCst)(preCstNode, ruleName, ruleCstResult);
            this.setNodeLocationFromNode(preCstNode.location, ruleCstResult.location);
          };
          TreeBuilder2.prototype.getBaseCstVisitorConstructor = function() {
            if ((0, isUndefined_1.default)(this.baseCstVisitorConstructor)) {
              var newBaseCstVisitorConstructor = (0, cst_visitor_1.createBaseSemanticVisitorConstructor)(this.className, (0, keys_1.default)(this.gastProductionsCache));
              this.baseCstVisitorConstructor = newBaseCstVisitorConstructor;
              return newBaseCstVisitorConstructor;
            }
            return this.baseCstVisitorConstructor;
          };
          TreeBuilder2.prototype.getBaseCstVisitorConstructorWithDefaults = function() {
            if ((0, isUndefined_1.default)(this.baseCstVisitorWithDefaultsConstructor)) {
              var newConstructor = (0, cst_visitor_1.createBaseVisitorConstructorWithDefaults)(this.className, (0, keys_1.default)(this.gastProductionsCache), this.getBaseCstVisitorConstructor());
              this.baseCstVisitorWithDefaultsConstructor = newConstructor;
              return newConstructor;
            }
            return this.baseCstVisitorWithDefaultsConstructor;
          };
          TreeBuilder2.prototype.getLastExplicitRuleShortName = function() {
            var ruleStack = this.RULE_STACK;
            return ruleStack[ruleStack.length - 1];
          };
          TreeBuilder2.prototype.getPreviousExplicitRuleShortName = function() {
            var ruleStack = this.RULE_STACK;
            return ruleStack[ruleStack.length - 2];
          };
          TreeBuilder2.prototype.getLastExplicitRuleOccurrenceIndex = function() {
            var occurrenceStack = this.RULE_OCCURRENCE_STACK;
            return occurrenceStack[occurrenceStack.length - 1];
          };
          return TreeBuilder2;
        }()
      );
      exports2.TreeBuilder = TreeBuilder;
    }
  });

  // node_modules/.pnpm/chevrotain@10.5.0/node_modules/chevrotain/lib/src/parse/parser/traits/lexer_adapter.js
  var require_lexer_adapter = __commonJS({
    "node_modules/.pnpm/chevrotain@10.5.0/node_modules/chevrotain/lib/src/parse/parser/traits/lexer_adapter.js"(exports2) {
      "use strict";
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.LexerAdapter = void 0;
      var parser_1 = require_parser();
      var LexerAdapter = (
        /** @class */
        function() {
          function LexerAdapter2() {
          }
          LexerAdapter2.prototype.initLexerAdapter = function() {
            this.tokVector = [];
            this.tokVectorLength = 0;
            this.currIdx = -1;
          };
          Object.defineProperty(LexerAdapter2.prototype, "input", {
            get: function() {
              return this.tokVector;
            },
            set: function(newInput) {
              if (this.selfAnalysisDone !== true) {
                throw Error("Missing <performSelfAnalysis> invocation at the end of the Parser's constructor.");
              }
              this.reset();
              this.tokVector = newInput;
              this.tokVectorLength = newInput.length;
            },
            enumerable: false,
            configurable: true
          });
          LexerAdapter2.prototype.SKIP_TOKEN = function() {
            if (this.currIdx <= this.tokVector.length - 2) {
              this.consumeToken();
              return this.LA(1);
            } else {
              return parser_1.END_OF_FILE;
            }
          };
          LexerAdapter2.prototype.LA = function(howMuch) {
            var soughtIdx = this.currIdx + howMuch;
            if (soughtIdx < 0 || this.tokVectorLength <= soughtIdx) {
              return parser_1.END_OF_FILE;
            } else {
              return this.tokVector[soughtIdx];
            }
          };
          LexerAdapter2.prototype.consumeToken = function() {
            this.currIdx++;
          };
          LexerAdapter2.prototype.exportLexerState = function() {
            return this.currIdx;
          };
          LexerAdapter2.prototype.importLexerState = function(newState) {
            this.currIdx = newState;
          };
          LexerAdapter2.prototype.resetLexerState = function() {
            this.currIdx = -1;
          };
          LexerAdapter2.prototype.moveToTerminatedState = function() {
            this.currIdx = this.tokVector.length - 1;
          };
          LexerAdapter2.prototype.getLexerPosition = function() {
            return this.exportLexerState();
          };
          return LexerAdapter2;
        }()
      );
      exports2.LexerAdapter = LexerAdapter;
    }
  });

  // node_modules/.pnpm/chevrotain@10.5.0/node_modules/chevrotain/lib/src/parse/parser/traits/recognizer_api.js
  var require_recognizer_api = __commonJS({
    "node_modules/.pnpm/chevrotain@10.5.0/node_modules/chevrotain/lib/src/parse/parser/traits/recognizer_api.js"(exports2) {
      "use strict";
      var __importDefault = exports2 && exports2.__importDefault || function(mod) {
        return mod && mod.__esModule ? mod : { "default": mod };
      };
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.RecognizerApi = void 0;
      var values_1 = __importDefault(require_values());
      var includes_1 = __importDefault(require_includes());
      var exceptions_public_1 = require_exceptions_public();
      var parser_1 = require_parser();
      var errors_public_1 = require_errors_public();
      var checks_1 = require_checks();
      var gast_1 = require_api2();
      var RecognizerApi = (
        /** @class */
        function() {
          function RecognizerApi2() {
          }
          RecognizerApi2.prototype.ACTION = function(impl) {
            return impl.call(this);
          };
          RecognizerApi2.prototype.consume = function(idx, tokType, options) {
            return this.consumeInternal(tokType, idx, options);
          };
          RecognizerApi2.prototype.subrule = function(idx, ruleToCall, options) {
            return this.subruleInternal(ruleToCall, idx, options);
          };
          RecognizerApi2.prototype.option = function(idx, actionORMethodDef) {
            return this.optionInternal(actionORMethodDef, idx);
          };
          RecognizerApi2.prototype.or = function(idx, altsOrOpts) {
            return this.orInternal(altsOrOpts, idx);
          };
          RecognizerApi2.prototype.many = function(idx, actionORMethodDef) {
            return this.manyInternal(idx, actionORMethodDef);
          };
          RecognizerApi2.prototype.atLeastOne = function(idx, actionORMethodDef) {
            return this.atLeastOneInternal(idx, actionORMethodDef);
          };
          RecognizerApi2.prototype.CONSUME = function(tokType, options) {
            return this.consumeInternal(tokType, 0, options);
          };
          RecognizerApi2.prototype.CONSUME1 = function(tokType, options) {
            return this.consumeInternal(tokType, 1, options);
          };
          RecognizerApi2.prototype.CONSUME2 = function(tokType, options) {
            return this.consumeInternal(tokType, 2, options);
          };
          RecognizerApi2.prototype.CONSUME3 = function(tokType, options) {
            return this.consumeInternal(tokType, 3, options);
          };
          RecognizerApi2.prototype.CONSUME4 = function(tokType, options) {
            return this.consumeInternal(tokType, 4, options);
          };
          RecognizerApi2.prototype.CONSUME5 = function(tokType, options) {
            return this.consumeInternal(tokType, 5, options);
          };
          RecognizerApi2.prototype.CONSUME6 = function(tokType, options) {
            return this.consumeInternal(tokType, 6, options);
          };
          RecognizerApi2.prototype.CONSUME7 = function(tokType, options) {
            return this.consumeInternal(tokType, 7, options);
          };
          RecognizerApi2.prototype.CONSUME8 = function(tokType, options) {
            return this.consumeInternal(tokType, 8, options);
          };
          RecognizerApi2.prototype.CONSUME9 = function(tokType, options) {
            return this.consumeInternal(tokType, 9, options);
          };
          RecognizerApi2.prototype.SUBRULE = function(ruleToCall, options) {
            return this.subruleInternal(ruleToCall, 0, options);
          };
          RecognizerApi2.prototype.SUBRULE1 = function(ruleToCall, options) {
            return this.subruleInternal(ruleToCall, 1, options);
          };
          RecognizerApi2.prototype.SUBRULE2 = function(ruleToCall, options) {
            return this.subruleInternal(ruleToCall, 2, options);
          };
          RecognizerApi2.prototype.SUBRULE3 = function(ruleToCall, options) {
            return this.subruleInternal(ruleToCall, 3, options);
          };
          RecognizerApi2.prototype.SUBRULE4 = function(ruleToCall, options) {
            return this.subruleInternal(ruleToCall, 4, options);
          };
          RecognizerApi2.prototype.SUBRULE5 = function(ruleToCall, options) {
            return this.subruleInternal(ruleToCall, 5, options);
          };
          RecognizerApi2.prototype.SUBRULE6 = function(ruleToCall, options) {
            return this.subruleInternal(ruleToCall, 6, options);
          };
          RecognizerApi2.prototype.SUBRULE7 = function(ruleToCall, options) {
            return this.subruleInternal(ruleToCall, 7, options);
          };
          RecognizerApi2.prototype.SUBRULE8 = function(ruleToCall, options) {
            return this.subruleInternal(ruleToCall, 8, options);
          };
          RecognizerApi2.prototype.SUBRULE9 = function(ruleToCall, options) {
            return this.subruleInternal(ruleToCall, 9, options);
          };
          RecognizerApi2.prototype.OPTION = function(actionORMethodDef) {
            return this.optionInternal(actionORMethodDef, 0);
          };
          RecognizerApi2.prototype.OPTION1 = function(actionORMethodDef) {
            return this.optionInternal(actionORMethodDef, 1);
          };
          RecognizerApi2.prototype.OPTION2 = function(actionORMethodDef) {
            return this.optionInternal(actionORMethodDef, 2);
          };
          RecognizerApi2.prototype.OPTION3 = function(actionORMethodDef) {
            return this.optionInternal(actionORMethodDef, 3);
          };
          RecognizerApi2.prototype.OPTION4 = function(actionORMethodDef) {
            return this.optionInternal(actionORMethodDef, 4);
          };
          RecognizerApi2.prototype.OPTION5 = function(actionORMethodDef) {
            return this.optionInternal(actionORMethodDef, 5);
          };
          RecognizerApi2.prototype.OPTION6 = function(actionORMethodDef) {
            return this.optionInternal(actionORMethodDef, 6);
          };
          RecognizerApi2.prototype.OPTION7 = function(actionORMethodDef) {
            return this.optionInternal(actionORMethodDef, 7);
          };
          RecognizerApi2.prototype.OPTION8 = function(actionORMethodDef) {
            return this.optionInternal(actionORMethodDef, 8);
          };
          RecognizerApi2.prototype.OPTION9 = function(actionORMethodDef) {
            return this.optionInternal(actionORMethodDef, 9);
          };
          RecognizerApi2.prototype.OR = function(altsOrOpts) {
            return this.orInternal(altsOrOpts, 0);
          };
          RecognizerApi2.prototype.OR1 = function(altsOrOpts) {
            return this.orInternal(altsOrOpts, 1);
          };
          RecognizerApi2.prototype.OR2 = function(altsOrOpts) {
            return this.orInternal(altsOrOpts, 2);
          };
          RecognizerApi2.prototype.OR3 = function(altsOrOpts) {
            return this.orInternal(altsOrOpts, 3);
          };
          RecognizerApi2.prototype.OR4 = function(altsOrOpts) {
            return this.orInternal(altsOrOpts, 4);
          };
          RecognizerApi2.prototype.OR5 = function(altsOrOpts) {
            return this.orInternal(altsOrOpts, 5);
          };
          RecognizerApi2.prototype.OR6 = function(altsOrOpts) {
            return this.orInternal(altsOrOpts, 6);
          };
          RecognizerApi2.prototype.OR7 = function(altsOrOpts) {
            return this.orInternal(altsOrOpts, 7);
          };
          RecognizerApi2.prototype.OR8 = function(altsOrOpts) {
            return this.orInternal(altsOrOpts, 8);
          };
          RecognizerApi2.prototype.OR9 = function(altsOrOpts) {
            return this.orInternal(altsOrOpts, 9);
          };
          RecognizerApi2.prototype.MANY = function(actionORMethodDef) {
            this.manyInternal(0, actionORMethodDef);
          };
          RecognizerApi2.prototype.MANY1 = function(actionORMethodDef) {
            this.manyInternal(1, actionORMethodDef);
          };
          RecognizerApi2.prototype.MANY2 = function(actionORMethodDef) {
            this.manyInternal(2, actionORMethodDef);
          };
          RecognizerApi2.prototype.MANY3 = function(actionORMethodDef) {
            this.manyInternal(3, actionORMethodDef);
          };
          RecognizerApi2.prototype.MANY4 = function(actionORMethodDef) {
            this.manyInternal(4, actionORMethodDef);
          };
          RecognizerApi2.prototype.MANY5 = function(actionORMethodDef) {
            this.manyInternal(5, actionORMethodDef);
          };
          RecognizerApi2.prototype.MANY6 = function(actionORMethodDef) {
            this.manyInternal(6, actionORMethodDef);
          };
          RecognizerApi2.prototype.MANY7 = function(actionORMethodDef) {
            this.manyInternal(7, actionORMethodDef);
          };
          RecognizerApi2.prototype.MANY8 = function(actionORMethodDef) {
            this.manyInternal(8, actionORMethodDef);
          };
          RecognizerApi2.prototype.MANY9 = function(actionORMethodDef) {
            this.manyInternal(9, actionORMethodDef);
          };
          RecognizerApi2.prototype.MANY_SEP = function(options) {
            this.manySepFirstInternal(0, options);
          };
          RecognizerApi2.prototype.MANY_SEP1 = function(options) {
            this.manySepFirstInternal(1, options);
          };
          RecognizerApi2.prototype.MANY_SEP2 = function(options) {
            this.manySepFirstInternal(2, options);
          };
          RecognizerApi2.prototype.MANY_SEP3 = function(options) {
            this.manySepFirstInternal(3, options);
          };
          RecognizerApi2.prototype.MANY_SEP4 = function(options) {
            this.manySepFirstInternal(4, options);
          };
          RecognizerApi2.prototype.MANY_SEP5 = function(options) {
            this.manySepFirstInternal(5, options);
          };
          RecognizerApi2.prototype.MANY_SEP6 = function(options) {
            this.manySepFirstInternal(6, options);
          };
          RecognizerApi2.prototype.MANY_SEP7 = function(options) {
            this.manySepFirstInternal(7, options);
          };
          RecognizerApi2.prototype.MANY_SEP8 = function(options) {
            this.manySepFirstInternal(8, options);
          };
          RecognizerApi2.prototype.MANY_SEP9 = function(options) {
            this.manySepFirstInternal(9, options);
          };
          RecognizerApi2.prototype.AT_LEAST_ONE = function(actionORMethodDef) {
            this.atLeastOneInternal(0, actionORMethodDef);
          };
          RecognizerApi2.prototype.AT_LEAST_ONE1 = function(actionORMethodDef) {
            return this.atLeastOneInternal(1, actionORMethodDef);
          };
          RecognizerApi2.prototype.AT_LEAST_ONE2 = function(actionORMethodDef) {
            this.atLeastOneInternal(2, actionORMethodDef);
          };
          RecognizerApi2.prototype.AT_LEAST_ONE3 = function(actionORMethodDef) {
            this.atLeastOneInternal(3, actionORMethodDef);
          };
          RecognizerApi2.prototype.AT_LEAST_ONE4 = function(actionORMethodDef) {
            this.atLeastOneInternal(4, actionORMethodDef);
          };
          RecognizerApi2.prototype.AT_LEAST_ONE5 = function(actionORMethodDef) {
            this.atLeastOneInternal(5, actionORMethodDef);
          };
          RecognizerApi2.prototype.AT_LEAST_ONE6 = function(actionORMethodDef) {
            this.atLeastOneInternal(6, actionORMethodDef);
          };
          RecognizerApi2.prototype.AT_LEAST_ONE7 = function(actionORMethodDef) {
            this.atLeastOneInternal(7, actionORMethodDef);
          };
          RecognizerApi2.prototype.AT_LEAST_ONE8 = function(actionORMethodDef) {
            this.atLeastOneInternal(8, actionORMethodDef);
          };
          RecognizerApi2.prototype.AT_LEAST_ONE9 = function(actionORMethodDef) {
            this.atLeastOneInternal(9, actionORMethodDef);
          };
          RecognizerApi2.prototype.AT_LEAST_ONE_SEP = function(options) {
            this.atLeastOneSepFirstInternal(0, options);
          };
          RecognizerApi2.prototype.AT_LEAST_ONE_SEP1 = function(options) {
            this.atLeastOneSepFirstInternal(1, options);
          };
          RecognizerApi2.prototype.AT_LEAST_ONE_SEP2 = function(options) {
            this.atLeastOneSepFirstInternal(2, options);
          };
          RecognizerApi2.prototype.AT_LEAST_ONE_SEP3 = function(options) {
            this.atLeastOneSepFirstInternal(3, options);
          };
          RecognizerApi2.prototype.AT_LEAST_ONE_SEP4 = function(options) {
            this.atLeastOneSepFirstInternal(4, options);
          };
          RecognizerApi2.prototype.AT_LEAST_ONE_SEP5 = function(options) {
            this.atLeastOneSepFirstInternal(5, options);
          };
          RecognizerApi2.prototype.AT_LEAST_ONE_SEP6 = function(options) {
            this.atLeastOneSepFirstInternal(6, options);
          };
          RecognizerApi2.prototype.AT_LEAST_ONE_SEP7 = function(options) {
            this.atLeastOneSepFirstInternal(7, options);
          };
          RecognizerApi2.prototype.AT_LEAST_ONE_SEP8 = function(options) {
            this.atLeastOneSepFirstInternal(8, options);
          };
          RecognizerApi2.prototype.AT_LEAST_ONE_SEP9 = function(options) {
            this.atLeastOneSepFirstInternal(9, options);
          };
          RecognizerApi2.prototype.RULE = function(name, implementation, config2) {
            if (config2 === void 0) {
              config2 = parser_1.DEFAULT_RULE_CONFIG;
            }
            if ((0, includes_1.default)(this.definedRulesNames, name)) {
              var errMsg = errors_public_1.defaultGrammarValidatorErrorProvider.buildDuplicateRuleNameError({
                topLevelRule: name,
                grammarName: this.className
              });
              var error = {
                message: errMsg,
                type: parser_1.ParserDefinitionErrorType.DUPLICATE_RULE_NAME,
                ruleName: name
              };
              this.definitionErrors.push(error);
            }
            this.definedRulesNames.push(name);
            var ruleImplementation = this.defineRule(name, implementation, config2);
            this[name] = ruleImplementation;
            return ruleImplementation;
          };
          RecognizerApi2.prototype.OVERRIDE_RULE = function(name, impl, config2) {
            if (config2 === void 0) {
              config2 = parser_1.DEFAULT_RULE_CONFIG;
            }
            var ruleErrors = (0, checks_1.validateRuleIsOverridden)(name, this.definedRulesNames, this.className);
            this.definitionErrors = this.definitionErrors.concat(ruleErrors);
            var ruleImplementation = this.defineRule(name, impl, config2);
            this[name] = ruleImplementation;
            return ruleImplementation;
          };
          RecognizerApi2.prototype.BACKTRACK = function(grammarRule, args2) {
            return function() {
              this.isBackTrackingStack.push(1);
              var orgState = this.saveRecogState();
              try {
                grammarRule.apply(this, args2);
                return true;
              } catch (e) {
                if ((0, exceptions_public_1.isRecognitionException)(e)) {
                  return false;
                } else {
                  throw e;
                }
              } finally {
                this.reloadRecogState(orgState);
                this.isBackTrackingStack.pop();
              }
            };
          };
          RecognizerApi2.prototype.getGAstProductions = function() {
            return this.gastProductionsCache;
          };
          RecognizerApi2.prototype.getSerializedGastProductions = function() {
            return (0, gast_1.serializeGrammar)((0, values_1.default)(this.gastProductionsCache));
          };
          return RecognizerApi2;
        }()
      );
      exports2.RecognizerApi = RecognizerApi;
    }
  });

  // node_modules/.pnpm/chevrotain@10.5.0/node_modules/chevrotain/lib/src/parse/parser/traits/recognizer_engine.js
  var require_recognizer_engine = __commonJS({
    "node_modules/.pnpm/chevrotain@10.5.0/node_modules/chevrotain/lib/src/parse/parser/traits/recognizer_engine.js"(exports2) {
      "use strict";
      var __importDefault = exports2 && exports2.__importDefault || function(mod) {
        return mod && mod.__esModule ? mod : { "default": mod };
      };
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.RecognizerEngine = void 0;
      var isEmpty_1 = __importDefault(require_isEmpty());
      var isArray_1 = __importDefault(require_isArray());
      var flatten_1 = __importDefault(require_flatten());
      var every_1 = __importDefault(require_every());
      var uniq_1 = __importDefault(require_uniq());
      var isObject_1 = __importDefault(require_isObject());
      var has_1 = __importDefault(require_has());
      var values_1 = __importDefault(require_values());
      var reduce_1 = __importDefault(require_reduce());
      var clone_1 = __importDefault(require_clone());
      var keys_1 = require_keys2();
      var exceptions_public_1 = require_exceptions_public();
      var lookahead_1 = require_lookahead();
      var interpreter_1 = require_interpreter();
      var parser_1 = require_parser();
      var recoverable_1 = require_recoverable();
      var tokens_public_1 = require_tokens_public();
      var tokens_1 = require_tokens();
      var RecognizerEngine = (
        /** @class */
        function() {
          function RecognizerEngine2() {
          }
          RecognizerEngine2.prototype.initRecognizerEngine = function(tokenVocabulary, config2) {
            this.className = this.constructor.name;
            this.shortRuleNameToFull = {};
            this.fullRuleNameToShort = {};
            this.ruleShortNameIdx = 256;
            this.tokenMatcher = tokens_1.tokenStructuredMatcherNoCategories;
            this.subruleIdx = 0;
            this.definedRulesNames = [];
            this.tokensMap = {};
            this.isBackTrackingStack = [];
            this.RULE_STACK = [];
            this.RULE_OCCURRENCE_STACK = [];
            this.gastProductionsCache = {};
            if ((0, has_1.default)(config2, "serializedGrammar")) {
              throw Error("The Parser's configuration can no longer contain a <serializedGrammar> property.\n	See: https://chevrotain.io/docs/changes/BREAKING_CHANGES.html#_6-0-0\n	For Further details.");
            }
            if ((0, isArray_1.default)(tokenVocabulary)) {
              if ((0, isEmpty_1.default)(tokenVocabulary)) {
                throw Error("A Token Vocabulary cannot be empty.\n	Note that the first argument for the parser constructor\n	is no longer a Token vector (since v4.0).");
              }
              if (typeof tokenVocabulary[0].startOffset === "number") {
                throw Error("The Parser constructor no longer accepts a token vector as the first argument.\n	See: https://chevrotain.io/docs/changes/BREAKING_CHANGES.html#_4-0-0\n	For Further details.");
              }
            }
            if ((0, isArray_1.default)(tokenVocabulary)) {
              this.tokensMap = (0, reduce_1.default)(tokenVocabulary, function(acc, tokType) {
                acc[tokType.name] = tokType;
                return acc;
              }, {});
            } else if ((0, has_1.default)(tokenVocabulary, "modes") && (0, every_1.default)((0, flatten_1.default)((0, values_1.default)(tokenVocabulary.modes)), tokens_1.isTokenType)) {
              var allTokenTypes_1 = (0, flatten_1.default)((0, values_1.default)(tokenVocabulary.modes));
              var uniqueTokens = (0, uniq_1.default)(allTokenTypes_1);
              this.tokensMap = (0, reduce_1.default)(uniqueTokens, function(acc, tokType) {
                acc[tokType.name] = tokType;
                return acc;
              }, {});
            } else if ((0, isObject_1.default)(tokenVocabulary)) {
              this.tokensMap = (0, clone_1.default)(tokenVocabulary);
            } else {
              throw new Error("<tokensDictionary> argument must be An Array of Token constructors, A dictionary of Token constructors or an IMultiModeLexerDefinition");
            }
            this.tokensMap["EOF"] = tokens_public_1.EOF;
            var allTokenTypes = (0, has_1.default)(tokenVocabulary, "modes") ? (0, flatten_1.default)((0, values_1.default)(tokenVocabulary.modes)) : (0, values_1.default)(tokenVocabulary);
            var noTokenCategoriesUsed = (0, every_1.default)(allTokenTypes, function(tokenConstructor) {
              return (0, isEmpty_1.default)(tokenConstructor.categoryMatches);
            });
            this.tokenMatcher = noTokenCategoriesUsed ? tokens_1.tokenStructuredMatcherNoCategories : tokens_1.tokenStructuredMatcher;
            (0, tokens_1.augmentTokenTypes)((0, values_1.default)(this.tokensMap));
          };
          RecognizerEngine2.prototype.defineRule = function(ruleName, impl, config2) {
            if (this.selfAnalysisDone) {
              throw Error("Grammar rule <".concat(ruleName, "> may not be defined after the 'performSelfAnalysis' method has been called'\n") + "Make sure that all grammar rule definitions are done before 'performSelfAnalysis' is called.");
            }
            var resyncEnabled = (0, has_1.default)(config2, "resyncEnabled") ? config2.resyncEnabled : parser_1.DEFAULT_RULE_CONFIG.resyncEnabled;
            var recoveryValueFunc = (0, has_1.default)(config2, "recoveryValueFunc") ? config2.recoveryValueFunc : parser_1.DEFAULT_RULE_CONFIG.recoveryValueFunc;
            var shortName = this.ruleShortNameIdx << keys_1.BITS_FOR_METHOD_TYPE + keys_1.BITS_FOR_OCCURRENCE_IDX;
            this.ruleShortNameIdx++;
            this.shortRuleNameToFull[shortName] = ruleName;
            this.fullRuleNameToShort[ruleName] = shortName;
            var invokeRuleWithTry;
            if (this.outputCst === true) {
              invokeRuleWithTry = function invokeRuleWithTry2() {
                var args2 = [];
                for (var _i = 0; _i < arguments.length; _i++) {
                  args2[_i] = arguments[_i];
                }
                try {
                  this.ruleInvocationStateUpdate(shortName, ruleName, this.subruleIdx);
                  impl.apply(this, args2);
                  var cst = this.CST_STACK[this.CST_STACK.length - 1];
                  this.cstPostRule(cst);
                  return cst;
                } catch (e) {
                  return this.invokeRuleCatch(e, resyncEnabled, recoveryValueFunc);
                } finally {
                  this.ruleFinallyStateUpdate();
                }
              };
            } else {
              invokeRuleWithTry = function invokeRuleWithTryCst() {
                var args2 = [];
                for (var _i = 0; _i < arguments.length; _i++) {
                  args2[_i] = arguments[_i];
                }
                try {
                  this.ruleInvocationStateUpdate(shortName, ruleName, this.subruleIdx);
                  return impl.apply(this, args2);
                } catch (e) {
                  return this.invokeRuleCatch(e, resyncEnabled, recoveryValueFunc);
                } finally {
                  this.ruleFinallyStateUpdate();
                }
              };
            }
            var wrappedGrammarRule = Object.assign(invokeRuleWithTry, { ruleName, originalGrammarAction: impl });
            return wrappedGrammarRule;
          };
          RecognizerEngine2.prototype.invokeRuleCatch = function(e, resyncEnabledConfig, recoveryValueFunc) {
            var isFirstInvokedRule = this.RULE_STACK.length === 1;
            var reSyncEnabled = resyncEnabledConfig && !this.isBackTracking() && this.recoveryEnabled;
            if ((0, exceptions_public_1.isRecognitionException)(e)) {
              var recogError = e;
              if (reSyncEnabled) {
                var reSyncTokType = this.findReSyncTokenType();
                if (this.isInCurrentRuleReSyncSet(reSyncTokType)) {
                  recogError.resyncedTokens = this.reSyncTo(reSyncTokType);
                  if (this.outputCst) {
                    var partialCstResult = this.CST_STACK[this.CST_STACK.length - 1];
                    partialCstResult.recoveredNode = true;
                    return partialCstResult;
                  } else {
                    return recoveryValueFunc(e);
                  }
                } else {
                  if (this.outputCst) {
                    var partialCstResult = this.CST_STACK[this.CST_STACK.length - 1];
                    partialCstResult.recoveredNode = true;
                    recogError.partialCstResult = partialCstResult;
                  }
                  throw recogError;
                }
              } else if (isFirstInvokedRule) {
                this.moveToTerminatedState();
                return recoveryValueFunc(e);
              } else {
                throw recogError;
              }
            } else {
              throw e;
            }
          };
          RecognizerEngine2.prototype.optionInternal = function(actionORMethodDef, occurrence) {
            var key = this.getKeyForAutomaticLookahead(keys_1.OPTION_IDX, occurrence);
            return this.optionInternalLogic(actionORMethodDef, occurrence, key);
          };
          RecognizerEngine2.prototype.optionInternalLogic = function(actionORMethodDef, occurrence, key) {
            var _this = this;
            var lookAheadFunc = this.getLaFuncFromCache(key);
            var action2;
            if (typeof actionORMethodDef !== "function") {
              action2 = actionORMethodDef.DEF;
              var predicate_1 = actionORMethodDef.GATE;
              if (predicate_1 !== void 0) {
                var orgLookaheadFunction_1 = lookAheadFunc;
                lookAheadFunc = function() {
                  return predicate_1.call(_this) && orgLookaheadFunction_1.call(_this);
                };
              }
            } else {
              action2 = actionORMethodDef;
            }
            if (lookAheadFunc.call(this) === true) {
              return action2.call(this);
            }
            return void 0;
          };
          RecognizerEngine2.prototype.atLeastOneInternal = function(prodOccurrence, actionORMethodDef) {
            var laKey = this.getKeyForAutomaticLookahead(keys_1.AT_LEAST_ONE_IDX, prodOccurrence);
            return this.atLeastOneInternalLogic(prodOccurrence, actionORMethodDef, laKey);
          };
          RecognizerEngine2.prototype.atLeastOneInternalLogic = function(prodOccurrence, actionORMethodDef, key) {
            var _this = this;
            var lookAheadFunc = this.getLaFuncFromCache(key);
            var action2;
            if (typeof actionORMethodDef !== "function") {
              action2 = actionORMethodDef.DEF;
              var predicate_2 = actionORMethodDef.GATE;
              if (predicate_2 !== void 0) {
                var orgLookaheadFunction_2 = lookAheadFunc;
                lookAheadFunc = function() {
                  return predicate_2.call(_this) && orgLookaheadFunction_2.call(_this);
                };
              }
            } else {
              action2 = actionORMethodDef;
            }
            if (lookAheadFunc.call(this) === true) {
              var notStuck = this.doSingleRepetition(action2);
              while (lookAheadFunc.call(this) === true && notStuck === true) {
                notStuck = this.doSingleRepetition(action2);
              }
            } else {
              throw this.raiseEarlyExitException(prodOccurrence, lookahead_1.PROD_TYPE.REPETITION_MANDATORY, actionORMethodDef.ERR_MSG);
            }
            this.attemptInRepetitionRecovery(this.atLeastOneInternal, [prodOccurrence, actionORMethodDef], lookAheadFunc, keys_1.AT_LEAST_ONE_IDX, prodOccurrence, interpreter_1.NextTerminalAfterAtLeastOneWalker);
          };
          RecognizerEngine2.prototype.atLeastOneSepFirstInternal = function(prodOccurrence, options) {
            var laKey = this.getKeyForAutomaticLookahead(keys_1.AT_LEAST_ONE_SEP_IDX, prodOccurrence);
            this.atLeastOneSepFirstInternalLogic(prodOccurrence, options, laKey);
          };
          RecognizerEngine2.prototype.atLeastOneSepFirstInternalLogic = function(prodOccurrence, options, key) {
            var _this = this;
            var action2 = options.DEF;
            var separator = options.SEP;
            var firstIterationLookaheadFunc = this.getLaFuncFromCache(key);
            if (firstIterationLookaheadFunc.call(this) === true) {
              ;
              action2.call(this);
              var separatorLookAheadFunc = function() {
                return _this.tokenMatcher(_this.LA(1), separator);
              };
              while (this.tokenMatcher(this.LA(1), separator) === true) {
                this.CONSUME(separator);
                action2.call(this);
              }
              this.attemptInRepetitionRecovery(this.repetitionSepSecondInternal, [
                prodOccurrence,
                separator,
                separatorLookAheadFunc,
                action2,
                interpreter_1.NextTerminalAfterAtLeastOneSepWalker
              ], separatorLookAheadFunc, keys_1.AT_LEAST_ONE_SEP_IDX, prodOccurrence, interpreter_1.NextTerminalAfterAtLeastOneSepWalker);
            } else {
              throw this.raiseEarlyExitException(prodOccurrence, lookahead_1.PROD_TYPE.REPETITION_MANDATORY_WITH_SEPARATOR, options.ERR_MSG);
            }
          };
          RecognizerEngine2.prototype.manyInternal = function(prodOccurrence, actionORMethodDef) {
            var laKey = this.getKeyForAutomaticLookahead(keys_1.MANY_IDX, prodOccurrence);
            return this.manyInternalLogic(prodOccurrence, actionORMethodDef, laKey);
          };
          RecognizerEngine2.prototype.manyInternalLogic = function(prodOccurrence, actionORMethodDef, key) {
            var _this = this;
            var lookaheadFunction = this.getLaFuncFromCache(key);
            var action2;
            if (typeof actionORMethodDef !== "function") {
              action2 = actionORMethodDef.DEF;
              var predicate_3 = actionORMethodDef.GATE;
              if (predicate_3 !== void 0) {
                var orgLookaheadFunction_3 = lookaheadFunction;
                lookaheadFunction = function() {
                  return predicate_3.call(_this) && orgLookaheadFunction_3.call(_this);
                };
              }
            } else {
              action2 = actionORMethodDef;
            }
            var notStuck = true;
            while (lookaheadFunction.call(this) === true && notStuck === true) {
              notStuck = this.doSingleRepetition(action2);
            }
            this.attemptInRepetitionRecovery(
              this.manyInternal,
              [prodOccurrence, actionORMethodDef],
              lookaheadFunction,
              keys_1.MANY_IDX,
              prodOccurrence,
              interpreter_1.NextTerminalAfterManyWalker,
              // The notStuck parameter is only relevant when "attemptInRepetitionRecovery"
              // is invoked from manyInternal, in the MANY_SEP case and AT_LEAST_ONE[_SEP]
              // An infinite loop cannot occur as:
              // - Either the lookahead is guaranteed to consume something (Single Token Separator)
              // - AT_LEAST_ONE by definition is guaranteed to consume something (or error out).
              notStuck
            );
          };
          RecognizerEngine2.prototype.manySepFirstInternal = function(prodOccurrence, options) {
            var laKey = this.getKeyForAutomaticLookahead(keys_1.MANY_SEP_IDX, prodOccurrence);
            this.manySepFirstInternalLogic(prodOccurrence, options, laKey);
          };
          RecognizerEngine2.prototype.manySepFirstInternalLogic = function(prodOccurrence, options, key) {
            var _this = this;
            var action2 = options.DEF;
            var separator = options.SEP;
            var firstIterationLaFunc = this.getLaFuncFromCache(key);
            if (firstIterationLaFunc.call(this) === true) {
              action2.call(this);
              var separatorLookAheadFunc = function() {
                return _this.tokenMatcher(_this.LA(1), separator);
              };
              while (this.tokenMatcher(this.LA(1), separator) === true) {
                this.CONSUME(separator);
                action2.call(this);
              }
              this.attemptInRepetitionRecovery(this.repetitionSepSecondInternal, [
                prodOccurrence,
                separator,
                separatorLookAheadFunc,
                action2,
                interpreter_1.NextTerminalAfterManySepWalker
              ], separatorLookAheadFunc, keys_1.MANY_SEP_IDX, prodOccurrence, interpreter_1.NextTerminalAfterManySepWalker);
            }
          };
          RecognizerEngine2.prototype.repetitionSepSecondInternal = function(prodOccurrence, separator, separatorLookAheadFunc, action2, nextTerminalAfterWalker) {
            while (separatorLookAheadFunc()) {
              this.CONSUME(separator);
              action2.call(this);
            }
            this.attemptInRepetitionRecovery(this.repetitionSepSecondInternal, [
              prodOccurrence,
              separator,
              separatorLookAheadFunc,
              action2,
              nextTerminalAfterWalker
            ], separatorLookAheadFunc, keys_1.AT_LEAST_ONE_SEP_IDX, prodOccurrence, nextTerminalAfterWalker);
          };
          RecognizerEngine2.prototype.doSingleRepetition = function(action2) {
            var beforeIteration = this.getLexerPosition();
            action2.call(this);
            var afterIteration = this.getLexerPosition();
            return afterIteration > beforeIteration;
          };
          RecognizerEngine2.prototype.orInternal = function(altsOrOpts, occurrence) {
            var laKey = this.getKeyForAutomaticLookahead(keys_1.OR_IDX, occurrence);
            var alts = (0, isArray_1.default)(altsOrOpts) ? altsOrOpts : altsOrOpts.DEF;
            var laFunc = this.getLaFuncFromCache(laKey);
            var altIdxToTake = laFunc.call(this, alts);
            if (altIdxToTake !== void 0) {
              var chosenAlternative = alts[altIdxToTake];
              return chosenAlternative.ALT.call(this);
            }
            this.raiseNoAltException(occurrence, altsOrOpts.ERR_MSG);
          };
          RecognizerEngine2.prototype.ruleFinallyStateUpdate = function() {
            this.RULE_STACK.pop();
            this.RULE_OCCURRENCE_STACK.pop();
            this.cstFinallyStateUpdate();
            if (this.RULE_STACK.length === 0 && this.isAtEndOfInput() === false) {
              var firstRedundantTok = this.LA(1);
              var errMsg = this.errorMessageProvider.buildNotAllInputParsedMessage({
                firstRedundant: firstRedundantTok,
                ruleName: this.getCurrRuleFullName()
              });
              this.SAVE_ERROR(new exceptions_public_1.NotAllInputParsedException(errMsg, firstRedundantTok));
            }
          };
          RecognizerEngine2.prototype.subruleInternal = function(ruleToCall, idx, options) {
            var ruleResult;
            try {
              var args2 = options !== void 0 ? options.ARGS : void 0;
              this.subruleIdx = idx;
              ruleResult = ruleToCall.apply(this, args2);
              this.cstPostNonTerminal(ruleResult, options !== void 0 && options.LABEL !== void 0 ? options.LABEL : ruleToCall.ruleName);
              return ruleResult;
            } catch (e) {
              throw this.subruleInternalError(e, options, ruleToCall.ruleName);
            }
          };
          RecognizerEngine2.prototype.subruleInternalError = function(e, options, ruleName) {
            if ((0, exceptions_public_1.isRecognitionException)(e) && e.partialCstResult !== void 0) {
              this.cstPostNonTerminal(e.partialCstResult, options !== void 0 && options.LABEL !== void 0 ? options.LABEL : ruleName);
              delete e.partialCstResult;
            }
            throw e;
          };
          RecognizerEngine2.prototype.consumeInternal = function(tokType, idx, options) {
            var consumedToken;
            try {
              var nextToken = this.LA(1);
              if (this.tokenMatcher(nextToken, tokType) === true) {
                this.consumeToken();
                consumedToken = nextToken;
              } else {
                this.consumeInternalError(tokType, nextToken, options);
              }
            } catch (eFromConsumption) {
              consumedToken = this.consumeInternalRecovery(tokType, idx, eFromConsumption);
            }
            this.cstPostTerminal(options !== void 0 && options.LABEL !== void 0 ? options.LABEL : tokType.name, consumedToken);
            return consumedToken;
          };
          RecognizerEngine2.prototype.consumeInternalError = function(tokType, nextToken, options) {
            var msg;
            var previousToken = this.LA(0);
            if (options !== void 0 && options.ERR_MSG) {
              msg = options.ERR_MSG;
            } else {
              msg = this.errorMessageProvider.buildMismatchTokenMessage({
                expected: tokType,
                actual: nextToken,
                previous: previousToken,
                ruleName: this.getCurrRuleFullName()
              });
            }
            throw this.SAVE_ERROR(new exceptions_public_1.MismatchedTokenException(msg, nextToken, previousToken));
          };
          RecognizerEngine2.prototype.consumeInternalRecovery = function(tokType, idx, eFromConsumption) {
            if (this.recoveryEnabled && // TODO: more robust checking of the exception type. Perhaps Typescript extending expressions?
            eFromConsumption.name === "MismatchedTokenException" && !this.isBackTracking()) {
              var follows = this.getFollowsForInRuleRecovery(tokType, idx);
              try {
                return this.tryInRuleRecovery(tokType, follows);
              } catch (eFromInRuleRecovery) {
                if (eFromInRuleRecovery.name === recoverable_1.IN_RULE_RECOVERY_EXCEPTION) {
                  throw eFromConsumption;
                } else {
                  throw eFromInRuleRecovery;
                }
              }
            } else {
              throw eFromConsumption;
            }
          };
          RecognizerEngine2.prototype.saveRecogState = function() {
            var savedErrors = this.errors;
            var savedRuleStack = (0, clone_1.default)(this.RULE_STACK);
            return {
              errors: savedErrors,
              lexerState: this.exportLexerState(),
              RULE_STACK: savedRuleStack,
              CST_STACK: this.CST_STACK
            };
          };
          RecognizerEngine2.prototype.reloadRecogState = function(newState) {
            this.errors = newState.errors;
            this.importLexerState(newState.lexerState);
            this.RULE_STACK = newState.RULE_STACK;
          };
          RecognizerEngine2.prototype.ruleInvocationStateUpdate = function(shortName, fullName, idxInCallingRule) {
            this.RULE_OCCURRENCE_STACK.push(idxInCallingRule);
            this.RULE_STACK.push(shortName);
            this.cstInvocationStateUpdate(fullName);
          };
          RecognizerEngine2.prototype.isBackTracking = function() {
            return this.isBackTrackingStack.length !== 0;
          };
          RecognizerEngine2.prototype.getCurrRuleFullName = function() {
            var shortName = this.getLastExplicitRuleShortName();
            return this.shortRuleNameToFull[shortName];
          };
          RecognizerEngine2.prototype.shortRuleNameToFullName = function(shortName) {
            return this.shortRuleNameToFull[shortName];
          };
          RecognizerEngine2.prototype.isAtEndOfInput = function() {
            return this.tokenMatcher(this.LA(1), tokens_public_1.EOF);
          };
          RecognizerEngine2.prototype.reset = function() {
            this.resetLexerState();
            this.subruleIdx = 0;
            this.isBackTrackingStack = [];
            this.errors = [];
            this.RULE_STACK = [];
            this.CST_STACK = [];
            this.RULE_OCCURRENCE_STACK = [];
          };
          return RecognizerEngine2;
        }()
      );
      exports2.RecognizerEngine = RecognizerEngine;
    }
  });

  // node_modules/.pnpm/chevrotain@10.5.0/node_modules/chevrotain/lib/src/parse/parser/traits/error_handler.js
  var require_error_handler = __commonJS({
    "node_modules/.pnpm/chevrotain@10.5.0/node_modules/chevrotain/lib/src/parse/parser/traits/error_handler.js"(exports2) {
      "use strict";
      var __importDefault = exports2 && exports2.__importDefault || function(mod) {
        return mod && mod.__esModule ? mod : { "default": mod };
      };
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.ErrorHandler = void 0;
      var exceptions_public_1 = require_exceptions_public();
      var has_1 = __importDefault(require_has());
      var clone_1 = __importDefault(require_clone());
      var lookahead_1 = require_lookahead();
      var parser_1 = require_parser();
      var ErrorHandler = (
        /** @class */
        function() {
          function ErrorHandler2() {
          }
          ErrorHandler2.prototype.initErrorHandler = function(config2) {
            this._errors = [];
            this.errorMessageProvider = (0, has_1.default)(config2, "errorMessageProvider") ? config2.errorMessageProvider : parser_1.DEFAULT_PARSER_CONFIG.errorMessageProvider;
          };
          ErrorHandler2.prototype.SAVE_ERROR = function(error) {
            if ((0, exceptions_public_1.isRecognitionException)(error)) {
              error.context = {
                ruleStack: this.getHumanReadableRuleStack(),
                ruleOccurrenceStack: (0, clone_1.default)(this.RULE_OCCURRENCE_STACK)
              };
              this._errors.push(error);
              return error;
            } else {
              throw Error("Trying to save an Error which is not a RecognitionException");
            }
          };
          Object.defineProperty(ErrorHandler2.prototype, "errors", {
            get: function() {
              return (0, clone_1.default)(this._errors);
            },
            set: function(newErrors) {
              this._errors = newErrors;
            },
            enumerable: false,
            configurable: true
          });
          ErrorHandler2.prototype.raiseEarlyExitException = function(occurrence, prodType, userDefinedErrMsg) {
            var ruleName = this.getCurrRuleFullName();
            var ruleGrammar = this.getGAstProductions()[ruleName];
            var lookAheadPathsPerAlternative = (0, lookahead_1.getLookaheadPathsForOptionalProd)(occurrence, ruleGrammar, prodType, this.maxLookahead);
            var insideProdPaths = lookAheadPathsPerAlternative[0];
            var actualTokens = [];
            for (var i = 1; i <= this.maxLookahead; i++) {
              actualTokens.push(this.LA(i));
            }
            var msg = this.errorMessageProvider.buildEarlyExitMessage({
              expectedIterationPaths: insideProdPaths,
              actual: actualTokens,
              previous: this.LA(0),
              customUserDescription: userDefinedErrMsg,
              ruleName
            });
            throw this.SAVE_ERROR(new exceptions_public_1.EarlyExitException(msg, this.LA(1), this.LA(0)));
          };
          ErrorHandler2.prototype.raiseNoAltException = function(occurrence, errMsgTypes) {
            var ruleName = this.getCurrRuleFullName();
            var ruleGrammar = this.getGAstProductions()[ruleName];
            var lookAheadPathsPerAlternative = (0, lookahead_1.getLookaheadPathsForOr)(occurrence, ruleGrammar, this.maxLookahead);
            var actualTokens = [];
            for (var i = 1; i <= this.maxLookahead; i++) {
              actualTokens.push(this.LA(i));
            }
            var previousToken = this.LA(0);
            var errMsg = this.errorMessageProvider.buildNoViableAltMessage({
              expectedPathsPerAlt: lookAheadPathsPerAlternative,
              actual: actualTokens,
              previous: previousToken,
              customUserDescription: errMsgTypes,
              ruleName: this.getCurrRuleFullName()
            });
            throw this.SAVE_ERROR(new exceptions_public_1.NoViableAltException(errMsg, this.LA(1), previousToken));
          };
          return ErrorHandler2;
        }()
      );
      exports2.ErrorHandler = ErrorHandler;
    }
  });

  // node_modules/.pnpm/chevrotain@10.5.0/node_modules/chevrotain/lib/src/parse/parser/traits/context_assist.js
  var require_context_assist = __commonJS({
    "node_modules/.pnpm/chevrotain@10.5.0/node_modules/chevrotain/lib/src/parse/parser/traits/context_assist.js"(exports2) {
      "use strict";
      var __importDefault = exports2 && exports2.__importDefault || function(mod) {
        return mod && mod.__esModule ? mod : { "default": mod };
      };
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.ContentAssist = void 0;
      var interpreter_1 = require_interpreter();
      var first_1 = __importDefault(require_first2());
      var isUndefined_1 = __importDefault(require_isUndefined());
      var ContentAssist = (
        /** @class */
        function() {
          function ContentAssist2() {
          }
          ContentAssist2.prototype.initContentAssist = function() {
          };
          ContentAssist2.prototype.computeContentAssist = function(startRuleName, precedingInput) {
            var startRuleGast = this.gastProductionsCache[startRuleName];
            if ((0, isUndefined_1.default)(startRuleGast)) {
              throw Error("Rule ->".concat(startRuleName, "<- does not exist in this grammar."));
            }
            return (0, interpreter_1.nextPossibleTokensAfter)([startRuleGast], precedingInput, this.tokenMatcher, this.maxLookahead);
          };
          ContentAssist2.prototype.getNextPossibleTokenTypes = function(grammarPath) {
            var topRuleName = (0, first_1.default)(grammarPath.ruleStack);
            var gastProductions = this.getGAstProductions();
            var topProduction = gastProductions[topRuleName];
            var nextPossibleTokenTypes = new interpreter_1.NextAfterTokenWalker(topProduction, grammarPath).startWalking();
            return nextPossibleTokenTypes;
          };
          return ContentAssist2;
        }()
      );
      exports2.ContentAssist = ContentAssist;
    }
  });

  // node_modules/.pnpm/chevrotain@10.5.0/node_modules/chevrotain/lib/src/parse/parser/traits/gast_recorder.js
  var require_gast_recorder = __commonJS({
    "node_modules/.pnpm/chevrotain@10.5.0/node_modules/chevrotain/lib/src/parse/parser/traits/gast_recorder.js"(exports2) {
      "use strict";
      var __importDefault = exports2 && exports2.__importDefault || function(mod) {
        return mod && mod.__esModule ? mod : { "default": mod };
      };
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.GastRecorder = void 0;
      var last_1 = __importDefault(require_last());
      var isArray_1 = __importDefault(require_isArray());
      var some_1 = __importDefault(require_some());
      var forEach_1 = __importDefault(require_forEach());
      var isFunction_1 = __importDefault(require_isFunction());
      var has_1 = __importDefault(require_has());
      var gast_1 = require_api2();
      var lexer_public_1 = require_lexer_public();
      var tokens_1 = require_tokens();
      var tokens_public_1 = require_tokens_public();
      var parser_1 = require_parser();
      var keys_1 = require_keys2();
      var RECORDING_NULL_OBJECT = {
        description: "This Object indicates the Parser is during Recording Phase"
      };
      Object.freeze(RECORDING_NULL_OBJECT);
      var HANDLE_SEPARATOR = true;
      var MAX_METHOD_IDX = Math.pow(2, keys_1.BITS_FOR_OCCURRENCE_IDX) - 1;
      var RFT = (0, tokens_public_1.createToken)({ name: "RECORDING_PHASE_TOKEN", pattern: lexer_public_1.Lexer.NA });
      (0, tokens_1.augmentTokenTypes)([RFT]);
      var RECORDING_PHASE_TOKEN = (0, tokens_public_1.createTokenInstance)(
        RFT,
        "This IToken indicates the Parser is in Recording Phase\n	See: https://chevrotain.io/docs/guide/internals.html#grammar-recording for details",
        // Using "-1" instead of NaN (as in EOF) because an actual number is less likely to
        // cause errors if the output of LA or CONSUME would be (incorrectly) used during the recording phase.
        -1,
        -1,
        -1,
        -1,
        -1,
        -1
      );
      Object.freeze(RECORDING_PHASE_TOKEN);
      var RECORDING_PHASE_CSTNODE = {
        name: "This CSTNode indicates the Parser is in Recording Phase\n	See: https://chevrotain.io/docs/guide/internals.html#grammar-recording for details",
        children: {}
      };
      var GastRecorder = (
        /** @class */
        function() {
          function GastRecorder2() {
          }
          GastRecorder2.prototype.initGastRecorder = function(config2) {
            this.recordingProdStack = [];
            this.RECORDING_PHASE = false;
          };
          GastRecorder2.prototype.enableRecording = function() {
            var _this = this;
            this.RECORDING_PHASE = true;
            this.TRACE_INIT("Enable Recording", function() {
              var _loop_1 = function(i2) {
                var idx = i2 > 0 ? i2 : "";
                _this["CONSUME".concat(idx)] = function(arg1, arg2) {
                  return this.consumeInternalRecord(arg1, i2, arg2);
                };
                _this["SUBRULE".concat(idx)] = function(arg1, arg2) {
                  return this.subruleInternalRecord(arg1, i2, arg2);
                };
                _this["OPTION".concat(idx)] = function(arg1) {
                  return this.optionInternalRecord(arg1, i2);
                };
                _this["OR".concat(idx)] = function(arg1) {
                  return this.orInternalRecord(arg1, i2);
                };
                _this["MANY".concat(idx)] = function(arg1) {
                  this.manyInternalRecord(i2, arg1);
                };
                _this["MANY_SEP".concat(idx)] = function(arg1) {
                  this.manySepFirstInternalRecord(i2, arg1);
                };
                _this["AT_LEAST_ONE".concat(idx)] = function(arg1) {
                  this.atLeastOneInternalRecord(i2, arg1);
                };
                _this["AT_LEAST_ONE_SEP".concat(idx)] = function(arg1) {
                  this.atLeastOneSepFirstInternalRecord(i2, arg1);
                };
              };
              for (var i = 0; i < 10; i++) {
                _loop_1(i);
              }
              _this["consume"] = function(idx, arg1, arg2) {
                return this.consumeInternalRecord(arg1, idx, arg2);
              };
              _this["subrule"] = function(idx, arg1, arg2) {
                return this.subruleInternalRecord(arg1, idx, arg2);
              };
              _this["option"] = function(idx, arg1) {
                return this.optionInternalRecord(arg1, idx);
              };
              _this["or"] = function(idx, arg1) {
                return this.orInternalRecord(arg1, idx);
              };
              _this["many"] = function(idx, arg1) {
                this.manyInternalRecord(idx, arg1);
              };
              _this["atLeastOne"] = function(idx, arg1) {
                this.atLeastOneInternalRecord(idx, arg1);
              };
              _this.ACTION = _this.ACTION_RECORD;
              _this.BACKTRACK = _this.BACKTRACK_RECORD;
              _this.LA = _this.LA_RECORD;
            });
          };
          GastRecorder2.prototype.disableRecording = function() {
            var _this = this;
            this.RECORDING_PHASE = false;
            this.TRACE_INIT("Deleting Recording methods", function() {
              var that = _this;
              for (var i = 0; i < 10; i++) {
                var idx = i > 0 ? i : "";
                delete that["CONSUME".concat(idx)];
                delete that["SUBRULE".concat(idx)];
                delete that["OPTION".concat(idx)];
                delete that["OR".concat(idx)];
                delete that["MANY".concat(idx)];
                delete that["MANY_SEP".concat(idx)];
                delete that["AT_LEAST_ONE".concat(idx)];
                delete that["AT_LEAST_ONE_SEP".concat(idx)];
              }
              delete that["consume"];
              delete that["subrule"];
              delete that["option"];
              delete that["or"];
              delete that["many"];
              delete that["atLeastOne"];
              delete that.ACTION;
              delete that.BACKTRACK;
              delete that.LA;
            });
          };
          GastRecorder2.prototype.ACTION_RECORD = function(impl) {
          };
          GastRecorder2.prototype.BACKTRACK_RECORD = function(grammarRule, args2) {
            return function() {
              return true;
            };
          };
          GastRecorder2.prototype.LA_RECORD = function(howMuch) {
            return parser_1.END_OF_FILE;
          };
          GastRecorder2.prototype.topLevelRuleRecord = function(name, def) {
            try {
              var newTopLevelRule = new gast_1.Rule({ definition: [], name });
              newTopLevelRule.name = name;
              this.recordingProdStack.push(newTopLevelRule);
              def.call(this);
              this.recordingProdStack.pop();
              return newTopLevelRule;
            } catch (originalError) {
              if (originalError.KNOWN_RECORDER_ERROR !== true) {
                try {
                  originalError.message = originalError.message + '\n	 This error was thrown during the "grammar recording phase" For more info see:\n	https://chevrotain.io/docs/guide/internals.html#grammar-recording';
                } catch (mutabilityError) {
                  throw originalError;
                }
              }
              throw originalError;
            }
          };
          GastRecorder2.prototype.optionInternalRecord = function(actionORMethodDef, occurrence) {
            return recordProd.call(this, gast_1.Option, actionORMethodDef, occurrence);
          };
          GastRecorder2.prototype.atLeastOneInternalRecord = function(occurrence, actionORMethodDef) {
            recordProd.call(this, gast_1.RepetitionMandatory, actionORMethodDef, occurrence);
          };
          GastRecorder2.prototype.atLeastOneSepFirstInternalRecord = function(occurrence, options) {
            recordProd.call(this, gast_1.RepetitionMandatoryWithSeparator, options, occurrence, HANDLE_SEPARATOR);
          };
          GastRecorder2.prototype.manyInternalRecord = function(occurrence, actionORMethodDef) {
            recordProd.call(this, gast_1.Repetition, actionORMethodDef, occurrence);
          };
          GastRecorder2.prototype.manySepFirstInternalRecord = function(occurrence, options) {
            recordProd.call(this, gast_1.RepetitionWithSeparator, options, occurrence, HANDLE_SEPARATOR);
          };
          GastRecorder2.prototype.orInternalRecord = function(altsOrOpts, occurrence) {
            return recordOrProd.call(this, altsOrOpts, occurrence);
          };
          GastRecorder2.prototype.subruleInternalRecord = function(ruleToCall, occurrence, options) {
            assertMethodIdxIsValid(occurrence);
            if (!ruleToCall || (0, has_1.default)(ruleToCall, "ruleName") === false) {
              var error = new Error("<SUBRULE".concat(getIdxSuffix(occurrence), "> argument is invalid") + " expecting a Parser method reference but got: <".concat(JSON.stringify(ruleToCall), ">") + "\n inside top level rule: <".concat(this.recordingProdStack[0].name, ">"));
              error.KNOWN_RECORDER_ERROR = true;
              throw error;
            }
            var prevProd = (0, last_1.default)(this.recordingProdStack);
            var ruleName = ruleToCall.ruleName;
            var newNoneTerminal = new gast_1.NonTerminal({
              idx: occurrence,
              nonTerminalName: ruleName,
              label: options === null || options === void 0 ? void 0 : options.LABEL,
              // The resolving of the `referencedRule` property will be done once all the Rule's GASTs have been created
              referencedRule: void 0
            });
            prevProd.definition.push(newNoneTerminal);
            return this.outputCst ? RECORDING_PHASE_CSTNODE : RECORDING_NULL_OBJECT;
          };
          GastRecorder2.prototype.consumeInternalRecord = function(tokType, occurrence, options) {
            assertMethodIdxIsValid(occurrence);
            if (!(0, tokens_1.hasShortKeyProperty)(tokType)) {
              var error = new Error("<CONSUME".concat(getIdxSuffix(occurrence), "> argument is invalid") + " expecting a TokenType reference but got: <".concat(JSON.stringify(tokType), ">") + "\n inside top level rule: <".concat(this.recordingProdStack[0].name, ">"));
              error.KNOWN_RECORDER_ERROR = true;
              throw error;
            }
            var prevProd = (0, last_1.default)(this.recordingProdStack);
            var newNoneTerminal = new gast_1.Terminal({
              idx: occurrence,
              terminalType: tokType,
              label: options === null || options === void 0 ? void 0 : options.LABEL
            });
            prevProd.definition.push(newNoneTerminal);
            return RECORDING_PHASE_TOKEN;
          };
          return GastRecorder2;
        }()
      );
      exports2.GastRecorder = GastRecorder;
      function recordProd(prodConstructor, mainProdArg, occurrence, handleSep) {
        if (handleSep === void 0) {
          handleSep = false;
        }
        assertMethodIdxIsValid(occurrence);
        var prevProd = (0, last_1.default)(this.recordingProdStack);
        var grammarAction = (0, isFunction_1.default)(mainProdArg) ? mainProdArg : mainProdArg.DEF;
        var newProd = new prodConstructor({ definition: [], idx: occurrence });
        if (handleSep) {
          newProd.separator = mainProdArg.SEP;
        }
        if ((0, has_1.default)(mainProdArg, "MAX_LOOKAHEAD")) {
          newProd.maxLookahead = mainProdArg.MAX_LOOKAHEAD;
        }
        this.recordingProdStack.push(newProd);
        grammarAction.call(this);
        prevProd.definition.push(newProd);
        this.recordingProdStack.pop();
        return RECORDING_NULL_OBJECT;
      }
      function recordOrProd(mainProdArg, occurrence) {
        var _this = this;
        assertMethodIdxIsValid(occurrence);
        var prevProd = (0, last_1.default)(this.recordingProdStack);
        var hasOptions = (0, isArray_1.default)(mainProdArg) === false;
        var alts = hasOptions === false ? mainProdArg : mainProdArg.DEF;
        var newOrProd = new gast_1.Alternation({
          definition: [],
          idx: occurrence,
          ignoreAmbiguities: hasOptions && mainProdArg.IGNORE_AMBIGUITIES === true
        });
        if ((0, has_1.default)(mainProdArg, "MAX_LOOKAHEAD")) {
          newOrProd.maxLookahead = mainProdArg.MAX_LOOKAHEAD;
        }
        var hasPredicates = (0, some_1.default)(alts, function(currAlt) {
          return (0, isFunction_1.default)(currAlt.GATE);
        });
        newOrProd.hasPredicates = hasPredicates;
        prevProd.definition.push(newOrProd);
        (0, forEach_1.default)(alts, function(currAlt) {
          var currAltFlat = new gast_1.Alternative({ definition: [] });
          newOrProd.definition.push(currAltFlat);
          if ((0, has_1.default)(currAlt, "IGNORE_AMBIGUITIES")) {
            currAltFlat.ignoreAmbiguities = currAlt.IGNORE_AMBIGUITIES;
          } else if ((0, has_1.default)(currAlt, "GATE")) {
            currAltFlat.ignoreAmbiguities = true;
          }
          _this.recordingProdStack.push(currAltFlat);
          currAlt.ALT.call(_this);
          _this.recordingProdStack.pop();
        });
        return RECORDING_NULL_OBJECT;
      }
      function getIdxSuffix(idx) {
        return idx === 0 ? "" : "".concat(idx);
      }
      function assertMethodIdxIsValid(idx) {
        if (idx < 0 || idx > MAX_METHOD_IDX) {
          var error = new Error(
            // The stack trace will contain all the needed details
            "Invalid DSL Method idx value: <".concat(idx, ">\n	") + "Idx value must be a none negative value smaller than ".concat(MAX_METHOD_IDX + 1)
          );
          error.KNOWN_RECORDER_ERROR = true;
          throw error;
        }
      }
    }
  });

  // node_modules/.pnpm/chevrotain@10.5.0/node_modules/chevrotain/lib/src/parse/parser/traits/perf_tracer.js
  var require_perf_tracer = __commonJS({
    "node_modules/.pnpm/chevrotain@10.5.0/node_modules/chevrotain/lib/src/parse/parser/traits/perf_tracer.js"(exports2) {
      "use strict";
      var __importDefault = exports2 && exports2.__importDefault || function(mod) {
        return mod && mod.__esModule ? mod : { "default": mod };
      };
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.PerformanceTracer = void 0;
      var has_1 = __importDefault(require_has());
      var utils_1 = require_api();
      var parser_1 = require_parser();
      var PerformanceTracer = (
        /** @class */
        function() {
          function PerformanceTracer2() {
          }
          PerformanceTracer2.prototype.initPerformanceTracer = function(config2) {
            if ((0, has_1.default)(config2, "traceInitPerf")) {
              var userTraceInitPerf = config2.traceInitPerf;
              var traceIsNumber = typeof userTraceInitPerf === "number";
              this.traceInitMaxIdent = traceIsNumber ? userTraceInitPerf : Infinity;
              this.traceInitPerf = traceIsNumber ? userTraceInitPerf > 0 : userTraceInitPerf;
            } else {
              this.traceInitMaxIdent = 0;
              this.traceInitPerf = parser_1.DEFAULT_PARSER_CONFIG.traceInitPerf;
            }
            this.traceInitIndent = -1;
          };
          PerformanceTracer2.prototype.TRACE_INIT = function(phaseDesc, phaseImpl) {
            if (this.traceInitPerf === true) {
              this.traceInitIndent++;
              var indent = new Array(this.traceInitIndent + 1).join("	");
              if (this.traceInitIndent < this.traceInitMaxIdent) {
                console.log("".concat(indent, "--> <").concat(phaseDesc, ">"));
              }
              var _a2 = (0, utils_1.timer)(phaseImpl), time = _a2.time, value = _a2.value;
              var traceMethod = time > 10 ? console.warn : console.log;
              if (this.traceInitIndent < this.traceInitMaxIdent) {
                traceMethod("".concat(indent, "<-- <").concat(phaseDesc, "> time: ").concat(time, "ms"));
              }
              this.traceInitIndent--;
              return value;
            } else {
              return phaseImpl();
            }
          };
          return PerformanceTracer2;
        }()
      );
      exports2.PerformanceTracer = PerformanceTracer;
    }
  });

  // node_modules/.pnpm/chevrotain@10.5.0/node_modules/chevrotain/lib/src/parse/parser/utils/apply_mixins.js
  var require_apply_mixins = __commonJS({
    "node_modules/.pnpm/chevrotain@10.5.0/node_modules/chevrotain/lib/src/parse/parser/utils/apply_mixins.js"(exports2) {
      "use strict";
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.applyMixins = void 0;
      function applyMixins(derivedCtor, baseCtors) {
        baseCtors.forEach(function(baseCtor) {
          var baseProto = baseCtor.prototype;
          Object.getOwnPropertyNames(baseProto).forEach(function(propName) {
            if (propName === "constructor") {
              return;
            }
            var basePropDescriptor = Object.getOwnPropertyDescriptor(baseProto, propName);
            if (basePropDescriptor && (basePropDescriptor.get || basePropDescriptor.set)) {
              Object.defineProperty(derivedCtor.prototype, propName, basePropDescriptor);
            } else {
              derivedCtor.prototype[propName] = baseCtor.prototype[propName];
            }
          });
        });
      }
      exports2.applyMixins = applyMixins;
    }
  });

  // node_modules/.pnpm/chevrotain@10.5.0/node_modules/chevrotain/lib/src/parse/parser/parser.js
  var require_parser = __commonJS({
    "node_modules/.pnpm/chevrotain@10.5.0/node_modules/chevrotain/lib/src/parse/parser/parser.js"(exports2) {
      "use strict";
      var __extends = exports2 && exports2.__extends || function() {
        var extendStatics = function(d, b) {
          extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b3) {
            d2.__proto__ = b3;
          } || function(d2, b3) {
            for (var p in b3)
              if (Object.prototype.hasOwnProperty.call(b3, p))
                d2[p] = b3[p];
          };
          return extendStatics(d, b);
        };
        return function(d, b) {
          if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
          extendStatics(d, b);
          function __() {
            this.constructor = d;
          }
          d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
        };
      }();
      var __importDefault = exports2 && exports2.__importDefault || function(mod) {
        return mod && mod.__esModule ? mod : { "default": mod };
      };
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.EmbeddedActionsParser = exports2.CstParser = exports2.Parser = exports2.EMPTY_ALT = exports2.ParserDefinitionErrorType = exports2.DEFAULT_RULE_CONFIG = exports2.DEFAULT_PARSER_CONFIG = exports2.END_OF_FILE = void 0;
      var isEmpty_1 = __importDefault(require_isEmpty());
      var map_1 = __importDefault(require_map());
      var forEach_1 = __importDefault(require_forEach());
      var values_1 = __importDefault(require_values());
      var has_1 = __importDefault(require_has());
      var clone_1 = __importDefault(require_clone());
      var utils_1 = require_api();
      var follow_1 = require_follow();
      var tokens_public_1 = require_tokens_public();
      var errors_public_1 = require_errors_public();
      var gast_resolver_public_1 = require_gast_resolver_public();
      var recoverable_1 = require_recoverable();
      var looksahead_1 = require_looksahead();
      var tree_builder_1 = require_tree_builder();
      var lexer_adapter_1 = require_lexer_adapter();
      var recognizer_api_1 = require_recognizer_api();
      var recognizer_engine_1 = require_recognizer_engine();
      var error_handler_1 = require_error_handler();
      var context_assist_1 = require_context_assist();
      var gast_recorder_1 = require_gast_recorder();
      var perf_tracer_1 = require_perf_tracer();
      var apply_mixins_1 = require_apply_mixins();
      var checks_1 = require_checks();
      exports2.END_OF_FILE = (0, tokens_public_1.createTokenInstance)(tokens_public_1.EOF, "", NaN, NaN, NaN, NaN, NaN, NaN);
      Object.freeze(exports2.END_OF_FILE);
      exports2.DEFAULT_PARSER_CONFIG = Object.freeze({
        recoveryEnabled: false,
        maxLookahead: 3,
        dynamicTokensEnabled: false,
        outputCst: true,
        errorMessageProvider: errors_public_1.defaultParserErrorProvider,
        nodeLocationTracking: "none",
        traceInitPerf: false,
        skipValidations: false
      });
      exports2.DEFAULT_RULE_CONFIG = Object.freeze({
        recoveryValueFunc: function() {
          return void 0;
        },
        resyncEnabled: true
      });
      var ParserDefinitionErrorType;
      (function(ParserDefinitionErrorType2) {
        ParserDefinitionErrorType2[ParserDefinitionErrorType2["INVALID_RULE_NAME"] = 0] = "INVALID_RULE_NAME";
        ParserDefinitionErrorType2[ParserDefinitionErrorType2["DUPLICATE_RULE_NAME"] = 1] = "DUPLICATE_RULE_NAME";
        ParserDefinitionErrorType2[ParserDefinitionErrorType2["INVALID_RULE_OVERRIDE"] = 2] = "INVALID_RULE_OVERRIDE";
        ParserDefinitionErrorType2[ParserDefinitionErrorType2["DUPLICATE_PRODUCTIONS"] = 3] = "DUPLICATE_PRODUCTIONS";
        ParserDefinitionErrorType2[ParserDefinitionErrorType2["UNRESOLVED_SUBRULE_REF"] = 4] = "UNRESOLVED_SUBRULE_REF";
        ParserDefinitionErrorType2[ParserDefinitionErrorType2["LEFT_RECURSION"] = 5] = "LEFT_RECURSION";
        ParserDefinitionErrorType2[ParserDefinitionErrorType2["NONE_LAST_EMPTY_ALT"] = 6] = "NONE_LAST_EMPTY_ALT";
        ParserDefinitionErrorType2[ParserDefinitionErrorType2["AMBIGUOUS_ALTS"] = 7] = "AMBIGUOUS_ALTS";
        ParserDefinitionErrorType2[ParserDefinitionErrorType2["CONFLICT_TOKENS_RULES_NAMESPACE"] = 8] = "CONFLICT_TOKENS_RULES_NAMESPACE";
        ParserDefinitionErrorType2[ParserDefinitionErrorType2["INVALID_TOKEN_NAME"] = 9] = "INVALID_TOKEN_NAME";
        ParserDefinitionErrorType2[ParserDefinitionErrorType2["NO_NON_EMPTY_LOOKAHEAD"] = 10] = "NO_NON_EMPTY_LOOKAHEAD";
        ParserDefinitionErrorType2[ParserDefinitionErrorType2["AMBIGUOUS_PREFIX_ALTS"] = 11] = "AMBIGUOUS_PREFIX_ALTS";
        ParserDefinitionErrorType2[ParserDefinitionErrorType2["TOO_MANY_ALTS"] = 12] = "TOO_MANY_ALTS";
        ParserDefinitionErrorType2[ParserDefinitionErrorType2["CUSTOM_LOOKAHEAD_VALIDATION"] = 13] = "CUSTOM_LOOKAHEAD_VALIDATION";
      })(ParserDefinitionErrorType = exports2.ParserDefinitionErrorType || (exports2.ParserDefinitionErrorType = {}));
      function EMPTY_ALT(value) {
        if (value === void 0) {
          value = void 0;
        }
        return function() {
          return value;
        };
      }
      exports2.EMPTY_ALT = EMPTY_ALT;
      var Parser = (
        /** @class */
        function() {
          function Parser2(tokenVocabulary, config2) {
            this.definitionErrors = [];
            this.selfAnalysisDone = false;
            var that = this;
            that.initErrorHandler(config2);
            that.initLexerAdapter();
            that.initLooksAhead(config2);
            that.initRecognizerEngine(tokenVocabulary, config2);
            that.initRecoverable(config2);
            that.initTreeBuilder(config2);
            that.initContentAssist();
            that.initGastRecorder(config2);
            that.initPerformanceTracer(config2);
            if ((0, has_1.default)(config2, "ignoredIssues")) {
              throw new Error("The <ignoredIssues> IParserConfig property has been deprecated.\n	Please use the <IGNORE_AMBIGUITIES> flag on the relevant DSL method instead.\n	See: https://chevrotain.io/docs/guide/resolving_grammar_errors.html#IGNORING_AMBIGUITIES\n	For further details.");
            }
            this.skipValidations = (0, has_1.default)(config2, "skipValidations") ? config2.skipValidations : exports2.DEFAULT_PARSER_CONFIG.skipValidations;
          }
          Parser2.performSelfAnalysis = function(parserInstance) {
            throw Error("The **static** `performSelfAnalysis` method has been deprecated.	\nUse the **instance** method with the same name instead.");
          };
          Parser2.prototype.performSelfAnalysis = function() {
            var _this = this;
            this.TRACE_INIT("performSelfAnalysis", function() {
              var defErrorsMsgs;
              _this.selfAnalysisDone = true;
              var className = _this.className;
              _this.TRACE_INIT("toFastProps", function() {
                (0, utils_1.toFastProperties)(_this);
              });
              _this.TRACE_INIT("Grammar Recording", function() {
                try {
                  _this.enableRecording();
                  (0, forEach_1.default)(_this.definedRulesNames, function(currRuleName) {
                    var wrappedRule = _this[currRuleName];
                    var originalGrammarAction = wrappedRule["originalGrammarAction"];
                    var recordedRuleGast;
                    _this.TRACE_INIT("".concat(currRuleName, " Rule"), function() {
                      recordedRuleGast = _this.topLevelRuleRecord(currRuleName, originalGrammarAction);
                    });
                    _this.gastProductionsCache[currRuleName] = recordedRuleGast;
                  });
                } finally {
                  _this.disableRecording();
                }
              });
              var resolverErrors = [];
              _this.TRACE_INIT("Grammar Resolving", function() {
                resolverErrors = (0, gast_resolver_public_1.resolveGrammar)({
                  rules: (0, values_1.default)(_this.gastProductionsCache)
                });
                _this.definitionErrors = _this.definitionErrors.concat(resolverErrors);
              });
              _this.TRACE_INIT("Grammar Validations", function() {
                if ((0, isEmpty_1.default)(resolverErrors) && _this.skipValidations === false) {
                  var validationErrors = (0, gast_resolver_public_1.validateGrammar)({
                    rules: (0, values_1.default)(_this.gastProductionsCache),
                    tokenTypes: (0, values_1.default)(_this.tokensMap),
                    errMsgProvider: errors_public_1.defaultGrammarValidatorErrorProvider,
                    grammarName: className
                  });
                  var lookaheadValidationErrors = (0, checks_1.validateLookahead)({
                    lookaheadStrategy: _this.lookaheadStrategy,
                    rules: (0, values_1.default)(_this.gastProductionsCache),
                    tokenTypes: (0, values_1.default)(_this.tokensMap),
                    grammarName: className
                  });
                  _this.definitionErrors = _this.definitionErrors.concat(validationErrors, lookaheadValidationErrors);
                }
              });
              if ((0, isEmpty_1.default)(_this.definitionErrors)) {
                if (_this.recoveryEnabled) {
                  _this.TRACE_INIT("computeAllProdsFollows", function() {
                    var allFollows = (0, follow_1.computeAllProdsFollows)((0, values_1.default)(_this.gastProductionsCache));
                    _this.resyncFollows = allFollows;
                  });
                }
                _this.TRACE_INIT("ComputeLookaheadFunctions", function() {
                  var _a2, _b2;
                  (_b2 = (_a2 = _this.lookaheadStrategy).initialize) === null || _b2 === void 0 ? void 0 : _b2.call(_a2, {
                    rules: (0, values_1.default)(_this.gastProductionsCache)
                  });
                  _this.preComputeLookaheadFunctions((0, values_1.default)(_this.gastProductionsCache));
                });
              }
              if (!Parser2.DEFER_DEFINITION_ERRORS_HANDLING && !(0, isEmpty_1.default)(_this.definitionErrors)) {
                defErrorsMsgs = (0, map_1.default)(_this.definitionErrors, function(defError) {
                  return defError.message;
                });
                throw new Error("Parser Definition Errors detected:\n ".concat(defErrorsMsgs.join("\n-------------------------------\n")));
              }
            });
          };
          Parser2.DEFER_DEFINITION_ERRORS_HANDLING = false;
          return Parser2;
        }()
      );
      exports2.Parser = Parser;
      (0, apply_mixins_1.applyMixins)(Parser, [
        recoverable_1.Recoverable,
        looksahead_1.LooksAhead,
        tree_builder_1.TreeBuilder,
        lexer_adapter_1.LexerAdapter,
        recognizer_engine_1.RecognizerEngine,
        recognizer_api_1.RecognizerApi,
        error_handler_1.ErrorHandler,
        context_assist_1.ContentAssist,
        gast_recorder_1.GastRecorder,
        perf_tracer_1.PerformanceTracer
      ]);
      var CstParser = (
        /** @class */
        function(_super) {
          __extends(CstParser2, _super);
          function CstParser2(tokenVocabulary, config2) {
            if (config2 === void 0) {
              config2 = exports2.DEFAULT_PARSER_CONFIG;
            }
            var configClone = (0, clone_1.default)(config2);
            configClone.outputCst = true;
            return _super.call(this, tokenVocabulary, configClone) || this;
          }
          return CstParser2;
        }(Parser)
      );
      exports2.CstParser = CstParser;
      var EmbeddedActionsParser = (
        /** @class */
        function(_super) {
          __extends(EmbeddedActionsParser2, _super);
          function EmbeddedActionsParser2(tokenVocabulary, config2) {
            if (config2 === void 0) {
              config2 = exports2.DEFAULT_PARSER_CONFIG;
            }
            var configClone = (0, clone_1.default)(config2);
            configClone.outputCst = false;
            return _super.call(this, tokenVocabulary, configClone) || this;
          }
          return EmbeddedActionsParser2;
        }(Parser)
      );
      exports2.EmbeddedActionsParser = EmbeddedActionsParser;
    }
  });

  // node_modules/.pnpm/@chevrotain+cst-dts-gen@10.5.0/node_modules/@chevrotain/cst-dts-gen/lib/src/model.js
  var require_model2 = __commonJS({
    "node_modules/.pnpm/@chevrotain+cst-dts-gen@10.5.0/node_modules/@chevrotain/cst-dts-gen/lib/src/model.js"(exports2) {
      "use strict";
      var __extends = exports2 && exports2.__extends || function() {
        var extendStatics = function(d, b) {
          extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b3) {
            d2.__proto__ = b3;
          } || function(d2, b3) {
            for (var p in b3)
              if (Object.prototype.hasOwnProperty.call(b3, p))
                d2[p] = b3[p];
          };
          return extendStatics(d, b);
        };
        return function(d, b) {
          if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
          extendStatics(d, b);
          function __() {
            this.constructor = d;
          }
          d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
        };
      }();
      var __importDefault = exports2 && exports2.__importDefault || function(mod) {
        return mod && mod.__esModule ? mod : { "default": mod };
      };
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.buildModel = void 0;
      var gast_1 = require_api2();
      var map_1 = __importDefault(require_map());
      var flatten_1 = __importDefault(require_flatten());
      var values_1 = __importDefault(require_values());
      var some_1 = __importDefault(require_some());
      var groupBy_1 = __importDefault(require_groupBy());
      var assign_1 = __importDefault(require_assign());
      function buildModel(productions) {
        var generator = new CstNodeDefinitionGenerator();
        var allRules = (0, values_1.default)(productions);
        return (0, map_1.default)(allRules, function(rule) {
          return generator.visitRule(rule);
        });
      }
      exports2.buildModel = buildModel;
      var CstNodeDefinitionGenerator = (
        /** @class */
        function(_super) {
          __extends(CstNodeDefinitionGenerator2, _super);
          function CstNodeDefinitionGenerator2() {
            return _super !== null && _super.apply(this, arguments) || this;
          }
          CstNodeDefinitionGenerator2.prototype.visitRule = function(node) {
            var rawElements = this.visitEach(node.definition);
            var grouped = (0, groupBy_1.default)(rawElements, function(el) {
              return el.propertyName;
            });
            var properties = (0, map_1.default)(grouped, function(group, propertyName) {
              var allNullable = !(0, some_1.default)(group, function(el) {
                return !el.canBeNull;
              });
              var propertyType = group[0].type;
              if (group.length > 1) {
                propertyType = (0, map_1.default)(group, function(g4) {
                  return g4.type;
                });
              }
              return {
                name: propertyName,
                type: propertyType,
                optional: allNullable
              };
            });
            return {
              name: node.name,
              properties
            };
          };
          CstNodeDefinitionGenerator2.prototype.visitAlternative = function(node) {
            return this.visitEachAndOverrideWith(node.definition, { canBeNull: true });
          };
          CstNodeDefinitionGenerator2.prototype.visitOption = function(node) {
            return this.visitEachAndOverrideWith(node.definition, { canBeNull: true });
          };
          CstNodeDefinitionGenerator2.prototype.visitRepetition = function(node) {
            return this.visitEachAndOverrideWith(node.definition, { canBeNull: true });
          };
          CstNodeDefinitionGenerator2.prototype.visitRepetitionMandatory = function(node) {
            return this.visitEach(node.definition);
          };
          CstNodeDefinitionGenerator2.prototype.visitRepetitionMandatoryWithSeparator = function(node) {
            return this.visitEach(node.definition).concat({
              propertyName: node.separator.name,
              canBeNull: true,
              type: getType(node.separator)
            });
          };
          CstNodeDefinitionGenerator2.prototype.visitRepetitionWithSeparator = function(node) {
            return this.visitEachAndOverrideWith(node.definition, {
              canBeNull: true
            }).concat({
              propertyName: node.separator.name,
              canBeNull: true,
              type: getType(node.separator)
            });
          };
          CstNodeDefinitionGenerator2.prototype.visitAlternation = function(node) {
            return this.visitEachAndOverrideWith(node.definition, { canBeNull: true });
          };
          CstNodeDefinitionGenerator2.prototype.visitTerminal = function(node) {
            return [
              {
                propertyName: node.label || node.terminalType.name,
                canBeNull: false,
                type: getType(node)
              }
            ];
          };
          CstNodeDefinitionGenerator2.prototype.visitNonTerminal = function(node) {
            return [
              {
                propertyName: node.label || node.nonTerminalName,
                canBeNull: false,
                type: getType(node)
              }
            ];
          };
          CstNodeDefinitionGenerator2.prototype.visitEachAndOverrideWith = function(definition, override) {
            return (0, map_1.default)(this.visitEach(definition), function(definition2) {
              return (0, assign_1.default)({}, definition2, override);
            });
          };
          CstNodeDefinitionGenerator2.prototype.visitEach = function(definition) {
            var _this = this;
            return (0, flatten_1.default)((0, map_1.default)(definition, function(definition2) {
              return _this.visit(definition2);
            }));
          };
          return CstNodeDefinitionGenerator2;
        }(gast_1.GAstVisitor)
      );
      function getType(production) {
        if (production instanceof gast_1.NonTerminal) {
          return {
            kind: "rule",
            name: production.referencedRule.name
          };
        }
        return { kind: "token" };
      }
    }
  });

  // node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_castSlice.js
  var require_castSlice = __commonJS({
    "node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_castSlice.js"(exports2, module2) {
      var baseSlice = require_baseSlice();
      function castSlice(array, start, end) {
        var length = array.length;
        end = end === void 0 ? length : end;
        return !start && end >= length ? array : baseSlice(array, start, end);
      }
      module2.exports = castSlice;
    }
  });

  // node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_hasUnicode.js
  var require_hasUnicode = __commonJS({
    "node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_hasUnicode.js"(exports2, module2) {
      var rsAstralRange = "\\ud800-\\udfff";
      var rsComboMarksRange = "\\u0300-\\u036f";
      var reComboHalfMarksRange = "\\ufe20-\\ufe2f";
      var rsComboSymbolsRange = "\\u20d0-\\u20ff";
      var rsComboRange = rsComboMarksRange + reComboHalfMarksRange + rsComboSymbolsRange;
      var rsVarRange = "\\ufe0e\\ufe0f";
      var rsZWJ = "\\u200d";
      var reHasUnicode = RegExp("[" + rsZWJ + rsAstralRange + rsComboRange + rsVarRange + "]");
      function hasUnicode(string) {
        return reHasUnicode.test(string);
      }
      module2.exports = hasUnicode;
    }
  });

  // node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_asciiToArray.js
  var require_asciiToArray = __commonJS({
    "node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_asciiToArray.js"(exports2, module2) {
      function asciiToArray(string) {
        return string.split("");
      }
      module2.exports = asciiToArray;
    }
  });

  // node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_unicodeToArray.js
  var require_unicodeToArray = __commonJS({
    "node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_unicodeToArray.js"(exports2, module2) {
      var rsAstralRange = "\\ud800-\\udfff";
      var rsComboMarksRange = "\\u0300-\\u036f";
      var reComboHalfMarksRange = "\\ufe20-\\ufe2f";
      var rsComboSymbolsRange = "\\u20d0-\\u20ff";
      var rsComboRange = rsComboMarksRange + reComboHalfMarksRange + rsComboSymbolsRange;
      var rsVarRange = "\\ufe0e\\ufe0f";
      var rsAstral = "[" + rsAstralRange + "]";
      var rsCombo = "[" + rsComboRange + "]";
      var rsFitz = "\\ud83c[\\udffb-\\udfff]";
      var rsModifier = "(?:" + rsCombo + "|" + rsFitz + ")";
      var rsNonAstral = "[^" + rsAstralRange + "]";
      var rsRegional = "(?:\\ud83c[\\udde6-\\uddff]){2}";
      var rsSurrPair = "[\\ud800-\\udbff][\\udc00-\\udfff]";
      var rsZWJ = "\\u200d";
      var reOptMod = rsModifier + "?";
      var rsOptVar = "[" + rsVarRange + "]?";
      var rsOptJoin = "(?:" + rsZWJ + "(?:" + [rsNonAstral, rsRegional, rsSurrPair].join("|") + ")" + rsOptVar + reOptMod + ")*";
      var rsSeq = rsOptVar + reOptMod + rsOptJoin;
      var rsSymbol = "(?:" + [rsNonAstral + rsCombo + "?", rsCombo, rsRegional, rsSurrPair, rsAstral].join("|") + ")";
      var reUnicode = RegExp(rsFitz + "(?=" + rsFitz + ")|" + rsSymbol + rsSeq, "g");
      function unicodeToArray(string) {
        return string.match(reUnicode) || [];
      }
      module2.exports = unicodeToArray;
    }
  });

  // node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_stringToArray.js
  var require_stringToArray = __commonJS({
    "node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_stringToArray.js"(exports2, module2) {
      var asciiToArray = require_asciiToArray();
      var hasUnicode = require_hasUnicode();
      var unicodeToArray = require_unicodeToArray();
      function stringToArray(string) {
        return hasUnicode(string) ? unicodeToArray(string) : asciiToArray(string);
      }
      module2.exports = stringToArray;
    }
  });

  // node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_createCaseFirst.js
  var require_createCaseFirst = __commonJS({
    "node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_createCaseFirst.js"(exports2, module2) {
      var castSlice = require_castSlice();
      var hasUnicode = require_hasUnicode();
      var stringToArray = require_stringToArray();
      var toString = require_toString();
      function createCaseFirst(methodName) {
        return function(string) {
          string = toString(string);
          var strSymbols = hasUnicode(string) ? stringToArray(string) : void 0;
          var chr = strSymbols ? strSymbols[0] : string.charAt(0);
          var trailing = strSymbols ? castSlice(strSymbols, 1).join("") : string.slice(1);
          return chr[methodName]() + trailing;
        };
      }
      module2.exports = createCaseFirst;
    }
  });

  // node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/upperFirst.js
  var require_upperFirst = __commonJS({
    "node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/upperFirst.js"(exports2, module2) {
      var createCaseFirst = require_createCaseFirst();
      var upperFirst = createCaseFirst("toUpperCase");
      module2.exports = upperFirst;
    }
  });

  // node_modules/.pnpm/@chevrotain+cst-dts-gen@10.5.0/node_modules/@chevrotain/cst-dts-gen/lib/src/generate.js
  var require_generate = __commonJS({
    "node_modules/.pnpm/@chevrotain+cst-dts-gen@10.5.0/node_modules/@chevrotain/cst-dts-gen/lib/src/generate.js"(exports2) {
      "use strict";
      var __importDefault = exports2 && exports2.__importDefault || function(mod) {
        return mod && mod.__esModule ? mod : { "default": mod };
      };
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.genDts = void 0;
      var flatten_1 = __importDefault(require_flatten());
      var isArray_1 = __importDefault(require_isArray());
      var map_1 = __importDefault(require_map());
      var reduce_1 = __importDefault(require_reduce());
      var uniq_1 = __importDefault(require_uniq());
      var upperFirst_1 = __importDefault(require_upperFirst());
      function genDts(model, options) {
        var contentParts = [];
        contentParts = contentParts.concat('import type { CstNode, ICstVisitor, IToken } from "chevrotain";');
        contentParts = contentParts.concat((0, flatten_1.default)((0, map_1.default)(model, function(node) {
          return genCstNodeTypes(node);
        })));
        if (options.includeVisitorInterface) {
          contentParts = contentParts.concat(genVisitor(options.visitorInterfaceName, model));
        }
        return contentParts.join("\n\n") + "\n";
      }
      exports2.genDts = genDts;
      function genCstNodeTypes(node) {
        var nodeCstInterface = genNodeInterface(node);
        var nodeChildrenInterface = genNodeChildrenType(node);
        return [nodeCstInterface, nodeChildrenInterface];
      }
      function genNodeInterface(node) {
        var nodeInterfaceName = getNodeInterfaceName(node.name);
        var childrenTypeName = getNodeChildrenTypeName(node.name);
        return "export interface ".concat(nodeInterfaceName, ' extends CstNode {\n  name: "').concat(node.name, '";\n  children: ').concat(childrenTypeName, ";\n}");
      }
      function genNodeChildrenType(node) {
        var typeName = getNodeChildrenTypeName(node.name);
        return "export type ".concat(typeName, " = {\n  ").concat((0, map_1.default)(node.properties, function(property) {
          return genChildProperty(property);
        }).join("\n  "), "\n};");
      }
      function genChildProperty(prop) {
        var typeName = buildTypeString(prop.type);
        return "".concat(prop.name).concat(prop.optional ? "?" : "", ": ").concat(typeName, "[];");
      }
      function genVisitor(name, nodes) {
        return "export interface ".concat(name, "<IN, OUT> extends ICstVisitor<IN, OUT> {\n  ").concat((0, map_1.default)(nodes, function(node) {
          return genVisitorFunction(node);
        }).join("\n  "), "\n}");
      }
      function genVisitorFunction(node) {
        var childrenTypeName = getNodeChildrenTypeName(node.name);
        return "".concat(node.name, "(children: ").concat(childrenTypeName, ", param?: IN): OUT;");
      }
      function buildTypeString(type) {
        if ((0, isArray_1.default)(type)) {
          var typeNames = (0, uniq_1.default)((0, map_1.default)(type, function(t) {
            return getTypeString(t);
          }));
          var typeString = (0, reduce_1.default)(typeNames, function(sum, t) {
            return sum + " | " + t;
          });
          return "(" + typeString + ")";
        } else {
          return getTypeString(type);
        }
      }
      function getTypeString(type) {
        if (type.kind === "token") {
          return "IToken";
        }
        return getNodeInterfaceName(type.name);
      }
      function getNodeInterfaceName(ruleName) {
        return (0, upperFirst_1.default)(ruleName) + "CstNode";
      }
      function getNodeChildrenTypeName(ruleName) {
        return (0, upperFirst_1.default)(ruleName) + "CstChildren";
      }
    }
  });

  // node_modules/.pnpm/@chevrotain+cst-dts-gen@10.5.0/node_modules/@chevrotain/cst-dts-gen/lib/src/api.js
  var require_api3 = __commonJS({
    "node_modules/.pnpm/@chevrotain+cst-dts-gen@10.5.0/node_modules/@chevrotain/cst-dts-gen/lib/src/api.js"(exports2) {
      "use strict";
      var __assign = exports2 && exports2.__assign || function() {
        __assign = Object.assign || function(t) {
          for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s)
              if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
          }
          return t;
        };
        return __assign.apply(this, arguments);
      };
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.generateCstDts = void 0;
      var model_1 = require_model2();
      var generate_1 = require_generate();
      var defaultOptions = {
        includeVisitorInterface: true,
        visitorInterfaceName: "ICstNodeVisitor"
      };
      function generateCstDts(productions, options) {
        var effectiveOptions = __assign(__assign({}, defaultOptions), options);
        var model = (0, model_1.buildModel)(productions);
        return (0, generate_1.genDts)(model, effectiveOptions);
      }
      exports2.generateCstDts = generateCstDts;
    }
  });

  // node_modules/.pnpm/chevrotain@10.5.0/node_modules/chevrotain/lib/src/diagrams/render_public.js
  var require_render_public = __commonJS({
    "node_modules/.pnpm/chevrotain@10.5.0/node_modules/chevrotain/lib/src/diagrams/render_public.js"(exports2) {
      "use strict";
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.createSyntaxDiagramsCode = void 0;
      var version_1 = require_version();
      function createSyntaxDiagramsCode(grammar, _a2) {
        var _b2 = _a2 === void 0 ? {} : _a2, _c = _b2.resourceBase, resourceBase = _c === void 0 ? "https://unpkg.com/chevrotain@".concat(version_1.VERSION, "/diagrams/") : _c, _d = _b2.css, css = _d === void 0 ? "https://unpkg.com/chevrotain@".concat(version_1.VERSION, "/diagrams/diagrams.css") : _d;
        var header = '\n<!-- This is a generated file -->\n<!DOCTYPE html>\n<meta charset="utf-8">\n<style>\n  body {\n    background-color: hsl(30, 20%, 95%)\n  }\n</style>\n\n';
        var cssHtml = "\n<link rel='stylesheet' href='".concat(css, "'>\n");
        var scripts = "\n<script src='".concat(resourceBase, "vendor/railroad-diagrams.js'></script>\n<script src='").concat(resourceBase, "src/diagrams_builder.js'></script>\n<script src='").concat(resourceBase, "src/diagrams_behavior.js'></script>\n<script src='").concat(resourceBase, "src/main.js'></script>\n");
        var diagramsDiv = '\n<div id="diagrams" align="center"></div>    \n';
        var serializedGrammar = "\n<script>\n    window.serializedGrammar = ".concat(JSON.stringify(grammar, null, "  "), ";\n</script>\n");
        var initLogic = '\n<script>\n    var diagramsDiv = document.getElementById("diagrams");\n    main.drawDiagramsFromSerializedGrammar(serializedGrammar, diagramsDiv);\n</script>\n';
        return header + cssHtml + scripts + diagramsDiv + serializedGrammar + initLogic;
      }
      exports2.createSyntaxDiagramsCode = createSyntaxDiagramsCode;
    }
  });

  // node_modules/.pnpm/chevrotain@10.5.0/node_modules/chevrotain/lib/src/api.js
  var require_api4 = __commonJS({
    "node_modules/.pnpm/chevrotain@10.5.0/node_modules/chevrotain/lib/src/api.js"(exports2) {
      "use strict";
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.Parser = exports2.createSyntaxDiagramsCode = exports2.clearCache = exports2.generateCstDts = exports2.GAstVisitor = exports2.serializeProduction = exports2.serializeGrammar = exports2.Terminal = exports2.Rule = exports2.RepetitionWithSeparator = exports2.RepetitionMandatoryWithSeparator = exports2.RepetitionMandatory = exports2.Repetition = exports2.Option = exports2.NonTerminal = exports2.Alternative = exports2.Alternation = exports2.defaultLexerErrorProvider = exports2.NoViableAltException = exports2.NotAllInputParsedException = exports2.MismatchedTokenException = exports2.isRecognitionException = exports2.EarlyExitException = exports2.defaultParserErrorProvider = exports2.LLkLookaheadStrategy = exports2.getLookaheadPaths = exports2.tokenName = exports2.tokenMatcher = exports2.tokenLabel = exports2.EOF = exports2.createTokenInstance = exports2.createToken = exports2.LexerDefinitionErrorType = exports2.Lexer = exports2.EMPTY_ALT = exports2.ParserDefinitionErrorType = exports2.EmbeddedActionsParser = exports2.CstParser = exports2.VERSION = void 0;
      var version_1 = require_version();
      Object.defineProperty(exports2, "VERSION", { enumerable: true, get: function() {
        return version_1.VERSION;
      } });
      var parser_1 = require_parser();
      Object.defineProperty(exports2, "CstParser", { enumerable: true, get: function() {
        return parser_1.CstParser;
      } });
      Object.defineProperty(exports2, "EmbeddedActionsParser", { enumerable: true, get: function() {
        return parser_1.EmbeddedActionsParser;
      } });
      Object.defineProperty(exports2, "ParserDefinitionErrorType", { enumerable: true, get: function() {
        return parser_1.ParserDefinitionErrorType;
      } });
      Object.defineProperty(exports2, "EMPTY_ALT", { enumerable: true, get: function() {
        return parser_1.EMPTY_ALT;
      } });
      var lexer_public_1 = require_lexer_public();
      Object.defineProperty(exports2, "Lexer", { enumerable: true, get: function() {
        return lexer_public_1.Lexer;
      } });
      Object.defineProperty(exports2, "LexerDefinitionErrorType", { enumerable: true, get: function() {
        return lexer_public_1.LexerDefinitionErrorType;
      } });
      var tokens_public_1 = require_tokens_public();
      Object.defineProperty(exports2, "createToken", { enumerable: true, get: function() {
        return tokens_public_1.createToken;
      } });
      Object.defineProperty(exports2, "createTokenInstance", { enumerable: true, get: function() {
        return tokens_public_1.createTokenInstance;
      } });
      Object.defineProperty(exports2, "EOF", { enumerable: true, get: function() {
        return tokens_public_1.EOF;
      } });
      Object.defineProperty(exports2, "tokenLabel", { enumerable: true, get: function() {
        return tokens_public_1.tokenLabel;
      } });
      Object.defineProperty(exports2, "tokenMatcher", { enumerable: true, get: function() {
        return tokens_public_1.tokenMatcher;
      } });
      Object.defineProperty(exports2, "tokenName", { enumerable: true, get: function() {
        return tokens_public_1.tokenName;
      } });
      var lookahead_1 = require_lookahead();
      Object.defineProperty(exports2, "getLookaheadPaths", { enumerable: true, get: function() {
        return lookahead_1.getLookaheadPaths;
      } });
      var llk_lookahead_1 = require_llk_lookahead();
      Object.defineProperty(exports2, "LLkLookaheadStrategy", { enumerable: true, get: function() {
        return llk_lookahead_1.LLkLookaheadStrategy;
      } });
      var errors_public_1 = require_errors_public();
      Object.defineProperty(exports2, "defaultParserErrorProvider", { enumerable: true, get: function() {
        return errors_public_1.defaultParserErrorProvider;
      } });
      var exceptions_public_1 = require_exceptions_public();
      Object.defineProperty(exports2, "EarlyExitException", { enumerable: true, get: function() {
        return exceptions_public_1.EarlyExitException;
      } });
      Object.defineProperty(exports2, "isRecognitionException", { enumerable: true, get: function() {
        return exceptions_public_1.isRecognitionException;
      } });
      Object.defineProperty(exports2, "MismatchedTokenException", { enumerable: true, get: function() {
        return exceptions_public_1.MismatchedTokenException;
      } });
      Object.defineProperty(exports2, "NotAllInputParsedException", { enumerable: true, get: function() {
        return exceptions_public_1.NotAllInputParsedException;
      } });
      Object.defineProperty(exports2, "NoViableAltException", { enumerable: true, get: function() {
        return exceptions_public_1.NoViableAltException;
      } });
      var lexer_errors_public_1 = require_lexer_errors_public();
      Object.defineProperty(exports2, "defaultLexerErrorProvider", { enumerable: true, get: function() {
        return lexer_errors_public_1.defaultLexerErrorProvider;
      } });
      var gast_1 = require_api2();
      Object.defineProperty(exports2, "Alternation", { enumerable: true, get: function() {
        return gast_1.Alternation;
      } });
      Object.defineProperty(exports2, "Alternative", { enumerable: true, get: function() {
        return gast_1.Alternative;
      } });
      Object.defineProperty(exports2, "NonTerminal", { enumerable: true, get: function() {
        return gast_1.NonTerminal;
      } });
      Object.defineProperty(exports2, "Option", { enumerable: true, get: function() {
        return gast_1.Option;
      } });
      Object.defineProperty(exports2, "Repetition", { enumerable: true, get: function() {
        return gast_1.Repetition;
      } });
      Object.defineProperty(exports2, "RepetitionMandatory", { enumerable: true, get: function() {
        return gast_1.RepetitionMandatory;
      } });
      Object.defineProperty(exports2, "RepetitionMandatoryWithSeparator", { enumerable: true, get: function() {
        return gast_1.RepetitionMandatoryWithSeparator;
      } });
      Object.defineProperty(exports2, "RepetitionWithSeparator", { enumerable: true, get: function() {
        return gast_1.RepetitionWithSeparator;
      } });
      Object.defineProperty(exports2, "Rule", { enumerable: true, get: function() {
        return gast_1.Rule;
      } });
      Object.defineProperty(exports2, "Terminal", { enumerable: true, get: function() {
        return gast_1.Terminal;
      } });
      var gast_2 = require_api2();
      Object.defineProperty(exports2, "serializeGrammar", { enumerable: true, get: function() {
        return gast_2.serializeGrammar;
      } });
      Object.defineProperty(exports2, "serializeProduction", { enumerable: true, get: function() {
        return gast_2.serializeProduction;
      } });
      Object.defineProperty(exports2, "GAstVisitor", { enumerable: true, get: function() {
        return gast_2.GAstVisitor;
      } });
      var cst_dts_gen_1 = require_api3();
      Object.defineProperty(exports2, "generateCstDts", { enumerable: true, get: function() {
        return cst_dts_gen_1.generateCstDts;
      } });
      function clearCache() {
        console.warn("The clearCache function was 'soft' removed from the Chevrotain API.\n	 It performs no action other than printing this message.\n	 Please avoid using it as it will be completely removed in the future");
      }
      exports2.clearCache = clearCache;
      var render_public_1 = require_render_public();
      Object.defineProperty(exports2, "createSyntaxDiagramsCode", { enumerable: true, get: function() {
        return render_public_1.createSyntaxDiagramsCode;
      } });
      var Parser = (
        /** @class */
        function() {
          function Parser2() {
            throw new Error("The Parser class has been deprecated, use CstParser or EmbeddedActionsParser instead.	\nSee: https://chevrotain.io/docs/changes/BREAKING_CHANGES.html#_7-0-0");
          }
          return Parser2;
        }()
      );
      exports2.Parser = Parser;
    }
  });

  // node_modules/.pnpm/@mrleebo+prisma-ast@0.5.1/node_modules/@mrleebo/prisma-ast/dist/prisma-ast.cjs.production.min.js
  var require_prisma_ast_cjs_production_min = __commonJS({
    "node_modules/.pnpm/@mrleebo+prisma-ast@0.5.1/node_modules/@mrleebo/prisma-ast/dist/prisma-ast.cjs.production.min.js"(exports2) {
      "use strict";
      Object.defineProperty(exports2, "__esModule", { value: true });
      var e = require_api4();
      var t = __require("os");
      var n = e.createToken({ name: "Identifier", pattern: /[a-zA-Z]\w*/ });
      var r = e.createToken({ name: "Datasource", pattern: /datasource/, push_mode: "block" });
      var a = e.createToken({ name: "Generator", pattern: /generator/, push_mode: "block" });
      var i = e.createToken({ name: "Model", pattern: /model/, push_mode: "block" });
      var u = e.createToken({ name: "Enum", pattern: /enum/, push_mode: "block" });
      var o = e.createToken({ name: "True", pattern: /true/, longer_alt: n });
      var s = e.createToken({ name: "False", pattern: /false/, longer_alt: n });
      var c = e.createToken({ name: "Null", pattern: /null/, longer_alt: n });
      var m = e.createToken({ name: "Comment", pattern: e.Lexer.NA });
      var l = e.createToken({ name: "DocComment", pattern: /\/\/\/\s*(.+)/, categories: [m] });
      var p = e.createToken({ name: "LineComment", pattern: /\/\/\s*(.+)/, categories: [m] });
      var f = e.createToken({ name: "Attribute", pattern: e.Lexer.NA });
      var L = e.createToken({ name: "ModelAttribute", pattern: /@@/, label: "'@@'", categories: [f] });
      var d = e.createToken({ name: "FieldAttribute", pattern: /@/, label: "'@'", categories: [f] });
      var y = e.createToken({ name: "Dot", pattern: /\./, label: "'.'" });
      var E = e.createToken({ name: "QuestionMark", pattern: /\?/, label: "'?'" });
      var h = e.createToken({ name: "LCurly", pattern: /{/, label: "'{'" });
      var b = e.createToken({ name: "RCurly", pattern: /}/, label: "'}'", pop_mode: true });
      var v = e.createToken({ name: "LRound", pattern: /\(/, label: "'('" });
      var g4 = e.createToken({ name: "RRound", pattern: /\)/, label: "')'" });
      var A = e.createToken({ name: "LSquare", pattern: /\[/, label: "'['" });
      var U = e.createToken({ name: "RSquare", pattern: /\]/, label: "']'" });
      var S = e.createToken({ name: "Comma", pattern: /,/, label: "','" });
      var k = e.createToken({ name: "Colon", pattern: /:/, label: "':'" });
      var O = e.createToken({ name: "Equals", pattern: /=/, label: "'='" });
      var B = e.createToken({ name: "StringLiteral", pattern: /"(:?[^\\"\n\r]|\\(:?[bfnrtv"\\/]|u[0-9a-fA-F]{4}))*"/ });
      var T = e.createToken({ name: "NumberLiteral", pattern: /-?(0|[1-9]\d*)(\.\d+)?([eE][+-]?\d+)?/ });
      var N = e.createToken({ name: "WhiteSpace", pattern: /\s+/, group: e.Lexer.SKIPPED });
      var M = e.createToken({ name: "LineBreak", pattern: /\n|\r\n/, line_breaks: true, label: "LineBreak" });
      var C = [m, l, p, M, N];
      var R = { modes: { global: [].concat(C, [r, a, i, u]), block: [].concat(C, [f, L, d, y, E, h, b, A, U, v, g4, S, k, O, o, s, c, B, T, n]) }, defaultMode: "global" };
      var w = new e.Lexer(R);
      function j(e2, t2) {
        e2.prototype = Object.create(t2.prototype), e2.prototype.constructor = e2, (Object.setPrototypeOf || function(e3, t3) {
          return e3.__proto__ = t3, e3;
        })(e2, t2);
      }
      var x = new (function(e2) {
        function t2() {
          var t3;
          return (t3 = e2.call(this, R) || this).break = t3.RULE("break", function() {
            t3.CONSUME1(M), t3.CONSUME2(M);
          }), t3.keyedArg = t3.RULE("keyedArg", function() {
            t3.CONSUME(n, { LABEL: "keyName" }), t3.CONSUME(k), t3.SUBRULE(t3.value);
          }), t3.array = t3.RULE("array", function() {
            t3.CONSUME(A), t3.MANY_SEP({ SEP: S, DEF: function() {
              t3.SUBRULE(t3.value);
            } }), t3.CONSUME(U);
          }), t3.func = t3.RULE("func", function() {
            t3.CONSUME(n, { LABEL: "funcName" }), t3.CONSUME(v), t3.MANY_SEP({ SEP: S, DEF: function() {
              t3.OR([{ ALT: function() {
                return t3.SUBRULE(t3.keyedArg);
              } }, { ALT: function() {
                return t3.SUBRULE(t3.value);
              } }]);
            } }), t3.CONSUME(g4);
          }), t3.value = t3.RULE("value", function() {
            t3.OR([{ ALT: function() {
              return t3.CONSUME(B, { LABEL: "value" });
            } }, { ALT: function() {
              return t3.CONSUME(T, { LABEL: "value" });
            } }, { ALT: function() {
              return t3.SUBRULE(t3.array, { LABEL: "value" });
            } }, { ALT: function() {
              return t3.SUBRULE(t3.func, { LABEL: "value" });
            } }, { ALT: function() {
              return t3.CONSUME(o, { LABEL: "value" });
            } }, { ALT: function() {
              return t3.CONSUME(s, { LABEL: "value" });
            } }, { ALT: function() {
              return t3.CONSUME(c, { LABEL: "value" });
            } }, { ALT: function() {
              return t3.CONSUME(n, { LABEL: "value" });
            } }]);
          }), t3.property = t3.RULE("property", function() {
            t3.CONSUME(n, { LABEL: "propertyName" }), t3.CONSUME(O), t3.SUBRULE(t3.value, { LABEL: "propertyValue" });
          }), t3.assignment = t3.RULE("assignment", function() {
            t3.CONSUME(n, { LABEL: "assignmentName" }), t3.CONSUME(O), t3.SUBRULE(t3.value, { LABEL: "assignmentValue" });
          }), t3.field = t3.RULE("field", function() {
            t3.CONSUME(n, { LABEL: "fieldName" }), t3.SUBRULE(t3.value, { LABEL: "fieldType" }), t3.OPTION1(function() {
              t3.OR([{ ALT: function() {
                t3.CONSUME(A, { LABEL: "array" }), t3.CONSUME(U, { LABEL: "array" });
              } }, { ALT: function() {
                return t3.CONSUME(E, { LABEL: "optional" });
              } }]);
            }), t3.MANY(function() {
              t3.SUBRULE(t3.attribute, { LABEL: "attributeList" });
            }), t3.OPTION2(function() {
              t3.CONSUME(m, { LABEL: "comment" });
            });
          }), t3.block = t3.RULE("block", function(e3) {
            void 0 === e3 && (e3 = {});
            var n2 = e3.componentType, r2 = "enum" === n2, a2 = "model" === n2;
            t3.CONSUME(h), t3.CONSUME1(M), t3.MANY(function() {
              t3.OR([{ ALT: function() {
                return t3.SUBRULE(t3.comment, { LABEL: "list" });
              } }, { GATE: function() {
                return a2;
              }, ALT: function() {
                return t3.SUBRULE(t3.property, { LABEL: "list" });
              } }, { ALT: function() {
                return t3.SUBRULE(t3.attribute, { LABEL: "list" });
              } }, { GATE: function() {
                return a2;
              }, ALT: function() {
                return t3.SUBRULE(t3.field, { LABEL: "list" });
              } }, { GATE: function() {
                return r2;
              }, ALT: function() {
                return t3.SUBRULE(t3.enum, { LABEL: "list" });
              } }, { GATE: function() {
                return !a2;
              }, ALT: function() {
                return t3.SUBRULE(t3.assignment, { LABEL: "list" });
              } }, { ALT: function() {
                return t3.SUBRULE(t3.break, { LABEL: "list" });
              } }, { ALT: function() {
                return t3.CONSUME2(M);
              } }]);
            }), t3.CONSUME(b);
          }), t3.enum = t3.RULE("enum", function() {
            t3.CONSUME(n, { LABEL: "enumName" }), t3.OPTION(function() {
              t3.CONSUME(m, { LABEL: "comment" });
            });
          }), t3.attribute = t3.RULE("attribute", function() {
            t3.OR1([{ ALT: function() {
              return t3.CONSUME(L, { LABEL: "modelAttribute" });
            } }, { ALT: function() {
              return t3.CONSUME(d, { LABEL: "fieldAttribute" });
            } }]), t3.OR2([{ ALT: function() {
              t3.CONSUME1(n, { LABEL: "groupName" }), t3.CONSUME(y), t3.CONSUME2(n, { LABEL: "attributeName" });
            } }, { ALT: function() {
              return t3.CONSUME(n, { LABEL: "attributeName" });
            } }]), t3.OPTION(function() {
              t3.CONSUME(v), t3.MANY_SEP({ SEP: S, DEF: function() {
                t3.SUBRULE(t3.attributeArg);
              } }), t3.CONSUME(g4);
            });
          }), t3.attributeArg = t3.RULE("attributeArg", function() {
            t3.OR([{ ALT: function() {
              return t3.SUBRULE(t3.keyedArg, { LABEL: "value" });
            } }, { ALT: function() {
              return t3.SUBRULE(t3.value, { LABEL: "value" });
            } }]);
          }), t3.component = t3.RULE("component", function() {
            var e3 = t3.OR1([{ ALT: function() {
              return t3.CONSUME(r, { LABEL: "type" });
            } }, { ALT: function() {
              return t3.CONSUME(a, { LABEL: "type" });
            } }, { ALT: function() {
              return t3.CONSUME(i, { LABEL: "type" });
            } }, { ALT: function() {
              return t3.CONSUME(u, { LABEL: "type" });
            } }]);
            t3.OR2([{ ALT: function() {
              t3.CONSUME1(n, { LABEL: "groupName" }), t3.CONSUME(y), t3.CONSUME2(n, { LABEL: "componentName" });
            } }, { ALT: function() {
              return t3.CONSUME(n, { LABEL: "componentName" });
            } }]), t3.SUBRULE(t3.block, { ARGS: [{ componentType: e3.image }] });
          }), t3.comment = t3.RULE("comment", function() {
            t3.CONSUME(m, { LABEL: "text" });
          }), t3.schema = t3.RULE("schema", function() {
            t3.MANY(function() {
              t3.OR([{ ALT: function() {
                return t3.SUBRULE(t3.comment, { LABEL: "list" });
              } }, { ALT: function() {
                return t3.SUBRULE(t3.component, { LABEL: "list" });
              } }, { ALT: function() {
                return t3.SUBRULE(t3.break, { LABEL: "list" });
              } }, { ALT: function() {
                return t3.CONSUME(M);
              } }]);
            });
          }), t3.performSelfAnalysis(), t3;
        }
        return j(t2, e2), t2;
      }(e.CstParser))();
      var _ = function(e2) {
        function t2() {
          var t3;
          return (t3 = e2.call(this) || this).validateVisitor(), t3;
        }
        j(t2, e2);
        var n2 = t2.prototype;
        return n2.schema = function(e3) {
          var t3, n3 = this;
          return { type: "schema", list: (null == (t3 = e3.list) ? void 0 : t3.map(function(e4) {
            return n3.visit([e4]);
          })) || [] };
        }, n2.component = function(e3) {
          var t3 = e3.type[0].image, n3 = e3.componentName[0].image, r2 = this.visit(e3.block);
          switch (t3) {
            case "datasource":
              return { type: "datasource", name: n3, assignments: r2 };
            case "generator":
              return { type: "generator", name: n3, assignments: r2 };
            case "model":
              return { type: "model", name: n3, properties: r2 };
            case "enum":
              return { type: "enum", name: n3, enumerators: r2 };
            default:
              throw new Error("Unexpected block type: " + t3);
          }
        }, n2.break = function() {
          return { type: "break" };
        }, n2.comment = function(e3) {
          return { type: "comment", text: e3.text[0].image };
        }, n2.block = function(e3) {
          var t3, n3 = this;
          return null == (t3 = e3.list) ? void 0 : t3.map(function(e4) {
            return n3.visit([e4]);
          });
        }, n2.assignment = function(e3) {
          var t3 = this.visit(e3.assignmentValue);
          return { type: "assignment", key: e3.assignmentName[0].image, value: t3 };
        }, n2.field = function(e3) {
          var t3, n3, r2 = this, a2 = this.visit(e3.fieldType), i2 = e3.fieldName[0].image, u2 = e3.attributeList && e3.attributeList.map(function(e4) {
            return r2.visit([e4]);
          }), o2 = null == (t3 = e3.comment) || null == (n3 = t3[0]) ? void 0 : n3.image;
          return { type: "field", name: i2, fieldType: a2, array: null != e3.array, optional: null != e3.optional, attributes: u2, comment: o2 };
        }, n2.attribute = function(e3) {
          var t3 = this, n3 = e3.attributeName[0].image, r2 = (e3.groupName || [{}])[0].image, a2 = e3.attributeArg && e3.attributeArg.map(function(e4) {
            return t3.visit(e4);
          });
          return { type: "attribute", name: n3, kind: null != e3.modelAttribute ? "model" : "field", group: r2, args: a2 };
        }, n2.attributeArg = function(e3) {
          return { type: "attributeArgument", value: this.visit(e3.value) };
        }, n2.func = function(e3) {
          var t3 = this, n3 = e3.funcName[0].image, r2 = e3.value && e3.value.map(function(e4) {
            return t3.visit([e4]);
          }), a2 = e3.keyedArg && e3.keyedArg.map(function(e4) {
            return t3.visit([e4]);
          });
          return { type: "function", name: n3, params: (r2 || a2) && [].concat(null != r2 ? r2 : [], null != a2 ? a2 : []) };
        }, n2.array = function(e3) {
          var t3 = this;
          return { type: "array", args: e3.value && e3.value.map(function(e4) {
            return t3.visit([e4]);
          }) };
        }, n2.keyedArg = function(e3) {
          return { type: "keyValue", key: e3.keyName[0].image, value: this.visit(e3.value) };
        }, n2.value = function(e3) {
          return "image" in e3.value[0] ? e3.value[0].image : this.visit(e3.value);
        }, n2.enum = function(e3) {
          var t3, n3;
          return { type: "enumerator", name: e3.enumName[0].image, comment: null == (t3 = e3.comment) || null == (n3 = t3[0]) ? void 0 : n3.image };
        }, t2;
      }(x.getBaseCstVisitorConstructorWithDefaults());
      function P(e2) {
        var t2 = w.tokenize(e2);
        x.input = t2.tokens;
        var n2 = x.schema();
        if (x.errors.length > 0)
          throw x.errors[0];
        return new _().visit(n2);
      }
      var I = ["break", "comment"];
      var V = ["generator", "datasource", "model", "enum", "break", "comment"];
      function D(e2, n2) {
        void 0 === n2 && (n2 = {});
        var r2 = n2.sort, a2 = n2.locales, i2 = void 0 === a2 ? void 0 : a2, u2 = n2.sortOrder, o2 = void 0 === u2 ? void 0 : u2, s2 = e2.list;
        if (void 0 !== r2 && r2) {
          s2 = e2.list = s2.filter(function(e3) {
            return "break" !== e3.type;
          });
          var c2 = function(e3, t2, n3) {
            return void 0 === n3 && (n3 = V), function(r3, a3) {
              if (-1 !== I.indexOf(r3.type) != (-1 !== I.indexOf(a3.type)))
                return e3.list.indexOf(r3) - e3.list.indexOf(a3);
              n3 !== V && (n3 = n3.concat(V));
              var i3 = n3.indexOf(r3.type) - n3.indexOf(a3.type);
              return 0 !== i3 ? i3 : "name" in r3 && "name" in a3 ? r3.name.localeCompare(a3.name, t2) : 0;
            };
          }(e2, i2, o2);
          s2.sort(c2);
        }
        return s2.map(F).filter(Boolean).join(t.EOL).replace(/(\r?\n\s*){3,}/g, t.EOL + t.EOL) + t.EOL;
      }
      function F(e2) {
        switch (e2.type) {
          case "comment":
            return G(e2);
          case "datasource":
            return r2 = H((n2 = e2).assignments), "\ndatasource " + n2.name + " {\n  " + r2 + "\n}";
          case "enum":
            return function(e3) {
              var n3 = e3.enumerators.map(q).filter(Boolean).join(t.EOL + "  ").replace(/(\r?\n\s*){3,}/g, t.EOL + t.EOL + "  ");
              return "\nenum " + e3.name + " {\n  " + n3 + "\n}";
            }(e2);
          case "generator":
            return function(e3) {
              var t2 = H(e3.assignments);
              return "\ngenerator " + e3.name + " {\n  " + t2 + "\n}";
            }(e2);
          case "model":
            return function(e3) {
              var n3, r3, a2, i2, u2, o2 = (r3 = 0, a2 = (n3 = e3.properties).reduce(function(e4, t2, n4, a3) {
                return "break" === t2.type || (n4 > 0 && "break" === a3[n4 - 1].type && (e4[++r3] = []), e4[r3].push(t2)), e4;
              }, [[]]), i2 = a2.map(function(e4) {
                return e4.reduce(function(e5, t2) {
                  return Math.max(e5, "field" === t2.type ? t2.name.length : 0);
                }, 0);
              }), u2 = a2.map(function(e4) {
                return e4.reduce(function(e5, t2) {
                  return Math.max(e5, "field" === t2.type ? K(t2).length : 0);
                }, 0);
              }), n3.map(function(e4, t2, n4) {
                return t2 > 0 && "break" !== e4.type && "break" === n4[t2 - 1].type && (i2.shift(), u2.shift()), function(e5, t3, n5) {
                  switch (void 0 === t3 && (t3 = 0), void 0 === n5 && (n5 = 0), e5.type) {
                    case "attribute":
                      return z(e5);
                    case "field":
                      return function(e6, t4, n6) {
                        void 0 === t4 && (t4 = 0), void 0 === n6 && (n6 = 0);
                        var r4 = e6.name.padEnd(t4), a3 = K(e6).padEnd(n6), i3 = e6.attributes ? e6.attributes.map(z) : [], u3 = e6.comment;
                        return [r4, a3].concat(i3).filter(Boolean).join(" ").trim() + (u3 ? " " + u3 : "");
                      }(e5, t3, n5);
                    case "comment":
                      return G(e5);
                    case "break":
                      return Y();
                    default:
                      throw new Error("Unrecognized property type");
                  }
                }(e4, i2[0], u2[0]);
              }).filter(Boolean).join(t.EOL + "  ").replace(/(\r?\n\s*){3,}/g, t.EOL + t.EOL + "  "));
              return "\nmodel " + e3.name + " {\n  " + o2 + "\n}";
            }(e2);
          case "break":
            return Y();
          default:
            throw new Error("Unrecognized block type");
        }
        var n2, r2;
      }
      function G(e2) {
        return e2.text;
      }
      function Y() {
        return t.EOL;
      }
      function q(e2) {
        switch (e2.type) {
          case "enumerator":
            return [e2.name, e2.comment].filter(Boolean).join(" ");
          case "attribute":
            return z(e2);
          case "comment":
            return G(e2);
          case "break":
            return Y();
          default:
            throw new Error("Unexpected enumerator type");
        }
      }
      function z(e2) {
        var t2 = e2.args && e2.args.length > 0 ? "(" + e2.args.map(W).filter(Boolean).join(", ") + ")" : "", n2 = [e2.name];
        return e2.group && n2.unshift(e2.group), ("field" === e2.kind ? "@" : "@@") + n2.join(".") + t2;
      }
      function W(e2) {
        return Z(e2.value);
      }
      function K(e2) {
        var t2 = e2.array ? "[]" : e2.optional ? "?" : "";
        if ("object" == typeof e2.fieldType)
          switch (e2.fieldType.type) {
            case "function":
              return "" + Q(e2.fieldType) + t2;
            default:
              throw new Error("Unexpected field type");
          }
        return "" + e2.fieldType + t2;
      }
      function Q(e2) {
        var t2 = e2.params ? e2.params.map(Z) : "";
        return e2.name + "(" + t2 + ")";
      }
      function Z(e2) {
        switch (typeof e2) {
          case "object":
            if ("type" in e2)
              switch (e2.type) {
                case "keyValue":
                  return e2.key + ": " + Z(e2.value);
                case "function":
                  return Q(e2);
                case "array":
                  return "[" + (null != e2.args ? e2.args.map(Z).join(", ") : "") + "]";
                default:
                  throw new Error("Unexpected value type");
              }
            throw new Error("Unexpected object value");
          default:
            return String(e2);
        }
      }
      function H(e2) {
        var n2 = 0, r2 = e2.reduce(function(e3, t2, r3, a2) {
          return "break" === t2.type || (r3 > 0 && "break" === a2[r3 - 1].type && (e3[++n2] = []), e3[n2].push(t2)), e3;
        }, [[]]).map(function(e3) {
          return e3.reduce(function(e4, t2) {
            return Math.max(e4, "assignment" === t2.type ? t2.key.length : 0);
          }, 0);
        });
        return e2.map(function(e3, t2, n3) {
          return t2 > 0 && "break" !== e3.type && "break" === n3[t2 - 1].type && r2.shift(), function(e4, t3) {
            switch (void 0 === t3 && (t3 = 0), e4.type) {
              case "comment":
                return G(e4);
              case "break":
                return Y();
              case "assignment":
                return e4.key.padEnd(t3) + " = " + Z(e4.value);
              default:
                throw new Error("Unexpected assignment type");
            }
          }(e3, r2[0]);
        }).filter(Boolean).join(t.EOL + "  ").replace(/(\r?\n\s*){3,}/g, t.EOL + t.EOL + "  ");
      }
      var J = function() {
        function e2(e3) {
          void 0 === e3 && (e3 = ""), this.schema = P(e3);
        }
        var t2 = e2.prototype;
        return t2.print = function(e3) {
          return void 0 === e3 && (e3 = {}), D(this.schema, e3);
        }, t2.getSchema = function() {
          return this.schema;
        }, t2.generator = function(e3, t3) {
          void 0 === t3 && (t3 = "prisma-client-js");
          var n2 = this.schema.list.reduce(function(t4, n3) {
            return "generator" === n3.type && n3.name === e3 ? n3 : t4;
          }, { type: "generator", name: e3, assignments: [{ type: "assignment", key: "provider", value: '"' + t3 + '"' }] });
          return this.schema.list.includes(n2) || this.schema.list.push(n2), this._subject = n2, this;
        }, t2.drop = function(e3) {
          var t3 = this.schema.list.findIndex(function(t4) {
            return "name" in t4 && t4.name === e3;
          });
          return this.schema.list.splice(t3, 1), this;
        }, t2.datasource = function(e3, t3) {
          var n2 = { type: "datasource", name: "db", assignments: [{ type: "assignment", key: "url", value: "string" == typeof t3 ? '"' + t3 + '"' : { type: "function", name: "env", params: ['"' + t3.env + '"'] } }, { type: "assignment", key: "provider", value: e3 }] }, r2 = this.schema.list.findIndex(function(e4) {
            return "datasource" === e4.type;
          });
          return this.schema.list.splice(r2, -1 !== r2 ? 1 : 0, n2), this._subject = n2, this;
        }, t2.model = function(e3) {
          var t3 = this.schema.list.reduce(function(t4, n2) {
            return "model" === n2.type && n2.name === e3 ? n2 : t4;
          }, { type: "model", name: e3, properties: [] });
          return this.schema.list.includes(t3) || this.schema.list.push(t3), this._subject = t3, this;
        }, t2.enum = function(e3, t3) {
          void 0 === t3 && (t3 = []);
          var n2 = this.schema.list.reduce(function(t4, n3) {
            return "enum" === n3.type && n3.name === e3 ? n3 : t4;
          }, { type: "enum", name: e3, enumerators: t3.map(function(e4) {
            return { type: "enumerator", name: e4 };
          }) });
          return this.schema.list.includes(n2) || this.schema.list.push(n2), this._subject = n2, this;
        }, t2.enumerator = function(e3) {
          var t3 = this.getSubject();
          if (!t3 || !("type" in t3) || "enum" !== t3.type)
            throw new Error("Subject must be a prisma model!");
          return t3.enumerators.push({ type: "enumerator", name: e3 }), this;
        }, t2.getSubject = function() {
          return this._subject;
        }, t2.getParent = function() {
          return this._parent;
        }, t2.blockAttribute = function(e3, t3) {
          var n2 = this.getSubject();
          if (!n2 || !("type" in n2) || "model" !== n2.type) {
            var r2 = this.getParent();
            if (!r2 || !("type" in r2) || "model" !== r2.type)
              throw new Error("Subject must be a prisma model!");
            n2 = this._subject = r2;
          }
          var a2 = t3 ? "string" == typeof t3 ? [{ type: "attributeArgument", value: '"' + t3 + '"' }] : Array.isArray(t3) ? [{ type: "attributeArgument", value: { type: "array", args: t3 } }] : Object.entries(t3).map(function(e4) {
            return { type: "attributeArgument", value: { type: "keyValue", key: e4[0], value: e4[1] } };
          }) : [];
          return n2.properties.push({ type: "attribute", kind: "model", name: e3, args: a2 }), this;
        }, t2.attribute = function(e3, t3) {
          var n2 = this.getParent(), r2 = this.getSubject();
          if (!n2 || !("type" in n2) || "model" !== n2.type)
            throw new Error("Parent must be a prisma model!");
          if (!r2 || !("type" in r2) || "field" !== r2.type)
            throw new Error("Subject must be a prisma field!");
          r2.attributes || (r2.attributes = []);
          var a2 = r2.attributes.reduce(function(t4, n3) {
            return "attribute" === n3.type && n3.name === e3 ? n3 : t4;
          }, { type: "attribute", kind: "field", name: e3 });
          if (Array.isArray(t3)) {
            var i2 = function e4(t4) {
              var n3, r3;
              return "string" == typeof t4 ? t4 : { type: "function", name: t4.name, params: null != (n3 = null == (r3 = t4.function) ? void 0 : r3.map(e4)) ? n3 : [] };
            };
            t3.length > 0 && (a2.args = t3.map(function(e4) {
              return { type: "attributeArgument", value: i2(e4) };
            }));
          } else
            "object" == typeof t3 && (a2.args = Object.entries(t3).map(function(e4) {
              return { type: "attributeArgument", value: { type: "keyValue", key: e4[0], value: { type: "array", args: e4[1] } } };
            }));
          return r2.attributes.includes(a2) || r2.attributes.push(a2), this;
        }, t2.removeAttribute = function(e3) {
          var t3 = this.getParent(), n2 = this.getSubject();
          if (!t3 || !("type" in t3) || "model" !== t3.type)
            throw new Error("Parent must be a prisma model!");
          if (!n2 || !("type" in n2) || "field" !== n2.type)
            throw new Error("Subject must be a prisma field!");
          return n2.attributes || (n2.attributes = []), n2.attributes = n2.attributes.filter(function(t4) {
            return !("attribute" === t4.type && t4.name === e3);
          }), this;
        }, t2.assignment = function(e3, t3) {
          var n2 = this.getSubject();
          if (!n2 || !("type" in n2) || !["generator", "datasource"].includes(n2.type))
            throw new Error("Subject must be a prisma generator or datasource!");
          var r2 = n2.assignments.reduce(function(n3, r3) {
            return "assignment" === r3.type && r3.key === e3 ? function(e4, n4) {
              return e4.value = '"' + t3 + '"', e4;
            }(r3) : n3;
          }, { type: "assignment", key: e3, value: '"' + t3 + '"' });
          return n2.assignments.includes(r2) || n2.assignments.push(r2), this;
        }, t2.blockInsert = function(e3) {
          var t3 = this.getSubject(), n2 = ["datasource", "enum", "generator", "model"];
          if (!t3 || !("type" in t3) || !n2.includes(t3.type)) {
            var r2 = this.getParent();
            if (!r2 || !("type" in r2) || !n2.includes(r2.type))
              throw new Error("Subject must be a prisma block!");
            t3 = this._subject = r2;
          }
          switch (t3.type) {
            case "datasource":
              t3.assignments.push(e3);
              break;
            case "enum":
              t3.enumerators.push(e3);
              break;
            case "generator":
              t3.assignments.push(e3);
              break;
            case "model":
              t3.properties.push(e3);
          }
          return this;
        }, t2.break = function() {
          return this.blockInsert({ type: "break" });
        }, t2.comment = function(e3, t3) {
          return void 0 === t3 && (t3 = false), this.blockInsert({ type: "comment", text: "//" + (t3 ? "/" : "") + " " + e3 });
        }, t2.schemaComment = function(e3, t3) {
          return void 0 === t3 && (t3 = false), this.schema.list.push({ type: "comment", text: "//" + (t3 ? "/" : "") + " " + e3 }), this;
        }, t2.field = function(e3, t3) {
          void 0 === t3 && (t3 = "String");
          var n2 = this.getSubject();
          if (!n2 || !("type" in n2) || "model" !== n2.type) {
            var r2 = this.getParent();
            if (!r2 || !("type" in r2) || "model" !== r2.type)
              throw new Error("Subject must be a prisma model!");
            n2 = this._subject = r2;
          }
          var a2 = n2.properties.reduce(function(t4, n3) {
            return "field" === n3.type && n3.name === e3 ? n3 : t4;
          }, { type: "field", name: e3, fieldType: t3 });
          return n2.properties.includes(a2) || n2.properties.push(a2), this._parent = n2, this._subject = a2, this;
        }, t2.removeField = function(e3) {
          var t3 = this.getSubject();
          if (!t3 || !("type" in t3) || "model" !== t3.type) {
            var n2 = this.getParent();
            if (!n2 || !("type" in n2) || "model" !== n2.type)
              throw new Error("Subject must be a prisma model!");
            t3 = this._subject = n2;
          }
          return t3.properties = t3.properties.filter(function(t4) {
            return !("field" === t4.type && t4.name === e3);
          }), this;
        }, t2.then = function(e3) {
          return e3(this._subject), this;
        }, e2;
      }();
      exports2.ConcretePrismaSchemaBuilder = J, exports2.createPrismaSchemaBuilder = function(e2) {
        return new J(e2);
      }, exports2.getSchema = P, exports2.printSchema = D;
    }
  });

  // node_modules/.pnpm/@mrleebo+prisma-ast@0.5.1/node_modules/@mrleebo/prisma-ast/dist/prisma-ast.cjs.development.js
  var require_prisma_ast_cjs_development = __commonJS({
    "node_modules/.pnpm/@mrleebo+prisma-ast@0.5.1/node_modules/@mrleebo/prisma-ast/dist/prisma-ast.cjs.development.js"(exports2) {
      "use strict";
      Object.defineProperty(exports2, "__esModule", { value: true });
      var chevrotain = require_api4();
      var os5 = __require("os");
      var Identifier = /* @__PURE__ */ chevrotain.createToken({
        name: "Identifier",
        pattern: /[a-zA-Z]\w*/
      });
      var Datasource = /* @__PURE__ */ chevrotain.createToken({
        name: "Datasource",
        pattern: /datasource/,
        push_mode: "block"
      });
      var Generator = /* @__PURE__ */ chevrotain.createToken({
        name: "Generator",
        pattern: /generator/,
        push_mode: "block"
      });
      var Model = /* @__PURE__ */ chevrotain.createToken({
        name: "Model",
        pattern: /model/,
        push_mode: "block"
      });
      var Enum = /* @__PURE__ */ chevrotain.createToken({
        name: "Enum",
        pattern: /enum/,
        push_mode: "block"
      });
      var True = /* @__PURE__ */ chevrotain.createToken({
        name: "True",
        pattern: /true/,
        longer_alt: Identifier
      });
      var False = /* @__PURE__ */ chevrotain.createToken({
        name: "False",
        pattern: /false/,
        longer_alt: Identifier
      });
      var Null = /* @__PURE__ */ chevrotain.createToken({
        name: "Null",
        pattern: /null/,
        longer_alt: Identifier
      });
      var Comment = /* @__PURE__ */ chevrotain.createToken({
        name: "Comment",
        pattern: chevrotain.Lexer.NA
      });
      var DocComment = /* @__PURE__ */ chevrotain.createToken({
        name: "DocComment",
        pattern: /\/\/\/\s*(.+)/,
        categories: [Comment]
      });
      var LineComment = /* @__PURE__ */ chevrotain.createToken({
        name: "LineComment",
        pattern: /\/\/\s*(.+)/,
        categories: [Comment]
      });
      var Attribute = /* @__PURE__ */ chevrotain.createToken({
        name: "Attribute",
        pattern: chevrotain.Lexer.NA
      });
      var ModelAttribute = /* @__PURE__ */ chevrotain.createToken({
        name: "ModelAttribute",
        pattern: /@@/,
        label: "'@@'",
        categories: [Attribute]
      });
      var FieldAttribute = /* @__PURE__ */ chevrotain.createToken({
        name: "FieldAttribute",
        pattern: /@/,
        label: "'@'",
        categories: [Attribute]
      });
      var Dot = /* @__PURE__ */ chevrotain.createToken({
        name: "Dot",
        pattern: /\./,
        label: "'.'"
      });
      var QuestionMark = /* @__PURE__ */ chevrotain.createToken({
        name: "QuestionMark",
        pattern: /\?/,
        label: "'?'"
      });
      var LCurly = /* @__PURE__ */ chevrotain.createToken({
        name: "LCurly",
        pattern: /{/,
        label: "'{'"
      });
      var RCurly = /* @__PURE__ */ chevrotain.createToken({
        name: "RCurly",
        pattern: /}/,
        label: "'}'",
        pop_mode: true
      });
      var LRound = /* @__PURE__ */ chevrotain.createToken({
        name: "LRound",
        pattern: /\(/,
        label: "'('"
      });
      var RRound = /* @__PURE__ */ chevrotain.createToken({
        name: "RRound",
        pattern: /\)/,
        label: "')'"
      });
      var LSquare = /* @__PURE__ */ chevrotain.createToken({
        name: "LSquare",
        pattern: /\[/,
        label: "'['"
      });
      var RSquare = /* @__PURE__ */ chevrotain.createToken({
        name: "RSquare",
        pattern: /\]/,
        label: "']'"
      });
      var Comma = /* @__PURE__ */ chevrotain.createToken({
        name: "Comma",
        pattern: /,/,
        label: "','"
      });
      var Colon = /* @__PURE__ */ chevrotain.createToken({
        name: "Colon",
        pattern: /:/,
        label: "':'"
      });
      var Equals = /* @__PURE__ */ chevrotain.createToken({
        name: "Equals",
        pattern: /=/,
        label: "'='"
      });
      var StringLiteral = /* @__PURE__ */ chevrotain.createToken({
        name: "StringLiteral",
        pattern: /"(:?[^\\"\n\r]|\\(:?[bfnrtv"\\/]|u[0-9a-fA-F]{4}))*"/
      });
      var NumberLiteral = /* @__PURE__ */ chevrotain.createToken({
        name: "NumberLiteral",
        pattern: /-?(0|[1-9]\d*)(\.\d+)?([eE][+-]?\d+)?/
      });
      var WhiteSpace = /* @__PURE__ */ chevrotain.createToken({
        name: "WhiteSpace",
        pattern: /\s+/,
        group: chevrotain.Lexer.SKIPPED
      });
      var LineBreak = /* @__PURE__ */ chevrotain.createToken({
        name: "LineBreak",
        pattern: /\n|\r\n/,
        line_breaks: true,
        label: "LineBreak"
      });
      var naTokens = [Comment, DocComment, LineComment, LineBreak, WhiteSpace];
      var multiModeTokens = {
        modes: {
          global: /* @__PURE__ */ [].concat(naTokens, [Datasource, Generator, Model, Enum]),
          block: /* @__PURE__ */ [].concat(naTokens, [Attribute, ModelAttribute, FieldAttribute, Dot, QuestionMark, LCurly, RCurly, LSquare, RSquare, LRound, RRound, Comma, Colon, Equals, True, False, Null, StringLiteral, NumberLiteral, Identifier])
        },
        defaultMode: "global"
      };
      var PrismaLexer = /* @__PURE__ */ new chevrotain.Lexer(multiModeTokens);
      function _inheritsLoose(subClass, superClass) {
        subClass.prototype = Object.create(superClass.prototype);
        subClass.prototype.constructor = subClass;
        _setPrototypeOf(subClass, superClass);
      }
      function _setPrototypeOf(o, p) {
        _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf2(o2, p2) {
          o2.__proto__ = p2;
          return o2;
        };
        return _setPrototypeOf(o, p);
      }
      var PrismaParser = /* @__PURE__ */ function(_CstParser) {
        _inheritsLoose(PrismaParser2, _CstParser);
        function PrismaParser2() {
          var _this;
          _this = _CstParser.call(this, multiModeTokens) || this;
          _this["break"] = _this.RULE("break", function() {
            _this.CONSUME1(LineBreak);
            _this.CONSUME2(LineBreak);
          });
          _this.keyedArg = _this.RULE("keyedArg", function() {
            _this.CONSUME(Identifier, {
              LABEL: "keyName"
            });
            _this.CONSUME(Colon);
            _this.SUBRULE(_this.value);
          });
          _this.array = _this.RULE("array", function() {
            _this.CONSUME(LSquare);
            _this.MANY_SEP({
              SEP: Comma,
              DEF: function DEF() {
                _this.SUBRULE(_this.value);
              }
            });
            _this.CONSUME(RSquare);
          });
          _this.func = _this.RULE("func", function() {
            _this.CONSUME(Identifier, {
              LABEL: "funcName"
            });
            _this.CONSUME(LRound);
            _this.MANY_SEP({
              SEP: Comma,
              DEF: function DEF() {
                _this.OR([{
                  ALT: function ALT() {
                    return _this.SUBRULE(_this.keyedArg);
                  }
                }, {
                  ALT: function ALT() {
                    return _this.SUBRULE(_this.value);
                  }
                }]);
              }
            });
            _this.CONSUME(RRound);
          });
          _this.value = _this.RULE("value", function() {
            _this.OR([{
              ALT: function ALT() {
                return _this.CONSUME(StringLiteral, {
                  LABEL: "value"
                });
              }
            }, {
              ALT: function ALT() {
                return _this.CONSUME(NumberLiteral, {
                  LABEL: "value"
                });
              }
            }, {
              ALT: function ALT() {
                return _this.SUBRULE(_this.array, {
                  LABEL: "value"
                });
              }
            }, {
              ALT: function ALT() {
                return _this.SUBRULE(_this.func, {
                  LABEL: "value"
                });
              }
            }, {
              ALT: function ALT() {
                return _this.CONSUME(True, {
                  LABEL: "value"
                });
              }
            }, {
              ALT: function ALT() {
                return _this.CONSUME(False, {
                  LABEL: "value"
                });
              }
            }, {
              ALT: function ALT() {
                return _this.CONSUME(Null, {
                  LABEL: "value"
                });
              }
            }, {
              ALT: function ALT() {
                return _this.CONSUME(Identifier, {
                  LABEL: "value"
                });
              }
            }]);
          });
          _this.property = _this.RULE("property", function() {
            _this.CONSUME(Identifier, {
              LABEL: "propertyName"
            });
            _this.CONSUME(Equals);
            _this.SUBRULE(_this.value, {
              LABEL: "propertyValue"
            });
          });
          _this.assignment = _this.RULE("assignment", function() {
            _this.CONSUME(Identifier, {
              LABEL: "assignmentName"
            });
            _this.CONSUME(Equals);
            _this.SUBRULE(_this.value, {
              LABEL: "assignmentValue"
            });
          });
          _this.field = _this.RULE("field", function() {
            _this.CONSUME(Identifier, {
              LABEL: "fieldName"
            });
            _this.SUBRULE(_this.value, {
              LABEL: "fieldType"
            });
            _this.OPTION1(function() {
              _this.OR([{
                ALT: function ALT() {
                  _this.CONSUME(LSquare, {
                    LABEL: "array"
                  });
                  _this.CONSUME(RSquare, {
                    LABEL: "array"
                  });
                }
              }, {
                ALT: function ALT() {
                  return _this.CONSUME(QuestionMark, {
                    LABEL: "optional"
                  });
                }
              }]);
            });
            _this.MANY(function() {
              _this.SUBRULE(_this.attribute, {
                LABEL: "attributeList"
              });
            });
            _this.OPTION2(function() {
              _this.CONSUME(Comment, {
                LABEL: "comment"
              });
            });
          });
          _this.block = _this.RULE("block", function(options) {
            if (options === void 0) {
              options = {};
            }
            var _options = options, componentType = _options.componentType;
            var isEnum = componentType === "enum";
            var isModel = componentType === "model";
            _this.CONSUME(LCurly);
            _this.CONSUME1(LineBreak);
            _this.MANY(function() {
              _this.OR([{
                ALT: function ALT() {
                  return _this.SUBRULE(_this.comment, {
                    LABEL: "list"
                  });
                }
              }, {
                GATE: function GATE() {
                  return isModel;
                },
                ALT: function ALT() {
                  return _this.SUBRULE(_this.property, {
                    LABEL: "list"
                  });
                }
              }, {
                ALT: function ALT() {
                  return _this.SUBRULE(_this.attribute, {
                    LABEL: "list"
                  });
                }
              }, {
                GATE: function GATE() {
                  return isModel;
                },
                ALT: function ALT() {
                  return _this.SUBRULE(_this.field, {
                    LABEL: "list"
                  });
                }
              }, {
                GATE: function GATE() {
                  return isEnum;
                },
                ALT: function ALT() {
                  return _this.SUBRULE(_this["enum"], {
                    LABEL: "list"
                  });
                }
              }, {
                GATE: function GATE() {
                  return !isModel;
                },
                ALT: function ALT() {
                  return _this.SUBRULE(_this.assignment, {
                    LABEL: "list"
                  });
                }
              }, {
                ALT: function ALT() {
                  return _this.SUBRULE(_this["break"], {
                    LABEL: "list"
                  });
                }
              }, {
                ALT: function ALT() {
                  return _this.CONSUME2(LineBreak);
                }
              }]);
            });
            _this.CONSUME(RCurly);
          });
          _this["enum"] = _this.RULE("enum", function() {
            _this.CONSUME(Identifier, {
              LABEL: "enumName"
            });
            _this.OPTION(function() {
              _this.CONSUME(Comment, {
                LABEL: "comment"
              });
            });
          });
          _this.attribute = _this.RULE("attribute", function() {
            _this.OR1([{
              ALT: function ALT() {
                return _this.CONSUME(ModelAttribute, {
                  LABEL: "modelAttribute"
                });
              }
            }, {
              ALT: function ALT() {
                return _this.CONSUME(FieldAttribute, {
                  LABEL: "fieldAttribute"
                });
              }
            }]);
            _this.OR2([{
              ALT: function ALT() {
                _this.CONSUME1(Identifier, {
                  LABEL: "groupName"
                });
                _this.CONSUME(Dot);
                _this.CONSUME2(Identifier, {
                  LABEL: "attributeName"
                });
              }
            }, {
              ALT: function ALT() {
                return _this.CONSUME(Identifier, {
                  LABEL: "attributeName"
                });
              }
            }]);
            _this.OPTION(function() {
              _this.CONSUME(LRound);
              _this.MANY_SEP({
                SEP: Comma,
                DEF: function DEF() {
                  _this.SUBRULE(_this.attributeArg);
                }
              });
              _this.CONSUME(RRound);
            });
          });
          _this.attributeArg = _this.RULE("attributeArg", function() {
            _this.OR([{
              ALT: function ALT() {
                return _this.SUBRULE(_this.keyedArg, {
                  LABEL: "value"
                });
              }
            }, {
              ALT: function ALT() {
                return _this.SUBRULE(_this.value, {
                  LABEL: "value"
                });
              }
            }]);
          });
          _this.component = _this.RULE("component", function() {
            var type = _this.OR1([{
              ALT: function ALT() {
                return _this.CONSUME(Datasource, {
                  LABEL: "type"
                });
              }
            }, {
              ALT: function ALT() {
                return _this.CONSUME(Generator, {
                  LABEL: "type"
                });
              }
            }, {
              ALT: function ALT() {
                return _this.CONSUME(Model, {
                  LABEL: "type"
                });
              }
            }, {
              ALT: function ALT() {
                return _this.CONSUME(Enum, {
                  LABEL: "type"
                });
              }
            }]);
            _this.OR2([{
              ALT: function ALT() {
                _this.CONSUME1(Identifier, {
                  LABEL: "groupName"
                });
                _this.CONSUME(Dot);
                _this.CONSUME2(Identifier, {
                  LABEL: "componentName"
                });
              }
            }, {
              ALT: function ALT() {
                return _this.CONSUME(Identifier, {
                  LABEL: "componentName"
                });
              }
            }]);
            _this.SUBRULE(_this.block, {
              ARGS: [{
                componentType: type.image
              }]
            });
          });
          _this.comment = _this.RULE("comment", function() {
            _this.CONSUME(Comment, {
              LABEL: "text"
            });
          });
          _this.schema = _this.RULE("schema", function() {
            _this.MANY(function() {
              _this.OR([{
                ALT: function ALT() {
                  return _this.SUBRULE(_this.comment, {
                    LABEL: "list"
                  });
                }
              }, {
                ALT: function ALT() {
                  return _this.SUBRULE(_this.component, {
                    LABEL: "list"
                  });
                }
              }, {
                ALT: function ALT() {
                  return _this.SUBRULE(_this["break"], {
                    LABEL: "list"
                  });
                }
              }, {
                ALT: function ALT() {
                  return _this.CONSUME(LineBreak);
                }
              }]);
            });
          });
          _this.performSelfAnalysis();
          return _this;
        }
        return PrismaParser2;
      }(chevrotain.CstParser);
      var parser = /* @__PURE__ */ new PrismaParser();
      var BasePrismaVisitor = /* @__PURE__ */ parser.getBaseCstVisitorConstructorWithDefaults();
      var PrismaVisitor = /* @__PURE__ */ function(_BasePrismaVisitor) {
        _inheritsLoose(PrismaVisitor2, _BasePrismaVisitor);
        function PrismaVisitor2() {
          var _this;
          _this = _BasePrismaVisitor.call(this) || this;
          _this.validateVisitor();
          return _this;
        }
        var _proto = PrismaVisitor2.prototype;
        _proto.schema = function schema(ctx) {
          var _ctx$list, _this2 = this;
          var list = ((_ctx$list = ctx.list) == null ? void 0 : _ctx$list.map(function(item) {
            return _this2.visit([item]);
          })) || [];
          return {
            type: "schema",
            list
          };
        };
        _proto.component = function component(ctx) {
          var _ctx$type = ctx.type, type = _ctx$type[0].image;
          var _ctx$componentName = ctx.componentName, name = _ctx$componentName[0].image;
          var list = this.visit(ctx.block);
          switch (type) {
            case "datasource":
              return {
                type: "datasource",
                name,
                assignments: list
              };
            case "generator":
              return {
                type: "generator",
                name,
                assignments: list
              };
            case "model":
              return {
                type: "model",
                name,
                properties: list
              };
            case "enum":
              return {
                type: "enum",
                name,
                enumerators: list
              };
            default:
              throw new Error("Unexpected block type: " + type);
          }
        };
        _proto["break"] = function _break() {
          return {
            type: "break"
          };
        };
        _proto.comment = function comment(ctx) {
          var _ctx$text = ctx.text, comment2 = _ctx$text[0].image;
          return {
            type: "comment",
            text: comment2
          };
        };
        _proto.block = function block(ctx) {
          var _ctx$list2, _this3 = this;
          return (_ctx$list2 = ctx.list) == null ? void 0 : _ctx$list2.map(function(item) {
            return _this3.visit([item]);
          });
        };
        _proto.assignment = function assignment(ctx) {
          var value = this.visit(ctx.assignmentValue);
          var _ctx$assignmentName = ctx.assignmentName, key = _ctx$assignmentName[0].image;
          return {
            type: "assignment",
            key,
            value
          };
        };
        _proto.field = function field(ctx) {
          var _this4 = this, _ctx$comment, _ctx$comment$;
          var fieldType = this.visit(ctx.fieldType);
          var _ctx$fieldName = ctx.fieldName, name = _ctx$fieldName[0].image;
          var attributes = ctx.attributeList && ctx.attributeList.map(function(item) {
            return _this4.visit([item]);
          });
          var comment = (_ctx$comment = ctx.comment) == null ? void 0 : (_ctx$comment$ = _ctx$comment[0]) == null ? void 0 : _ctx$comment$.image;
          return {
            type: "field",
            name,
            fieldType,
            array: ctx.array != null,
            optional: ctx.optional != null,
            attributes,
            comment
          };
        };
        _proto.attribute = function attribute(ctx) {
          var _this5 = this;
          var _ctx$attributeName = ctx.attributeName, name = _ctx$attributeName[0].image;
          var _ref = ctx.groupName || [{}], group = _ref[0].image;
          var args2 = ctx.attributeArg && ctx.attributeArg.map(function(attr) {
            return _this5.visit(attr);
          });
          var kind = ctx.modelAttribute != null ? "model" : "field";
          return {
            type: "attribute",
            name,
            kind,
            group,
            args: args2
          };
        };
        _proto.attributeArg = function attributeArg(ctx) {
          var value = this.visit(ctx.value);
          return {
            type: "attributeArgument",
            value
          };
        };
        _proto.func = function func(ctx) {
          var _this6 = this;
          var _ctx$funcName = ctx.funcName, name = _ctx$funcName[0].image;
          var params = ctx.value && ctx.value.map(function(item) {
            return _this6.visit([item]);
          });
          var keyedParams = ctx.keyedArg && ctx.keyedArg.map(function(item) {
            return _this6.visit([item]);
          });
          var pars = (params || keyedParams) && [].concat(params != null ? params : [], keyedParams != null ? keyedParams : []);
          return {
            type: "function",
            name,
            params: pars
          };
        };
        _proto.array = function array(ctx) {
          var _this7 = this;
          var args2 = ctx.value && ctx.value.map(function(item) {
            return _this7.visit([item]);
          });
          return {
            type: "array",
            args: args2
          };
        };
        _proto.keyedArg = function keyedArg(ctx) {
          var _ctx$keyName = ctx.keyName, key = _ctx$keyName[0].image;
          var value = this.visit(ctx.value);
          return {
            type: "keyValue",
            key,
            value
          };
        };
        _proto.value = function value(ctx) {
          if (isToken(ctx.value)) {
            var _ctx$value = ctx.value, image = _ctx$value[0].image;
            return image;
          }
          return this.visit(ctx.value);
        };
        _proto["enum"] = function _enum(ctx) {
          var _ctx$comment2, _ctx$comment2$;
          var _ctx$enumName = ctx.enumName, name = _ctx$enumName[0].image;
          var comment = (_ctx$comment2 = ctx.comment) == null ? void 0 : (_ctx$comment2$ = _ctx$comment2[0]) == null ? void 0 : _ctx$comment2$.image;
          return {
            type: "enumerator",
            name,
            comment
          };
        };
        return PrismaVisitor2;
      }(BasePrismaVisitor);
      function isToken(node) {
        return "image" in node[0];
      }
      function getSchema3(source) {
        var lexingResult = PrismaLexer.tokenize(source);
        parser.input = lexingResult.tokens;
        var cstNode = parser.schema();
        if (parser.errors.length > 0)
          throw parser.errors[0];
        var visitor = new PrismaVisitor();
        return visitor.visit(cstNode);
      }
      var unsorted = ["break", "comment"];
      var defaultSortOrder = ["generator", "datasource", "model", "enum", "break", "comment"];
      var schemaSorter = function schemaSorter2(schema, locales, sortOrder) {
        if (sortOrder === void 0) {
          sortOrder = defaultSortOrder;
        }
        return function(a, b) {
          var aUnsorted = unsorted.indexOf(a.type) !== -1;
          var bUnsorted = unsorted.indexOf(b.type) !== -1;
          if (aUnsorted !== bUnsorted) {
            return schema.list.indexOf(a) - schema.list.indexOf(b);
          }
          if (sortOrder !== defaultSortOrder)
            sortOrder = sortOrder.concat(defaultSortOrder);
          var typeIndex = sortOrder.indexOf(a.type) - sortOrder.indexOf(b.type);
          if (typeIndex !== 0)
            return typeIndex;
          if ("name" in a && "name" in b)
            return a.name.localeCompare(b.name, locales);
          return 0;
        };
      };
      function printSchema2(schema, options) {
        if (options === void 0) {
          options = {};
        }
        var _options = options, _options$sort = _options.sort, sort = _options$sort === void 0 ? false : _options$sort, _options$locales = _options.locales, locales = _options$locales === void 0 ? void 0 : _options$locales, _options$sortOrder = _options.sortOrder, sortOrder = _options$sortOrder === void 0 ? void 0 : _options$sortOrder;
        var blocks = schema.list;
        if (sort) {
          blocks = schema.list = blocks.filter(function(block) {
            return block.type !== "break";
          });
          var sorter = schemaSorter(schema, locales, sortOrder);
          blocks.sort(sorter);
        }
        return blocks.map(printBlock).filter(Boolean).join(os5.EOL).replace(/(\r?\n\s*){3,}/g, os5.EOL + os5.EOL) + os5.EOL;
      }
      function printBlock(block) {
        switch (block.type) {
          case "comment":
            return printComment(block);
          case "datasource":
            return printDatasource(block);
          case "enum":
            return printEnum(block);
          case "generator":
            return printGenerator(block);
          case "model":
            return printModel(block);
          case "break":
            return printBreak();
          default:
            throw new Error("Unrecognized block type");
        }
      }
      function printComment(comment) {
        return comment.text;
      }
      function printBreak() {
        return os5.EOL;
      }
      function printDatasource(db) {
        var children = computeAssignmentFormatting(db.assignments);
        return "\ndatasource " + db.name + " {\n  " + children + "\n}";
      }
      function printEnum(enumerator) {
        var children = enumerator.enumerators.map(printEnumerator).filter(Boolean).join(os5.EOL + "  ").replace(/(\r?\n\s*){3,}/g, os5.EOL + os5.EOL + "  ");
        return "\nenum " + enumerator.name + " {\n  " + children + "\n}";
      }
      function printEnumerator(enumerator) {
        switch (enumerator.type) {
          case "enumerator":
            return [enumerator.name, enumerator.comment].filter(Boolean).join(" ");
          case "attribute":
            return printAttribute(enumerator);
          case "comment":
            return printComment(enumerator);
          case "break":
            return printBreak();
          default:
            throw new Error("Unexpected enumerator type");
        }
      }
      function printGenerator(generator) {
        var children = computeAssignmentFormatting(generator.assignments);
        return "\ngenerator " + generator.name + " {\n  " + children + "\n}";
      }
      function printModel(model) {
        var children = computePropertyFormatting(model.properties);
        return "\nmodel " + model.name + " {\n  " + children + "\n}";
      }
      function printAssignment(node, keyLength) {
        if (keyLength === void 0) {
          keyLength = 0;
        }
        switch (node.type) {
          case "comment":
            return printComment(node);
          case "break":
            return printBreak();
          case "assignment":
            return node.key.padEnd(keyLength) + " = " + printValue(node.value);
          default:
            throw new Error("Unexpected assignment type");
        }
      }
      function printProperty(node, nameLength, typeLength) {
        if (nameLength === void 0) {
          nameLength = 0;
        }
        if (typeLength === void 0) {
          typeLength = 0;
        }
        switch (node.type) {
          case "attribute":
            return printAttribute(node);
          case "field":
            return printField(node, nameLength, typeLength);
          case "comment":
            return printComment(node);
          case "break":
            return printBreak();
          default:
            throw new Error("Unrecognized property type");
        }
      }
      function printAttribute(attribute) {
        var args2 = attribute.args && attribute.args.length > 0 ? "(" + attribute.args.map(printAttributeArg).filter(Boolean).join(", ") + ")" : "";
        var name = [attribute.name];
        if (attribute.group)
          name.unshift(attribute.group);
        return (attribute.kind === "field" ? "@" : "@@") + name.join(".") + args2;
      }
      function printAttributeArg(arg) {
        return printValue(arg.value);
      }
      function printField(field, nameLength, typeLength) {
        if (nameLength === void 0) {
          nameLength = 0;
        }
        if (typeLength === void 0) {
          typeLength = 0;
        }
        var name = field.name.padEnd(nameLength);
        var fieldType = printFieldType(field).padEnd(typeLength);
        var attrs = field.attributes ? field.attributes.map(printAttribute) : [];
        var comment = field.comment;
        return [name, fieldType].concat(attrs).filter(Boolean).join(" ").trim() + (comment ? " " + comment : "");
      }
      function printFieldType(field) {
        var suffix = field.array ? "[]" : field.optional ? "?" : "";
        if (typeof field.fieldType === "object") {
          switch (field.fieldType.type) {
            case "function": {
              return "" + printFunction(field.fieldType) + suffix;
            }
            default:
              throw new Error("Unexpected field type");
          }
        }
        return "" + field.fieldType + suffix;
      }
      function printFunction(func) {
        var params = func.params ? func.params.map(printValue) : "";
        return func.name + "(" + params + ")";
      }
      function printValue(value) {
        switch (typeof value) {
          case "object": {
            if ("type" in value) {
              switch (value.type) {
                case "keyValue":
                  return value.key + ": " + printValue(value.value);
                case "function":
                  return printFunction(value);
                case "array":
                  return "[" + (value.args != null ? value.args.map(printValue).join(", ") : "") + "]";
                default:
                  throw new Error("Unexpected value type");
              }
            }
            throw new Error("Unexpected object value");
          }
          default:
            return String(value);
        }
      }
      function computeAssignmentFormatting(list) {
        var pos = 0;
        var listBlocks = list.reduce(function(memo, current, index, arr) {
          if (current.type === "break")
            return memo;
          if (index > 0 && arr[index - 1].type === "break")
            memo[++pos] = [];
          memo[pos].push(current);
          return memo;
        }, [[]]);
        var keyLengths = listBlocks.map(function(lists) {
          return lists.reduce(function(max2, current) {
            return Math.max(max2, current.type === "assignment" ? current.key.length : 0);
          }, 0);
        });
        return list.map(function(item, index, arr) {
          if (index > 0 && item.type !== "break" && arr[index - 1].type === "break")
            keyLengths.shift();
          return printAssignment(item, keyLengths[0]);
        }).filter(Boolean).join(os5.EOL + "  ").replace(/(\r?\n\s*){3,}/g, os5.EOL + os5.EOL + "  ");
      }
      function computePropertyFormatting(list) {
        var pos = 0;
        var listBlocks = list.reduce(function(memo, current, index, arr) {
          if (current.type === "break")
            return memo;
          if (index > 0 && arr[index - 1].type === "break")
            memo[++pos] = [];
          memo[pos].push(current);
          return memo;
        }, [[]]);
        var nameLengths = listBlocks.map(function(lists) {
          return lists.reduce(function(max2, current) {
            return Math.max(max2, current.type === "field" ? current.name.length : 0);
          }, 0);
        });
        var typeLengths = listBlocks.map(function(lists) {
          return lists.reduce(function(max2, current) {
            return Math.max(max2, current.type === "field" ? printFieldType(current).length : 0);
          }, 0);
        });
        return list.map(function(prop, index, arr) {
          if (index > 0 && prop.type !== "break" && arr[index - 1].type === "break") {
            nameLengths.shift();
            typeLengths.shift();
          }
          return printProperty(prop, nameLengths[0], typeLengths[0]);
        }).filter(Boolean).join(os5.EOL + "  ").replace(/(\r?\n\s*){3,}/g, os5.EOL + os5.EOL + "  ");
      }
      var ConcretePrismaSchemaBuilder = /* @__PURE__ */ function() {
        function ConcretePrismaSchemaBuilder2(source) {
          if (source === void 0) {
            source = "";
          }
          this.schema = getSchema3(source);
        }
        var _proto = ConcretePrismaSchemaBuilder2.prototype;
        _proto.print = function print(options) {
          if (options === void 0) {
            options = {};
          }
          return printSchema2(this.schema, options);
        };
        _proto.getSchema = function getSchema4() {
          return this.schema;
        };
        _proto.generator = function generator(name, provider) {
          if (provider === void 0) {
            provider = "prisma-client-js";
          }
          var generator2 = this.schema.list.reduce(function(memo, block) {
            return block.type === "generator" && block.name === name ? block : memo;
          }, {
            type: "generator",
            name,
            assignments: [{
              type: "assignment",
              key: "provider",
              value: '"' + provider + '"'
            }]
          });
          if (!this.schema.list.includes(generator2))
            this.schema.list.push(generator2);
          this._subject = generator2;
          return this;
        };
        _proto.drop = function drop(name) {
          var index = this.schema.list.findIndex(function(block) {
            return "name" in block && block.name === name;
          });
          this.schema.list.splice(index, 1);
          return this;
        };
        _proto.datasource = function datasource(provider, url2) {
          var datasource2 = {
            type: "datasource",
            name: "db",
            assignments: [{
              type: "assignment",
              key: "url",
              value: typeof url2 === "string" ? '"' + url2 + '"' : {
                type: "function",
                name: "env",
                params: ['"' + url2.env + '"']
              }
            }, {
              type: "assignment",
              key: "provider",
              value: provider
            }]
          };
          var existingIndex = this.schema.list.findIndex(function(block) {
            return block.type === "datasource";
          });
          this.schema.list.splice(existingIndex, existingIndex !== -1 ? 1 : 0, datasource2);
          this._subject = datasource2;
          return this;
        };
        _proto.model = function model(name) {
          var model2 = this.schema.list.reduce(function(memo, block) {
            return block.type === "model" && block.name === name ? block : memo;
          }, {
            type: "model",
            name,
            properties: []
          });
          if (!this.schema.list.includes(model2))
            this.schema.list.push(model2);
          this._subject = model2;
          return this;
        };
        _proto["enum"] = function _enum(name, enumeratorNames) {
          if (enumeratorNames === void 0) {
            enumeratorNames = [];
          }
          var e = this.schema.list.reduce(function(memo, block) {
            return block.type === "enum" && block.name === name ? block : memo;
          }, {
            type: "enum",
            name,
            enumerators: enumeratorNames.map(function(name2) {
              return {
                type: "enumerator",
                name: name2
              };
            })
          });
          if (!this.schema.list.includes(e))
            this.schema.list.push(e);
          this._subject = e;
          return this;
        };
        _proto.enumerator = function enumerator(value) {
          var subject = this.getSubject();
          if (!subject || !("type" in subject) || subject.type !== "enum") {
            throw new Error("Subject must be a prisma model!");
          }
          subject.enumerators.push({
            type: "enumerator",
            name: value
          });
          return this;
        };
        _proto.getSubject = function getSubject() {
          return this._subject;
        };
        _proto.getParent = function getParent() {
          return this._parent;
        };
        _proto.blockAttribute = function blockAttribute(name, args2) {
          var subject = this.getSubject();
          if (!subject || !("type" in subject) || subject.type !== "model") {
            var parent = this.getParent();
            if (!parent || !("type" in parent) || parent.type !== "model")
              throw new Error("Subject must be a prisma model!");
            subject = this._subject = parent;
          }
          var attributeArgs = function() {
            if (!args2)
              return [];
            if (typeof args2 === "string")
              return [{
                type: "attributeArgument",
                value: '"' + args2 + '"'
              }];
            if (Array.isArray(args2))
              return [{
                type: "attributeArgument",
                value: {
                  type: "array",
                  args: args2
                }
              }];
            return Object.entries(args2).map(function(_ref) {
              var key = _ref[0], value = _ref[1];
              return {
                type: "attributeArgument",
                value: {
                  type: "keyValue",
                  key,
                  value
                }
              };
            });
          }();
          var property = {
            type: "attribute",
            kind: "model",
            name,
            args: attributeArgs
          };
          subject.properties.push(property);
          return this;
        };
        _proto.attribute = function attribute(name, args2) {
          var parent = this.getParent();
          var subject = this.getSubject();
          if (!parent || !("type" in parent) || parent.type !== "model") {
            throw new Error("Parent must be a prisma model!");
          }
          if (!subject || !("type" in subject) || subject.type !== "field") {
            throw new Error("Subject must be a prisma field!");
          }
          if (!subject.attributes)
            subject.attributes = [];
          var attribute2 = subject.attributes.reduce(function(memo, attr) {
            return attr.type === "attribute" && attr.name === name ? attr : memo;
          }, {
            type: "attribute",
            kind: "field",
            name
          });
          if (Array.isArray(args2)) {
            var mapArg = function mapArg2(arg) {
              var _arg$function$map, _arg$function;
              return typeof arg === "string" ? arg : {
                type: "function",
                name: arg.name,
                params: (_arg$function$map = (_arg$function = arg["function"]) == null ? void 0 : _arg$function.map(mapArg2)) != null ? _arg$function$map : []
              };
            };
            if (args2.length > 0)
              attribute2.args = args2.map(function(arg) {
                return {
                  type: "attributeArgument",
                  value: mapArg(arg)
                };
              });
          } else if (typeof args2 === "object") {
            attribute2.args = Object.entries(args2).map(function(_ref2) {
              var key = _ref2[0], value = _ref2[1];
              return {
                type: "attributeArgument",
                value: {
                  type: "keyValue",
                  key,
                  value: {
                    type: "array",
                    args: value
                  }
                }
              };
            });
          }
          if (!subject.attributes.includes(attribute2))
            subject.attributes.push(attribute2);
          return this;
        };
        _proto.removeAttribute = function removeAttribute(name) {
          var parent = this.getParent();
          var subject = this.getSubject();
          if (!parent || !("type" in parent) || parent.type !== "model") {
            throw new Error("Parent must be a prisma model!");
          }
          if (!subject || !("type" in subject) || subject.type !== "field") {
            throw new Error("Subject must be a prisma field!");
          }
          if (!subject.attributes)
            subject.attributes = [];
          subject.attributes = subject.attributes.filter(function(attr) {
            return !(attr.type === "attribute" && attr.name === name);
          });
          return this;
        };
        _proto.assignment = function assignment(key, value) {
          var subject = this.getSubject();
          if (!subject || !("type" in subject) || !["generator", "datasource"].includes(subject.type))
            throw new Error("Subject must be a prisma generator or datasource!");
          function tap(subject2, callback) {
            callback(subject2);
            return subject2;
          }
          var assignment2 = subject.assignments.reduce(function(memo, assignment3) {
            return assignment3.type === "assignment" && assignment3.key === key ? tap(assignment3, function(a) {
              a.value = '"' + value + '"';
            }) : memo;
          }, {
            type: "assignment",
            key,
            value: '"' + value + '"'
          });
          if (!subject.assignments.includes(assignment2))
            subject.assignments.push(assignment2);
          return this;
        };
        _proto.blockInsert = function blockInsert(statement) {
          var subject = this.getSubject();
          var allowed = ["datasource", "enum", "generator", "model"];
          if (!subject || !("type" in subject) || !allowed.includes(subject.type)) {
            var parent = this.getParent();
            if (!parent || !("type" in parent) || !allowed.includes(parent.type)) {
              throw new Error("Subject must be a prisma block!");
            }
            subject = this._subject = parent;
          }
          switch (subject.type) {
            case "datasource": {
              subject.assignments.push(statement);
              break;
            }
            case "enum": {
              subject.enumerators.push(statement);
              break;
            }
            case "generator": {
              subject.assignments.push(statement);
              break;
            }
            case "model": {
              subject.properties.push(statement);
              break;
            }
          }
          return this;
        };
        _proto["break"] = function _break() {
          var lineBreak = {
            type: "break"
          };
          return this.blockInsert(lineBreak);
        };
        _proto.comment = function comment(text, node) {
          if (node === void 0) {
            node = false;
          }
          var comment2 = {
            type: "comment",
            text: "//" + (node ? "/" : "") + " " + text
          };
          return this.blockInsert(comment2);
        };
        _proto.schemaComment = function schemaComment(text, node) {
          if (node === void 0) {
            node = false;
          }
          var comment = {
            type: "comment",
            text: "//" + (node ? "/" : "") + " " + text
          };
          this.schema.list.push(comment);
          return this;
        };
        _proto.field = function field(name, fieldType) {
          if (fieldType === void 0) {
            fieldType = "String";
          }
          var subject = this.getSubject();
          if (!subject || !("type" in subject) || subject.type !== "model") {
            var parent = this.getParent();
            if (!parent || !("type" in parent) || parent.type !== "model")
              throw new Error("Subject must be a prisma model!");
            subject = this._subject = parent;
          }
          var field2 = subject.properties.reduce(function(memo, block) {
            return block.type === "field" && block.name === name ? block : memo;
          }, {
            type: "field",
            name,
            fieldType
          });
          if (!subject.properties.includes(field2))
            subject.properties.push(field2);
          this._parent = subject;
          this._subject = field2;
          return this;
        };
        _proto.removeField = function removeField(name) {
          var subject = this.getSubject();
          if (!subject || !("type" in subject) || subject.type !== "model") {
            var parent = this.getParent();
            if (!parent || !("type" in parent) || parent.type !== "model")
              throw new Error("Subject must be a prisma model!");
            subject = this._subject = parent;
          }
          subject.properties = subject.properties.filter(function(field) {
            return !(field.type === "field" && field.name === name);
          });
          return this;
        };
        _proto.then = function then(callback) {
          callback(this._subject);
          return this;
        };
        return ConcretePrismaSchemaBuilder2;
      }();
      function createPrismaSchemaBuilder(source) {
        return new ConcretePrismaSchemaBuilder(source);
      }
      exports2.ConcretePrismaSchemaBuilder = ConcretePrismaSchemaBuilder;
      exports2.createPrismaSchemaBuilder = createPrismaSchemaBuilder;
      exports2.getSchema = getSchema3;
      exports2.printSchema = printSchema2;
    }
  });

  // node_modules/.pnpm/@mrleebo+prisma-ast@0.5.1/node_modules/@mrleebo/prisma-ast/dist/index.js
  var require_dist2 = __commonJS({
    "node_modules/.pnpm/@mrleebo+prisma-ast@0.5.1/node_modules/@mrleebo/prisma-ast/dist/index.js"(exports2, module2) {
      "use strict";
      if (process.env.NODE_ENV === "production") {
        module2.exports = require_prisma_ast_cjs_production_min();
      } else {
        module2.exports = require_prisma_ast_cjs_development();
      }
    }
  });

  // app/build.ts
  var build_exports = {};
  __export(build_exports, {
    build: () => build
  });
  var import_fs_jetpack17, build;
  var init_build = __esm({
    "app/build.ts"() {
      "use strict";
      init_export();
      import_fs_jetpack17 = __toESM(require_main());
      build = async () => {
        if (!await (0, import_fs_jetpack17.existsAsync)(dir.root(".output/app/stencil"))) {
          await (0, import_fs_jetpack17.copyAsync)(dir.root("stencil"), dir.root(".output/app/stencil"), {
            overwrite: true
          });
        }
      };
    }
  });

  // node_modules/.pnpm/isexe@2.0.0/node_modules/isexe/windows.js
  var require_windows = __commonJS({
    "node_modules/.pnpm/isexe@2.0.0/node_modules/isexe/windows.js"(exports2, module2) {
      module2.exports = isexe;
      isexe.sync = sync;
      var fs2 = __require("fs");
      function checkPathExt(path4, options) {
        var pathext = options.pathExt !== void 0 ? options.pathExt : process.env.PATHEXT;
        if (!pathext) {
          return true;
        }
        pathext = pathext.split(";");
        if (pathext.indexOf("") !== -1) {
          return true;
        }
        for (var i = 0; i < pathext.length; i++) {
          var p = pathext[i].toLowerCase();
          if (p && path4.substr(-p.length).toLowerCase() === p) {
            return true;
          }
        }
        return false;
      }
      function checkStat(stat6, path4, options) {
        if (!stat6.isSymbolicLink() && !stat6.isFile()) {
          return false;
        }
        return checkPathExt(path4, options);
      }
      function isexe(path4, options, cb) {
        fs2.stat(path4, function(er, stat6) {
          cb(er, er ? false : checkStat(stat6, path4, options));
        });
      }
      function sync(path4, options) {
        return checkStat(fs2.statSync(path4), path4, options);
      }
    }
  });

  // node_modules/.pnpm/isexe@2.0.0/node_modules/isexe/mode.js
  var require_mode2 = __commonJS({
    "node_modules/.pnpm/isexe@2.0.0/node_modules/isexe/mode.js"(exports2, module2) {
      module2.exports = isexe;
      isexe.sync = sync;
      var fs2 = __require("fs");
      function isexe(path4, options, cb) {
        fs2.stat(path4, function(er, stat6) {
          cb(er, er ? false : checkStat(stat6, options));
        });
      }
      function sync(path4, options) {
        return checkStat(fs2.statSync(path4), options);
      }
      function checkStat(stat6, options) {
        return stat6.isFile() && checkMode(stat6, options);
      }
      function checkMode(stat6, options) {
        var mod = stat6.mode;
        var uid = stat6.uid;
        var gid = stat6.gid;
        var myUid = options.uid !== void 0 ? options.uid : process.getuid && process.getuid();
        var myGid = options.gid !== void 0 ? options.gid : process.getgid && process.getgid();
        var u = parseInt("100", 8);
        var g4 = parseInt("010", 8);
        var o = parseInt("001", 8);
        var ug = u | g4;
        var ret = mod & o || mod & g4 && gid === myGid || mod & u && uid === myUid || mod & ug && myUid === 0;
        return ret;
      }
    }
  });

  // node_modules/.pnpm/isexe@2.0.0/node_modules/isexe/index.js
  var require_isexe = __commonJS({
    "node_modules/.pnpm/isexe@2.0.0/node_modules/isexe/index.js"(exports2, module2) {
      var fs2 = __require("fs");
      var core;
      if (process.platform === "win32" || global.TESTING_WINDOWS) {
        core = require_windows();
      } else {
        core = require_mode2();
      }
      module2.exports = isexe;
      isexe.sync = sync;
      function isexe(path4, options, cb) {
        if (typeof options === "function") {
          cb = options;
          options = {};
        }
        if (!cb) {
          if (typeof Promise !== "function") {
            throw new TypeError("callback not provided");
          }
          return new Promise(function(resolve, reject) {
            isexe(path4, options || {}, function(er, is) {
              if (er) {
                reject(er);
              } else {
                resolve(is);
              }
            });
          });
        }
        core(path4, options || {}, function(er, is) {
          if (er) {
            if (er.code === "EACCES" || options && options.ignoreErrors) {
              er = null;
              is = false;
            }
          }
          cb(er, is);
        });
      }
      function sync(path4, options) {
        try {
          return core.sync(path4, options || {});
        } catch (er) {
          if (options && options.ignoreErrors || er.code === "EACCES") {
            return false;
          } else {
            throw er;
          }
        }
      }
    }
  });

  // node_modules/.pnpm/which@2.0.2/node_modules/which/which.js
  var require_which = __commonJS({
    "node_modules/.pnpm/which@2.0.2/node_modules/which/which.js"(exports2, module2) {
      var isWindows = process.platform === "win32" || process.env.OSTYPE === "cygwin" || process.env.OSTYPE === "msys";
      var path4 = __require("path");
      var COLON = isWindows ? ";" : ":";
      var isexe = require_isexe();
      var getNotFoundError = (cmd) => Object.assign(new Error(`not found: ${cmd}`), { code: "ENOENT" });
      var getPathInfo = (cmd, opt) => {
        const colon = opt.colon || COLON;
        const pathEnv = cmd.match(/\//) || isWindows && cmd.match(/\\/) ? [""] : [
          // windows always checks the cwd first
          ...isWindows ? [process.cwd()] : [],
          ...(opt.path || process.env.PATH || /* istanbul ignore next: very unusual */
          "").split(colon)
        ];
        const pathExtExe = isWindows ? opt.pathExt || process.env.PATHEXT || ".EXE;.CMD;.BAT;.COM" : "";
        const pathExt = isWindows ? pathExtExe.split(colon) : [""];
        if (isWindows) {
          if (cmd.indexOf(".") !== -1 && pathExt[0] !== "")
            pathExt.unshift("");
        }
        return {
          pathEnv,
          pathExt,
          pathExtExe
        };
      };
      var which = (cmd, opt, cb) => {
        if (typeof opt === "function") {
          cb = opt;
          opt = {};
        }
        if (!opt)
          opt = {};
        const { pathEnv, pathExt, pathExtExe } = getPathInfo(cmd, opt);
        const found = [];
        const step = (i) => new Promise((resolve, reject) => {
          if (i === pathEnv.length)
            return opt.all && found.length ? resolve(found) : reject(getNotFoundError(cmd));
          const ppRaw = pathEnv[i];
          const pathPart = /^".*"$/.test(ppRaw) ? ppRaw.slice(1, -1) : ppRaw;
          const pCmd = path4.join(pathPart, cmd);
          const p = !pathPart && /^\.[\\\/]/.test(cmd) ? cmd.slice(0, 2) + pCmd : pCmd;
          resolve(subStep(p, i, 0));
        });
        const subStep = (p, i, ii) => new Promise((resolve, reject) => {
          if (ii === pathExt.length)
            return resolve(step(i + 1));
          const ext = pathExt[ii];
          isexe(p + ext, { pathExt: pathExtExe }, (er, is) => {
            if (!er && is) {
              if (opt.all)
                found.push(p + ext);
              else
                return resolve(p + ext);
            }
            return resolve(subStep(p, i, ii + 1));
          });
        });
        return cb ? step(0).then((res) => cb(null, res), cb) : step(0);
      };
      var whichSync = (cmd, opt) => {
        opt = opt || {};
        const { pathEnv, pathExt, pathExtExe } = getPathInfo(cmd, opt);
        const found = [];
        for (let i = 0; i < pathEnv.length; i++) {
          const ppRaw = pathEnv[i];
          const pathPart = /^".*"$/.test(ppRaw) ? ppRaw.slice(1, -1) : ppRaw;
          const pCmd = path4.join(pathPart, cmd);
          const p = !pathPart && /^\.[\\\/]/.test(cmd) ? cmd.slice(0, 2) + pCmd : pCmd;
          for (let j = 0; j < pathExt.length; j++) {
            const cur = p + pathExt[j];
            try {
              const is = isexe.sync(cur, { pathExt: pathExtExe });
              if (is) {
                if (opt.all)
                  found.push(cur);
                else
                  return cur;
              }
            } catch (ex) {
            }
          }
        }
        if (opt.all && found.length)
          return found;
        if (opt.nothrow)
          return null;
        throw getNotFoundError(cmd);
      };
      module2.exports = which;
      which.sync = whichSync;
    }
  });

  // node_modules/.pnpm/path-key@3.1.1/node_modules/path-key/index.js
  var require_path_key = __commonJS({
    "node_modules/.pnpm/path-key@3.1.1/node_modules/path-key/index.js"(exports2, module2) {
      "use strict";
      var pathKey2 = (options = {}) => {
        const environment = options.env || process.env;
        const platform = options.platform || process.platform;
        if (platform !== "win32") {
          return "PATH";
        }
        return Object.keys(environment).reverse().find((key) => key.toUpperCase() === "PATH") || "Path";
      };
      module2.exports = pathKey2;
      module2.exports.default = pathKey2;
    }
  });

  // node_modules/.pnpm/cross-spawn@7.0.3/node_modules/cross-spawn/lib/util/resolveCommand.js
  var require_resolveCommand = __commonJS({
    "node_modules/.pnpm/cross-spawn@7.0.3/node_modules/cross-spawn/lib/util/resolveCommand.js"(exports2, module2) {
      "use strict";
      var path4 = __require("path");
      var which = require_which();
      var getPathKey = require_path_key();
      function resolveCommandAttempt(parsed, withoutPathExt) {
        const env3 = parsed.options.env || process.env;
        const cwd2 = process.cwd();
        const hasCustomCwd = parsed.options.cwd != null;
        const shouldSwitchCwd = hasCustomCwd && process.chdir !== void 0 && !process.chdir.disabled;
        if (shouldSwitchCwd) {
          try {
            process.chdir(parsed.options.cwd);
          } catch (err2) {
          }
        }
        let resolved;
        try {
          resolved = which.sync(parsed.command, {
            path: env3[getPathKey({ env: env3 })],
            pathExt: withoutPathExt ? path4.delimiter : void 0
          });
        } catch (e) {
        } finally {
          if (shouldSwitchCwd) {
            process.chdir(cwd2);
          }
        }
        if (resolved) {
          resolved = path4.resolve(hasCustomCwd ? parsed.options.cwd : "", resolved);
        }
        return resolved;
      }
      function resolveCommand(parsed) {
        return resolveCommandAttempt(parsed) || resolveCommandAttempt(parsed, true);
      }
      module2.exports = resolveCommand;
    }
  });

  // node_modules/.pnpm/cross-spawn@7.0.3/node_modules/cross-spawn/lib/util/escape.js
  var require_escape = __commonJS({
    "node_modules/.pnpm/cross-spawn@7.0.3/node_modules/cross-spawn/lib/util/escape.js"(exports2, module2) {
      "use strict";
      var metaCharsRegExp = /([()\][%!^"`<>&|;, *?])/g;
      function escapeCommand(arg) {
        arg = arg.replace(metaCharsRegExp, "^$1");
        return arg;
      }
      function escapeArgument(arg, doubleEscapeMetaChars) {
        arg = `${arg}`;
        arg = arg.replace(/(\\*)"/g, '$1$1\\"');
        arg = arg.replace(/(\\*)$/, "$1$1");
        arg = `"${arg}"`;
        arg = arg.replace(metaCharsRegExp, "^$1");
        if (doubleEscapeMetaChars) {
          arg = arg.replace(metaCharsRegExp, "^$1");
        }
        return arg;
      }
      module2.exports.command = escapeCommand;
      module2.exports.argument = escapeArgument;
    }
  });

  // node_modules/.pnpm/shebang-regex@3.0.0/node_modules/shebang-regex/index.js
  var require_shebang_regex = __commonJS({
    "node_modules/.pnpm/shebang-regex@3.0.0/node_modules/shebang-regex/index.js"(exports2, module2) {
      "use strict";
      module2.exports = /^#!(.*)/;
    }
  });

  // node_modules/.pnpm/shebang-command@2.0.0/node_modules/shebang-command/index.js
  var require_shebang_command = __commonJS({
    "node_modules/.pnpm/shebang-command@2.0.0/node_modules/shebang-command/index.js"(exports2, module2) {
      "use strict";
      var shebangRegex = require_shebang_regex();
      module2.exports = (string = "") => {
        const match = string.match(shebangRegex);
        if (!match) {
          return null;
        }
        const [path4, argument] = match[0].replace(/#! ?/, "").split(" ");
        const binary = path4.split("/").pop();
        if (binary === "env") {
          return argument;
        }
        return argument ? `${binary} ${argument}` : binary;
      };
    }
  });

  // node_modules/.pnpm/cross-spawn@7.0.3/node_modules/cross-spawn/lib/util/readShebang.js
  var require_readShebang = __commonJS({
    "node_modules/.pnpm/cross-spawn@7.0.3/node_modules/cross-spawn/lib/util/readShebang.js"(exports2, module2) {
      "use strict";
      var fs2 = __require("fs");
      var shebangCommand = require_shebang_command();
      function readShebang(command) {
        const size = 150;
        const buffer = Buffer.alloc(size);
        let fd2;
        try {
          fd2 = fs2.openSync(command, "r");
          fs2.readSync(fd2, buffer, 0, size, 0);
          fs2.closeSync(fd2);
        } catch (e) {
        }
        return shebangCommand(buffer.toString());
      }
      module2.exports = readShebang;
    }
  });

  // node_modules/.pnpm/cross-spawn@7.0.3/node_modules/cross-spawn/lib/parse.js
  var require_parse3 = __commonJS({
    "node_modules/.pnpm/cross-spawn@7.0.3/node_modules/cross-spawn/lib/parse.js"(exports2, module2) {
      "use strict";
      var path4 = __require("path");
      var resolveCommand = require_resolveCommand();
      var escape = require_escape();
      var readShebang = require_readShebang();
      var isWin = process.platform === "win32";
      var isExecutableRegExp = /\.(?:com|exe)$/i;
      var isCmdShimRegExp = /node_modules[\\/].bin[\\/][^\\/]+\.cmd$/i;
      function detectShebang(parsed) {
        parsed.file = resolveCommand(parsed);
        const shebang = parsed.file && readShebang(parsed.file);
        if (shebang) {
          parsed.args.unshift(parsed.file);
          parsed.command = shebang;
          return resolveCommand(parsed);
        }
        return parsed.file;
      }
      function parseNonShell(parsed) {
        if (!isWin) {
          return parsed;
        }
        const commandFile = detectShebang(parsed);
        const needsShell = !isExecutableRegExp.test(commandFile);
        if (parsed.options.forceShell || needsShell) {
          const needsDoubleEscapeMetaChars = isCmdShimRegExp.test(commandFile);
          parsed.command = path4.normalize(parsed.command);
          parsed.command = escape.command(parsed.command);
          parsed.args = parsed.args.map((arg) => escape.argument(arg, needsDoubleEscapeMetaChars));
          const shellCommand = [parsed.command].concat(parsed.args).join(" ");
          parsed.args = ["/d", "/s", "/c", `"${shellCommand}"`];
          parsed.command = process.env.comspec || "cmd.exe";
          parsed.options.windowsVerbatimArguments = true;
        }
        return parsed;
      }
      function parse4(command, args2, options) {
        if (args2 && !Array.isArray(args2)) {
          options = args2;
          args2 = null;
        }
        args2 = args2 ? args2.slice(0) : [];
        options = Object.assign({}, options);
        const parsed = {
          command,
          args: args2,
          options,
          file: void 0,
          original: {
            command,
            args: args2
          }
        };
        return options.shell ? parsed : parseNonShell(parsed);
      }
      module2.exports = parse4;
    }
  });

  // node_modules/.pnpm/cross-spawn@7.0.3/node_modules/cross-spawn/lib/enoent.js
  var require_enoent = __commonJS({
    "node_modules/.pnpm/cross-spawn@7.0.3/node_modules/cross-spawn/lib/enoent.js"(exports2, module2) {
      "use strict";
      var isWin = process.platform === "win32";
      function notFoundError(original, syscall) {
        return Object.assign(new Error(`${syscall} ${original.command} ENOENT`), {
          code: "ENOENT",
          errno: "ENOENT",
          syscall: `${syscall} ${original.command}`,
          path: original.command,
          spawnargs: original.args
        });
      }
      function hookChildProcess(cp, parsed) {
        if (!isWin) {
          return;
        }
        const originalEmit = cp.emit;
        cp.emit = function(name, arg1) {
          if (name === "exit") {
            const err2 = verifyENOENT(arg1, parsed, "spawn");
            if (err2) {
              return originalEmit.call(cp, "error", err2);
            }
          }
          return originalEmit.apply(cp, arguments);
        };
      }
      function verifyENOENT(status, parsed) {
        if (isWin && status === 1 && !parsed.file) {
          return notFoundError(parsed.original, "spawn");
        }
        return null;
      }
      function verifyENOENTSync(status, parsed) {
        if (isWin && status === 1 && !parsed.file) {
          return notFoundError(parsed.original, "spawnSync");
        }
        return null;
      }
      module2.exports = {
        hookChildProcess,
        verifyENOENT,
        verifyENOENTSync,
        notFoundError
      };
    }
  });

  // node_modules/.pnpm/cross-spawn@7.0.3/node_modules/cross-spawn/index.js
  var require_cross_spawn = __commonJS({
    "node_modules/.pnpm/cross-spawn@7.0.3/node_modules/cross-spawn/index.js"(exports2, module2) {
      "use strict";
      var cp = __require("child_process");
      var parse4 = require_parse3();
      var enoent = require_enoent();
      function spawn4(command, args2, options) {
        const parsed = parse4(command, args2, options);
        const spawned = cp.spawn(parsed.command, parsed.args, parsed.options);
        enoent.hookChildProcess(spawned, parsed);
        return spawned;
      }
      function spawnSync3(command, args2, options) {
        const parsed = parse4(command, args2, options);
        const result = cp.spawnSync(parsed.command, parsed.args, parsed.options);
        result.error = result.error || enoent.verifyENOENTSync(result.status, parsed);
        return result;
      }
      module2.exports = spawn4;
      module2.exports.spawn = spawn4;
      module2.exports.sync = spawnSync3;
      module2.exports._parse = parse4;
      module2.exports._enoent = enoent;
    }
  });

  // node_modules/.pnpm/signal-exit@3.0.7/node_modules/signal-exit/signals.js
  var require_signals2 = __commonJS({
    "node_modules/.pnpm/signal-exit@3.0.7/node_modules/signal-exit/signals.js"(exports2, module2) {
      module2.exports = [
        "SIGABRT",
        "SIGALRM",
        "SIGHUP",
        "SIGINT",
        "SIGTERM"
      ];
      if (process.platform !== "win32") {
        module2.exports.push(
          "SIGVTALRM",
          "SIGXCPU",
          "SIGXFSZ",
          "SIGUSR2",
          "SIGTRAP",
          "SIGSYS",
          "SIGQUIT",
          "SIGIOT"
          // should detect profiler and enable/disable accordingly.
          // see #21
          // 'SIGPROF'
        );
      }
      if (process.platform === "linux") {
        module2.exports.push(
          "SIGIO",
          "SIGPOLL",
          "SIGPWR",
          "SIGSTKFLT",
          "SIGUNUSED"
        );
      }
    }
  });

  // node_modules/.pnpm/signal-exit@3.0.7/node_modules/signal-exit/index.js
  var require_signal_exit = __commonJS({
    "node_modules/.pnpm/signal-exit@3.0.7/node_modules/signal-exit/index.js"(exports2, module2) {
      var process7 = global.process;
      var processOk = function(process8) {
        return process8 && typeof process8 === "object" && typeof process8.removeListener === "function" && typeof process8.emit === "function" && typeof process8.reallyExit === "function" && typeof process8.listeners === "function" && typeof process8.kill === "function" && typeof process8.pid === "number" && typeof process8.on === "function";
      };
      if (!processOk(process7)) {
        module2.exports = function() {
          return function() {
          };
        };
      } else {
        assert = __require("assert");
        signals = require_signals2();
        isWin = /^win/i.test(process7.platform);
        EE = __require("events");
        if (typeof EE !== "function") {
          EE = EE.EventEmitter;
        }
        if (process7.__signal_exit_emitter__) {
          emitter = process7.__signal_exit_emitter__;
        } else {
          emitter = process7.__signal_exit_emitter__ = new EE();
          emitter.count = 0;
          emitter.emitted = {};
        }
        if (!emitter.infinite) {
          emitter.setMaxListeners(Infinity);
          emitter.infinite = true;
        }
        module2.exports = function(cb, opts) {
          if (!processOk(global.process)) {
            return function() {
            };
          }
          assert.equal(typeof cb, "function", "a callback must be provided for exit handler");
          if (loaded === false) {
            load();
          }
          var ev = "exit";
          if (opts && opts.alwaysLast) {
            ev = "afterexit";
          }
          var remove = function() {
            emitter.removeListener(ev, cb);
            if (emitter.listeners("exit").length === 0 && emitter.listeners("afterexit").length === 0) {
              unload();
            }
          };
          emitter.on(ev, cb);
          return remove;
        };
        unload = function unload2() {
          if (!loaded || !processOk(global.process)) {
            return;
          }
          loaded = false;
          signals.forEach(function(sig) {
            try {
              process7.removeListener(sig, sigListeners[sig]);
            } catch (er) {
            }
          });
          process7.emit = originalProcessEmit;
          process7.reallyExit = originalProcessReallyExit;
          emitter.count -= 1;
        };
        module2.exports.unload = unload;
        emit = function emit2(event, code, signal) {
          if (emitter.emitted[event]) {
            return;
          }
          emitter.emitted[event] = true;
          emitter.emit(event, code, signal);
        };
        sigListeners = {};
        signals.forEach(function(sig) {
          sigListeners[sig] = function listener() {
            if (!processOk(global.process)) {
              return;
            }
            var listeners = process7.listeners(sig);
            if (listeners.length === emitter.count) {
              unload();
              emit("exit", null, sig);
              emit("afterexit", null, sig);
              if (isWin && sig === "SIGHUP") {
                sig = "SIGINT";
              }
              process7.kill(process7.pid, sig);
            }
          };
        });
        module2.exports.signals = function() {
          return signals;
        };
        loaded = false;
        load = function load2() {
          if (loaded || !processOk(global.process)) {
            return;
          }
          loaded = true;
          emitter.count += 1;
          signals = signals.filter(function(sig) {
            try {
              process7.on(sig, sigListeners[sig]);
              return true;
            } catch (er) {
              return false;
            }
          });
          process7.emit = processEmit;
          process7.reallyExit = processReallyExit;
        };
        module2.exports.load = load;
        originalProcessReallyExit = process7.reallyExit;
        processReallyExit = function processReallyExit2(code) {
          if (!processOk(global.process)) {
            return;
          }
          process7.exitCode = code || /* istanbul ignore next */
          0;
          emit("exit", process7.exitCode, null);
          emit("afterexit", process7.exitCode, null);
          originalProcessReallyExit.call(process7, process7.exitCode);
        };
        originalProcessEmit = process7.emit;
        processEmit = function processEmit2(ev, arg) {
          if (ev === "exit" && processOk(global.process)) {
            if (arg !== void 0) {
              process7.exitCode = arg;
            }
            var ret = originalProcessEmit.apply(this, arguments);
            emit("exit", process7.exitCode, null);
            emit("afterexit", process7.exitCode, null);
            return ret;
          } else {
            return originalProcessEmit.apply(this, arguments);
          }
        };
      }
      var assert;
      var signals;
      var isWin;
      var EE;
      var emitter;
      var unload;
      var emit;
      var sigListeners;
      var loaded;
      var load;
      var originalProcessReallyExit;
      var processReallyExit;
      var originalProcessEmit;
      var processEmit;
    }
  });

  // node_modules/.pnpm/get-stream@6.0.1/node_modules/get-stream/buffer-stream.js
  var require_buffer_stream = __commonJS({
    "node_modules/.pnpm/get-stream@6.0.1/node_modules/get-stream/buffer-stream.js"(exports2, module2) {
      "use strict";
      var { PassThrough: PassThroughStream } = __require("stream");
      module2.exports = (options) => {
        options = { ...options };
        const { array } = options;
        let { encoding } = options;
        const isBuffer = encoding === "buffer";
        let objectMode = false;
        if (array) {
          objectMode = !(encoding || isBuffer);
        } else {
          encoding = encoding || "utf8";
        }
        if (isBuffer) {
          encoding = null;
        }
        const stream = new PassThroughStream({ objectMode });
        if (encoding) {
          stream.setEncoding(encoding);
        }
        let length = 0;
        const chunks = [];
        stream.on("data", (chunk) => {
          chunks.push(chunk);
          if (objectMode) {
            length = chunks.length;
          } else {
            length += chunk.length;
          }
        });
        stream.getBufferedValue = () => {
          if (array) {
            return chunks;
          }
          return isBuffer ? Buffer.concat(chunks, length) : chunks.join("");
        };
        stream.getBufferedLength = () => length;
        return stream;
      };
    }
  });

  // node_modules/.pnpm/get-stream@6.0.1/node_modules/get-stream/index.js
  var require_get_stream = __commonJS({
    "node_modules/.pnpm/get-stream@6.0.1/node_modules/get-stream/index.js"(exports2, module2) {
      "use strict";
      var { constants: BufferConstants } = __require("buffer");
      var stream = __require("stream");
      var { promisify } = __require("util");
      var bufferStream = require_buffer_stream();
      var streamPipelinePromisified = promisify(stream.pipeline);
      var MaxBufferError = class extends Error {
        constructor() {
          super("maxBuffer exceeded");
          this.name = "MaxBufferError";
        }
      };
      async function getStream2(inputStream, options) {
        if (!inputStream) {
          throw new Error("Expected a stream");
        }
        options = {
          maxBuffer: Infinity,
          ...options
        };
        const { maxBuffer } = options;
        const stream2 = bufferStream(options);
        await new Promise((resolve, reject) => {
          const rejectPromise = (error) => {
            if (error && stream2.getBufferedLength() <= BufferConstants.MAX_LENGTH) {
              error.bufferedData = stream2.getBufferedValue();
            }
            reject(error);
          };
          (async () => {
            try {
              await streamPipelinePromisified(inputStream, stream2);
              resolve();
            } catch (error) {
              rejectPromise(error);
            }
          })();
          stream2.on("data", () => {
            if (stream2.getBufferedLength() > maxBuffer) {
              rejectPromise(new MaxBufferError());
            }
          });
        });
        return stream2.getBufferedValue();
      }
      module2.exports = getStream2;
      module2.exports.buffer = (stream2, options) => getStream2(stream2, { ...options, encoding: "buffer" });
      module2.exports.array = (stream2, options) => getStream2(stream2, { ...options, array: true });
      module2.exports.MaxBufferError = MaxBufferError;
    }
  });

  // node_modules/.pnpm/merge-stream@2.0.0/node_modules/merge-stream/index.js
  var require_merge_stream = __commonJS({
    "node_modules/.pnpm/merge-stream@2.0.0/node_modules/merge-stream/index.js"(exports2, module2) {
      "use strict";
      var { PassThrough } = __require("stream");
      module2.exports = function() {
        var sources = [];
        var output = new PassThrough({ objectMode: true });
        output.setMaxListeners(0);
        output.add = add;
        output.isEmpty = isEmpty;
        output.on("unpipe", remove);
        Array.prototype.slice.call(arguments).forEach(add);
        return output;
        function add(source) {
          if (Array.isArray(source)) {
            source.forEach(add);
            return this;
          }
          sources.push(source);
          source.once("end", remove.bind(null, source));
          source.once("error", output.emit.bind(output, "error"));
          source.pipe(output, { end: false });
          return this;
        }
        function isEmpty() {
          return sources.length == 0;
        }
        function remove(source) {
          sources = sources.filter(function(it) {
            return it !== source;
          });
          if (!sources.length && output.readable) {
            output.end();
          }
        }
      };
    }
  });

  // pkgs/base/pkgs/bundler/runner.ts
  var import_command_exists = __toESM(require_command_exists2());
  var import_fs = __require("fs");

  // pkgs/base/pkgs/bundler/global.ts
  var bundler = globalThis;
  if (!bundler.runs)
    bundler.runs = {};

  // pkgs/base/pkgs/utility/spawn.ts
  var import_child_process = __require("child_process");
  var spawn = (file, args2, opt) => {
    let proc = opt?.ipc ? (0, import_child_process.fork)(file, args2, {
      cwd: opt?.cwd,
      stdio: "inherit",
      execArgv: ["--enable-source-maps", "--trace-warnings"]
    }) : (0, import_child_process.spawn)(file, args2, {
      cwd: opt?.cwd,
      stdio: opt?.silent === true ? "ignore" : "inherit",
      shell: true
    });
    const callback = {
      onMessage: (e) => {
      },
      onExit: (e) => {
      }
    };
    const result = {
      data: {},
      markedRunning: false,
      onMessage: (fn) => {
        callback.onMessage = fn;
      },
      proc,
      onExit: (fn) => {
        callback.onExit = fn;
      },
      killing: null,
      async kill() {
        await new Promise((resolve) => {
          if (opt?.ipc) {
            proc.on("message", (e) => {
              if (e === "::SPAWN_DISPOSED::") {
                resolve();
              }
            });
            proc.send("::SPAWN_DISPOSE::");
          } else {
            resolve();
          }
        });
      }
    };
    return new Promise((resolve) => {
      if (opt?.ipc) {
        proc.on("message", async (e) => {
          callback.onMessage(e);
        });
        proc.on("exit", async (code, signal) => {
          callback.onExit({
            exitCode: code || 0,
            signal
          });
        });
        resolve(result);
      } else {
        proc.on("exit", async (code, signal) => {
          callback.onExit({
            exitCode: code || 0,
            signal
          });
          resolve(result);
        });
      }
    });
  };

  // pkgs/base/pkgs/bundler/runner.ts
  var runner = {
    get list() {
      return bundler.runs;
    },
    async dispose() {
      const all = Object.values(bundler.runs).map(async (runs) => {
        runs.forEach(async (run) => {
          await run.kill();
        });
      });
      return await Promise.all(all);
    },
    async restart(path4) {
      if (!bundler.restart) {
        bundler.restart = /* @__PURE__ */ new Set();
      }
      bundler.restart.add(path4);
      if (bundler.runs[path4]) {
        bundler.runs[path4].forEach(async (run) => {
          const data = run.data;
          await this.stop(path4);
          await runner.run(data.arg);
          bundler.restart.delete(path4);
        });
      } else if (bundler.lastRunArgs[path4]) {
        await runner.run(bundler.lastRunArgs[path4]);
        bundler.restart.delete(path4);
      } else {
        bundler.restart.delete(path4);
        return false;
      }
    },
    async stop(path4) {
      return new Promise((resolve) => {
        if (!bundler.runs[path4]) {
          resolve(true);
        } else {
          bundler.runs[path4].forEach((run) => {
            run.onExit(() => resolve(true));
            run.kill();
            bundler.runs[path4].delete(run);
            if (bundler.runs[path4].size === 0)
              delete bundler.runs[path4];
          });
        }
      });
    },
    async run(arg) {
      try {
        const { path: path4, args: args2, cwd: cwd2, onStop } = arg;
        let isCommand = false;
        if (!(0, import_fs.existsSync)(path4)) {
          if (await (0, import_command_exists.default)(path4)) {
            isCommand = true;
          }
        }
        if (!bundler.runs[path4]) {
          bundler.runs[path4] = /* @__PURE__ */ new Set();
        }
        if (!bundler.lastRunArgs) {
          bundler.lastRunArgs = {};
        }
        bundler.lastRunArgs[path4] = arg;
        const run = await spawn(path4, args2 || [], {
          cwd: cwd2,
          ipc: isCommand ? false : true,
          silent: arg.silent
        });
        bundler.runs[path4].add(run);
        run.data = {
          arg
        };
        run.onExit(async (e) => {
          if (onStop)
            await onStop(e);
          bundler.runs[path4].delete(run);
          if (bundler.runs[path4].size === 0)
            delete bundler.runs[path4];
          if (bundler.restart && !bundler.restart.has(path4)) {
            this.run(arg);
          }
        });
        let resolved = false;
        return await new Promise((resolve) => {
          if (!isCommand) {
            run.onMessage((e) => {
              if (!resolved) {
                resolved = true;
                resolve(true);
              }
            });
          } else {
            resolve(true);
          }
        });
      } catch (e) {
        console.log(e);
        return false;
      }
    }
  };

  // node_modules/.pnpm/chalk@5.3.0/node_modules/chalk/source/vendor/ansi-styles/index.js
  var ANSI_BACKGROUND_OFFSET = 10;
  var wrapAnsi16 = (offset = 0) => (code) => `\x1B[${code + offset}m`;
  var wrapAnsi256 = (offset = 0) => (code) => `\x1B[${38 + offset};5;${code}m`;
  var wrapAnsi16m = (offset = 0) => (red, green, blue) => `\x1B[${38 + offset};2;${red};${green};${blue}m`;
  var styles = {
    modifier: {
      reset: [0, 0],
      // 21 isn't widely supported and 22 does the same thing
      bold: [1, 22],
      dim: [2, 22],
      italic: [3, 23],
      underline: [4, 24],
      overline: [53, 55],
      inverse: [7, 27],
      hidden: [8, 28],
      strikethrough: [9, 29]
    },
    color: {
      black: [30, 39],
      red: [31, 39],
      green: [32, 39],
      yellow: [33, 39],
      blue: [34, 39],
      magenta: [35, 39],
      cyan: [36, 39],
      white: [37, 39],
      // Bright color
      blackBright: [90, 39],
      gray: [90, 39],
      // Alias of `blackBright`
      grey: [90, 39],
      // Alias of `blackBright`
      redBright: [91, 39],
      greenBright: [92, 39],
      yellowBright: [93, 39],
      blueBright: [94, 39],
      magentaBright: [95, 39],
      cyanBright: [96, 39],
      whiteBright: [97, 39]
    },
    bgColor: {
      bgBlack: [40, 49],
      bgRed: [41, 49],
      bgGreen: [42, 49],
      bgYellow: [43, 49],
      bgBlue: [44, 49],
      bgMagenta: [45, 49],
      bgCyan: [46, 49],
      bgWhite: [47, 49],
      // Bright color
      bgBlackBright: [100, 49],
      bgGray: [100, 49],
      // Alias of `bgBlackBright`
      bgGrey: [100, 49],
      // Alias of `bgBlackBright`
      bgRedBright: [101, 49],
      bgGreenBright: [102, 49],
      bgYellowBright: [103, 49],
      bgBlueBright: [104, 49],
      bgMagentaBright: [105, 49],
      bgCyanBright: [106, 49],
      bgWhiteBright: [107, 49]
    }
  };
  var modifierNames = Object.keys(styles.modifier);
  var foregroundColorNames = Object.keys(styles.color);
  var backgroundColorNames = Object.keys(styles.bgColor);
  var colorNames = [...foregroundColorNames, ...backgroundColorNames];
  function assembleStyles() {
    const codes = /* @__PURE__ */ new Map();
    for (const [groupName, group] of Object.entries(styles)) {
      for (const [styleName, style] of Object.entries(group)) {
        styles[styleName] = {
          open: `\x1B[${style[0]}m`,
          close: `\x1B[${style[1]}m`
        };
        group[styleName] = styles[styleName];
        codes.set(style[0], style[1]);
      }
      Object.defineProperty(styles, groupName, {
        value: group,
        enumerable: false
      });
    }
    Object.defineProperty(styles, "codes", {
      value: codes,
      enumerable: false
    });
    styles.color.close = "\x1B[39m";
    styles.bgColor.close = "\x1B[49m";
    styles.color.ansi = wrapAnsi16();
    styles.color.ansi256 = wrapAnsi256();
    styles.color.ansi16m = wrapAnsi16m();
    styles.bgColor.ansi = wrapAnsi16(ANSI_BACKGROUND_OFFSET);
    styles.bgColor.ansi256 = wrapAnsi256(ANSI_BACKGROUND_OFFSET);
    styles.bgColor.ansi16m = wrapAnsi16m(ANSI_BACKGROUND_OFFSET);
    Object.defineProperties(styles, {
      rgbToAnsi256: {
        value(red, green, blue) {
          if (red === green && green === blue) {
            if (red < 8) {
              return 16;
            }
            if (red > 248) {
              return 231;
            }
            return Math.round((red - 8) / 247 * 24) + 232;
          }
          return 16 + 36 * Math.round(red / 255 * 5) + 6 * Math.round(green / 255 * 5) + Math.round(blue / 255 * 5);
        },
        enumerable: false
      },
      hexToRgb: {
        value(hex) {
          const matches = /[a-f\d]{6}|[a-f\d]{3}/i.exec(hex.toString(16));
          if (!matches) {
            return [0, 0, 0];
          }
          let [colorString] = matches;
          if (colorString.length === 3) {
            colorString = [...colorString].map((character) => character + character).join("");
          }
          const integer = Number.parseInt(colorString, 16);
          return [
            /* eslint-disable no-bitwise */
            integer >> 16 & 255,
            integer >> 8 & 255,
            integer & 255
            /* eslint-enable no-bitwise */
          ];
        },
        enumerable: false
      },
      hexToAnsi256: {
        value: (hex) => styles.rgbToAnsi256(...styles.hexToRgb(hex)),
        enumerable: false
      },
      ansi256ToAnsi: {
        value(code) {
          if (code < 8) {
            return 30 + code;
          }
          if (code < 16) {
            return 90 + (code - 8);
          }
          let red;
          let green;
          let blue;
          if (code >= 232) {
            red = ((code - 232) * 10 + 8) / 255;
            green = red;
            blue = red;
          } else {
            code -= 16;
            const remainder = code % 36;
            red = Math.floor(code / 36) / 5;
            green = Math.floor(remainder / 6) / 5;
            blue = remainder % 6 / 5;
          }
          const value = Math.max(red, green, blue) * 2;
          if (value === 0) {
            return 30;
          }
          let result = 30 + (Math.round(blue) << 2 | Math.round(green) << 1 | Math.round(red));
          if (value === 2) {
            result += 60;
          }
          return result;
        },
        enumerable: false
      },
      rgbToAnsi: {
        value: (red, green, blue) => styles.ansi256ToAnsi(styles.rgbToAnsi256(red, green, blue)),
        enumerable: false
      },
      hexToAnsi: {
        value: (hex) => styles.ansi256ToAnsi(styles.hexToAnsi256(hex)),
        enumerable: false
      }
    });
    return styles;
  }
  var ansiStyles = assembleStyles();
  var ansi_styles_default = ansiStyles;

  // node_modules/.pnpm/chalk@5.3.0/node_modules/chalk/source/vendor/supports-color/index.js
  var import_node_process = __toESM(__require("node:process"), 1);
  var import_node_os = __toESM(__require("node:os"), 1);
  var import_node_tty = __toESM(__require("node:tty"), 1);
  function hasFlag(flag, argv = globalThis.Deno ? globalThis.Deno.args : import_node_process.default.argv) {
    const prefix = flag.startsWith("-") ? "" : flag.length === 1 ? "-" : "--";
    const position = argv.indexOf(prefix + flag);
    const terminatorPosition = argv.indexOf("--");
    return position !== -1 && (terminatorPosition === -1 || position < terminatorPosition);
  }
  var { env } = import_node_process.default;
  var flagForceColor;
  if (hasFlag("no-color") || hasFlag("no-colors") || hasFlag("color=false") || hasFlag("color=never")) {
    flagForceColor = 0;
  } else if (hasFlag("color") || hasFlag("colors") || hasFlag("color=true") || hasFlag("color=always")) {
    flagForceColor = 1;
  }
  function envForceColor() {
    if ("FORCE_COLOR" in env) {
      if (env.FORCE_COLOR === "true") {
        return 1;
      }
      if (env.FORCE_COLOR === "false") {
        return 0;
      }
      return env.FORCE_COLOR.length === 0 ? 1 : Math.min(Number.parseInt(env.FORCE_COLOR, 10), 3);
    }
  }
  function translateLevel(level) {
    if (level === 0) {
      return false;
    }
    return {
      level,
      hasBasic: true,
      has256: level >= 2,
      has16m: level >= 3
    };
  }
  function _supportsColor(haveStream, { streamIsTTY, sniffFlags = true } = {}) {
    const noFlagForceColor = envForceColor();
    if (noFlagForceColor !== void 0) {
      flagForceColor = noFlagForceColor;
    }
    const forceColor = sniffFlags ? flagForceColor : noFlagForceColor;
    if (forceColor === 0) {
      return 0;
    }
    if (sniffFlags) {
      if (hasFlag("color=16m") || hasFlag("color=full") || hasFlag("color=truecolor")) {
        return 3;
      }
      if (hasFlag("color=256")) {
        return 2;
      }
    }
    if ("TF_BUILD" in env && "AGENT_NAME" in env) {
      return 1;
    }
    if (haveStream && !streamIsTTY && forceColor === void 0) {
      return 0;
    }
    const min = forceColor || 0;
    if (env.TERM === "dumb") {
      return min;
    }
    if (import_node_process.default.platform === "win32") {
      const osRelease = import_node_os.default.release().split(".");
      if (Number(osRelease[0]) >= 10 && Number(osRelease[2]) >= 10586) {
        return Number(osRelease[2]) >= 14931 ? 3 : 2;
      }
      return 1;
    }
    if ("CI" in env) {
      if ("GITHUB_ACTIONS" in env || "GITEA_ACTIONS" in env) {
        return 3;
      }
      if (["TRAVIS", "CIRCLECI", "APPVEYOR", "GITLAB_CI", "BUILDKITE", "DRONE"].some((sign) => sign in env) || env.CI_NAME === "codeship") {
        return 1;
      }
      return min;
    }
    if ("TEAMCITY_VERSION" in env) {
      return /^(9\.(0*[1-9]\d*)\.|\d{2,}\.)/.test(env.TEAMCITY_VERSION) ? 1 : 0;
    }
    if (env.COLORTERM === "truecolor") {
      return 3;
    }
    if (env.TERM === "xterm-kitty") {
      return 3;
    }
    if ("TERM_PROGRAM" in env) {
      const version = Number.parseInt((env.TERM_PROGRAM_VERSION || "").split(".")[0], 10);
      switch (env.TERM_PROGRAM) {
        case "iTerm.app": {
          return version >= 3 ? 3 : 2;
        }
        case "Apple_Terminal": {
          return 2;
        }
      }
    }
    if (/-256(color)?$/i.test(env.TERM)) {
      return 2;
    }
    if (/^screen|^xterm|^vt100|^vt220|^rxvt|color|ansi|cygwin|linux/i.test(env.TERM)) {
      return 1;
    }
    if ("COLORTERM" in env) {
      return 1;
    }
    return min;
  }
  function createSupportsColor(stream, options = {}) {
    const level = _supportsColor(stream, {
      streamIsTTY: stream && stream.isTTY,
      ...options
    });
    return translateLevel(level);
  }
  var supportsColor = {
    stdout: createSupportsColor({ isTTY: import_node_tty.default.isatty(1) }),
    stderr: createSupportsColor({ isTTY: import_node_tty.default.isatty(2) })
  };
  var supports_color_default = supportsColor;

  // node_modules/.pnpm/chalk@5.3.0/node_modules/chalk/source/utilities.js
  function stringReplaceAll(string, substring, replacer) {
    let index = string.indexOf(substring);
    if (index === -1) {
      return string;
    }
    const substringLength = substring.length;
    let endIndex = 0;
    let returnValue = "";
    do {
      returnValue += string.slice(endIndex, index) + substring + replacer;
      endIndex = index + substringLength;
      index = string.indexOf(substring, endIndex);
    } while (index !== -1);
    returnValue += string.slice(endIndex);
    return returnValue;
  }
  function stringEncaseCRLFWithFirstIndex(string, prefix, postfix, index) {
    let endIndex = 0;
    let returnValue = "";
    do {
      const gotCR = string[index - 1] === "\r";
      returnValue += string.slice(endIndex, gotCR ? index - 1 : index) + prefix + (gotCR ? "\r\n" : "\n") + postfix;
      endIndex = index + 1;
      index = string.indexOf("\n", endIndex);
    } while (index !== -1);
    returnValue += string.slice(endIndex);
    return returnValue;
  }

  // node_modules/.pnpm/chalk@5.3.0/node_modules/chalk/source/index.js
  var { stdout: stdoutColor, stderr: stderrColor } = supports_color_default;
  var GENERATOR = Symbol("GENERATOR");
  var STYLER = Symbol("STYLER");
  var IS_EMPTY = Symbol("IS_EMPTY");
  var levelMapping = [
    "ansi",
    "ansi",
    "ansi256",
    "ansi16m"
  ];
  var styles2 = /* @__PURE__ */ Object.create(null);
  var applyOptions = (object, options = {}) => {
    if (options.level && !(Number.isInteger(options.level) && options.level >= 0 && options.level <= 3)) {
      throw new Error("The `level` option should be an integer from 0 to 3");
    }
    const colorLevel = stdoutColor ? stdoutColor.level : 0;
    object.level = options.level === void 0 ? colorLevel : options.level;
  };
  var chalkFactory = (options) => {
    const chalk5 = (...strings) => strings.join(" ");
    applyOptions(chalk5, options);
    Object.setPrototypeOf(chalk5, createChalk.prototype);
    return chalk5;
  };
  function createChalk(options) {
    return chalkFactory(options);
  }
  Object.setPrototypeOf(createChalk.prototype, Function.prototype);
  for (const [styleName, style] of Object.entries(ansi_styles_default)) {
    styles2[styleName] = {
      get() {
        const builder = createBuilder(this, createStyler(style.open, style.close, this[STYLER]), this[IS_EMPTY]);
        Object.defineProperty(this, styleName, { value: builder });
        return builder;
      }
    };
  }
  styles2.visible = {
    get() {
      const builder = createBuilder(this, this[STYLER], true);
      Object.defineProperty(this, "visible", { value: builder });
      return builder;
    }
  };
  var getModelAnsi = (model, level, type, ...arguments_) => {
    if (model === "rgb") {
      if (level === "ansi16m") {
        return ansi_styles_default[type].ansi16m(...arguments_);
      }
      if (level === "ansi256") {
        return ansi_styles_default[type].ansi256(ansi_styles_default.rgbToAnsi256(...arguments_));
      }
      return ansi_styles_default[type].ansi(ansi_styles_default.rgbToAnsi(...arguments_));
    }
    if (model === "hex") {
      return getModelAnsi("rgb", level, type, ...ansi_styles_default.hexToRgb(...arguments_));
    }
    return ansi_styles_default[type][model](...arguments_);
  };
  var usedModels = ["rgb", "hex", "ansi256"];
  for (const model of usedModels) {
    styles2[model] = {
      get() {
        const { level } = this;
        return function(...arguments_) {
          const styler = createStyler(getModelAnsi(model, levelMapping[level], "color", ...arguments_), ansi_styles_default.color.close, this[STYLER]);
          return createBuilder(this, styler, this[IS_EMPTY]);
        };
      }
    };
    const bgModel = "bg" + model[0].toUpperCase() + model.slice(1);
    styles2[bgModel] = {
      get() {
        const { level } = this;
        return function(...arguments_) {
          const styler = createStyler(getModelAnsi(model, levelMapping[level], "bgColor", ...arguments_), ansi_styles_default.bgColor.close, this[STYLER]);
          return createBuilder(this, styler, this[IS_EMPTY]);
        };
      }
    };
  }
  var proto = Object.defineProperties(() => {
  }, {
    ...styles2,
    level: {
      enumerable: true,
      get() {
        return this[GENERATOR].level;
      },
      set(level) {
        this[GENERATOR].level = level;
      }
    }
  });
  var createStyler = (open, close, parent) => {
    let openAll;
    let closeAll;
    if (parent === void 0) {
      openAll = open;
      closeAll = close;
    } else {
      openAll = parent.openAll + open;
      closeAll = close + parent.closeAll;
    }
    return {
      open,
      close,
      openAll,
      closeAll,
      parent
    };
  };
  var createBuilder = (self2, _styler, _isEmpty) => {
    const builder = (...arguments_) => applyStyle(builder, arguments_.length === 1 ? "" + arguments_[0] : arguments_.join(" "));
    Object.setPrototypeOf(builder, proto);
    builder[GENERATOR] = self2;
    builder[STYLER] = _styler;
    builder[IS_EMPTY] = _isEmpty;
    return builder;
  };
  var applyStyle = (self2, string) => {
    if (self2.level <= 0 || !string) {
      return self2[IS_EMPTY] ? "" : string;
    }
    let styler = self2[STYLER];
    if (styler === void 0) {
      return string;
    }
    const { openAll, closeAll } = styler;
    if (string.includes("\x1B")) {
      while (styler !== void 0) {
        string = stringReplaceAll(string, styler.close, styler.open);
        styler = styler.parent;
      }
    }
    const lfIndex = string.indexOf("\n");
    if (lfIndex !== -1) {
      string = stringEncaseCRLFWithFirstIndex(string, closeAll, openAll, lfIndex);
    }
    return openAll + string + closeAll;
  };
  Object.defineProperties(createChalk.prototype, styles2);
  var chalk = createChalk();
  var chalkStderr = createChalk({ level: stderrColor ? stderrColor.level : 0 });
  var source_default = chalk;

  // pkgs/base/src/main.ts
  init_export();
  var import_fs_jetpack26 = __toESM(require_main());
  var import_lodash6 = __toESM(require_lodash());
  var import_path19 = __require("path");

  // pkgs/base/pkgs/pkg/export.ts
  var import_child_process2 = __require("child_process");
  var import_chalk2 = __toESM(require_source());
  var import_fs3 = __toESM(__require("fs"));
  var import_path3 = __toESM(__require("path"));

  // pkgs/base/pkgs/pkg/src/should-install.ts
  var import_chalk = __toESM(require_source());
  var import_fs_jetpack = __toESM(require_main());
  var import_path2 = __require("path");
  var shouldInstall = async (path4, silent = false) => {
    const dir2 = (0, import_path2.dirname)(path4);
    let pkg2 = {};
    try {
      pkg2 = await (0, import_fs_jetpack.readAsync)(path4, "json");
    } catch (e) {
      try {
        pkg2 = await (0, import_fs_jetpack.readAsync)((0, import_path2.join)(path4, "package.json"), "json");
      } catch (e2) {
      }
    }
    let install = false;
    for (const e of ["dependencies", "devDependencies"]) {
      if (!pkg2 || pkg2 && !pkg2[e])
        continue;
      const entries = Object.entries(pkg2[e]);
      for (const [k, v] of entries) {
        if (k === "hyper-express")
          continue;
        if (v.startsWith(".") || v.startsWith("/")) {
          continue;
        }
        if (v === "*") {
          try {
            const res = await fetch(
              `https://data.jsdelivr.com/v1/packages/npm/${k}/resolved`
            );
            const json = await res.json();
            pkg2[e][k] = json.version;
            if (!silent && !install)
              console.log(
                `found ${import_chalk.default.cyan(`${k} = "*"`)} in ${path4.substring(
                  process.cwd().length + 1
                )}`
              );
            install = true;
          } catch (e2) {
          }
        }
      }
    }
    if (install) {
      await (0, import_fs_jetpack.writeAsync)(path4, pkg2, { jsonIndent: 2 });
    }
    return install;
  };

  // pkgs/base/pkgs/pkg/export.ts
  init_export();
  var import_fs_jetpack2 = __toESM(require_main());
  var g = globalThis;
  if (!g.pkgRunning) {
    g.pkgRunning = /* @__PURE__ */ new Set();
  }
  var getModuleVersion = async (name) => {
    if (!g.allPkgs) {
      g.allPkgs = {};
      const dirs = await scanDir([dir.root()]);
      await Promise.all(
        dirs.map(async (e) => {
          try {
            const res = await (0, import_fs_jetpack2.readAsync)(e, "json");
            g.allPkgs[e] = res;
          } catch (e2) {
          }
        })
      );
    }
    for (const pkg2 of Object.values(g.allPkgs)) {
      if (pkg2.dependencies) {
        for (const [k, v] of Object.entries(pkg2.dependencies)) {
          if (k === name)
            return v;
        }
      }
      if (pkg2.devDependencies) {
        for (const [k, v] of Object.entries(pkg2.devDependencies)) {
          if (k === name)
            return v;
        }
      }
    }
  };
  var pkg = {
    async extractExternal(pkg2) {
      const dependencies = {};
      if (pkg2.external) {
        for (const f of pkg2.external) {
          const v = await getModuleVersion(f);
          if (v)
            dependencies[f] = v;
          if (f === "*") {
            if (pkg2.dependencies) {
              for (const [k, v2] of Object.entries(pkg2.dependencies)) {
                if (!v2.startsWith("workspace:") && !v2.startsWith(".")) {
                  dependencies[k] = v2;
                }
              }
            }
            if (pkg2.devDependencies) {
              for (const [k, v2] of Object.entries(pkg2.devDependencies)) {
                if (!v2.startsWith("workspace:") && !v2.startsWith(".")) {
                  dependencies[k] = v2;
                }
              }
            }
          }
        }
      } else {
        if (pkg2.dependencies) {
          for (const [k, v] of Object.entries(pkg2.dependencies)) {
            if (!v.startsWith("workspace:") && !v.startsWith(".")) {
              dependencies[k] = v;
            }
          }
        }
        if (pkg2.devDependencies) {
          for (const [k, v] of Object.entries(pkg2.devDependencies)) {
            if (!v.startsWith("workspace:") && !v.startsWith(".")) {
              dependencies[k] = v;
            }
          }
        }
      }
      return { name: pkg2.name, version: pkg2.version, dependencies };
    },
    async install(path4, arg) {
      const _arg = arg ? arg : { cwd: void 0, silent: false };
      let silent = _arg.silent === true ? true : false;
      if (g.pkgRunning.size > 0) {
        await Promise.all([...g.pkgRunning.values()]);
      }
      const prom = new Promise(async (resolve) => {
        let install = false;
        let mustInstall = [path4];
        if (arg && arg.deep) {
          let dirs = await scanDir([path4]);
          if (typeof arg.deep === "object") {
            dirs = dirs.filter((d) => {
              if (typeof arg.deep === "object") {
                for (const e of arg.deep.exclude) {
                  if (d.startsWith(e)) {
                    return false;
                  }
                }
              }
              return true;
            });
          }
          const mustInstall2 = [];
          for (const p of dirs) {
            if (await shouldInstall(p, silent)) {
              mustInstall2.push(p);
              install = true;
            }
          }
        } else {
          install = await shouldInstall(path4, silent);
        }
        if (install) {
          if (arg?.onInstall)
            await arg.onInstall();
          if (!silent) {
            console.log(
              `
${import_chalk2.default.magenta("Installing")} deps:
 ${import_chalk2.default.blue("\u27A5")}`,
              mustInstall.map((e) => {
                if (e.startsWith(dir.root()))
                  return import_chalk2.default.green(e.substring(dir.root().length + 1));
                if (e === dir.root())
                  return import_chalk2.default.green(e);
              }).join(" ")
            );
          }
          const child = (0, import_child_process2.spawn)("pnpm", ["i"], {
            stdio: silent ? "ignore" : "inherit",
            cwd: _arg.cwd || process.cwd(),
            shell: true
          });
          child.on("exit", () => {
            g.pkgRunning.delete(prom);
            if (arg?.onInstallDone)
              arg.onInstallDone();
            resolve();
          });
        } else {
          resolve();
        }
      });
      g.pkgRunning.add(prom);
      return await prom;
    }
  };
  var scanDir = async (paths) => {
    const pkgs = [];
    for (const path4 of paths) {
      for await (const p of walkDir(path4)) {
        if (p.endsWith("package.json")) {
          pkgs.push(p);
        }
        if (p.endsWith("node_modules"))
          break;
      }
    }
    return pkgs;
  };
  async function* walkDir(dir2) {
    for await (const d of await import_fs3.default.promises.opendir(dir2)) {
      const entry = import_path3.default.join(dir2, d.name);
      if (d.isDirectory()) {
        if (!entry.endsWith("node_modules")) {
          yield* await walkDir(entry);
        }
      } else if (d.isFile())
        yield entry;
    }
  }

  // pkgs/base/pkgs/rpc/src/connect.ts
  var import_cuid2 = __toESM(require_cuid2());

  // node_modules/.pnpm/@qiwi+deep-proxy@2.0.3/node_modules/@qiwi/deep-proxy/target/es6/cache.js
  var cache = { proxies: /* @__PURE__ */ new WeakMap(), traps: /* @__PURE__ */ new WeakMap() };
  var getCache = (e, t, a) => e.get(t) || e.set(t, new a()).get(t);
  var getKey = (e) => e.join();
  var addToCache = (e, t, a, c, o) => {
    getCache(getCache(cache.traps, e, WeakMap), t, Map).set(getKey(a), c), cache.proxies.set(c, o);
  };
  var getFromCache = (e, t, a) => {
    var c, o;
    return cache.proxies.get(null === (o = null === (c = cache.traps.get(e)) || void 0 === c ? void 0 : c.get(t)) || void 0 === o ? void 0 : o.get(getKey(a)));
  };

  // node_modules/.pnpm/@qiwi+deep-proxy@2.0.3/node_modules/@qiwi/deep-proxy/target/es6/proxy.js
  var DEFAULT = Symbol("default");
  var trapNames = Object.keys(Object.getOwnPropertyDescriptors(Reflect));
  var trapsWithKey = ["get", "has", "set", "defineProperty", "deleteProperty", "getOwnPropertyDescriptor"];
  var parseParameters = (e, r) => {
    let t, a, o, s, c, p, n, l;
    switch (e) {
      case "get":
        [t, a, s] = r;
        break;
      case "set":
        [t, a, o, s] = r;
        break;
      case "deleteProperty":
      case "defineProperty":
        [t, p] = r;
        break;
      case "has":
      case "getOwnPropertyDescriptor":
        [t, a] = r;
        break;
      case "apply":
        [t, n, c] = r;
        break;
      case "construct":
        [t, c] = r;
        break;
      case "setPrototypeOf":
        [t, l] = r;
        break;
      default:
        [t] = r;
    }
    return { target: t, name: a, receiver: s, val: o, args: c, descriptor: p, thisValue: n, prototype: l };
  };
  var createHandlerContext = (e, r) => {
    const { trapName: t, handler: a, traps: o, root: s, path: c } = e, { target: p, name: n, val: l, receiver: d, args: i, descriptor: h, thisValue: y, prototype: u } = parseParameters(t, r), g4 = trapsWithKey.includes(t) ? n : void 0;
    return { parameters: r, target: p, name: n, val: l, args: i, descriptor: h, receiver: d, thisValue: y, prototype: u, trapName: t, traps: o, path: c, handler: a, key: g4, newValue: "set" === t ? l : void 0, root: s, get proxy() {
      return getFromCache(s, p, c);
    }, get value() {
      return g4 && p[g4];
    }, DEFAULT, PROXY: createDeepProxy.bind({ root: s, handler: a, path: [...c, g4] }) };
  };
  var trap = function(...e) {
    const { trapName: r, handler: t } = this, a = createHandlerContext(this, e), { PROXY: o, DEFAULT: s } = a, c = t(a);
    return c === o ? o(a.value) : c === s ? Reflect[r](...e) : c;
  };
  var createTraps = (e, r, t) => trapNames.reduce((a, o) => (a[o] = trap.bind({ trapName: o, handler: e, traps: a, root: r, path: t }), a), {});
  var checkTarget = (e) => {
    if (null === e || "object" != typeof e && "function" != typeof e)
      throw new TypeError("Deep proxy could be applied to objects and functions only");
  };
  var defaultProxyHandler = ({ DEFAULT: e }) => e;
  var createDeepProxy = function(e, r, t, a) {
    checkTarget(e);
    const o = Object.assign({}, this), s = r || o.handler || defaultProxyHandler, c = t || o.path || [], p = o.root || a || e, n = getFromCache(p, e, c);
    if (n)
      return n;
    const l = createTraps(s, p, c), d = new Proxy(e, l);
    return addToCache(p, e, c, l, d), d;
  };
  var DeepProxy = class {
    constructor(e, r, t, a) {
      return createDeepProxy(e, r, t, a);
    }
  };

  // pkgs/base/pkgs/rpc/src/connect.ts
  var import_lodash = __toESM(require_lodash2());

  // node_modules/.pnpm/ws@8.12.1/node_modules/ws/wrapper.mjs
  var import_stream = __toESM(require_stream(), 1);
  var import_receiver = __toESM(require_receiver(), 1);
  var import_sender = __toESM(require_sender(), 1);
  var import_websocket = __toESM(require_websocket(), 1);
  var import_websocket_server = __toESM(require_websocket_server(), 1);

  // pkgs/base/pkgs/rpc/src/config.ts
  var import_fs4 = __require("fs");
  var import_path4 = __require("path");
  init_export();
  var config = new Proxy(
    {
      _path: "",
      _raw: null
    },
    {
      get(target, p, receiver) {
        initConf(target);
        return target._raw[p];
      },
      set(target, p, newValue, receiver) {
        initConf(target);
        target._raw[p] = newValue;
        (0, import_fs4.writeFileSync)(target._path, JSON.stringify(target._raw, null, 2));
        return true;
      }
    }
  );
  var initConf = (target) => {
    target._path = (0, import_path4.join)(process.cwd(), "rpc.json");
    try {
      if ((0, import_fs4.existsSync)((0, import_path4.join)(process.cwd(), "base"))) {
        target._path = dir.root(".output/app/rpc.json");
      }
      if ((0, import_fs4.existsSync)(target._path)) {
        const json = (0, import_fs4.readFileSync)(target._path, "utf-8");
        target._raw = JSON.parse(json);
      } else {
        (0, import_fs4.mkdirSync)((0, import_path4.dirname)(target._path), { recursive: true });
      }
    } catch (e) {
    }
    if (!target._raw) {
      target._raw = {
        port: 0,
        rpc: {}
      };
    }
  };

  // pkgs/base/pkgs/rpc/src/connect.ts
  var connectRPC = async (name, arg) => {
    const waitConnection = (0, import_lodash.default)(arg, "waitConnection", false);
    const exitWhenDisconnect = (0, import_lodash.default)(arg, "exitWhenDisconnect", true);
    let ws = false;
    let serverConnected = false;
    const onClose = () => {
      if (exitWhenDisconnect) {
        process.exit(0);
      }
    };
    const res = await connect(name, {
      waitServer: waitConnection,
      onClose
    });
    if (res) {
      ws = res.ws;
      serverConnected = res.serverConnected;
    }
    return new DeepProxy({}, ({ PROXY, key, path: path4, handler }) => {
      if (key) {
        if (key === "then") {
          return PROXY({}, handler, path4);
        }
        if (path4.length === 0 && key === "connected")
          return !!ws && !!serverConnected;
        return async (...args2) => {
          if (ws === false) {
            const res2 = await connect(name, {
              waitServer: true,
              onClose
            });
            if (res2) {
              ws = res2.ws;
              serverConnected = res2.serverConnected;
            }
          }
          const result = new Promise((resolve, reject) => {
            const msgid = (0, import_cuid2.createId)();
            let retryCounter = 0;
            let timeout = null;
            let retryTimeout = 5e3;
            const lastArg = args2[args2.length - 1];
            if (lastArg && typeof lastArg === "object" && lastArg["__retryTimeout"]) {
              retryTimeout = lastArg["__retryTimeout"];
            }
            timeout = setTimeout(() => {
              if (ws && ws.readyState === 1) {
                resend();
              }
            }, retryTimeout);
            const resend = () => {
              if (retryCounter > 3)
                reject("RPC Server disconnected, failed to reconne 3x");
              retryCounter++;
              if (ws) {
                const onmsg = (raw) => {
                  if (ws) {
                    const msg = JSON.parse(raw);
                    if (msg.msgid === msgid) {
                      if (timeout) {
                        clearTimeout(timeout);
                      }
                      ws.off("close", resend);
                      ws.off("message", onmsg);
                      if (msg.type === "action-result") {
                        if (msg.result === "null") {
                          msg.result = null;
                        } else if (msg.result === "undefined") {
                          msg.result = void 0;
                        } else if (msg.result === "0") {
                          msg.result = 0;
                        }
                        if (!!msg.error && !!msg.result) {
                          resolve(msg.result);
                        } else if (!msg.error) {
                          resolve(msg.result);
                        } else {
                          reject(msg.error.msg);
                        }
                      }
                    }
                  }
                };
                ws.once("close", resend);
                ws.on("message", onmsg);
                ws.send(
                  JSON.stringify({
                    type: "action",
                    msgid,
                    path: [...path4, key],
                    args: args2
                  })
                );
              }
            };
            resend();
          });
          return await result;
        };
      }
      return void 0;
    });
  };
  var connect = (name, arg) => {
    return new Promise(
      (resolve) => {
        const ws = new import_websocket.default(`ws://localhost:${config.port}/connect/${name}`);
        ws.on("open", () => {
          ws.send(JSON.stringify({ type: "identify", name }));
          ws.on("message", (raw) => {
            const msg = JSON.parse(raw);
            if (msg.type === "connected") {
              if (arg?.waitServer) {
                if (msg.serverConnected) {
                  resolve({ ws, serverConnected: msg.serverConnected });
                }
              } else {
                resolve({ ws, serverConnected: msg.serverConnected });
              }
            }
          });
        });
        ws.on("close", () => {
          resolve(false);
          if (arg?.onClose)
            arg.onClose();
        });
        ws.on("error", () => {
          resolve(false);
        });
      }
    );
  };

  // pkgs/base/pkgs/rpc/src/server.ts
  var import_hyper_express = __require("hyper-express");

  // node_modules/.pnpm/get-port@6.1.2/node_modules/get-port/index.js
  var import_node_net = __toESM(__require("node:net"), 1);
  var import_node_os2 = __toESM(__require("node:os"), 1);
  var Locked = class extends Error {
    constructor(port) {
      super(`${port} is locked`);
    }
  };
  var lockedPorts = {
    old: /* @__PURE__ */ new Set(),
    young: /* @__PURE__ */ new Set()
  };
  var releaseOldLockedPortsIntervalMs = 1e3 * 15;
  var minPort = 1024;
  var maxPort = 65535;
  var interval;
  var getLocalHosts = () => {
    const interfaces = import_node_os2.default.networkInterfaces();
    const results = /* @__PURE__ */ new Set([void 0, "0.0.0.0"]);
    for (const _interface of Object.values(interfaces)) {
      for (const config2 of _interface) {
        results.add(config2.address);
      }
    }
    return results;
  };
  var checkAvailablePort = (options) => new Promise((resolve, reject) => {
    const server = import_node_net.default.createServer();
    server.unref();
    server.on("error", reject);
    server.listen(options, () => {
      const { port } = server.address();
      server.close(() => {
        resolve(port);
      });
    });
  });
  var getAvailablePort = async (options, hosts) => {
    if (options.host || options.port === 0) {
      return checkAvailablePort(options);
    }
    for (const host of hosts) {
      try {
        await checkAvailablePort({ port: options.port, host });
      } catch (error) {
        if (!["EADDRNOTAVAIL", "EINVAL"].includes(error.code)) {
          throw error;
        }
      }
    }
    return options.port;
  };
  var portCheckSequence = function* (ports) {
    if (ports) {
      yield* ports;
    }
    yield 0;
  };
  async function getPorts(options) {
    let ports;
    let exclude = /* @__PURE__ */ new Set();
    if (options) {
      if (options.port) {
        ports = typeof options.port === "number" ? [options.port] : options.port;
      }
      if (options.exclude) {
        const excludeIterable = options.exclude;
        if (typeof excludeIterable[Symbol.iterator] !== "function") {
          throw new TypeError("The `exclude` option must be an iterable.");
        }
        for (const element of excludeIterable) {
          if (typeof element !== "number") {
            throw new TypeError("Each item in the `exclude` option must be a number corresponding to the port you want excluded.");
          }
          if (!Number.isSafeInteger(element)) {
            throw new TypeError(`Number ${element} in the exclude option is not a safe integer and can't be used`);
          }
        }
        exclude = new Set(excludeIterable);
      }
    }
    if (interval === void 0) {
      interval = setInterval(() => {
        lockedPorts.old = lockedPorts.young;
        lockedPorts.young = /* @__PURE__ */ new Set();
      }, releaseOldLockedPortsIntervalMs);
      if (interval.unref) {
        interval.unref();
      }
    }
    const hosts = getLocalHosts();
    for (const port of portCheckSequence(ports)) {
      try {
        if (exclude.has(port)) {
          continue;
        }
        let availablePort = await getAvailablePort({ ...options, port }, hosts);
        while (lockedPorts.old.has(availablePort) || lockedPorts.young.has(availablePort)) {
          if (port !== 0) {
            throw new Locked(port);
          }
          availablePort = await getAvailablePort({ ...options, port }, hosts);
        }
        lockedPorts.young.add(availablePort);
        return availablePort;
      } catch (error) {
        if (!["EADDRINUSE", "EACCES"].includes(error.code) && !(error instanceof Locked)) {
          throw error;
        }
      }
    }
    throw new Error("No available ports found");
  }
  function portNumbers(from, to) {
    if (!Number.isInteger(from) || !Number.isInteger(to)) {
      throw new TypeError("`from` and `to` must be integer numbers");
    }
    if (from < minPort || from > maxPort) {
      throw new RangeError(`'from' must be between ${minPort} and ${maxPort}`);
    }
    if (to < minPort || to > maxPort) {
      throw new RangeError(`'to' must be between ${minPort} and ${maxPort}`);
    }
    if (from > to) {
      throw new RangeError("`to` must be greater than or equal to `from`");
    }
    const generator = function* (from2, to2) {
      for (let port = from2; port <= to2; port++) {
        yield port;
      }
    };
    return generator(from, to);
  }

  // pkgs/base/pkgs/rpc/src/server.ts
  var import_cuid22 = __toESM(require_cuid2());
  var import_lodash2 = __toESM(require_lodash2());

  // node_modules/.pnpm/chalk@5.2.0/node_modules/chalk/source/vendor/ansi-styles/index.js
  var ANSI_BACKGROUND_OFFSET2 = 10;
  var wrapAnsi162 = (offset = 0) => (code) => `\x1B[${code + offset}m`;
  var wrapAnsi2562 = (offset = 0) => (code) => `\x1B[${38 + offset};5;${code}m`;
  var wrapAnsi16m2 = (offset = 0) => (red, green, blue) => `\x1B[${38 + offset};2;${red};${green};${blue}m`;
  var styles3 = {
    modifier: {
      reset: [0, 0],
      // 21 isn't widely supported and 22 does the same thing
      bold: [1, 22],
      dim: [2, 22],
      italic: [3, 23],
      underline: [4, 24],
      overline: [53, 55],
      inverse: [7, 27],
      hidden: [8, 28],
      strikethrough: [9, 29]
    },
    color: {
      black: [30, 39],
      red: [31, 39],
      green: [32, 39],
      yellow: [33, 39],
      blue: [34, 39],
      magenta: [35, 39],
      cyan: [36, 39],
      white: [37, 39],
      // Bright color
      blackBright: [90, 39],
      gray: [90, 39],
      // Alias of `blackBright`
      grey: [90, 39],
      // Alias of `blackBright`
      redBright: [91, 39],
      greenBright: [92, 39],
      yellowBright: [93, 39],
      blueBright: [94, 39],
      magentaBright: [95, 39],
      cyanBright: [96, 39],
      whiteBright: [97, 39]
    },
    bgColor: {
      bgBlack: [40, 49],
      bgRed: [41, 49],
      bgGreen: [42, 49],
      bgYellow: [43, 49],
      bgBlue: [44, 49],
      bgMagenta: [45, 49],
      bgCyan: [46, 49],
      bgWhite: [47, 49],
      // Bright color
      bgBlackBright: [100, 49],
      bgGray: [100, 49],
      // Alias of `bgBlackBright`
      bgGrey: [100, 49],
      // Alias of `bgBlackBright`
      bgRedBright: [101, 49],
      bgGreenBright: [102, 49],
      bgYellowBright: [103, 49],
      bgBlueBright: [104, 49],
      bgMagentaBright: [105, 49],
      bgCyanBright: [106, 49],
      bgWhiteBright: [107, 49]
    }
  };
  var modifierNames2 = Object.keys(styles3.modifier);
  var foregroundColorNames2 = Object.keys(styles3.color);
  var backgroundColorNames2 = Object.keys(styles3.bgColor);
  var colorNames2 = [...foregroundColorNames2, ...backgroundColorNames2];
  function assembleStyles2() {
    const codes = /* @__PURE__ */ new Map();
    for (const [groupName, group] of Object.entries(styles3)) {
      for (const [styleName, style] of Object.entries(group)) {
        styles3[styleName] = {
          open: `\x1B[${style[0]}m`,
          close: `\x1B[${style[1]}m`
        };
        group[styleName] = styles3[styleName];
        codes.set(style[0], style[1]);
      }
      Object.defineProperty(styles3, groupName, {
        value: group,
        enumerable: false
      });
    }
    Object.defineProperty(styles3, "codes", {
      value: codes,
      enumerable: false
    });
    styles3.color.close = "\x1B[39m";
    styles3.bgColor.close = "\x1B[49m";
    styles3.color.ansi = wrapAnsi162();
    styles3.color.ansi256 = wrapAnsi2562();
    styles3.color.ansi16m = wrapAnsi16m2();
    styles3.bgColor.ansi = wrapAnsi162(ANSI_BACKGROUND_OFFSET2);
    styles3.bgColor.ansi256 = wrapAnsi2562(ANSI_BACKGROUND_OFFSET2);
    styles3.bgColor.ansi16m = wrapAnsi16m2(ANSI_BACKGROUND_OFFSET2);
    Object.defineProperties(styles3, {
      rgbToAnsi256: {
        value(red, green, blue) {
          if (red === green && green === blue) {
            if (red < 8) {
              return 16;
            }
            if (red > 248) {
              return 231;
            }
            return Math.round((red - 8) / 247 * 24) + 232;
          }
          return 16 + 36 * Math.round(red / 255 * 5) + 6 * Math.round(green / 255 * 5) + Math.round(blue / 255 * 5);
        },
        enumerable: false
      },
      hexToRgb: {
        value(hex) {
          const matches = /[a-f\d]{6}|[a-f\d]{3}/i.exec(hex.toString(16));
          if (!matches) {
            return [0, 0, 0];
          }
          let [colorString] = matches;
          if (colorString.length === 3) {
            colorString = [...colorString].map((character) => character + character).join("");
          }
          const integer = Number.parseInt(colorString, 16);
          return [
            /* eslint-disable no-bitwise */
            integer >> 16 & 255,
            integer >> 8 & 255,
            integer & 255
            /* eslint-enable no-bitwise */
          ];
        },
        enumerable: false
      },
      hexToAnsi256: {
        value: (hex) => styles3.rgbToAnsi256(...styles3.hexToRgb(hex)),
        enumerable: false
      },
      ansi256ToAnsi: {
        value(code) {
          if (code < 8) {
            return 30 + code;
          }
          if (code < 16) {
            return 90 + (code - 8);
          }
          let red;
          let green;
          let blue;
          if (code >= 232) {
            red = ((code - 232) * 10 + 8) / 255;
            green = red;
            blue = red;
          } else {
            code -= 16;
            const remainder = code % 36;
            red = Math.floor(code / 36) / 5;
            green = Math.floor(remainder / 6) / 5;
            blue = remainder % 6 / 5;
          }
          const value = Math.max(red, green, blue) * 2;
          if (value === 0) {
            return 30;
          }
          let result = 30 + (Math.round(blue) << 2 | Math.round(green) << 1 | Math.round(red));
          if (value === 2) {
            result += 60;
          }
          return result;
        },
        enumerable: false
      },
      rgbToAnsi: {
        value: (red, green, blue) => styles3.ansi256ToAnsi(styles3.rgbToAnsi256(red, green, blue)),
        enumerable: false
      },
      hexToAnsi: {
        value: (hex) => styles3.ansi256ToAnsi(styles3.hexToAnsi256(hex)),
        enumerable: false
      }
    });
    return styles3;
  }
  var ansiStyles2 = assembleStyles2();
  var ansi_styles_default2 = ansiStyles2;

  // node_modules/.pnpm/chalk@5.2.0/node_modules/chalk/source/vendor/supports-color/index.js
  var import_node_process2 = __toESM(__require("node:process"), 1);
  var import_node_os3 = __toESM(__require("node:os"), 1);
  var import_node_tty2 = __toESM(__require("node:tty"), 1);
  function hasFlag2(flag, argv = globalThis.Deno ? globalThis.Deno.args : import_node_process2.default.argv) {
    const prefix = flag.startsWith("-") ? "" : flag.length === 1 ? "-" : "--";
    const position = argv.indexOf(prefix + flag);
    const terminatorPosition = argv.indexOf("--");
    return position !== -1 && (terminatorPosition === -1 || position < terminatorPosition);
  }
  var { env: env2 } = import_node_process2.default;
  var flagForceColor2;
  if (hasFlag2("no-color") || hasFlag2("no-colors") || hasFlag2("color=false") || hasFlag2("color=never")) {
    flagForceColor2 = 0;
  } else if (hasFlag2("color") || hasFlag2("colors") || hasFlag2("color=true") || hasFlag2("color=always")) {
    flagForceColor2 = 1;
  }
  function envForceColor2() {
    if ("FORCE_COLOR" in env2) {
      if (env2.FORCE_COLOR === "true") {
        return 1;
      }
      if (env2.FORCE_COLOR === "false") {
        return 0;
      }
      return env2.FORCE_COLOR.length === 0 ? 1 : Math.min(Number.parseInt(env2.FORCE_COLOR, 10), 3);
    }
  }
  function translateLevel2(level) {
    if (level === 0) {
      return false;
    }
    return {
      level,
      hasBasic: true,
      has256: level >= 2,
      has16m: level >= 3
    };
  }
  function _supportsColor2(haveStream, { streamIsTTY, sniffFlags = true } = {}) {
    const noFlagForceColor = envForceColor2();
    if (noFlagForceColor !== void 0) {
      flagForceColor2 = noFlagForceColor;
    }
    const forceColor = sniffFlags ? flagForceColor2 : noFlagForceColor;
    if (forceColor === 0) {
      return 0;
    }
    if (sniffFlags) {
      if (hasFlag2("color=16m") || hasFlag2("color=full") || hasFlag2("color=truecolor")) {
        return 3;
      }
      if (hasFlag2("color=256")) {
        return 2;
      }
    }
    if ("TF_BUILD" in env2 && "AGENT_NAME" in env2) {
      return 1;
    }
    if (haveStream && !streamIsTTY && forceColor === void 0) {
      return 0;
    }
    const min = forceColor || 0;
    if (env2.TERM === "dumb") {
      return min;
    }
    if (import_node_process2.default.platform === "win32") {
      const osRelease = import_node_os3.default.release().split(".");
      if (Number(osRelease[0]) >= 10 && Number(osRelease[2]) >= 10586) {
        return Number(osRelease[2]) >= 14931 ? 3 : 2;
      }
      return 1;
    }
    if ("CI" in env2) {
      if ("GITHUB_ACTIONS" in env2) {
        return 3;
      }
      if (["TRAVIS", "CIRCLECI", "APPVEYOR", "GITLAB_CI", "BUILDKITE", "DRONE"].some((sign) => sign in env2) || env2.CI_NAME === "codeship") {
        return 1;
      }
      return min;
    }
    if ("TEAMCITY_VERSION" in env2) {
      return /^(9\.(0*[1-9]\d*)\.|\d{2,}\.)/.test(env2.TEAMCITY_VERSION) ? 1 : 0;
    }
    if (env2.COLORTERM === "truecolor") {
      return 3;
    }
    if (env2.TERM === "xterm-kitty") {
      return 3;
    }
    if ("TERM_PROGRAM" in env2) {
      const version = Number.parseInt((env2.TERM_PROGRAM_VERSION || "").split(".")[0], 10);
      switch (env2.TERM_PROGRAM) {
        case "iTerm.app": {
          return version >= 3 ? 3 : 2;
        }
        case "Apple_Terminal": {
          return 2;
        }
      }
    }
    if (/-256(color)?$/i.test(env2.TERM)) {
      return 2;
    }
    if (/^screen|^xterm|^vt100|^vt220|^rxvt|color|ansi|cygwin|linux/i.test(env2.TERM)) {
      return 1;
    }
    if ("COLORTERM" in env2) {
      return 1;
    }
    return min;
  }
  function createSupportsColor2(stream, options = {}) {
    const level = _supportsColor2(stream, {
      streamIsTTY: stream && stream.isTTY,
      ...options
    });
    return translateLevel2(level);
  }
  var supportsColor2 = {
    stdout: createSupportsColor2({ isTTY: import_node_tty2.default.isatty(1) }),
    stderr: createSupportsColor2({ isTTY: import_node_tty2.default.isatty(2) })
  };
  var supports_color_default2 = supportsColor2;

  // node_modules/.pnpm/chalk@5.2.0/node_modules/chalk/source/utilities.js
  function stringReplaceAll2(string, substring, replacer) {
    let index = string.indexOf(substring);
    if (index === -1) {
      return string;
    }
    const substringLength = substring.length;
    let endIndex = 0;
    let returnValue = "";
    do {
      returnValue += string.slice(endIndex, index) + substring + replacer;
      endIndex = index + substringLength;
      index = string.indexOf(substring, endIndex);
    } while (index !== -1);
    returnValue += string.slice(endIndex);
    return returnValue;
  }
  function stringEncaseCRLFWithFirstIndex2(string, prefix, postfix, index) {
    let endIndex = 0;
    let returnValue = "";
    do {
      const gotCR = string[index - 1] === "\r";
      returnValue += string.slice(endIndex, gotCR ? index - 1 : index) + prefix + (gotCR ? "\r\n" : "\n") + postfix;
      endIndex = index + 1;
      index = string.indexOf("\n", endIndex);
    } while (index !== -1);
    returnValue += string.slice(endIndex);
    return returnValue;
  }

  // node_modules/.pnpm/chalk@5.2.0/node_modules/chalk/source/index.js
  var { stdout: stdoutColor2, stderr: stderrColor2 } = supports_color_default2;
  var GENERATOR2 = Symbol("GENERATOR");
  var STYLER2 = Symbol("STYLER");
  var IS_EMPTY2 = Symbol("IS_EMPTY");
  var levelMapping2 = [
    "ansi",
    "ansi",
    "ansi256",
    "ansi16m"
  ];
  var styles4 = /* @__PURE__ */ Object.create(null);
  var applyOptions2 = (object, options = {}) => {
    if (options.level && !(Number.isInteger(options.level) && options.level >= 0 && options.level <= 3)) {
      throw new Error("The `level` option should be an integer from 0 to 3");
    }
    const colorLevel = stdoutColor2 ? stdoutColor2.level : 0;
    object.level = options.level === void 0 ? colorLevel : options.level;
  };
  var chalkFactory2 = (options) => {
    const chalk5 = (...strings) => strings.join(" ");
    applyOptions2(chalk5, options);
    Object.setPrototypeOf(chalk5, createChalk2.prototype);
    return chalk5;
  };
  function createChalk2(options) {
    return chalkFactory2(options);
  }
  Object.setPrototypeOf(createChalk2.prototype, Function.prototype);
  for (const [styleName, style] of Object.entries(ansi_styles_default2)) {
    styles4[styleName] = {
      get() {
        const builder = createBuilder2(this, createStyler2(style.open, style.close, this[STYLER2]), this[IS_EMPTY2]);
        Object.defineProperty(this, styleName, { value: builder });
        return builder;
      }
    };
  }
  styles4.visible = {
    get() {
      const builder = createBuilder2(this, this[STYLER2], true);
      Object.defineProperty(this, "visible", { value: builder });
      return builder;
    }
  };
  var getModelAnsi2 = (model, level, type, ...arguments_) => {
    if (model === "rgb") {
      if (level === "ansi16m") {
        return ansi_styles_default2[type].ansi16m(...arguments_);
      }
      if (level === "ansi256") {
        return ansi_styles_default2[type].ansi256(ansi_styles_default2.rgbToAnsi256(...arguments_));
      }
      return ansi_styles_default2[type].ansi(ansi_styles_default2.rgbToAnsi(...arguments_));
    }
    if (model === "hex") {
      return getModelAnsi2("rgb", level, type, ...ansi_styles_default2.hexToRgb(...arguments_));
    }
    return ansi_styles_default2[type][model](...arguments_);
  };
  var usedModels2 = ["rgb", "hex", "ansi256"];
  for (const model of usedModels2) {
    styles4[model] = {
      get() {
        const { level } = this;
        return function(...arguments_) {
          const styler = createStyler2(getModelAnsi2(model, levelMapping2[level], "color", ...arguments_), ansi_styles_default2.color.close, this[STYLER2]);
          return createBuilder2(this, styler, this[IS_EMPTY2]);
        };
      }
    };
    const bgModel = "bg" + model[0].toUpperCase() + model.slice(1);
    styles4[bgModel] = {
      get() {
        const { level } = this;
        return function(...arguments_) {
          const styler = createStyler2(getModelAnsi2(model, levelMapping2[level], "bgColor", ...arguments_), ansi_styles_default2.bgColor.close, this[STYLER2]);
          return createBuilder2(this, styler, this[IS_EMPTY2]);
        };
      }
    };
  }
  var proto2 = Object.defineProperties(() => {
  }, {
    ...styles4,
    level: {
      enumerable: true,
      get() {
        return this[GENERATOR2].level;
      },
      set(level) {
        this[GENERATOR2].level = level;
      }
    }
  });
  var createStyler2 = (open, close, parent) => {
    let openAll;
    let closeAll;
    if (parent === void 0) {
      openAll = open;
      closeAll = close;
    } else {
      openAll = parent.openAll + open;
      closeAll = close + parent.closeAll;
    }
    return {
      open,
      close,
      openAll,
      closeAll,
      parent
    };
  };
  var createBuilder2 = (self2, _styler, _isEmpty) => {
    const builder = (...arguments_) => applyStyle2(builder, arguments_.length === 1 ? "" + arguments_[0] : arguments_.join(" "));
    Object.setPrototypeOf(builder, proto2);
    builder[GENERATOR2] = self2;
    builder[STYLER2] = _styler;
    builder[IS_EMPTY2] = _isEmpty;
    return builder;
  };
  var applyStyle2 = (self2, string) => {
    if (self2.level <= 0 || !string) {
      return self2[IS_EMPTY2] ? "" : string;
    }
    let styler = self2[STYLER2];
    if (styler === void 0) {
      return string;
    }
    const { openAll, closeAll } = styler;
    if (string.includes("\x1B")) {
      while (styler !== void 0) {
        string = stringReplaceAll2(string, styler.close, styler.open);
        styler = styler.parent;
      }
    }
    const lfIndex = string.indexOf("\n");
    if (lfIndex !== -1) {
      string = stringEncaseCRLFWithFirstIndex2(string, closeAll, openAll, lfIndex);
    }
    return openAll + string + closeAll;
  };
  Object.defineProperties(createChalk2.prototype, styles4);
  var chalk4 = createChalk2();
  var chalkStderr2 = createChalk2({ level: stderrColor2 ? stderrColor2.level : 0 });
  var source_default2 = chalk4;

  // pkgs/base/pkgs/rpc/src/server.ts
  var import_pretty_error = __toESM(require_PrettyError());
  var pe = new import_pretty_error.default();
  function getRandomArbitrary(min, max2) {
    return Math.round(Math.random() * (max2 - min) + min);
  }
  var createRPC = async (name, action2, opt) => {
    let srv = null;
    if (!config.port) {
      config.port = await getPorts({
        port: portNumbers(getRandomArbitrary(11e3, 14e3), 19e3)
      });
      srv = await createServer();
    }
    let ws = await connect2(name, action2);
    if (!ws) {
      srv = await createServer();
      ws = await connect2(name, action2);
    }
    if (opt?.isMain && !srv) {
      console.log(
        `
Royal is already running.
Make sure to kill running instance before starting.

`
      );
      process.exit(1);
    }
    return new DeepProxy(action2, ({ target, PROXY, key, path: path4, handler }) => {
      if (key) {
        if (key === "destroy") {
          return () => {
            if (srv) {
              srv.close();
            }
          };
        }
        if (key === "then") {
          return PROXY({}, handler, path4);
        }
        if (typeof target[key] === "function") {
          return target[key];
        }
        return PROXY(target[key], handler, path4);
      }
      return void 0;
    });
  };
  var connect2 = (name, action2) => {
    return new Promise((resolve) => {
      const ws = new import_websocket.default(`ws://localhost:${config.port}/create/${name}`);
      setTimeout(() => {
        if (ws.readyState !== ws.OPEN) {
          ws.close();
          resolve(false);
        }
      }, 500);
      ws.on("open", () => {
        ws.send(JSON.stringify({ type: "identify", name }));
        ws.on("message", async (raw) => {
          const msg = JSON.parse(raw);
          if (msg.type === "action") {
            const fn = (0, import_lodash2.default)(action2, msg.path.join("."));
            if (typeof fn === "undefined") {
              ws.send(
                JSON.stringify({
                  type: "action-result",
                  error: {
                    msg: `${source_default2.red(`ERROR`)}: Function ${source_default2.cyan(
                      msg.path.join(".")
                    )} not found in ${source_default2.green(name)} action`
                  },
                  clientid: msg.clientid,
                  msgid: msg.msgid
                })
              );
            }
            if (typeof fn === "function") {
              let result = void 0;
              let error = void 0;
              try {
                result = await fn(...msg.args);
              } catch (e) {
                if (typeof e === "string") {
                  error = { msg: e };
                } else {
                  error = { msg: e?.message || "" };
                }
              }
              const final = JSON.stringify({
                type: "action-result",
                result,
                error,
                clientid: msg.clientid,
                msgid: msg.msgid
              });
              ws.send(final);
            }
          }
        });
        resolve(ws);
      });
      ws.on("close", () => {
        resolve(false);
      });
      ws.on("error", () => {
        resolve(false);
      });
    });
  };
  var createServer = async () => {
    const MAX_BODY = Number.MAX_SAFE_INTEGER;
    const server = new import_hyper_express.Server({
      max_body_length: MAX_BODY,
      auto_close: true,
      trust_proxy: true,
      fast_buffers: true
    });
    const conns = {};
    server.ws("/create/:name", { max_payload_length: MAX_BODY }, (ws) => {
      ws.on("message", (raw) => {
        const msg = JSON.parse(raw);
        if (msg.type === "identify") {
          if (!conns[msg.name]) {
            conns[msg.name] = {
              server: null,
              clients: /* @__PURE__ */ new Set()
            };
          }
          conns[msg.name].server = ws;
          conns[msg.name].clients.forEach((ws2) => {
            ws2.send(
              JSON.stringify({
                type: "connected",
                serverConnected: true
              })
            );
          });
        } else if (msg.type === "action-result") {
          for (const v of Object.values(conns)) {
            v.clients.forEach((cws) => {
              if (cws.context.clientId === msg.clientid) {
                cws.send(raw);
              }
            });
          }
        }
      });
    });
    server.ws(
      "/connect/:name",
      { max_payload_length: MAX_BODY },
      (ws) => {
        ws.on("message", (raw) => {
          const msg = JSON.parse(raw);
          if (msg.type === "identify") {
            if (!conns[msg.name]) {
              conns[msg.name] = {
                server: null,
                clients: /* @__PURE__ */ new Set()
              };
            }
            ws.context.clientId = (0, import_cuid22.createId)();
            conns[msg.name].clients.add(ws);
            ws.send(
              JSON.stringify({
                type: "connected",
                serverConnected: !!conns[msg.name].server
              })
            );
          } else if (msg.type === "action") {
            let name = "";
            for (const [k, v] of Object.entries(conns)) {
              if (v.clients.has(ws)) {
                name = k;
              }
            }
            if (name && conns[name]) {
              conns[name].server?.send(
                JSON.stringify({ ...msg, clientid: ws.context.clientId })
              );
            }
          }
        });
      }
    );
    try {
      await server.listen(config.port, "localhost");
    } catch (e) {
      await server.listen(config.port, "127.0.0.1");
    }
    return server;
  };

  // pkgs/base/pkgs/bundler/bundle.ts
  init_export();
  var import_esbuild = __require("esbuild");
  var import_fs_jetpack3 = __toESM(require_main());
  var import_lodash3 = __toESM(require_lodash());
  var import_path5 = __require("path");
  var import_pretty_error2 = __toESM(require_PrettyError());
  var pe2 = new import_pretty_error2.default();
  var bundle = async (arg) => {
    const {
      input,
      output,
      watch,
      pkgjson,
      tstart,
      event,
      format,
      silent,
      splitting,
      plugins
    } = arg;
    let print = typeof silent === "undefined" ? true : !silent;
    let t0 = tstart || performance.now();
    if (!bundler.bundlers) {
      bundler.bundlers = /* @__PURE__ */ new Set();
    }
    const printableName = source_default.cyan(
      (0, import_path5.dirname)(input.substring(dir.root("").length + 1))
    );
    const tag = `Built ${(0, import_lodash3.default)(printableName, 23, " ")}`;
    return new Promise(async (resolve) => {
      try {
        let externalJson = { dependencies: {} };
        if (pkgjson) {
          let json = await (0, import_fs_jetpack3.readAsync)(pkgjson.input, "json");
          externalJson = await pkg.extractExternal(json);
          if (pkgjson.output) {
            await (0, import_fs_jetpack3.writeAsync)(pkgjson.output, externalJson);
          }
        }
        const external = [
          "esbuild",
          ...Object.keys(externalJson.dependencies),
          ...arg.external || []
        ];
        let isRebuild = false;
        const c = await (0, import_esbuild.context)({
          entryPoints: [input],
          outfile: splitting ? void 0 : output,
          outdir: splitting ? (0, import_path5.dirname)(output) : void 0,
          bundle: true,
          minify: arg.minify,
          sourcemap: true,
          platform: format === "esm" ? "browser" : "node",
          format: splitting ? "esm" : format,
          external,
          splitting,
          loader: {
            ".css": "text",
            ".png": "dataurl",
            ".webp": "dataurl",
            ".avif": "dataurl",
            ".mp4": "dataurl",
            ".jpg": "dataurl",
            ".jpeg": "dataurl",
            ".gif": "dataurl",
            ".svg": "dataurl",
            ".node": "dataurl"
          },
          define: {
            "process.env.NODE_ENV": `"production"`
          },
          plugins: [
            ...plugins || [],
            {
              name: "root",
              setup(build2) {
                build2.onStart(async () => {
                  if (isRebuild) {
                    t0 = performance.now();
                  }
                  if (event && event.onStart) {
                    await event.onStart({ isRebuild });
                  }
                });
                build2.onEnd(async () => {
                  if (event && event.onEnd) {
                    if (isRebuild && tstart !== false && print) {
                      console.log(
                        `${(0, import_lodash3.default)(tag, 30, " ")} ${formatDuration(
                          performance.now() - t0
                        )}`
                      );
                    }
                    await event.onEnd({ isRebuild });
                  }
                  if (!isRebuild) {
                    if (tstart !== false && print) {
                      console.log(
                        `${(0, import_lodash3.default)(tag, 30, " ")} ${formatDuration(
                          performance.now() - t0
                        )}`
                      );
                    }
                    isRebuild = true;
                    resolve(true);
                  }
                });
              }
            }
          ]
        });
        bundler.bundlers.add(c);
        if (watch) {
          c.watch();
        } else {
          c.rebuild();
        }
      } catch (e) {
        console.log(pe2.render(e));
        return false;
      }
    });
  };
  var formatDuration = (ms) => {
    if (ms > 1e3) {
      return `${(0, import_lodash3.default)((ms / 1e3).toFixed(3) + "", 6, " ")} s`;
    } else {
      return `${(0, import_lodash3.default)(ms.toFixed(2) + "", 6, " ")} ms`;
    }
  };

  // pkgs/base/src/builder/service-main.ts
  init_export();

  // pkgs/base/pkgs/bundler/watch.ts
  var import_watcher = __require("@parcel/watcher");
  init_export();
  var import_path6 = __require("path");
  var watcher = {
    _watches: {},
    _watcher: null,
    async dispose() {
      if (this._watcher)
        this._watcher.unsubscribe();
    },
    async watch(item) {
      if (!this._watches[item.dir]) {
        this._watches[item.dir] = /* @__PURE__ */ new Set();
      }
      this._watches[item.dir].add(item);
      if (!this._watcher) {
        this._watcher = await (0, import_watcher.subscribe)(
          dir.root(),
          (err2, changes) => {
            const keys = Object.keys(this._watches);
            const matcher = /* @__PURE__ */ new Map();
            for (const c of changes) {
              const match = keys.filter((e) => c.path.startsWith(e));
              if (match.length > 0) {
                for (const dir2 of match) {
                  const depth = c.path.substring(dir2.length + 1).split(import_path6.sep);
                  const watches = this._watches[dir2];
                  watches.forEach((e) => {
                    if (e.event) {
                      if (!e.depth || e.depth && depth.length <= e.depth) {
                        if (!matcher.has(e))
                          matcher.set(e, [c]);
                        else {
                          const found = matcher.get(e);
                          found?.push(c);
                        }
                      }
                    }
                  });
                }
              }
            }
            for (const [e, v] of matcher) {
              if (e.event)
                e.event(err2, v);
            }
          },
          {
            ignore: [
              "**/app/gen/**",
              "**/.**",
              "**/.output/**"
            ]
          }
        );
      }
    }
  };

  // pkgs/base/src/watcher/watch-service.ts
  init_export();
  var watchService = (name, event) => {
    watcher.watch({
      dir: dir.root(`app/${name}`),
      event
    });
  };

  // pkgs/base/src/builder/service-module.ts
  init_export();
  var import_fs_jetpack16 = __toESM(require_main());

  // pkgs/base/src/builder/service/prepare/db.ts
  init_export();
  var import_fs_jetpack8 = __toESM(require_main());

  // pkgs/service/pkgs/service-db/src/create-db.ts
  init_export();
  var import_fs_jetpack7 = __toESM(require_main());
  var import_lodash5 = __toESM(require_lodash());

  // pkgs/service/export.ts
  var import_catch_exit = __toESM(require_dist());
  init_export();

  // pkgs/service/src/action.ts
  init_export();
  var import_lodash4 = __toESM(require_lodash2());

  // pkgs/service/src/global.ts
  init_export();
  var svc = globalize({
    name: "svc",
    value: {
      root: null,
      definitions: {}
      // action definition
    },
    init: async (g4) => {
      g4.root = await connectRPC("root");
    }
  });

  // pkgs/service/src/create-service.ts
  init_export();
  var import_fs_jetpack4 = __toESM(require_main());

  // pkgs/service/src/service-module.ts
  init_export();

  // pkgs/service/export.ts
  var manageProcess = (name, pid) => {
    return {
      get isRunning() {
        return false;
      },
      async start() {
        return await svc.root.start({ name, pid: pid || name });
      },
      async restart() {
        return true;
      },
      async stop() {
        return true;
      }
    };
  };
  var executeAction = (arg) => {
    const { name, entry } = arg;
    let pid = arg.pid || name;
    const def = svc.definitions[name];
    if (def) {
      if (def[entry] === "function") {
        return async (...args2) => {
          return await svc.root.executeAction({
            name,
            pid,
            path: [entry],
            args: args2
          });
        };
      } else if (def[entry] === "object") {
        return new DeepProxy({}, ({ path: path4, key, PROXY }) => {
          const objkey = [entry, ...path4, key];
          if (def[objkey.join(".")] === "function") {
            return async (...args2) => {
              return await svc.root.executeAction({
                name,
                pid,
                path: objkey,
                args: args2
              });
            };
          }
          return PROXY({});
        });
      }
    } else {
      console.error(
        `Failed to call ${source_default2.magenta(
          `service.${name}.${entry}`
        )}
 Service ${source_default2.green(
          name
        )} not started yet. 

 Please put your service call inside onServiceReady(() => {})`
      );
    }
  };
  var service = new DeepProxy({}, ({ PROXY, path: path4, key }) => {
    return PROXY({}, ({ path: path5, key: key2, PROXY: PROXY2 }) => {
      if (key2 === "then")
        return PROXY2({});
      if (key2 === "_process" || key2 === "_all") {
        return manageProcess(path5[0]);
      }
      if (key2 === "_pid") {
        return PROXY2({}, ({ path: path6, key: key3 }) => {
          const pid = key3;
          return PROXY2({}, async ({ key: key4 }) => {
            if (key4 === "_process") {
              return manageProcess(path6[0], key4);
            }
            return executeAction({
              name: path6[0],
              pid,
              entry: key4
            });
          });
        });
      }
      return executeAction({ name: path5[0], entry: key2 });
    });
  });

  // pkgs/service/pkgs/service-db/src/action.ts
  var import_cuid23 = __toESM(require_cuid22());

  // pkgs/service/pkgs/service-db/src/ensure-prisma.ts
  var import_prisma_ast = __toESM(require_dist2());
  init_export();
  var import_fs_jetpack5 = __toESM(require_main());
  var import_path7 = __require("path");
  var fixPrismaName = async (path4) => {
    try {
      const pkg2 = await (0, import_fs_jetpack5.readAsync)(path4, "json");
      if (pkg2 && pkg2.name) {
        pkg2.name = pkg2.name.replace(/[\W_]+/g, "_");
        await (0, import_fs_jetpack5.writeAsync)(path4, pkg2);
      }
    } catch (e) {
    }
  };
  var ensurePrisma = async (name) => {
    const prismaPath = dir.root(`app/${name}/prisma/schema.prisma`);
    let dburl = "";
    if (!await (0, import_fs_jetpack5.existsAsync)(prismaPath)) {
      await (0, import_fs_jetpack5.dirAsync)((0, import_path7.dirname)(prismaPath));
      await (0, import_fs_jetpack5.writeAsync)(
        prismaPath,
        `generator client {
  provider = "prisma-client-js"
  output   = "./node_modules/.gen"
}

generator client_app {
  provider = "prisma-client-js"
  output   = "../node_modules/.gen"
}

datasource db {
  provider = "postgresql"
  url      = ""
}`
      );
    }
    const schemaRaw = await (0, import_fs_jetpack5.readAsync)(prismaPath, "utf8");
    if (!schemaRaw) {
      console.log(
        `Warning ${prismaPath.substring(dir.root().length + 1)} is empty.`
      );
    }
    if (schemaRaw) {
      const schema = (0, import_prisma_ast.getSchema)(schemaRaw);
      let hasModel = false;
      for (const s of schema.list) {
        if (s.type === "model") {
          hasModel = true;
        }
        if (s.type === "generator") {
          if (s.name === "client") {
            s.assignments = [
              {
                type: "assignment",
                key: "provider",
                value: '"prisma-client-js"'
              },
              {
                type: "assignment",
                key: "output",
                value: '"./node_modules/.gen"'
              }
            ];
          } else if (s.name === "client_app") {
            s.assignments = [
              {
                type: "assignment",
                key: "provider",
                value: '"prisma-client-js"'
              },
              {
                type: "assignment",
                key: "output",
                value: '"../node_modules/.gen"'
              }
            ];
          }
        } else if (s.type === "datasource") {
          s.assignments.forEach((e) => {
            if (e.type === "assignment" && e.key === "url") {
              dburl = JSON.parse(e.value.toString());
            }
          });
        }
      }
      const newSchemaRaw = (0, import_prisma_ast.printSchema)(schema).trim();
      await (0, import_fs_jetpack5.writeAsync)(prismaPath, newSchemaRaw);
      if (newSchemaRaw !== schemaRaw.trim() || !hasModel) {
        return { generated: false, pulled: false, dburl };
      }
      let prismaOutputSame = false;
      if (await (0, import_fs_jetpack5.existsAsync)(dir.root(`.output/app/${name}/schema.prisma`))) {
        prismaOutputSame = true;
        const outputSchema = await (0, import_fs_jetpack5.readAsync)(
          dir.root(`.output/app/${name}/schema.prisma`)
        );
        if (newSchemaRaw.trim() !== outputSchema?.trim()) {
          prismaOutputSame = false;
        }
      }
      await (0, import_fs_jetpack5.copyAsync)(
        dir.root(`app/${name}/prisma/schema.prisma`),
        dir.root(`.output/app/${name}/schema.prisma`),
        {
          overwrite: true
        }
      );
      if (!prismaOutputSame || !await (0, import_fs_jetpack5.existsAsync)(dir.root(`app/${name}/node_modules/.gen`))) {
        return { generated: false, pulled: true, dburl };
      }
    }
    return { generated: true, pulled: true, dburl };
  };

  // pkgs/service/pkgs/service-db/src/parse-prisma.ts
  var import_prisma_ast2 = __toESM(require_dist2());
  var import_fs_jetpack6 = __toESM(require_main());

  // pkgs/base/src/builder/service/prepare/db.ts
  var prepareDB = async (name, changes) => {
    if (!changes) {
      const prisma = await ensurePrisma(name);
      if (!prisma.generated && !!prisma.dburl) {
        console.log(`Generating prisma: ${source_default.cyan(`app/${name}`)}`);
        await runner.run({
          path: "pnpm",
          args: ["prisma", "generate"],
          cwd: dir.root(`app/${name}`),
          silent: true
        });
        await fixPrismaName(
          dir.root(`app/${name}/node_modules/.gen/package.json`)
        );
        await (0, import_fs_jetpack8.removeAsync)(dir.root(`.output/app/${name}/node_modules/.gen`));
      }
    }
    return { shouldRestart: true };
  };

  // pkgs/base/src/builder/service/prepare/srv.ts
  init_export();
  var import_fs_jetpack10 = __toESM(require_main());
  var import_promises2 = __require("fs/promises");
  var import_path10 = __require("path");

  // pkgs/base/src/scaffold/srv/api.ts
  init_export();
  var import_fs_jetpack9 = __toESM(require_main());
  var import_path9 = __require("path");

  // pkgs/base/src/scaffold/parser/traverse.ts
  var swc = __toESM(__require("@swc/core"));

  // pkgs/base/src/scaffold/parser/swc/visitor.js
  var Visitor$1 = {};
  Object.defineProperty(Visitor$1, "__esModule", { value: true });
  var Visitor_2 = Visitor$1.Visitor = void 0;
  var Visitor = class {
    visitProgram(n) {
      switch (n.type) {
        case "Module":
          return this.visitModule(n);
        case "Script":
          return this.visitScript(n);
      }
    }
    visitModule(m) {
      m.body = this.visitModuleItems(m.body);
      return m;
    }
    visitScript(m) {
      m.body = this.visitStatements(m.body);
      return m;
    }
    visitModuleItems(items) {
      return items.map(this.visitModuleItem.bind(this));
    }
    visitModuleItem(n) {
      switch (n.type) {
        case "ExportDeclaration":
        case "ExportDefaultDeclaration":
        case "ExportNamedDeclaration":
        case "ExportDefaultExpression":
        case "ImportDeclaration":
        case "ExportAllDeclaration":
        case "TsImportEqualsDeclaration":
        case "TsExportAssignment":
        case "TsNamespaceExportDeclaration":
          return this.visitModuleDeclaration(n);
        default:
          return this.visitStatement(n);
      }
    }
    visitModuleDeclaration(n) {
      switch (n.type) {
        case "ExportDeclaration":
          return this.visitExportDeclaration(n);
        case "ExportDefaultDeclaration":
          return this.visitExportDefaultDeclaration(n);
        case "ExportNamedDeclaration":
          return this.visitExportNamedDeclaration(n);
        case "ExportDefaultExpression":
          return this.visitExportDefaultExpression(n);
        case "ImportDeclaration":
          return this.visitImportDeclaration(n);
        case "ExportAllDeclaration":
          return this.visitExportAllDeclaration(n);
        case "TsImportEqualsDeclaration":
          return this.visitTsImportEqualsDeclaration(n);
        case "TsExportAssignment":
          return this.visitTsExportAssignment(n);
        case "TsNamespaceExportDeclaration":
          return this.visitTsNamespaceExportDeclaration(n);
      }
    }
    visitTsNamespaceExportDeclaration(n) {
      n.id = this.visitBindingIdentifier(n.id);
      return n;
    }
    visitTsExportAssignment(n) {
      n.expression = this.visitExpression(n.expression);
      return n;
    }
    visitTsImportEqualsDeclaration(n) {
      n.id = this.visitBindingIdentifier(n.id);
      n.moduleRef = this.visitTsModuleReference(n.moduleRef);
      return n;
    }
    visitTsModuleReference(n) {
      switch (n.type) {
        case "Identifier":
          return this.visitIdentifierReference(n);
        case "TsExternalModuleReference":
          return this.visitTsExternalModuleReference(n);
        case "TsQualifiedName":
          return this.visitTsQualifiedName(n);
      }
    }
    visitTsExternalModuleReference(n) {
      n.expression = this.visitExpression(n.expression);
      return n;
    }
    visitExportAllDeclaration(n) {
      n.source = this.visitStringLiteral(n.source);
      return n;
    }
    visitExportDefaultExpression(n) {
      n.expression = this.visitExpression(n.expression);
      return n;
    }
    visitExportNamedDeclaration(n) {
      n.specifiers = this.visitExportSpecifiers(n.specifiers);
      n.source = this.visitOptionalStringLiteral(n.source);
      return n;
    }
    visitExportSpecifiers(nodes) {
      return nodes.map(this.visitExportSpecifier.bind(this));
    }
    visitExportSpecifier(n) {
      switch (n.type) {
        case "ExportDefaultSpecifier":
          return this.visitExportDefaultSpecifier(n);
        case "ExportNamespaceSpecifier":
          return this.visitExportNamespaceSpecifier(n);
        case "ExportSpecifier":
          return this.visitNamedExportSpecifier(n);
      }
    }
    visitNamedExportSpecifier(n) {
      if (n.exported) {
        n.exported = this.visitBindingIdentifier(n.exported);
      }
      n.orig = this.visitIdentifierReference(n.orig);
      return n;
    }
    visitExportNamespaceSpecifier(n) {
      n.name = this.visitBindingIdentifier(n.name);
      return n;
    }
    visitExportDefaultSpecifier(n) {
      n.exported = this.visitBindingIdentifier(n.exported);
      return n;
    }
    visitOptionalStringLiteral(n) {
      if (n) {
        return this.visitStringLiteral(n);
      }
    }
    visitExportDefaultDeclaration(n) {
      n.decl = this.visitDefaultDeclaration(n.decl);
      return n;
    }
    visitDefaultDeclaration(n) {
      switch (n.type) {
        case "ClassExpression":
          return this.visitClassExpression(n);
        case "FunctionExpression":
          return this.visitFunctionExpression(n);
        case "TsInterfaceDeclaration":
          return this.visitTsInterfaceDeclaration(n);
      }
    }
    visitFunctionExpression(n) {
      n = this.visitFunction(n);
      if (n.identifier) {
        n.identifier = this.visitBindingIdentifier(n.identifier);
      }
      return n;
    }
    visitClassExpression(n) {
      n = this.visitClass(n);
      if (n.identifier) {
        n.identifier = this.visitBindingIdentifier(n.identifier);
      }
      return n;
    }
    visitExportDeclaration(n) {
      n.declaration = this.visitDeclaration(n.declaration);
      return n;
    }
    visitArrayExpression(e) {
      if (e.elements) {
        e.elements = e.elements.map(this.visitArrayElement.bind(this));
      }
      return e;
    }
    visitArrayElement(e) {
      if (e) {
        return this.visitExprOrSpread(e);
      }
    }
    visitExprOrSpread(e) {
      return Object.assign(Object.assign({}, e), {
        expression: this.visitExpression(e.expression)
      });
    }
    visitSpreadElement(e) {
      e.arguments = this.visitExpression(e.arguments);
      return e;
    }
    visitOptionalExpression(e) {
      if (e) {
        return this.visitExpression(e);
      }
    }
    visitArrowFunctionExpression(e) {
      e.body = this.visitArrowBody(e.body);
      e.params = this.visitPatterns(e.params);
      e.returnType = this.visitTsTypeAnnotation(e.returnType);
      e.typeParameters = this.visitTsTypeParameterDeclaration(e.typeParameters);
      return e;
    }
    visitArrowBody(body) {
      switch (body.type) {
        case "BlockStatement":
          return this.visitBlockStatement(body);
        default:
          return this.visitExpression(body);
      }
    }
    visitBlockStatement(block) {
      block.stmts = this.visitStatements(block.stmts);
      return block;
    }
    visitStatements(stmts) {
      return stmts.map(this.visitStatement.bind(this));
    }
    visitStatement(stmt) {
      switch (stmt.type) {
        case "ClassDeclaration":
        case "FunctionDeclaration":
        case "TsEnumDeclaration":
        case "TsInterfaceDeclaration":
        case "TsModuleDeclaration":
        case "TsTypeAliasDeclaration":
        case "VariableDeclaration":
          return this.visitDeclaration(stmt);
        case "BreakStatement":
          return this.visitBreakStatement(stmt);
        case "BlockStatement":
          return this.visitBlockStatement(stmt);
        case "ContinueStatement":
          return this.visitContinueStatement(stmt);
        case "DebuggerStatement":
          return this.visitDebuggerStatement(stmt);
        case "DoWhileStatement":
          return this.visitDoWhileStatement(stmt);
        case "EmptyStatement":
          return this.visitEmptyStatement(stmt);
        case "ForInStatement":
          return this.visitForInStatement(stmt);
        case "ForOfStatement":
          return this.visitForOfStatement(stmt);
        case "ForStatement":
          return this.visitForStatement(stmt);
        case "IfStatement":
          return this.visitIfStatement(stmt);
        case "LabeledStatement":
          return this.visitLabeledStatement(stmt);
        case "ReturnStatement":
          return this.visitReturnStatement(stmt);
        case "SwitchStatement":
          return this.visitSwitchStatement(stmt);
        case "ThrowStatement":
          return this.visitThrowStatement(stmt);
        case "TryStatement":
          return this.visitTryStatement(stmt);
        case "WhileStatement":
          return this.visitWhileStatement(stmt);
        case "WithStatement":
          return this.visitWithStatement(stmt);
        case "ExpressionStatement":
          return this.visitExpressionStatement(stmt);
        default:
          throw new Error(`Unknown statement type: ` + stmt.type);
      }
    }
    visitSwitchStatement(stmt) {
      stmt.discriminant = this.visitExpression(stmt.discriminant);
      stmt.cases = this.visitSwitchCases(stmt.cases);
      return stmt;
    }
    visitSwitchCases(cases) {
      return cases.map(this.visitSwitchCase.bind(this));
    }
    visitSwitchCase(c) {
      c.test = this.visitOptionalExpression(c.test);
      c.consequent = this.visitStatements(c.consequent);
      return c;
    }
    visitIfStatement(stmt) {
      stmt.test = this.visitExpression(stmt.test);
      stmt.consequent = this.visitStatement(stmt.consequent);
      stmt.alternate = this.visitOptionalStatement(stmt.alternate);
      return stmt;
    }
    visitOptionalStatement(stmt) {
      if (stmt) {
        return this.visitStatement(stmt);
      }
    }
    visitBreakStatement(stmt) {
      if (stmt.label) {
        stmt.label = this.visitLabelIdentifier(stmt.label);
      }
      return stmt;
    }
    visitWhileStatement(stmt) {
      stmt.test = this.visitExpression(stmt.test);
      stmt.body = this.visitStatement(stmt.body);
      return stmt;
    }
    visitTryStatement(stmt) {
      stmt.block = this.visitBlockStatement(stmt.block);
      stmt.handler = this.visitCatchClause(stmt.handler);
      if (stmt.finalizer) {
        stmt.finalizer = this.visitBlockStatement(stmt.finalizer);
      }
      return stmt;
    }
    visitCatchClause(handler) {
      if (handler) {
        if (handler.param) {
          handler.param = this.visitPattern(handler.param);
        }
        handler.body = this.visitBlockStatement(handler.body);
      }
      return handler;
    }
    visitThrowStatement(stmt) {
      stmt.argument = this.visitExpression(stmt.argument);
      return stmt;
    }
    visitReturnStatement(stmt) {
      if (stmt.argument) {
        stmt.argument = this.visitExpression(stmt.argument);
      }
      return stmt;
    }
    visitLabeledStatement(stmt) {
      stmt.label = this.visitLabelIdentifier(stmt.label);
      stmt.body = this.visitStatement(stmt.body);
      return stmt;
    }
    visitForStatement(stmt) {
      if (stmt.init) {
        if (stmt.init.type === "VariableDeclaration") {
          stmt.init = this.visitVariableDeclaration(stmt.init);
        } else {
          stmt.init = this.visitOptionalExpression(stmt.init);
        }
      }
      stmt.test = this.visitOptionalExpression(stmt.test);
      stmt.update = this.visitOptionalExpression(stmt.update);
      stmt.body = this.visitStatement(stmt.body);
      return stmt;
    }
    visitForOfStatement(stmt) {
      if (stmt.left.type === "VariableDeclaration") {
        stmt.left = this.visitVariableDeclaration(stmt.left);
      } else {
        stmt.left = this.visitPattern(stmt.left);
      }
      stmt.right = this.visitExpression(stmt.right);
      stmt.body = this.visitStatement(stmt.body);
      return stmt;
    }
    visitForInStatement(stmt) {
      if (stmt.left.type === "VariableDeclaration") {
        stmt.left = this.visitVariableDeclaration(stmt.left);
      } else {
        stmt.left = this.visitPattern(stmt.left);
      }
      stmt.right = this.visitExpression(stmt.right);
      stmt.body = this.visitStatement(stmt.body);
      return stmt;
    }
    visitEmptyStatement(stmt) {
      return stmt;
    }
    visitDoWhileStatement(stmt) {
      stmt.body = this.visitStatement(stmt.body);
      stmt.test = this.visitExpression(stmt.test);
      return stmt;
    }
    visitDebuggerStatement(stmt) {
      return stmt;
    }
    visitWithStatement(stmt) {
      stmt.object = this.visitExpression(stmt.object);
      stmt.body = this.visitStatement(stmt.body);
      return stmt;
    }
    visitDeclaration(decl) {
      switch (decl.type) {
        case "ClassDeclaration":
          return this.visitClassDeclaration(decl);
        case "FunctionDeclaration":
          return this.visitFunctionDeclaration(decl);
        case "TsEnumDeclaration":
          return this.visitTsEnumDeclaration(decl);
        case "TsInterfaceDeclaration":
          return this.visitTsInterfaceDeclaration(decl);
        case "TsModuleDeclaration":
          return this.visitTsModuleDeclaration(decl);
        case "TsTypeAliasDeclaration":
          return this.visitTsTypeAliasDeclaration(decl);
        case "VariableDeclaration":
          return this.visitVariableDeclaration(decl);
      }
    }
    visitVariableDeclaration(n) {
      n.declarations = this.visitVariableDeclarators(n.declarations);
      return n;
    }
    visitVariableDeclarators(nodes) {
      return nodes.map(this.visitVariableDeclarator.bind(this));
    }
    visitVariableDeclarator(n) {
      n.id = this.visitPattern(n.id);
      n.init = this.visitOptionalExpression(n.init);
      return n;
    }
    visitTsTypeAliasDeclaration(n) {
      n.id = this.visitBindingIdentifier(n.id);
      n.typeAnnotation = this.visitTsType(n.typeAnnotation);
      n.typeParams = this.visitTsTypeParameterDeclaration(n.typeParams);
      return n;
    }
    visitTsModuleDeclaration(n) {
      n.id = this.visitTsModuleName(n.id);
      if (n.body) {
        n.body = this.visitTsNamespaceBody(n.body);
      }
      return n;
    }
    visitTsModuleName(n) {
      switch (n.type) {
        case "Identifier":
          return this.visitBindingIdentifier(n);
        case "StringLiteral":
          return this.visitStringLiteral(n);
      }
    }
    visitTsNamespaceBody(n) {
      if (n) {
        switch (n.type) {
          case "TsModuleBlock":
            return this.visitTsModuleBlock(n);
          case "TsNamespaceDeclaration":
            return this.visitTsNamespaceDeclaration(n);
        }
      }
    }
    visitTsNamespaceDeclaration(n) {
      const body = this.visitTsNamespaceBody(n.body);
      if (body) {
        n.body = body;
      }
      n.id = this.visitBindingIdentifier(n.id);
      return n;
    }
    visitTsModuleBlock(n) {
      n.body = this.visitModuleItems(n.body);
      return n;
    }
    visitTsInterfaceDeclaration(n) {
      n.id = this.visitBindingIdentifier(n.id);
      n.typeParams = this.visitTsTypeParameterDeclaration(n.typeParams);
      n.extends = this.visitTsExpressionsWithTypeArguments(n.extends);
      n.body = this.visitTsInterfaceBody(n.body);
      return n;
    }
    visitTsInterfaceBody(n) {
      n.body = this.visitTsTypeElements(n.body);
      return n;
    }
    visitTsTypeElements(nodes) {
      return nodes.map(this.visitTsTypeElement.bind(this));
    }
    visitTsTypeElement(n) {
      n.params = this.visitTsFnParameters(n.params);
      n.typeAnnotation = this.visitTsTypeAnnotation(n.typeAnnotation);
      return n;
    }
    visitTsEnumDeclaration(n) {
      n.id = this.visitIdentifier(n.id);
      n.members = this.visitTsEnumMembers(n.members);
      return n;
    }
    visitTsEnumMembers(nodes) {
      return nodes.map(this.visitTsEnumMember.bind(this));
    }
    visitTsEnumMember(n) {
      n.id = this.visitTsEnumMemberId(n.id);
      n.init = this.visitOptionalExpression(n.init);
      return n;
    }
    visitTsEnumMemberId(n) {
      switch (n.type) {
        case "Identifier":
          return this.visitBindingIdentifier(n);
        case "StringLiteral":
          return this.visitStringLiteral(n);
      }
    }
    visitFunctionDeclaration(decl) {
      decl.identifier = this.visitIdentifier(decl.identifier);
      decl = this.visitFunction(decl);
      return decl;
    }
    visitClassDeclaration(decl) {
      decl = this.visitClass(decl);
      decl.identifier = this.visitIdentifier(decl.identifier);
      return decl;
    }
    visitClassBody(members) {
      return members.map(this.visitClassMember.bind(this));
    }
    visitClassMember(member) {
      switch (member.type) {
        case "ClassMethod":
          return this.visitClassMethod(member);
        case "ClassProperty":
          return this.visitClassProperty(member);
        case "Constructor":
          return this.visitConstructor(member);
        case "PrivateMethod":
          return this.visitPrivateMethod(member);
        case "PrivateProperty":
          return this.visitPrivateProperty(member);
        case "TsIndexSignature":
          return this.visitTsIndexSignature(member);
      }
    }
    visitTsIndexSignature(n) {
      n.params = this.visitTsFnParameters(n.params);
      n.typeAnnotation = this.visitTsTypeAnnotation(n.typeAnnotation);
      return n;
    }
    visitTsFnParameters(params) {
      return params.map(this.visitTsFnParameter.bind(this));
    }
    visitTsFnParameter(n) {
      n.typeAnnotation = this.visitTsTypeAnnotation(n.typeAnnotation);
      return n;
    }
    visitPrivateProperty(n) {
      n.decorators = this.visitDecorators(n.decorators);
      n.key = this.visitPrivateName(n.key);
      n.typeAnnotation = this.visitTsTypeAnnotation(n.typeAnnotation);
      n.value = this.visitOptionalExpression(n.value);
      return n;
    }
    visitPrivateMethod(n) {
      n.accessibility = this.visitAccessibility(n.accessibility);
      n.function = this.visitFunction(n.function);
      n.key = this.visitPrivateName(n.key);
      return n;
    }
    visitPrivateName(n) {
      return n;
    }
    visitConstructor(n) {
      n.accessibility = this.visitAccessibility(n.accessibility);
      n.key = this.visitPropertyName(n.key);
      n.params = this.visitConstructorParameters(n.params);
      if (n.body) {
        n.body = this.visitBlockStatement(n.body);
      }
      return n;
    }
    visitConstructorParameters(nodes) {
      return nodes.map(this.visitConstructorParameter.bind(this));
    }
    visitConstructorParameter(n) {
      switch (n.type) {
        case "TsParameterProperty":
          return this.visitTsParameterProperty(n);
        default:
          return this.visitParameter(n);
      }
    }
    visitTsParameterProperty(n) {
      n.accessibility = this.visitAccessibility(n.accessibility);
      n.decorators = this.visitDecorators(n.decorators);
      n.param = this.visitTsParameterPropertyParameter(n.param);
      return n;
    }
    visitTsParameterPropertyParameter(n) {
      n.typeAnnotation = this.visitTsTypeAnnotation(n.typeAnnotation);
      return n;
    }
    visitPropertyName(key) {
      switch (key.type) {
        case "Identifier":
          return this.visitBindingIdentifier(key);
        case "StringLiteral":
          return this.visitStringLiteral(key);
        case "NumericLiteral":
          return this.visitNumericLiteral(key);
        default:
          return this.visitComputedPropertyKey(key);
      }
    }
    visitAccessibility(n) {
      return n;
    }
    visitClassProperty(n) {
      n.accessibility = this.visitAccessibility(n.accessibility);
      n.decorators = this.visitDecorators(n.decorators);
      n.key = this.visitExpression(n.key);
      n.typeAnnotation = this.visitTsTypeAnnotation(n.typeAnnotation);
      n.value = this.visitOptionalExpression(n.value);
      return n;
    }
    visitClassMethod(n) {
      n.accessibility = this.visitAccessibility(n.accessibility);
      n.function = this.visitFunction(n.function);
      n.key = this.visitPropertyName(n.key);
      return n;
    }
    visitPropertName(n) {
      switch (n.type) {
        case "Identifier":
          return this.visitIdentifier(n);
        case "NumericLiteral":
          return this.visitNumericLiteral(n);
        case "StringLiteral":
          return this.visitStringLiteral(n);
        case "Computed":
          return this.visitComputedPropertyKey(n);
      }
    }
    visitComputedPropertyKey(n) {
      n.expression = this.visitExpression(n.expression);
      return n;
    }
    visitClass(n) {
      n.decorators = this.visitDecorators(n.decorators);
      n.superClass = this.visitOptionalExpression(n.superClass);
      n.superTypeParams = this.visitTsTypeParameterInstantiation(
        n.superTypeParams
      );
      if (n.implements) {
        n.implements = this.visitTsExpressionsWithTypeArguments(n.implements);
      }
      n.body = this.visitClassBody(n.body);
      return n;
    }
    visitFunction(n) {
      n.decorators = this.visitDecorators(n.decorators);
      n.params = this.visitParameters(n.params);
      if (n.body) {
        n.body = this.visitBlockStatement(n.body);
      }
      n.returnType = this.visitTsTypeAnnotation(n.returnType);
      n.typeParameters = this.visitTsTypeParameterDeclaration(n.typeParameters);
      return n;
    }
    visitTsExpressionsWithTypeArguments(nodes) {
      return nodes.map(this.visitTsExpressionWithTypeArguments.bind(this));
    }
    visitTsExpressionWithTypeArguments(n) {
      n.expression = this.visitTsEntityName(n.expression);
      n.typeArguments = this.visitTsTypeParameterInstantiation(n.typeArguments);
      return n;
    }
    visitTsTypeParameterInstantiation(n) {
      if (n) {
        n.params = this.visitTsTypes(n.params);
      }
      return n;
    }
    visitTsTypes(nodes) {
      return nodes.map(this.visitTsType.bind(this));
    }
    visitTsEntityName(n) {
      switch (n.type) {
        case "Identifier":
          return this.visitBindingIdentifier(n);
        case "TsQualifiedName":
          return this.visitTsQualifiedName(n);
      }
    }
    visitTsQualifiedName(n) {
      n.left = this.visitTsEntityName(n.left);
      n.right = this.visitIdentifier(n.right);
      return n;
    }
    visitDecorators(nodes) {
      if (nodes) {
        return nodes.map(this.visitDecorator.bind(this));
      }
    }
    visitDecorator(n) {
      n.expression = this.visitExpression(n.expression);
      return n;
    }
    visitExpressionStatement(stmt) {
      stmt.expression = this.visitExpression(stmt.expression);
      return stmt;
    }
    visitContinueStatement(stmt) {
      if (stmt.label) {
        stmt.label = this.visitLabelIdentifier(stmt.label);
      }
      return stmt;
    }
    visitExpression(n) {
      switch (n.type) {
        case "ArrayExpression":
          return this.visitArrayExpression(n);
        case "ArrowFunctionExpression":
          return this.visitArrowFunctionExpression(n);
        case "AssignmentExpression":
          return this.visitAssignmentExpression(n);
        case "AwaitExpression":
          return this.visitAwaitExpression(n);
        case "BinaryExpression":
          return this.visitBinaryExpression(n);
        case "BooleanLiteral":
          return this.visitBooleanLiteral(n);
        case "CallExpression":
          return this.visitCallExpression(n);
        case "ClassExpression":
          return this.visitClassExpression(n);
        case "ConditionalExpression":
          return this.visitConditionalExpression(n);
        case "FunctionExpression":
          return this.visitFunctionExpression(n);
        case "Identifier":
          return this.visitIdentifierReference(n);
        case "JSXElement":
          return this.visitJSXElement(n);
        case "JSXEmptyExpression":
          return this.visitJSXEmptyExpression(n);
        case "JSXFragment":
          return this.visitJSXFragment(n);
        case "JSXMemberExpression":
          return this.visitJSXMemberExpression(n);
        case "JSXNamespacedName":
          return this.visitJSXNamespacedName(n);
        case "JSXText":
          return this.visitJSXText(n);
        case "MemberExpression":
          return this.visitMemberExpression(n);
        case "MetaProperty":
          return this.visitMetaProperty(n);
        case "NewExpression":
          return this.visitNewExpression(n);
        case "NullLiteral":
          return this.visitNullLiteral(n);
        case "NumericLiteral":
          return this.visitNumericLiteral(n);
        case "ObjectExpression":
          return this.visitObjectExpression(n);
        case "ParenthesisExpression":
          return this.visitParenthesisExpression(n);
        case "PrivateName":
          return this.visitPrivateName(n);
        case "RegExpLiteral":
          return this.visitRegExpLiteral(n);
        case "SequenceExpression":
          return this.visitSequenceExpression(n);
        case "StringLiteral":
          return this.visitStringLiteral(n);
        case "TaggedTemplateExpression":
          return this.visitTaggedTemplateExpression(n);
        case "TemplateLiteral":
          return this.visitTemplateLiteral(n);
        case "ThisExpression":
          return this.visitThisExpression(n);
        case "TsAsExpression":
          return this.visitTsAsExpression(n);
        case "TsNonNullExpression":
          return this.visitTsNonNullExpression(n);
        case "TsTypeAssertion":
          return this.visitTsTypeAssertion(n);
        case "TsConstAssertion":
          return this.visitTsConstAssertion(n);
        case "UnaryExpression":
          return this.visitUnaryExpression(n);
        case "UpdateExpression":
          return this.visitUpdateExpression(n);
        case "YieldExpression":
          return this.visitYieldExpression(n);
        case "OptionalChainingExpression":
          return this.visitOptionalChainingExpression(n);
        case "Invalid":
          return n;
      }
    }
    visitOptionalChainingExpression(n) {
      if (n.expr) {
        n.expr = this.visitExpression(n.expr);
      }
      return n;
    }
    visitAssignmentExpression(n) {
      n.left = this.visitPatternOrExpressison(n.left);
      n.right = this.visitExpression(n.right);
      return n;
    }
    visitPatternOrExpressison(n) {
      switch (n.type) {
        case "ObjectPattern":
        case "ArrayPattern":
        case "Identifier":
        case "AssignmentPattern":
        case "RestElement":
          return this.visitPattern(n);
        default:
          return this.visitExpression(n);
      }
    }
    visitYieldExpression(n) {
      n.argument = this.visitOptionalExpression(n.argument);
      return n;
    }
    visitUpdateExpression(n) {
      n.argument = this.visitExpression(n.argument);
      return n;
    }
    visitUnaryExpression(n) {
      n.argument = this.visitExpression(n.argument);
      return n;
    }
    visitTsTypeAssertion(n) {
      n.expression = this.visitExpression(n.expression);
      n.typeAnnotation = this.visitTsType(n.typeAnnotation);
      return n;
    }
    visitTsConstAssertion(n) {
      n.expression = this.visitExpression(n.expression);
      return n;
    }
    visitTsNonNullExpression(n) {
      n.expression = this.visitExpression(n.expression);
      return n;
    }
    visitTsAsExpression(n) {
      n.expression = this.visitExpression(n.expression);
      n.typeAnnotation = this.visitTsType(n.typeAnnotation);
      return n;
    }
    visitThisExpression(n) {
      return n;
    }
    visitTemplateLiteral(n) {
      n.expressions = n.expressions.map(this.visitExpression.bind(this));
      return n;
    }
    visitParameters(n) {
      return n.map(this.visitParameter.bind(this));
    }
    visitParameter(n) {
      n.pat = this.visitPattern(n.pat);
      return n;
    }
    visitTaggedTemplateExpression(n) {
      n.tag = this.visitExpression(n.tag);
      const template = this.visitTemplateLiteral(n.template);
      if (template.type === "TemplateLiteral") {
        n.template = template;
      }
      return n;
    }
    visitSequenceExpression(n) {
      n.expressions = n.expressions.map(this.visitExpression.bind(this));
      return n;
    }
    visitRegExpLiteral(n) {
      return n;
    }
    visitParenthesisExpression(n) {
      n.expression = this.visitExpression(n.expression);
      return n;
    }
    visitObjectExpression(n) {
      if (n.properties) {
        n.properties = this.visitObjectProperties(n.properties);
      }
      return n;
    }
    visitObjectProperties(nodes) {
      return nodes.map(this.visitObjectProperty.bind(this));
    }
    visitObjectProperty(n) {
      switch (n.type) {
        case "SpreadElement":
          return this.visitSpreadElement(n);
        default:
          return this.visitProperty(n);
      }
    }
    visitProperty(n) {
      switch (n.type) {
        case "Identifier":
          return this.visitIdentifier(n);
        case "AssignmentProperty":
          return this.visitAssignmentProperty(n);
        case "GetterProperty":
          return this.visitGetterProperty(n);
        case "KeyValueProperty":
          return this.visitKeyValueProperty(n);
        case "MethodProperty":
          return this.visitMethodProperty(n);
        case "SetterProperty":
          return this.visitSetterProperty(n);
      }
    }
    visitSetterProperty(n) {
      n.key = this.visitPropertyName(n.key);
      n.param = this.visitPattern(n.param);
      if (n.body) {
        n.body = this.visitBlockStatement(n.body);
      }
      return n;
    }
    visitMethodProperty(n) {
      n.key = this.visitPropertyName(n.key);
      if (n.body) {
        n.body = this.visitBlockStatement(n.body);
      }
      n.decorators = this.visitDecorators(n.decorators);
      n.params = this.visitParameters(n.params);
      n.returnType = this.visitTsTypeAnnotation(n.returnType);
      n.typeParameters = this.visitTsTypeParameterDeclaration(n.typeParameters);
      return n;
    }
    visitKeyValueProperty(n) {
      n.key = this.visitPropertyName(n.key);
      n.value = this.visitExpression(n.value);
      return n;
    }
    visitGetterProperty(n) {
      n.key = this.visitPropertyName(n.key);
      if (n.body) {
        n.body = this.visitBlockStatement(n.body);
      }
      n.typeAnnotation = this.visitTsTypeAnnotation(n.typeAnnotation);
      return n;
    }
    visitAssignmentProperty(n) {
      n.key = this.visitIdentifier(n.key);
      n.value = this.visitExpression(n.value);
      return n;
    }
    visitNullLiteral(n) {
      return n;
    }
    visitNewExpression(n) {
      n.callee = this.visitExpression(n.callee);
      if (n.arguments) {
        n.arguments = this.visitArguments(n.arguments);
      }
      n.typeArguments = this.visitTsTypeArguments(n.typeArguments);
      return n;
    }
    visitTsTypeArguments(n) {
      if (n) {
        n.params = this.visitTsTypes(n.params);
      }
      return n;
    }
    visitArguments(nodes) {
      return nodes.map(this.visitArgument.bind(this));
    }
    visitArgument(n) {
      n.expression = this.visitExpression(n.expression);
      return n;
    }
    visitMetaProperty(n) {
      n.meta = this.visitIdentifierReference(n.meta);
      n.property = this.visitIdentifier(n.property);
      return n;
    }
    visitMemberExpression(n) {
      n.object = this.visitExpressionOrSuper(n.object);
      n.property = this.visitExpression(n.property);
      return n;
    }
    visitExpressionOrSuper(n) {
      if (n.type === "Super") {
        return n;
      }
      return this.visitExpression(n);
    }
    visitJSXText(n) {
      return n;
    }
    visitJSXNamespacedName(n) {
      n.namespace = this.visitIdentifierReference(n.namespace);
      n.name = this.visitIdentifierReference(n.name);
      return n;
    }
    visitJSXMemberExpression(n) {
      n.object = this.visitJSXObject(n.object);
      n.property = this.visitIdentifierReference(n.property);
      return n;
    }
    visitJSXObject(n) {
      switch (n.type) {
        case "Identifier":
          return this.visitIdentifierReference(n);
        case "JSXMemberExpression":
          return this.visitJSXMemberExpression(n);
      }
    }
    visitJSXFragment(n) {
      n.opening = this.visitJSXOpeningFragment(n.opening);
      if (n.children) {
        n.children = this.visitJSXElementChildren(n.children);
      }
      n.closing = this.visitJSXClosingFragment(n.closing);
      return n;
    }
    visitJSXClosingFragment(n) {
      return n;
    }
    visitJSXElementChildren(nodes) {
      return nodes.map(this.visitJSXElementChild.bind(this));
    }
    visitJSXElementChild(n) {
      switch (n.type) {
        case "JSXElement":
          return this.visitJSXElement(n);
        case "JSXExpressionContainer":
          return this.visitJSXExpressionContainer(n);
        case "JSXFragment":
          return this.visitJSXFragment(n);
        case "JSXSpreadChild":
          return this.visitJSXSpreadChild(n);
        case "JSXText":
          return this.visitJSXText(n);
      }
    }
    visitJSXExpressionContainer(n) {
      n.expression = this.visitExpression(n.expression);
      return n;
    }
    visitJSXSpreadChild(n) {
      n.expression = this.visitExpression(n.expression);
      return n;
    }
    visitJSXOpeningFragment(n) {
      return n;
    }
    visitJSXEmptyExpression(n) {
      return n;
    }
    visitJSXElement(n) {
      n.opening = this.visitJSXOpeningElement(n.opening);
      n.children = this.visitJSXElementChildren(n.children);
      n.closing = this.visitJSXClosingElement(n.closing);
      return n;
    }
    visitJSXClosingElement(n) {
      if (n) {
        n.name = this.visitJSXElementName(n.name);
      }
      return n;
    }
    visitJSXElementName(n) {
      switch (n.type) {
        case "Identifier":
          return this.visitIdentifierReference(n);
        case "JSXMemberExpression":
          return this.visitJSXMemberExpression(n);
        case "JSXNamespacedName":
          return this.visitJSXNamespacedName(n);
      }
    }
    visitJSXOpeningElement(n) {
      n.name = this.visitJSXElementName(n.name);
      n.typeArguments = this.visitTsTypeParameterInstantiation(n.typeArguments);
      n.attributes = this.visitJSXAttributes(n.attributes);
      return n;
    }
    visitJSXAttributes(attrs) {
      if (attrs) {
        return attrs.map(this.visitJSXAttributeOrSpread.bind(this));
      }
    }
    visitJSXAttributeOrSpread(n) {
      switch (n.type) {
        case "JSXAttribute":
          return this.visitJSXAttribute(n);
        case "SpreadElement":
          return this.visitSpreadElement(n);
      }
    }
    visitJSXAttribute(n) {
      n.name = this.visitJSXAttributeName(n.name);
      n.value = this.visitJSXAttributeValue(n.value);
      return n;
    }
    visitJSXAttributeValue(n) {
      if (!n) {
        return n;
      }
      switch (n.type) {
        case "BooleanLiteral":
          return this.visitBooleanLiteral(n);
        case "NullLiteral":
          return this.visitNullLiteral(n);
        case "NumericLiteral":
          return this.visitNumericLiteral(n);
        case "JSXText":
          return this.visitJSXText(n);
        case "StringLiteral":
          return this.visitStringLiteral(n);
        case "JSXElement":
          return this.visitJSXElement(n);
        case "JSXExpressionContainer":
          return this.visitJSXExpressionContainer(n);
        case "JSXFragment":
          return this.visitJSXFragment(n);
      }
      return n;
    }
    visitJSXAttributeName(n) {
      switch (n.type) {
        case "Identifier":
          return this.visitIdentifierReference(n);
        case "JSXNamespacedName":
          return this.visitJSXNamespacedName(n);
      }
    }
    visitConditionalExpression(n) {
      n.test = this.visitExpression(n.test);
      n.consequent = this.visitExpression(n.consequent);
      n.alternate = this.visitExpression(n.alternate);
      return n;
    }
    visitCallExpression(n) {
      n.callee = this.visitExpressionOrSuper(n.callee);
      n.typeArguments = this.visitTsTypeParameterInstantiation(n.typeArguments);
      if (n.arguments) {
        n.arguments = this.visitArguments(n.arguments);
      }
      return n;
    }
    visitBooleanLiteral(n) {
      return n;
    }
    visitBinaryExpression(n) {
      n.left = this.visitExpression(n.left);
      n.right = this.visitExpression(n.right);
      return n;
    }
    visitAwaitExpression(n) {
      n.argument = this.visitExpression(n.argument);
      return n;
    }
    visitTsTypeParameterDeclaration(n) {
      if (n) {
        n.parameters = this.visitTsTypeParameters(n.parameters);
      }
      return n;
    }
    visitTsTypeParameters(nodes) {
      return nodes.map(this.visitTsTypeParameter.bind(this));
    }
    visitTsTypeParameter(n) {
      if (n.constraint) {
        n.constraint = this.visitTsType(n.constraint);
      }
      if (n.default) {
        n.default = this.visitTsType(n.default);
      }
      n.name = this.visitIdentifierReference(n.name);
      return n;
    }
    visitTsTypeAnnotation(a) {
      if (a) {
        a.typeAnnotation = this.visitTsType(a.typeAnnotation);
      }
      return a;
    }
    visitTsType(n) {
      return n;
    }
    visitPatterns(nodes) {
      return nodes.map(this.visitPattern.bind(this));
    }
    visitImportDeclaration(n) {
      n.source = this.visitStringLiteral(n.source);
      n.specifiers = this.visitImportSpecifiers(n.specifiers || []);
      return n;
    }
    visitImportSpecifiers(nodes) {
      return nodes.map(this.visitImportSpecifier.bind(this));
    }
    visitImportSpecifier(node) {
      switch (node.type) {
        case "ImportDefaultSpecifier":
          return this.visitImportDefaultSpecifier(node);
        case "ImportNamespaceSpecifier":
          return this.visitImportNamespaceSpecifier(node);
        case "ImportSpecifier":
          return this.visitNamedImportSpecifier(node);
      }
    }
    visitNamedImportSpecifier(node) {
      node.local = this.visitBindingIdentifier(node.local);
      if (node.imported) {
        node.imported = this.visitIdentifierReference(node.imported);
      }
      return node;
    }
    visitImportNamespaceSpecifier(node) {
      node.local = this.visitBindingIdentifier(node.local);
      return node;
    }
    visitImportDefaultSpecifier(node) {
      node.local = this.visitBindingIdentifier(node.local);
      return node;
    }
    visitBindingIdentifier(i) {
      return this.visitIdentifier(i);
    }
    visitIdentifierReference(i) {
      return this.visitIdentifier(i);
    }
    visitLabelIdentifier(label) {
      return this.visitIdentifier(label);
    }
    visitIdentifier(n) {
      return n;
    }
    visitStringLiteral(n) {
      return n;
    }
    visitNumericLiteral(n) {
      return n;
    }
    visitPattern(n) {
      switch (n.type) {
        case "Identifier":
          return this.visitBindingIdentifier(n);
        case "ArrayPattern":
          return this.visitArrayPattern(n);
        case "ObjectPattern":
          return this.visitObjectPattern(n);
        case "AssignmentPattern":
          return this.visitAssignmentPattern(n);
        case "RestElement":
          return this.visitRestElement(n);
        default:
          return this.visitExpression(n);
      }
    }
    visitRestElement(n) {
      n.argument = this.visitPattern(n.argument);
      n.typeAnnotation = this.visitTsTypeAnnotation(n.typeAnnotation);
      return n;
    }
    visitAssignmentPattern(n) {
      n.left = this.visitPattern(n.left);
      n.right = this.visitExpression(n.right);
      n.typeAnnotation = this.visitTsTypeAnnotation(n.typeAnnotation);
      return n;
    }
    visitObjectPattern(n) {
      n.properties = this.visitObjectPatternProperties(n.properties || []);
      n.typeAnnotation = this.visitTsTypeAnnotation(n.typeAnnotation);
      return n;
    }
    visitObjectPatternProperties(nodes) {
      return nodes.map(this.visitObjectPatternProperty.bind(this));
    }
    visitObjectPatternProperty(n) {
      switch (n.type) {
        case "AssignmentPatternProperty":
          return this.visitAssignmentPatternProperty(n);
        case "KeyValuePatternProperty":
          return this.visitKeyValuePatternProperty(n);
        case "RestElement":
          return this.visitRestElement(n);
      }
    }
    visitKeyValuePatternProperty(n) {
      n.key = this.visitPropertyName(n.key);
      n.value = this.visitPattern(n.value);
      return n;
    }
    visitAssignmentPatternProperty(n) {
      n.key = this.visitBindingIdentifier(n.key);
      n.value = this.visitOptionalExpression(n.value);
      return n;
    }
    visitArrayPattern(n) {
      n.typeAnnotation = this.visitTsTypeAnnotation(n.typeAnnotation);
      n.elements = this.visitArrayPatternElements(n.elements);
      return n;
    }
    visitArrayPatternElements(nodes) {
      return nodes.map(this.visitArrayPatternElement.bind(this));
    }
    visitArrayPatternElement(n) {
      if (n) {
        n = this.visitPattern(n);
      }
      return n;
    }
  };
  Visitor_2 = Visitor$1.Visitor = Visitor;
  var _default = Visitor$1.default = Visitor;

  // pkgs/base/src/scaffold/parser/traverse.ts
  var traverse = async (source, params) => {
    const parsed = await swc.parse(source, {
      syntax: "typescript",
      tsx: true,
      target: "es2022",
      script: true
    });
    class Traverse extends _default {
      constructor() {
        super();
        const result = params(
          new Proxy(
            {},
            {
              get: (target, p, receiver) => {
                return this._parent(p);
              }
            }
          )
        );
        for (const [k, v] of Object.entries(result)) {
          this[k] = v;
        }
      }
      _parent(name) {
        return super[name];
      }
    }
    new Traverse().visitModule(parsed);
  };

  // pkgs/base/src/scaffold/parser/utils.ts
  var import_promises = __require("fs/promises");
  var import_path8 = __require("path");
  var walkDir2 = async function(directory) {
    let fileList = [];
    try {
      const files = await (0, import_promises.readdir)(directory);
      for (const file of files) {
        const p = (0, import_path8.join)(directory, file);
        if ((await (0, import_promises.stat)(p)).isDirectory()) {
          fileList = [...fileList, ...await walkDir2(p)];
        } else {
          fileList.push(p);
        }
      }
    } catch (e) {
    }
    return fileList;
  };

  // pkgs/base/src/scaffold/srv/api.ts
  var scan = async (path4) => {
    const dirs = (await walkDir2(path4)).filter(
      (e) => e.endsWith(".ts") || e.endsWith(".tsx")
    );
    return dirs;
  };
  var parseAPI = async (filePath) => {
    let name = (0, import_path9.basename)(filePath);
    name = name.substring(0, name.length - (0, import_path9.extname)(name).length).replace(/\W/gi, "_");
    const result = {
      name,
      url: "",
      file: filePath,
      params: []
    };
    const src = await (0, import_fs_jetpack9.readAsync)(filePath, "utf8");
    if (src) {
      await traverse(src, (parent) => ({
        visitObjectExpression(n) {
          for (const p of n.properties) {
            if (p.type === "KeyValueProperty" && p.key.type === "Identifier") {
              if (p.key.value === "url" && p.value.type === "StringLiteral") {
                result.url = p.value.value;
              }
            } else if (p.type === "MethodProperty" && p.key.type === "Identifier" && p.key.value === "api") {
              for (const prm of p.params) {
                if (prm.pat.type === "Identifier") {
                  result.params.push(prm.pat.value);
                }
              }
            }
          }
          return parent.visitObjectExpression(n);
        }
      }));
    }
    return result;
  };
  var generateAPI = async (name, path4) => {
    const parsed = await Promise.all((await scan(path4)).map(parseAPI));
    const content = () => (e) => {
      const filePath = e.file.substring(path4.length + 1);
      const importPath = `"../../../${name}/api/${filePath.substring(0, filePath.length - (0, import_path9.extname)(filePath).length).replace(/\\/gi, "/")}"`;
      return `export const ${e.name} = {
  name: "${e.name}",
  url: "${e.url}",
  path: "${e.file.replace(/\\/gi, "/").substring(dir.root("").length + 1)}",
  args: ${JSON.stringify(e.params)},
  handler: import(${importPath})
}`;
    };
    await (0, import_fs_jetpack9.writeAsync)(
      dir.root(`app/gen/srv/api/${name}-args.ts`),
      parsed.map((e) => {
        let page = (0, import_path9.basename)(e.file);
        page = page.substring(0, page.length - (0, import_path9.extname)(page).length).replace(/\W/gi, "_");
        return `export const ${page} = {
  url: "${e.url}",
  args: ${JSON.stringify(e.params)},
}`;
      }).join("\n")
    );
    await (0, import_fs_jetpack9.writeAsync)(
      dir.root(`app/gen/srv/api/${name}.ts`),
      parsed.map(content()).join("\n")
    );
  };
  var generateAPIEntry = async (dirs) => {
    await (0, import_fs_jetpack9.removeAsync)(dir.root(`app/gen/srv/api`));
    await (0, import_fs_jetpack9.writeAsync)(
      dir.root(`app/gen/srv/api/entry.ts`),
      dirs.map((e) => `export * as ${e} from "./${e}"`).join("\n")
    );
    await (0, import_fs_jetpack9.writeAsync)(
      dir.root(`app/gen/srv/api/entry-args.ts`),
      dirs.map((e) => `export * as ${e} from "./${e}-args"`).join("\n")
    );
  };

  // pkgs/base/src/builder/service/prepare/srv.ts
  var prepareSrv = async (name, changes) => {
    if (!changes) {
      await generateAPIEntry([name]);
      await generateAPI(name, dir.root(`app/${name}/api`));
      return { shouldRestart: false };
    }
    try {
      for (const e of changes.values()) {
        if (e.startsWith(dir.root(`app/${name}/api`))) {
          const s = await (0, import_promises2.stat)(e);
          if (s.size === 0) {
            const routeName = (0, import_path10.basename)(
              e.substring(0, e.length - (0, import_path10.extname)(e).length)
            );
            await (0, import_fs_jetpack10.writeAsync)(
              e,
              `import { apiContext } from "service-srv";
export const _ = {
  url: "/${routeName}",
  async api() {
    const { req, res } = apiContext(this);
    return "hello world";
  },
};`
            );
          }
        }
      }
    } catch (e) {
      console.error(e);
    }
    await generateAPIEntry([name]);
    await generateAPI(name, dir.root(`app/${name}/api`));
    return { shouldRestart: true };
  };

  // pkgs/base/src/builder/service/prepare/web.ts
  init_export();
  var import_fs_jetpack15 = __toESM(require_main());
  var import_promises4 = __require("fs/promises");
  var import_path14 = __require("path");

  // pkgs/base/src/scaffold/web/layout.ts
  init_export();
  var import_fs_jetpack11 = __toESM(require_main());
  var import_path11 = __require("path");
  var scan2 = async (path4) => {
    const dirs = (await walkDir2(path4)).filter(
      (e) => e.endsWith(".ts") || e.endsWith(".tsx")
    );
    return dirs;
  };
  var parse2 = async (filePath) => {
    const result = { file: filePath };
    return result;
  };
  var generateLayout = async (name, path4) => {
    const parsed = await Promise.all((await scan2(path4)).map(parse2));
    await (0, import_fs_jetpack11.writeAsync)(
      dir.root(`app/gen/web/layout/${name}.ts`),
      `export default {
${parsed.map((e) => {
        const page = e.file.substring(0, e.file.length - (0, import_path11.extname)(e.file).length).substring(path4.length + 1).replace(/\W/gi, "_");
        const filePath = e.file.substring(path4.length + 1);
        const importPath = `"../../../${name}/src/base/layout/${filePath.substring(
          0,
          filePath.length - (0, import_path11.extname)(filePath).length
        )}"`;
        return `  ${page}: import(${importPath})`;
      }).join(",\n")}
}`
    );
  };
  var generateLayoutEntry = async (dirs) => {
    await (0, import_fs_jetpack11.removeAsync)(dir.root(`app/gen/web/layout`));
    await (0, import_fs_jetpack11.writeAsync)(
      dir.root(`app/gen/web/layout/entry.ts`),
      dirs.map((e) => `export * as ${e} from "./${e}"`).join("\n")
    );
  };

  // pkgs/base/src/scaffold/web/page.ts
  init_export();
  var import_fs_jetpack12 = __toESM(require_main());
  var import_path12 = __require("path");
  var scan3 = async (path4) => {
    const dirs = (await walkDir2(path4)).filter(
      (e) => e.endsWith(".ts") || e.endsWith(".tsx")
    );
    return dirs;
  };
  var parsePage = async (filePath) => {
    const result = { url: "", ssr: false, layout: "", file: filePath };
    const src = await (0, import_fs_jetpack12.readAsync)(filePath, "utf8");
    if (src) {
      await traverse(src, (parent) => ({
        visitObjectExpression(n) {
          for (const p of n.properties) {
            if (p.type === "KeyValueProperty" && p.key.type === "Identifier") {
              if (p.key.value === "url" && p.value.type === "StringLiteral") {
                result.url = p.value.value;
              }
              if (p.key.value === "layout" && p.value.type === "StringLiteral") {
                result.layout = p.value.value;
              }
              if (p.key.value === "ssr" && p.value.type === "BooleanLiteral") {
                result.ssr = p.value.value;
              }
            }
          }
          return parent.visitObjectExpression(n);
        }
      }));
    }
    return result;
  };
  var generatePage = async (name, path4) => {
    const parsed = await Promise.all((await scan3(path4)).map(parsePage));
    const content = (ssr) => (e) => {
      const page = e.file.substring(0, e.file.length - (0, import_path12.extname)(e.file).length).substring(path4.length + 1).replace(/\W/gi, "_");
      const filePath = e.file.substring(path4.length + 1);
      const importPath = `"../../../${name}/src/base/page/${filePath.substring(
        0,
        filePath.length - (0, import_path12.extname)(filePath).length
      )}"`;
      return `export const ${page} = {
  name: "${page}",
  url: "${e.url}",
  path: "${e.file.substring(dir.root("").length + 1)}",
  ssr: ${e.ssr ? "true" : "false"},
  layout: ${e.layout ? `"${e.layout}"` : `undefined`},
  ${!ssr || e.ssr && ssr ? `component: () => import(${importPath})` : ""}
}`;
    };
    await (0, import_fs_jetpack12.writeAsync)(
      dir.root(`app/gen/web/page/${name}.ts`),
      parsed.map(content(false)).join("\n")
    );
    await (0, import_fs_jetpack12.writeAsync)(
      dir.root(`app/gen/web/page/${name}-ssr.ts`),
      parsed.map(content(true)).join("\n")
    );
  };
  var generatePageEntry = async (dirs) => {
    await (0, import_fs_jetpack12.removeAsync)(dir.root(`app/gen/web/page`));
    await (0, import_fs_jetpack12.writeAsync)(
      dir.root(`app/gen/web/page/entry.ts`),
      dirs.map((e) => `export * as ${e} from "./${e}"`).join("\n")
    );
    await (0, import_fs_jetpack12.writeAsync)(
      dir.root(`app/gen/web/page/entry-ssr.ts`),
      dirs.map((e) => `export * as ${e} from "./${e}-ssr"`).join("\n")
    );
  };

  // pkgs/base/src/scaffold/web/ssr.ts
  init_export();
  var import_fs_jetpack13 = __toESM(require_main());
  var import_path13 = __require("path");
  var scan4 = async (path4) => {
    const dirs = (await walkDir2(path4)).filter(
      (e) => e.endsWith(".ts") || e.endsWith(".tsx")
    );
    return dirs;
  };
  var parse3 = async (filePath) => {
    const result = { path: "", file: filePath };
    const src = await (0, import_fs_jetpack13.readAsync)(filePath, "utf8");
    if (src) {
      await traverse(src, (parent) => ({
        visitObjectExpression(n) {
          for (const p of n.properties) {
            if (p.type === "KeyValueProperty" && p.key.type === "Identifier") {
              if (p.key.value === "path" && p.value.type === "StringLiteral") {
                result.path = p.value.value;
              }
            }
          }
          return parent.visitObjectExpression(n);
        }
      }));
    }
    return result;
  };
  var generateSSR = async (name, path4) => {
    const parsed = await Promise.all((await scan4(path4)).map(parse3));
    await (0, import_fs_jetpack13.writeAsync)(
      dir.root(`app/gen/web/ssr/${name}.ts`),
      parsed.map((e) => {
        const page = e.file.substring(0, e.file.length - (0, import_path13.extname)(e.file).length).substring(path4.length + 1).replace(/\W/gi, "_");
        const filePath = e.file.substring(path4.length + 1);
        return `export const ${page} = ["${e.path}", import("../../../${name}/src/base/ssr/${filePath.substring(
          0,
          filePath.length - (0, import_path13.extname)(filePath).length
        )}")]`;
      }).join("\n")
    );
  };
  var generateSSREntry = async (dirs) => {
    await (0, import_fs_jetpack13.removeAsync)(dir.root(`app/gen/web/ssr`));
    await (0, import_fs_jetpack13.writeAsync)(
      dir.root(`app/gen/web/ssr/entry.ts`),
      dirs.map((e) => `export * as ${e} from "./${e}"`).join("\n")
    );
  };

  // pkgs/base/src/scaffold/web/web.ts
  init_export();
  var import_fs_jetpack14 = __toESM(require_main());
  var import_promises3 = __require("fs/promises");
  var scaffoldWeb = async () => {
    const webs = (await (0, import_promises3.readdir)(dir.root("app"))).filter(
      (e) => e.startsWith("web")
    );
    await (0, import_fs_jetpack14.writeAsync)(
      dir.path("app/gen/web/entry.ts"),
      `
${webs.map((e) => `export { App as ${e} } from "../../${e}/src/app";`).join("\n")}`
    );
  };

  // pkgs/base/src/builder/service/prepare/web.ts
  var prepareWeb = async (name, changes) => {
    if (!changes) {
      await scaffoldWeb();
      await generatePageEntry([name]);
      await generatePage(name, dir.root(`app/${name}/src/base/page`));
      await generateLayoutEntry([name]);
      await generateLayout(name, dir.root(`app/${name}/src/base/layout`));
      await generateSSREntry([name]);
      await generateSSR(name, dir.root(`app/${name}/src/base/ssr`));
      return { shouldRestart: false };
    }
    try {
      for (const e of changes.values()) {
        if (e.startsWith(dir.root(`app/${name}/src/base/page`))) {
          const s = await (0, import_promises4.stat)(e);
          if (s.size === 0) {
            const routeName = (0, import_path14.basename)(
              e.substring(0, e.length - (0, import_path14.extname)(e).length)
            );
            await (0, import_fs_jetpack15.writeAsync)(
              e,
              `import { page } from "web-init";

export default page({
  url: "/${routeName}",
  component: ({ }) => {
    return <div>Hello World</div>;
  },
});
`
            );
            await generatePageEntry([name]);
            await generatePage(name, dir.root(`app/${name}/src/base/page`));
          }
        }
      }
    } catch (e) {
      console.error(e);
    }
    return { shouldRestart: true };
  };

  // pkgs/base/src/builder/service/prepare.ts
  var prepareBuild = async (name, mark) => {
    if (name.startsWith("db"))
      return await prepareDB(name, mark);
    if (name.startsWith("srv"))
      return await prepareSrv(name, mark);
    if (name.startsWith("web"))
      return await prepareWeb(name, mark);
    return { shouldRestart: false };
  };

  // pkgs/base/src/builder/service-module.ts
  var buildServiceModule = async (name, arg) => {
    if (await (0, import_fs_jetpack16.existsAsync)(dir.root(`app/${name}/module.ts`))) {
      await bundle({
        input: dir.root(`app/${name}/module.ts`),
        output: dir.root(`.output/app/${name}/module.js`),
        tstart: false,
        watch: arg.watch,
        pkgjson: {
          input: dir.root(`app/${name}/package.json`)
        },
        event: arg.watch ? {
          async onStart({}) {
            await prepareBuild(name);
          },
          async onEnd({ isRebuild }) {
            if (isRebuild) {
              console.log(`${source_default.magenta("Reload")}  ${source_default.green(name)}`);
            }
          }
        } : void 0
      });
    }
  };

  // pkgs/base/src/builder/service-main.ts
  var marker = {};
  var buildServiceMain = async (name, arg) => {
    const tstart = performance.now();
    let shouldRestart = false;
    await buildServiceModule(name, arg);
    await bundle({
      input: dir.root(`app/${name}/main.ts`),
      output: dir.root(`.output/app/${name}/index.js`),
      tstart,
      pkgjson: {
        input: dir.root(`app/${name}/package.json`),
        output: dir.root(`.output/app/${name}/package.json`)
      },
      watch: arg.watch,
      event: arg.watch ? {
        async onStart({ isRebuild }) {
          shouldRestart = true;
          if (marker["*"])
            return;
          if (isRebuild && runner.list[baseGlobal.app.output]) {
            const mark = marker[name];
            if (mark) {
              if (mark instanceof Set) {
                const res = await prepareBuild(name, mark);
                if (res)
                  shouldRestart = res.shouldRestart;
                delete marker[name];
              } else if (mark === "skip") {
                delete marker[name];
              }
            }
          }
        },
        async onEnd({ isRebuild }) {
          if (isRebuild) {
            if (shouldRestart) {
              await baseGlobal.rpc.service.restart({ name });
            }
          }
        }
      } : void 0
    });
    watchService(name, async (err2, changes) => {
      if (!err2) {
        for (const c of changes) {
          if (c.type === "update") {
            const basePath = c.path.substring(dir.root(`app/${name}`).length + 1);
            if (basePath === "package.json") {
              marker[name] = "skip";
              await pkg.install(c.path);
              await baseGlobal.rpc.service.restart({ name });
              return;
            }
            if (basePath === "main.ts") {
              process.exit(99);
              return;
            }
            if (!marker[name])
              marker[name] = /* @__PURE__ */ new Set();
            const mark = marker[name];
            if (mark) {
              if (mark instanceof Set) {
                mark.add(c.path);
              }
            }
          }
        }
        const deladd = changes.filter((e) => e.type !== "update");
        if (deladd.length > 0) {
          marker[name] = "skip";
          await prepareBuild(name, new Set(deladd.map((e) => e.path)));
          await baseGlobal.rpc.service.restart({ name });
          setTimeout(() => {
            baseGlobal.rpc.service.restart({ name });
          }, 500);
        }
      }
    });
  };

  // pkgs/base/src/action.ts
  var baseGlobal = global;
  var action = {
    rebuildService: async (name) => {
      return await buildServiceMain(name, {
        watch: true
      });
    }
  };

  // pkgs/base/src/builder/build-app.ts
  init_export();
  var import_fs_jetpack18 = __toESM(require_main());
  var g2 = global;
  var buildMainApp = async (app) => {
    await bundle({
      input: app.input,
      output: app.output,
      format: "iife",
      pkgjson: {
        input: dir.root("app/package.json"),
        output: dir.root(".output/app/package.json")
      }
    });
    const src = await (0, import_fs_jetpack18.readAsync)(app.output, "utf8");
    await (0, import_fs_jetpack18.writeAsync)(
      app.output,
      `/*
\u2584\u2584\u2584         \u2584\xB7 \u2584\u258C \u2584\u2584\u2584\xB7 \u2584\u2584\u258C
\u2580\u2584 \u2588\xB7\u25AA     \u2590\u2588\u25AA\u2588\u2588\u258C\u2590\u2588 \u2580\u2588 \u2588\u2588\u2022
\u2590\u2580\u2580\u2584  \u2584\u2588\u2580\u2584 \u2590\u2588\u258C\u2590\u2588\u25AA\u2584\u2588\u2580\u2580\u2588 \u2588\u2588\u25AA
\u2590\u2588\u2022\u2588\u258C\u2590\u2588\u258C.\u2590\u258C \u2590\u2588\u2580\xB7.\u2590\u2588 \u25AA\u2590\u258C\u2590\u2588\u258C\u2590\u258C
.\u2580  \u2580 \u2580\u2588\u2584\u2580\u25AA  \u2580 \u2022  \u2580  \u2580 .\u2580\u2580\u2580
 */
(async () => {
  const { spawn } = require("child_process");
  const { existsSync } = require("fs");
  const { join } = require("path");
  if (!existsSync(join(process.cwd(), "node_modules"))) {
    await new Promise((resolve) => {
      console.log("Installing deps:", process.cwd());
      const pnpm = spawn("pnpm", ["i"], { stdio: "inherit", shell: true });
      pnpm.on("exit", resolve);
    });
  }
${src}
})()`
    );
    if (await (0, import_fs_jetpack18.existsAsync)(dir.root("app/build.ts"))) {
      try {
        const res = await Promise.resolve().then(() => (init_build(), build_exports));
        if (res && typeof res.build === "function") {
          console.log("\u203A Run app/build.ts");
        }
        g2.afterBuild = await res.build(baseGlobal.mode);
      } catch (e) {
        console.error("Failed to run app/build.ts", e);
      }
    }
  };

  // pkgs/base/src/builder/service/postrun/web.ts
  var import_child_process3 = __require("child_process");
  init_export();
  var import_fs_jetpack19 = __toESM(require_main());
  var import_path15 = __require("path");
  var postRunWeb = async (name) => {
    const src = await (0, import_fs_jetpack19.readAsync)(dir.root(`app/${name}/main.ts`), "utf8");
    let entry = "";
    if (src) {
      await traverse(src, (parent) => ({
        visitObjectExpression(n) {
          for (const p of n.properties) {
            if (p.type === "KeyValueProperty" && p.key.type === "Identifier" && p.key.value === "entry" && p.value.type === "StringLiteral") {
              entry = p.value.value;
            }
          }
          return parent.visitObjectExpression(n);
        }
      }));
    }
    if (entry) {
      await (0, import_fs_jetpack19.removeAsync)(dir.root(`.output/app/${name}/public`));
      const args2 = [
        (0, import_path15.join)(..."node_modules/parcel/lib/bin.js".split("/")),
        baseGlobal.mode === "dev" ? "watch" : "build",
        entry,
        baseGlobal.mode === "dev" ? "--no-hmr" : "--no-optimize",
        "--dist-dir",
        dir.root(`.output/app/${name}/public`)
      ].filter((e) => e);
      const parcel = (0, import_child_process3.spawn)("node", args2, {
        cwd: dir.root(`app/${name}`),
        stdio: ["ignore", "inherit", "inherit"]
      });
      baseGlobal.parcels.add(parcel);
      if (baseGlobal.mode !== "dev") {
        await new Promise((resolve) => {
          parcel.on("exit", resolve);
        });
      }
      setTimeout(async () => {
        const list = await (0, import_fs_jetpack19.listAsync)(dir.root(`.output/app/${name}/public`));
        if (list && list.length === 0) {
          console.log(
            `WARNING: parcel is hanging. Please exit nodejs process for:
 ${dir.root(
              `app/${name}/node_modules/parcel/lib/bin.js`
            )} `
          );
        }
      }, 5e3);
    } else {
      console.error(
        `${source_default.red(`ERROR:`)} Property ${source_default.cyan(
          `entry`
        )} not found in: ${source_default.green(`app/${name}/main.ts`)}`
      );
    }
  };

  // pkgs/base/src/builder/service/postrun.ts
  var postRun = async (name) => {
    if (name.startsWith("web"))
      await postRunWeb(name);
  };

  // pkgs/base/src/cleanup.ts
  var attachCleanUp = () => {
    let exiting = false;
    function exitHandler(code) {
      if (!exiting) {
        exiting = true;
        if (bundler.bundlers) {
          bundler.bundlers.forEach((ctx) => {
            ctx.dispose();
          });
        }
        if (baseGlobal.parcels) {
          baseGlobal.parcels.forEach((e) => e.kill(9));
        }
        if (bundler.runs) {
          for (const runs of Object.values(bundler.runs)) {
            runs.forEach(async (run) => {
              await run.kill();
            });
          }
        }
        console.log("Exit because of:", this.cause);
        process.exit(typeof code === "number" ? code : 0);
      }
    }
    process.on(
      "exit",
      exitHandler.bind({ cause: "NORMAL EXIT -> process.exit(0)" })
    );
    process.on("SIGINT", exitHandler.bind({ cause: "SIGINT (ctrl+c)" }));
    process.on("SIGUSR1", exitHandler.bind({ cause: "SIGUSR1" }));
    process.on("SIGUSR2", exitHandler.bind({ cause: "SIGUSR1" }));
    process.on(
      "uncaughtException",
      exitHandler.bind({ cause: "UNCAUGHT EXCEPTION" })
    );
  };

  // pkgs/base/src/commit-hook.ts
  init_export();
  var import_fs_jetpack20 = __toESM(require_main());

  // node_modules/.pnpm/execa@7.1.1/node_modules/execa/index.js
  var import_node_buffer2 = __require("node:buffer");
  var import_node_path2 = __toESM(__require("node:path"), 1);
  var import_node_child_process3 = __toESM(__require("node:child_process"), 1);
  var import_node_process5 = __toESM(__require("node:process"), 1);
  var import_cross_spawn = __toESM(require_cross_spawn(), 1);

  // node_modules/.pnpm/strip-final-newline@3.0.0/node_modules/strip-final-newline/index.js
  function stripFinalNewline(input) {
    const LF = typeof input === "string" ? "\n" : "\n".charCodeAt();
    const CR = typeof input === "string" ? "\r" : "\r".charCodeAt();
    if (input[input.length - 1] === LF) {
      input = input.slice(0, -1);
    }
    if (input[input.length - 1] === CR) {
      input = input.slice(0, -1);
    }
    return input;
  }

  // node_modules/.pnpm/npm-run-path@5.1.0/node_modules/npm-run-path/index.js
  var import_node_process3 = __toESM(__require("node:process"), 1);
  var import_node_path = __toESM(__require("node:path"), 1);
  var import_node_url = __toESM(__require("node:url"), 1);

  // node_modules/.pnpm/path-key@4.0.0/node_modules/path-key/index.js
  function pathKey(options = {}) {
    const {
      env: env3 = process.env,
      platform = process.platform
    } = options;
    if (platform !== "win32") {
      return "PATH";
    }
    return Object.keys(env3).reverse().find((key) => key.toUpperCase() === "PATH") || "Path";
  }

  // node_modules/.pnpm/npm-run-path@5.1.0/node_modules/npm-run-path/index.js
  function npmRunPath(options = {}) {
    const {
      cwd: cwd2 = import_node_process3.default.cwd(),
      path: path_ = import_node_process3.default.env[pathKey()],
      execPath = import_node_process3.default.execPath
    } = options;
    let previous;
    const cwdString = cwd2 instanceof URL ? import_node_url.default.fileURLToPath(cwd2) : cwd2;
    let cwdPath = import_node_path.default.resolve(cwdString);
    const result = [];
    while (previous !== cwdPath) {
      result.push(import_node_path.default.join(cwdPath, "node_modules/.bin"));
      previous = cwdPath;
      cwdPath = import_node_path.default.resolve(cwdPath, "..");
    }
    result.push(import_node_path.default.resolve(cwdString, execPath, ".."));
    return [...result, path_].join(import_node_path.default.delimiter);
  }
  function npmRunPathEnv({ env: env3 = import_node_process3.default.env, ...options } = {}) {
    env3 = { ...env3 };
    const path4 = pathKey({ env: env3 });
    options.path = env3[path4];
    env3[path4] = npmRunPath(options);
    return env3;
  }

  // node_modules/.pnpm/mimic-fn@4.0.0/node_modules/mimic-fn/index.js
  var copyProperty = (to, from, property, ignoreNonConfigurable) => {
    if (property === "length" || property === "prototype") {
      return;
    }
    if (property === "arguments" || property === "caller") {
      return;
    }
    const toDescriptor = Object.getOwnPropertyDescriptor(to, property);
    const fromDescriptor = Object.getOwnPropertyDescriptor(from, property);
    if (!canCopyProperty(toDescriptor, fromDescriptor) && ignoreNonConfigurable) {
      return;
    }
    Object.defineProperty(to, property, fromDescriptor);
  };
  var canCopyProperty = function(toDescriptor, fromDescriptor) {
    return toDescriptor === void 0 || toDescriptor.configurable || toDescriptor.writable === fromDescriptor.writable && toDescriptor.enumerable === fromDescriptor.enumerable && toDescriptor.configurable === fromDescriptor.configurable && (toDescriptor.writable || toDescriptor.value === fromDescriptor.value);
  };
  var changePrototype = (to, from) => {
    const fromPrototype = Object.getPrototypeOf(from);
    if (fromPrototype === Object.getPrototypeOf(to)) {
      return;
    }
    Object.setPrototypeOf(to, fromPrototype);
  };
  var wrappedToString = (withName, fromBody) => `/* Wrapped ${withName}*/
${fromBody}`;
  var toStringDescriptor = Object.getOwnPropertyDescriptor(Function.prototype, "toString");
  var toStringName = Object.getOwnPropertyDescriptor(Function.prototype.toString, "name");
  var changeToString = (to, from, name) => {
    const withName = name === "" ? "" : `with ${name.trim()}() `;
    const newToString = wrappedToString.bind(null, withName, from.toString());
    Object.defineProperty(newToString, "name", toStringName);
    Object.defineProperty(to, "toString", { ...toStringDescriptor, value: newToString });
  };
  function mimicFunction(to, from, { ignoreNonConfigurable = false } = {}) {
    const { name } = to;
    for (const property of Reflect.ownKeys(from)) {
      copyProperty(to, from, property, ignoreNonConfigurable);
    }
    changePrototype(to, from);
    changeToString(to, from, name);
    return to;
  }

  // node_modules/.pnpm/onetime@6.0.0/node_modules/onetime/index.js
  var calledFunctions = /* @__PURE__ */ new WeakMap();
  var onetime = (function_, options = {}) => {
    if (typeof function_ !== "function") {
      throw new TypeError("Expected a function");
    }
    let returnValue;
    let callCount = 0;
    const functionName = function_.displayName || function_.name || "<anonymous>";
    const onetime2 = function(...arguments_) {
      calledFunctions.set(onetime2, ++callCount);
      if (callCount === 1) {
        returnValue = function_.apply(this, arguments_);
        function_ = null;
      } else if (options.throw === true) {
        throw new Error(`Function \`${functionName}\` can only be called once`);
      }
      return returnValue;
    };
    mimicFunction(onetime2, function_);
    calledFunctions.set(onetime2, callCount);
    return onetime2;
  };
  onetime.callCount = (function_) => {
    if (!calledFunctions.has(function_)) {
      throw new Error(`The given function \`${function_.name}\` is not wrapped by the \`onetime\` package`);
    }
    return calledFunctions.get(function_);
  };
  var onetime_default = onetime;

  // node_modules/.pnpm/human-signals@4.3.1/node_modules/human-signals/build/src/main.js
  var import_node_os5 = __require("node:os");

  // node_modules/.pnpm/human-signals@4.3.1/node_modules/human-signals/build/src/realtime.js
  var getRealtimeSignals = () => {
    const length = SIGRTMAX - SIGRTMIN + 1;
    return Array.from({ length }, getRealtimeSignal);
  };
  var getRealtimeSignal = (value, index) => ({
    name: `SIGRT${index + 1}`,
    number: SIGRTMIN + index,
    action: "terminate",
    description: "Application-specific signal (realtime)",
    standard: "posix"
  });
  var SIGRTMIN = 34;
  var SIGRTMAX = 64;

  // node_modules/.pnpm/human-signals@4.3.1/node_modules/human-signals/build/src/signals.js
  var import_node_os4 = __require("node:os");

  // node_modules/.pnpm/human-signals@4.3.1/node_modules/human-signals/build/src/core.js
  var SIGNALS = [
    {
      name: "SIGHUP",
      number: 1,
      action: "terminate",
      description: "Terminal closed",
      standard: "posix"
    },
    {
      name: "SIGINT",
      number: 2,
      action: "terminate",
      description: "User interruption with CTRL-C",
      standard: "ansi"
    },
    {
      name: "SIGQUIT",
      number: 3,
      action: "core",
      description: "User interruption with CTRL-\\",
      standard: "posix"
    },
    {
      name: "SIGILL",
      number: 4,
      action: "core",
      description: "Invalid machine instruction",
      standard: "ansi"
    },
    {
      name: "SIGTRAP",
      number: 5,
      action: "core",
      description: "Debugger breakpoint",
      standard: "posix"
    },
    {
      name: "SIGABRT",
      number: 6,
      action: "core",
      description: "Aborted",
      standard: "ansi"
    },
    {
      name: "SIGIOT",
      number: 6,
      action: "core",
      description: "Aborted",
      standard: "bsd"
    },
    {
      name: "SIGBUS",
      number: 7,
      action: "core",
      description: "Bus error due to misaligned, non-existing address or paging error",
      standard: "bsd"
    },
    {
      name: "SIGEMT",
      number: 7,
      action: "terminate",
      description: "Command should be emulated but is not implemented",
      standard: "other"
    },
    {
      name: "SIGFPE",
      number: 8,
      action: "core",
      description: "Floating point arithmetic error",
      standard: "ansi"
    },
    {
      name: "SIGKILL",
      number: 9,
      action: "terminate",
      description: "Forced termination",
      standard: "posix",
      forced: true
    },
    {
      name: "SIGUSR1",
      number: 10,
      action: "terminate",
      description: "Application-specific signal",
      standard: "posix"
    },
    {
      name: "SIGSEGV",
      number: 11,
      action: "core",
      description: "Segmentation fault",
      standard: "ansi"
    },
    {
      name: "SIGUSR2",
      number: 12,
      action: "terminate",
      description: "Application-specific signal",
      standard: "posix"
    },
    {
      name: "SIGPIPE",
      number: 13,
      action: "terminate",
      description: "Broken pipe or socket",
      standard: "posix"
    },
    {
      name: "SIGALRM",
      number: 14,
      action: "terminate",
      description: "Timeout or timer",
      standard: "posix"
    },
    {
      name: "SIGTERM",
      number: 15,
      action: "terminate",
      description: "Termination",
      standard: "ansi"
    },
    {
      name: "SIGSTKFLT",
      number: 16,
      action: "terminate",
      description: "Stack is empty or overflowed",
      standard: "other"
    },
    {
      name: "SIGCHLD",
      number: 17,
      action: "ignore",
      description: "Child process terminated, paused or unpaused",
      standard: "posix"
    },
    {
      name: "SIGCLD",
      number: 17,
      action: "ignore",
      description: "Child process terminated, paused or unpaused",
      standard: "other"
    },
    {
      name: "SIGCONT",
      number: 18,
      action: "unpause",
      description: "Unpaused",
      standard: "posix",
      forced: true
    },
    {
      name: "SIGSTOP",
      number: 19,
      action: "pause",
      description: "Paused",
      standard: "posix",
      forced: true
    },
    {
      name: "SIGTSTP",
      number: 20,
      action: "pause",
      description: 'Paused using CTRL-Z or "suspend"',
      standard: "posix"
    },
    {
      name: "SIGTTIN",
      number: 21,
      action: "pause",
      description: "Background process cannot read terminal input",
      standard: "posix"
    },
    {
      name: "SIGBREAK",
      number: 21,
      action: "terminate",
      description: "User interruption with CTRL-BREAK",
      standard: "other"
    },
    {
      name: "SIGTTOU",
      number: 22,
      action: "pause",
      description: "Background process cannot write to terminal output",
      standard: "posix"
    },
    {
      name: "SIGURG",
      number: 23,
      action: "ignore",
      description: "Socket received out-of-band data",
      standard: "bsd"
    },
    {
      name: "SIGXCPU",
      number: 24,
      action: "core",
      description: "Process timed out",
      standard: "bsd"
    },
    {
      name: "SIGXFSZ",
      number: 25,
      action: "core",
      description: "File too big",
      standard: "bsd"
    },
    {
      name: "SIGVTALRM",
      number: 26,
      action: "terminate",
      description: "Timeout or timer",
      standard: "bsd"
    },
    {
      name: "SIGPROF",
      number: 27,
      action: "terminate",
      description: "Timeout or timer",
      standard: "bsd"
    },
    {
      name: "SIGWINCH",
      number: 28,
      action: "ignore",
      description: "Terminal window size changed",
      standard: "bsd"
    },
    {
      name: "SIGIO",
      number: 29,
      action: "terminate",
      description: "I/O is available",
      standard: "other"
    },
    {
      name: "SIGPOLL",
      number: 29,
      action: "terminate",
      description: "Watched event",
      standard: "other"
    },
    {
      name: "SIGINFO",
      number: 29,
      action: "ignore",
      description: "Request for process information",
      standard: "other"
    },
    {
      name: "SIGPWR",
      number: 30,
      action: "terminate",
      description: "Device running out of power",
      standard: "systemv"
    },
    {
      name: "SIGSYS",
      number: 31,
      action: "core",
      description: "Invalid system call",
      standard: "other"
    },
    {
      name: "SIGUNUSED",
      number: 31,
      action: "terminate",
      description: "Invalid system call",
      standard: "other"
    }
  ];

  // node_modules/.pnpm/human-signals@4.3.1/node_modules/human-signals/build/src/signals.js
  var getSignals = () => {
    const realtimeSignals = getRealtimeSignals();
    const signals = [...SIGNALS, ...realtimeSignals].map(normalizeSignal);
    return signals;
  };
  var normalizeSignal = ({
    name,
    number: defaultNumber,
    description,
    action: action2,
    forced = false,
    standard
  }) => {
    const {
      signals: { [name]: constantSignal }
    } = import_node_os4.constants;
    const supported = constantSignal !== void 0;
    const number = supported ? constantSignal : defaultNumber;
    return { name, number, description, supported, action: action2, forced, standard };
  };

  // node_modules/.pnpm/human-signals@4.3.1/node_modules/human-signals/build/src/main.js
  var getSignalsByName = () => {
    const signals = getSignals();
    return Object.fromEntries(signals.map(getSignalByName));
  };
  var getSignalByName = ({
    name,
    number,
    description,
    supported,
    action: action2,
    forced,
    standard
  }) => [name, { name, number, description, supported, action: action2, forced, standard }];
  var signalsByName = getSignalsByName();
  var getSignalsByNumber = () => {
    const signals = getSignals();
    const length = SIGRTMAX + 1;
    const signalsA = Array.from({ length }, (value, number) => getSignalByNumber(number, signals));
    return Object.assign({}, ...signalsA);
  };
  var getSignalByNumber = (number, signals) => {
    const signal = findSignalByNumber(number, signals);
    if (signal === void 0) {
      return {};
    }
    const { name, description, supported, action: action2, forced, standard } = signal;
    return {
      [number]: {
        name,
        number,
        description,
        supported,
        action: action2,
        forced,
        standard
      }
    };
  };
  var findSignalByNumber = (number, signals) => {
    const signal = signals.find(({ name }) => import_node_os5.constants.signals[name] === number);
    if (signal !== void 0) {
      return signal;
    }
    return signals.find((signalA) => signalA.number === number);
  };
  var signalsByNumber = getSignalsByNumber();

  // node_modules/.pnpm/execa@7.1.1/node_modules/execa/lib/error.js
  var getErrorPrefix = ({ timedOut, timeout, errorCode, signal, signalDescription, exitCode, isCanceled }) => {
    if (timedOut) {
      return `timed out after ${timeout} milliseconds`;
    }
    if (isCanceled) {
      return "was canceled";
    }
    if (errorCode !== void 0) {
      return `failed with ${errorCode}`;
    }
    if (signal !== void 0) {
      return `was killed with ${signal} (${signalDescription})`;
    }
    if (exitCode !== void 0) {
      return `failed with exit code ${exitCode}`;
    }
    return "failed";
  };
  var makeError = ({
    stdout,
    stderr,
    all,
    error,
    signal,
    exitCode,
    command,
    escapedCommand,
    timedOut,
    isCanceled,
    killed,
    parsed: { options: { timeout } }
  }) => {
    exitCode = exitCode === null ? void 0 : exitCode;
    signal = signal === null ? void 0 : signal;
    const signalDescription = signal === void 0 ? void 0 : signalsByName[signal].description;
    const errorCode = error && error.code;
    const prefix = getErrorPrefix({ timedOut, timeout, errorCode, signal, signalDescription, exitCode, isCanceled });
    const execaMessage = `Command ${prefix}: ${command}`;
    const isError = Object.prototype.toString.call(error) === "[object Error]";
    const shortMessage = isError ? `${execaMessage}
${error.message}` : execaMessage;
    const message = [shortMessage, stderr, stdout].filter(Boolean).join("\n");
    if (isError) {
      error.originalMessage = error.message;
      error.message = message;
    } else {
      error = new Error(message);
    }
    error.shortMessage = shortMessage;
    error.command = command;
    error.escapedCommand = escapedCommand;
    error.exitCode = exitCode;
    error.signal = signal;
    error.signalDescription = signalDescription;
    error.stdout = stdout;
    error.stderr = stderr;
    if (all !== void 0) {
      error.all = all;
    }
    if ("bufferedData" in error) {
      delete error.bufferedData;
    }
    error.failed = true;
    error.timedOut = Boolean(timedOut);
    error.isCanceled = isCanceled;
    error.killed = killed && !timedOut;
    return error;
  };

  // node_modules/.pnpm/execa@7.1.1/node_modules/execa/lib/stdio.js
  var aliases = ["stdin", "stdout", "stderr"];
  var hasAlias = (options) => aliases.some((alias) => options[alias] !== void 0);
  var normalizeStdio = (options) => {
    if (!options) {
      return;
    }
    const { stdio } = options;
    if (stdio === void 0) {
      return aliases.map((alias) => options[alias]);
    }
    if (hasAlias(options)) {
      throw new Error(`It's not possible to provide \`stdio\` in combination with one of ${aliases.map((alias) => `\`${alias}\``).join(", ")}`);
    }
    if (typeof stdio === "string") {
      return stdio;
    }
    if (!Array.isArray(stdio)) {
      throw new TypeError(`Expected \`stdio\` to be of type \`string\` or \`Array\`, got \`${typeof stdio}\``);
    }
    const length = Math.max(stdio.length, aliases.length);
    return Array.from({ length }, (value, index) => stdio[index]);
  };

  // node_modules/.pnpm/execa@7.1.1/node_modules/execa/lib/kill.js
  var import_node_os6 = __toESM(__require("node:os"), 1);
  var import_signal_exit = __toESM(require_signal_exit(), 1);
  var DEFAULT_FORCE_KILL_TIMEOUT = 1e3 * 5;
  var spawnedKill = (kill, signal = "SIGTERM", options = {}) => {
    const killResult = kill(signal);
    setKillTimeout(kill, signal, options, killResult);
    return killResult;
  };
  var setKillTimeout = (kill, signal, options, killResult) => {
    if (!shouldForceKill(signal, options, killResult)) {
      return;
    }
    const timeout = getForceKillAfterTimeout(options);
    const t = setTimeout(() => {
      kill("SIGKILL");
    }, timeout);
    if (t.unref) {
      t.unref();
    }
  };
  var shouldForceKill = (signal, { forceKillAfterTimeout }, killResult) => isSigterm(signal) && forceKillAfterTimeout !== false && killResult;
  var isSigterm = (signal) => signal === import_node_os6.default.constants.signals.SIGTERM || typeof signal === "string" && signal.toUpperCase() === "SIGTERM";
  var getForceKillAfterTimeout = ({ forceKillAfterTimeout = true }) => {
    if (forceKillAfterTimeout === true) {
      return DEFAULT_FORCE_KILL_TIMEOUT;
    }
    if (!Number.isFinite(forceKillAfterTimeout) || forceKillAfterTimeout < 0) {
      throw new TypeError(`Expected the \`forceKillAfterTimeout\` option to be a non-negative integer, got \`${forceKillAfterTimeout}\` (${typeof forceKillAfterTimeout})`);
    }
    return forceKillAfterTimeout;
  };
  var spawnedCancel = (spawned, context2) => {
    const killResult = spawned.kill();
    if (killResult) {
      context2.isCanceled = true;
    }
  };
  var timeoutKill = (spawned, signal, reject) => {
    spawned.kill(signal);
    reject(Object.assign(new Error("Timed out"), { timedOut: true, signal }));
  };
  var setupTimeout = (spawned, { timeout, killSignal = "SIGTERM" }, spawnedPromise) => {
    if (timeout === 0 || timeout === void 0) {
      return spawnedPromise;
    }
    let timeoutId;
    const timeoutPromise = new Promise((resolve, reject) => {
      timeoutId = setTimeout(() => {
        timeoutKill(spawned, killSignal, reject);
      }, timeout);
    });
    const safeSpawnedPromise = spawnedPromise.finally(() => {
      clearTimeout(timeoutId);
    });
    return Promise.race([timeoutPromise, safeSpawnedPromise]);
  };
  var validateTimeout = ({ timeout }) => {
    if (timeout !== void 0 && (!Number.isFinite(timeout) || timeout < 0)) {
      throw new TypeError(`Expected the \`timeout\` option to be a non-negative integer, got \`${timeout}\` (${typeof timeout})`);
    }
  };
  var setExitHandler = async (spawned, { cleanup, detached }, timedPromise) => {
    if (!cleanup || detached) {
      return timedPromise;
    }
    const removeExitHandler = (0, import_signal_exit.default)(() => {
      spawned.kill();
    });
    return timedPromise.finally(() => {
      removeExitHandler();
    });
  };

  // node_modules/.pnpm/execa@7.1.1/node_modules/execa/lib/pipe.js
  var import_node_fs = __require("node:fs");
  var import_node_child_process = __require("node:child_process");

  // node_modules/.pnpm/is-stream@3.0.0/node_modules/is-stream/index.js
  function isStream(stream) {
    return stream !== null && typeof stream === "object" && typeof stream.pipe === "function";
  }
  function isWritableStream(stream) {
    return isStream(stream) && stream.writable !== false && typeof stream._write === "function" && typeof stream._writableState === "object";
  }

  // node_modules/.pnpm/execa@7.1.1/node_modules/execa/lib/pipe.js
  var isExecaChildProcess = (target) => target instanceof import_node_child_process.ChildProcess && typeof target.then === "function";
  var pipeToTarget = (spawned, streamName, target) => {
    if (typeof target === "string") {
      spawned[streamName].pipe((0, import_node_fs.createWriteStream)(target));
      return spawned;
    }
    if (isWritableStream(target)) {
      spawned[streamName].pipe(target);
      return spawned;
    }
    if (!isExecaChildProcess(target)) {
      throw new TypeError("The second argument must be a string, a stream or an Execa child process.");
    }
    if (!isWritableStream(target.stdin)) {
      throw new TypeError("The target child process's stdin must be available.");
    }
    spawned[streamName].pipe(target.stdin);
    return target;
  };
  var addPipeMethods = (spawned) => {
    if (spawned.stdout !== null) {
      spawned.pipeStdout = pipeToTarget.bind(void 0, spawned, "stdout");
    }
    if (spawned.stderr !== null) {
      spawned.pipeStderr = pipeToTarget.bind(void 0, spawned, "stderr");
    }
    if (spawned.all !== void 0) {
      spawned.pipeAll = pipeToTarget.bind(void 0, spawned, "all");
    }
  };

  // node_modules/.pnpm/execa@7.1.1/node_modules/execa/lib/stream.js
  var import_node_fs2 = __require("node:fs");
  var import_get_stream = __toESM(require_get_stream(), 1);
  var import_merge_stream = __toESM(require_merge_stream(), 1);
  var validateInputOptions = (input) => {
    if (input !== void 0) {
      throw new TypeError("The `input` and `inputFile` options cannot be both set.");
    }
  };
  var getInputSync = ({ input, inputFile }) => {
    if (typeof inputFile !== "string") {
      return input;
    }
    validateInputOptions(input);
    return (0, import_node_fs2.readFileSync)(inputFile);
  };
  var handleInputSync = (options) => {
    const input = getInputSync(options);
    if (isStream(input)) {
      throw new TypeError("The `input` option cannot be a stream in sync mode");
    }
    return input;
  };
  var getInput = ({ input, inputFile }) => {
    if (typeof inputFile !== "string") {
      return input;
    }
    validateInputOptions(input);
    return (0, import_node_fs2.createReadStream)(inputFile);
  };
  var handleInput = (spawned, options) => {
    const input = getInput(options);
    if (input === void 0) {
      return;
    }
    if (isStream(input)) {
      input.pipe(spawned.stdin);
    } else {
      spawned.stdin.end(input);
    }
  };
  var makeAllStream = (spawned, { all }) => {
    if (!all || !spawned.stdout && !spawned.stderr) {
      return;
    }
    const mixed = (0, import_merge_stream.default)();
    if (spawned.stdout) {
      mixed.add(spawned.stdout);
    }
    if (spawned.stderr) {
      mixed.add(spawned.stderr);
    }
    return mixed;
  };
  var getBufferedData = async (stream, streamPromise) => {
    if (!stream || streamPromise === void 0) {
      return;
    }
    stream.destroy();
    try {
      return await streamPromise;
    } catch (error) {
      return error.bufferedData;
    }
  };
  var getStreamPromise = (stream, { encoding, buffer, maxBuffer }) => {
    if (!stream || !buffer) {
      return;
    }
    if (encoding) {
      return (0, import_get_stream.default)(stream, { encoding, maxBuffer });
    }
    return import_get_stream.default.buffer(stream, { maxBuffer });
  };
  var getSpawnedResult = async ({ stdout, stderr, all }, { encoding, buffer, maxBuffer }, processDone) => {
    const stdoutPromise = getStreamPromise(stdout, { encoding, buffer, maxBuffer });
    const stderrPromise = getStreamPromise(stderr, { encoding, buffer, maxBuffer });
    const allPromise = getStreamPromise(all, { encoding, buffer, maxBuffer: maxBuffer * 2 });
    try {
      return await Promise.all([processDone, stdoutPromise, stderrPromise, allPromise]);
    } catch (error) {
      return Promise.all([
        { error, signal: error.signal, timedOut: error.timedOut },
        getBufferedData(stdout, stdoutPromise),
        getBufferedData(stderr, stderrPromise),
        getBufferedData(all, allPromise)
      ]);
    }
  };

  // node_modules/.pnpm/execa@7.1.1/node_modules/execa/lib/promise.js
  var nativePromisePrototype = (/* @__PURE__ */ (async () => {
  })()).constructor.prototype;
  var descriptors = ["then", "catch", "finally"].map((property) => [
    property,
    Reflect.getOwnPropertyDescriptor(nativePromisePrototype, property)
  ]);
  var mergePromise = (spawned, promise) => {
    for (const [property, descriptor] of descriptors) {
      const value = typeof promise === "function" ? (...args2) => Reflect.apply(descriptor.value, promise(), args2) : descriptor.value.bind(promise);
      Reflect.defineProperty(spawned, property, { ...descriptor, value });
    }
  };
  var getSpawnedPromise = (spawned) => new Promise((resolve, reject) => {
    spawned.on("exit", (exitCode, signal) => {
      resolve({ exitCode, signal });
    });
    spawned.on("error", (error) => {
      reject(error);
    });
    if (spawned.stdin) {
      spawned.stdin.on("error", (error) => {
        reject(error);
      });
    }
  });

  // node_modules/.pnpm/execa@7.1.1/node_modules/execa/lib/command.js
  var import_node_buffer = __require("node:buffer");
  var import_node_child_process2 = __require("node:child_process");
  var normalizeArgs = (file, args2 = []) => {
    if (!Array.isArray(args2)) {
      return [file];
    }
    return [file, ...args2];
  };
  var NO_ESCAPE_REGEXP = /^[\w.-]+$/;
  var DOUBLE_QUOTES_REGEXP = /"/g;
  var escapeArg = (arg) => {
    if (typeof arg !== "string" || NO_ESCAPE_REGEXP.test(arg)) {
      return arg;
    }
    return `"${arg.replace(DOUBLE_QUOTES_REGEXP, '\\"')}"`;
  };
  var joinCommand = (file, args2) => normalizeArgs(file, args2).join(" ");
  var getEscapedCommand = (file, args2) => normalizeArgs(file, args2).map((arg) => escapeArg(arg)).join(" ");
  var SPACES_REGEXP = / +/g;
  var parseExpression = (expression) => {
    const typeOfExpression = typeof expression;
    if (typeOfExpression === "string") {
      return expression;
    }
    if (typeOfExpression === "number") {
      return String(expression);
    }
    if (typeOfExpression === "object" && expression !== null && !(expression instanceof import_node_child_process2.ChildProcess) && "stdout" in expression) {
      const typeOfStdout = typeof expression.stdout;
      if (typeOfStdout === "string") {
        return expression.stdout;
      }
      if (import_node_buffer.Buffer.isBuffer(expression.stdout)) {
        return expression.stdout.toString();
      }
      throw new TypeError(`Unexpected "${typeOfStdout}" stdout in template expression`);
    }
    throw new TypeError(`Unexpected "${typeOfExpression}" in template expression`);
  };
  var concatTokens = (tokens, nextTokens, isNew) => isNew || tokens.length === 0 || nextTokens.length === 0 ? [...tokens, ...nextTokens] : [
    ...tokens.slice(0, -1),
    `${tokens[tokens.length - 1]}${nextTokens[0]}`,
    ...nextTokens.slice(1)
  ];
  var parseTemplate = ({ templates, expressions, tokens, index, template }) => {
    const templateString = template ?? templates.raw[index];
    const templateTokens = templateString.split(SPACES_REGEXP).filter(Boolean);
    const newTokens = concatTokens(
      tokens,
      templateTokens,
      templateString.startsWith(" ")
    );
    if (index === expressions.length) {
      return newTokens;
    }
    const expression = expressions[index];
    const expressionTokens = Array.isArray(expression) ? expression.map((expression2) => parseExpression(expression2)) : [parseExpression(expression)];
    return concatTokens(
      newTokens,
      expressionTokens,
      templateString.endsWith(" ")
    );
  };
  var parseTemplates = (templates, expressions) => {
    let tokens = [];
    for (const [index, template] of templates.entries()) {
      tokens = parseTemplate({ templates, expressions, tokens, index, template });
    }
    return tokens;
  };

  // node_modules/.pnpm/execa@7.1.1/node_modules/execa/lib/verbose.js
  var import_node_util = __require("node:util");
  var import_node_process4 = __toESM(__require("node:process"), 1);
  var verboseDefault = (0, import_node_util.debuglog)("execa").enabled;
  var padField = (field, padding) => String(field).padStart(padding, "0");
  var getTimestamp = () => {
    const date = /* @__PURE__ */ new Date();
    return `${padField(date.getHours(), 2)}:${padField(date.getMinutes(), 2)}:${padField(date.getSeconds(), 2)}.${padField(date.getMilliseconds(), 3)}`;
  };
  var logCommand = (escapedCommand, { verbose }) => {
    if (!verbose) {
      return;
    }
    import_node_process4.default.stderr.write(`[${getTimestamp()}] ${escapedCommand}
`);
  };

  // node_modules/.pnpm/execa@7.1.1/node_modules/execa/index.js
  var DEFAULT_MAX_BUFFER = 1e3 * 1e3 * 100;
  var getEnv = ({ env: envOption, extendEnv, preferLocal, localDir, execPath }) => {
    const env3 = extendEnv ? { ...import_node_process5.default.env, ...envOption } : envOption;
    if (preferLocal) {
      return npmRunPathEnv({ env: env3, cwd: localDir, execPath });
    }
    return env3;
  };
  var handleArguments = (file, args2, options = {}) => {
    const parsed = import_cross_spawn.default._parse(file, args2, options);
    file = parsed.command;
    args2 = parsed.args;
    options = parsed.options;
    options = {
      maxBuffer: DEFAULT_MAX_BUFFER,
      buffer: true,
      stripFinalNewline: true,
      extendEnv: true,
      preferLocal: false,
      localDir: options.cwd || import_node_process5.default.cwd(),
      execPath: import_node_process5.default.execPath,
      encoding: "utf8",
      reject: true,
      cleanup: true,
      all: false,
      windowsHide: true,
      verbose: verboseDefault,
      ...options
    };
    options.env = getEnv(options);
    options.stdio = normalizeStdio(options);
    if (import_node_process5.default.platform === "win32" && import_node_path2.default.basename(file, ".exe") === "cmd") {
      args2.unshift("/q");
    }
    return { file, args: args2, options, parsed };
  };
  var handleOutput = (options, value, error) => {
    if (typeof value !== "string" && !import_node_buffer2.Buffer.isBuffer(value)) {
      return error === void 0 ? void 0 : "";
    }
    if (options.stripFinalNewline) {
      return stripFinalNewline(value);
    }
    return value;
  };
  function execa(file, args2, options) {
    const parsed = handleArguments(file, args2, options);
    const command = joinCommand(file, args2);
    const escapedCommand = getEscapedCommand(file, args2);
    logCommand(escapedCommand, parsed.options);
    validateTimeout(parsed.options);
    let spawned;
    try {
      spawned = import_node_child_process3.default.spawn(parsed.file, parsed.args, parsed.options);
    } catch (error) {
      const dummySpawned = new import_node_child_process3.default.ChildProcess();
      const errorPromise = Promise.reject(makeError({
        error,
        stdout: "",
        stderr: "",
        all: "",
        command,
        escapedCommand,
        parsed,
        timedOut: false,
        isCanceled: false,
        killed: false
      }));
      mergePromise(dummySpawned, errorPromise);
      return dummySpawned;
    }
    const spawnedPromise = getSpawnedPromise(spawned);
    const timedPromise = setupTimeout(spawned, parsed.options, spawnedPromise);
    const processDone = setExitHandler(spawned, parsed.options, timedPromise);
    const context2 = { isCanceled: false };
    spawned.kill = spawnedKill.bind(null, spawned.kill.bind(spawned));
    spawned.cancel = spawnedCancel.bind(null, spawned, context2);
    const handlePromise = async () => {
      const [{ error, exitCode, signal, timedOut }, stdoutResult, stderrResult, allResult] = await getSpawnedResult(spawned, parsed.options, processDone);
      const stdout = handleOutput(parsed.options, stdoutResult);
      const stderr = handleOutput(parsed.options, stderrResult);
      const all = handleOutput(parsed.options, allResult);
      if (error || exitCode !== 0 || signal !== null) {
        const returnedError = makeError({
          error,
          exitCode,
          signal,
          stdout,
          stderr,
          all,
          command,
          escapedCommand,
          parsed,
          timedOut,
          isCanceled: context2.isCanceled || (parsed.options.signal ? parsed.options.signal.aborted : false),
          killed: spawned.killed
        });
        if (!parsed.options.reject) {
          return returnedError;
        }
        throw returnedError;
      }
      return {
        command,
        escapedCommand,
        exitCode: 0,
        stdout,
        stderr,
        all,
        failed: false,
        timedOut: false,
        isCanceled: false,
        killed: false
      };
    };
    const handlePromiseOnce = onetime_default(handlePromise);
    handleInput(spawned, parsed.options);
    spawned.all = makeAllStream(spawned, parsed.options);
    addPipeMethods(spawned);
    mergePromise(spawned, handlePromiseOnce);
    return spawned;
  }
  function execaSync(file, args2, options) {
    const parsed = handleArguments(file, args2, options);
    const command = joinCommand(file, args2);
    const escapedCommand = getEscapedCommand(file, args2);
    logCommand(escapedCommand, parsed.options);
    const input = handleInputSync(parsed.options);
    let result;
    try {
      result = import_node_child_process3.default.spawnSync(parsed.file, parsed.args, { ...parsed.options, input });
    } catch (error) {
      throw makeError({
        error,
        stdout: "",
        stderr: "",
        all: "",
        command,
        escapedCommand,
        parsed,
        timedOut: false,
        isCanceled: false,
        killed: false
      });
    }
    const stdout = handleOutput(parsed.options, result.stdout, result.error);
    const stderr = handleOutput(parsed.options, result.stderr, result.error);
    if (result.error || result.status !== 0 || result.signal !== null) {
      const error = makeError({
        stdout,
        stderr,
        error: result.error,
        signal: result.signal,
        exitCode: result.status,
        command,
        escapedCommand,
        parsed,
        timedOut: result.error && result.error.code === "ETIMEDOUT",
        isCanceled: false,
        killed: result.signal !== null
      });
      if (!parsed.options.reject) {
        return error;
      }
      throw error;
    }
    return {
      command,
      escapedCommand,
      exitCode: 0,
      stdout,
      stderr,
      failed: false,
      timedOut: false,
      isCanceled: false,
      killed: false
    };
  }
  var normalizeScriptStdin = ({ input, inputFile, stdio }) => input === void 0 && inputFile === void 0 && stdio === void 0 ? { stdin: "inherit" } : {};
  var normalizeScriptOptions = (options = {}) => ({
    preferLocal: true,
    ...normalizeScriptStdin(options),
    ...options
  });
  function create$(options) {
    function $2(templatesOrOptions, ...expressions) {
      if (!Array.isArray(templatesOrOptions)) {
        return create$({ ...options, ...templatesOrOptions });
      }
      const [file, ...args2] = parseTemplates(templatesOrOptions, expressions);
      return execa(file, args2, normalizeScriptOptions(options));
    }
    $2.sync = (templates, ...expressions) => {
      if (!Array.isArray(templates)) {
        throw new TypeError("Please use $(options).sync`command` instead of $.sync(options)`command`.");
      }
      const [file, ...args2] = parseTemplates(templates, expressions);
      return execaSync(file, args2, normalizeScriptOptions(options));
    };
    return $2;
  }
  var $ = create$();

  // pkgs/base/src/commit-hook.ts
  var commitHook = async (args2) => {
    const isMainRepo = async () => {
      const conf = await (0, import_fs_jetpack20.readAsync)(dir.root(".git/config"), "utf8");
      if (conf?.includes("url = https://github.com/avolut/royal")) {
        return true;
      }
      return false;
    };
    if (args2.includes("pre-commit")) {
      if (await isMainRepo()) {
        if (!await (0, import_fs_jetpack20.existsAsync)(dir.root(".husky/_/husky.sh"))) {
          await $`pnpm husky install`;
        }
        await (0, import_fs_jetpack20.writeAsync)(dir.root(".output/.commit"), "");
      }
      process.exit(1);
      return true;
    }
    if (args2.includes("post-commit")) {
      if (await isMainRepo()) {
        if (await (0, import_fs_jetpack20.existsAsync)(dir.root(".output/.commit"))) {
          await (0, import_fs_jetpack20.removeAsync)(dir.root(".output/.commit"));
          await (0, import_fs_jetpack20.writeAsync)(dir.root("pkgs/version.json"), { ts: Date.now() });
          await $`git add .pkgs/version.json`;
          await $`git commit --ammend -C HEAD --no-verify`;
        }
      }
      process.exit(1);
      return true;
    }
    return false;
  };

  // pkgs/base/src/scaffold/app.ts
  init_export();
  var import_fs5 = __require("fs");
  var import_fs_jetpack22 = __toESM(require_main());

  // pkgs/base/src/appgen/service.ts
  init_export();
  var import_fs_jetpack21 = __toESM(require_main());
  var import_promises5 = __require("fs/promises");
  var serviceGen = async () => {
    const names = [];
    const actions = [];
    for (const f of await (0, import_promises5.readdir)(dir.root("app"))) {
      const s = await (0, import_promises5.stat)(dir.root(`app/${f}`));
      if (s.isDirectory() && await (0, import_fs_jetpack21.existsAsync)(dir.root(`app/${f}/main.ts`))) {
        names.push(f);
        if (f.startsWith("web") || f.startsWith("db") || f.startsWith("srv")) {
          actions.push({ type: "single", name: f });
        } else {
          const src = await (0, import_fs_jetpack21.readAsync)(dir.root(`app/${f}/main.ts`), "utf8");
          if (src) {
            await traverse(src, (parent) => ({
              visitObjectExpression(n) {
                for (const p of n.properties) {
                  if (p.type === "KeyValueProperty" && p.key.type === "Identifier" && p.key.value === "mode" && p.value.type === "StringLiteral") {
                    actions.push({ type: p.value.value, name: f });
                  }
                }
                return parent.visitObjectExpression(n);
              }
            }));
          }
        }
      }
    }
    await (0, import_fs_jetpack21.writeAsync)(
      dir.root(`app/gen/service/actions.d.ts`),
      `${actions.map((e) => {
        return `import { main as ${e.name}_action } from "../../${e.name}/main";`;
      }).join("\n")}

export type actions = {
${actions.map((e) => {
        return `  ${e.name}: {
    type: "${e.type}";
    action: Awaited<typeof ${e.name}_action>;
  };`;
      }).join("\n")}
}
`
    );
    await (0, import_fs_jetpack21.writeAsync)(
      dir.root(`app/gen/service/name.ts`),
      `export type SERVICE_NAME = "${names.join(`" | "`)}";`
    );
  };

  // pkgs/base/src/scaffold/app.ts
  var prepareApp = async () => {
    await (0, import_fs_jetpack22.writeAsync)(
      dir.path(".output/app/pnpm-workspace.yaml"),
      `packages:
  - ./*`
    );
    const dirs = (0, import_fs5.readdirSync)(dir.path("app")).filter(
      (e) => !["node_modules", "app.ts", "package.json", "gen"].includes(e)
    ).map((e) => ({ name: e, stat: (0, import_fs5.statSync)(dir.path(`app/${e}`)) })).filter(
      ({ stat: stat6, name }) => stat6.isDirectory() && (0, import_fs5.existsSync)(dir.path(`app/${name}/main.ts`))
    );
    await serviceGen();
    return {
      input: dir.root("app/app.ts"),
      output: dir.root(".output/app/app.js"),
      cwd: dir.root(".output/app"),
      serviceNames: dirs.map((e) => e.name)
    };
  };

  // pkgs/base/src/upgrade.ts
  var import_child_process4 = __require("child_process");
  init_export();

  // node_modules/.pnpm/fflate@0.8.0/node_modules/fflate/esm/index.mjs
  var import_module = __require("module");
  var require2 = (0, import_module.createRequire)("/");
  var Worker;
  try {
    Worker = require2("worker_threads").Worker;
  } catch (e) {
  }
  var u8 = Uint8Array;
  var u16 = Uint16Array;
  var i32 = Int32Array;
  var fleb = new u8([
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    1,
    1,
    1,
    1,
    2,
    2,
    2,
    2,
    3,
    3,
    3,
    3,
    4,
    4,
    4,
    4,
    5,
    5,
    5,
    5,
    0,
    /* unused */
    0,
    0,
    /* impossible */
    0
  ]);
  var fdeb = new u8([
    0,
    0,
    0,
    0,
    1,
    1,
    2,
    2,
    3,
    3,
    4,
    4,
    5,
    5,
    6,
    6,
    7,
    7,
    8,
    8,
    9,
    9,
    10,
    10,
    11,
    11,
    12,
    12,
    13,
    13,
    /* unused */
    0,
    0
  ]);
  var clim = new u8([16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15]);
  var freb = function(eb, start) {
    var b = new u16(31);
    for (var i = 0; i < 31; ++i) {
      b[i] = start += 1 << eb[i - 1];
    }
    var r = new i32(b[30]);
    for (var i = 1; i < 30; ++i) {
      for (var j = b[i]; j < b[i + 1]; ++j) {
        r[j] = j - b[i] << 5 | i;
      }
    }
    return { b, r };
  };
  var _a = freb(fleb, 2);
  var fl = _a.b;
  var revfl = _a.r;
  fl[28] = 258, revfl[258] = 28;
  var _b = freb(fdeb, 0);
  var fd = _b.b;
  var revfd = _b.r;
  var rev = new u16(32768);
  for (i = 0; i < 32768; ++i) {
    x = (i & 43690) >> 1 | (i & 21845) << 1;
    x = (x & 52428) >> 2 | (x & 13107) << 2;
    x = (x & 61680) >> 4 | (x & 3855) << 4;
    rev[i] = ((x & 65280) >> 8 | (x & 255) << 8) >> 1;
  }
  var x;
  var i;
  var hMap = function(cd, mb, r) {
    var s = cd.length;
    var i = 0;
    var l = new u16(mb);
    for (; i < s; ++i) {
      if (cd[i])
        ++l[cd[i] - 1];
    }
    var le = new u16(mb);
    for (i = 1; i < mb; ++i) {
      le[i] = le[i - 1] + l[i - 1] << 1;
    }
    var co;
    if (r) {
      co = new u16(1 << mb);
      var rvb = 15 - mb;
      for (i = 0; i < s; ++i) {
        if (cd[i]) {
          var sv = i << 4 | cd[i];
          var r_1 = mb - cd[i];
          var v = le[cd[i] - 1]++ << r_1;
          for (var m = v | (1 << r_1) - 1; v <= m; ++v) {
            co[rev[v] >> rvb] = sv;
          }
        }
      }
    } else {
      co = new u16(s);
      for (i = 0; i < s; ++i) {
        if (cd[i]) {
          co[i] = rev[le[cd[i] - 1]++] >> 15 - cd[i];
        }
      }
    }
    return co;
  };
  var flt = new u8(288);
  for (i = 0; i < 144; ++i)
    flt[i] = 8;
  var i;
  for (i = 144; i < 256; ++i)
    flt[i] = 9;
  var i;
  for (i = 256; i < 280; ++i)
    flt[i] = 7;
  var i;
  for (i = 280; i < 288; ++i)
    flt[i] = 8;
  var i;
  var fdt = new u8(32);
  for (i = 0; i < 32; ++i)
    fdt[i] = 5;
  var i;
  var flrm = /* @__PURE__ */ hMap(flt, 9, 1);
  var fdrm = /* @__PURE__ */ hMap(fdt, 5, 1);
  var max = function(a) {
    var m = a[0];
    for (var i = 1; i < a.length; ++i) {
      if (a[i] > m)
        m = a[i];
    }
    return m;
  };
  var bits = function(d, p, m) {
    var o = p / 8 | 0;
    return (d[o] | d[o + 1] << 8) >> (p & 7) & m;
  };
  var bits16 = function(d, p) {
    var o = p / 8 | 0;
    return (d[o] | d[o + 1] << 8 | d[o + 2] << 16) >> (p & 7);
  };
  var shft = function(p) {
    return (p + 7) / 8 | 0;
  };
  var slc = function(v, s, e) {
    if (s == null || s < 0)
      s = 0;
    if (e == null || e > v.length)
      e = v.length;
    var n = new u8(e - s);
    n.set(v.subarray(s, e));
    return n;
  };
  var ec = [
    "unexpected EOF",
    "invalid block type",
    "invalid length/literal",
    "invalid distance",
    "stream finished",
    "no stream handler",
    ,
    "no callback",
    "invalid UTF-8 data",
    "extra field too long",
    "date not in range 1980-2099",
    "filename too long",
    "stream finishing",
    "invalid zip data"
    // determined by unknown compression method
  ];
  var err = function(ind, msg, nt) {
    var e = new Error(msg || ec[ind]);
    e.code = ind;
    if (Error.captureStackTrace)
      Error.captureStackTrace(e, err);
    if (!nt)
      throw e;
    return e;
  };
  var inflt = function(dat, st, buf, dict) {
    var sl = dat.length, dl = dict ? dict.length : 0;
    if (!sl || st.f && !st.l)
      return buf || new u8(0);
    var noBuf = !buf || st.i != 2;
    var noSt = st.i;
    if (!buf)
      buf = new u8(sl * 3);
    var cbuf = function(l2) {
      var bl = buf.length;
      if (l2 > bl) {
        var nbuf = new u8(Math.max(bl * 2, l2));
        nbuf.set(buf);
        buf = nbuf;
      }
    };
    var final = st.f || 0, pos = st.p || 0, bt = st.b || 0, lm = st.l, dm = st.d, lbt = st.m, dbt = st.n;
    var tbts = sl * 8;
    do {
      if (!lm) {
        final = bits(dat, pos, 1);
        var type = bits(dat, pos + 1, 3);
        pos += 3;
        if (!type) {
          var s = shft(pos) + 4, l = dat[s - 4] | dat[s - 3] << 8, t = s + l;
          if (t > sl) {
            if (noSt)
              err(0);
            break;
          }
          if (noBuf)
            cbuf(bt + l);
          buf.set(dat.subarray(s, t), bt);
          st.b = bt += l, st.p = pos = t * 8, st.f = final;
          continue;
        } else if (type == 1)
          lm = flrm, dm = fdrm, lbt = 9, dbt = 5;
        else if (type == 2) {
          var hLit = bits(dat, pos, 31) + 257, hcLen = bits(dat, pos + 10, 15) + 4;
          var tl = hLit + bits(dat, pos + 5, 31) + 1;
          pos += 14;
          var ldt = new u8(tl);
          var clt = new u8(19);
          for (var i = 0; i < hcLen; ++i) {
            clt[clim[i]] = bits(dat, pos + i * 3, 7);
          }
          pos += hcLen * 3;
          var clb = max(clt), clbmsk = (1 << clb) - 1;
          var clm = hMap(clt, clb, 1);
          for (var i = 0; i < tl; ) {
            var r = clm[bits(dat, pos, clbmsk)];
            pos += r & 15;
            var s = r >> 4;
            if (s < 16) {
              ldt[i++] = s;
            } else {
              var c = 0, n = 0;
              if (s == 16)
                n = 3 + bits(dat, pos, 3), pos += 2, c = ldt[i - 1];
              else if (s == 17)
                n = 3 + bits(dat, pos, 7), pos += 3;
              else if (s == 18)
                n = 11 + bits(dat, pos, 127), pos += 7;
              while (n--)
                ldt[i++] = c;
            }
          }
          var lt = ldt.subarray(0, hLit), dt = ldt.subarray(hLit);
          lbt = max(lt);
          dbt = max(dt);
          lm = hMap(lt, lbt, 1);
          dm = hMap(dt, dbt, 1);
        } else
          err(1);
        if (pos > tbts) {
          if (noSt)
            err(0);
          break;
        }
      }
      if (noBuf)
        cbuf(bt + 131072);
      var lms = (1 << lbt) - 1, dms = (1 << dbt) - 1;
      var lpos = pos;
      for (; ; lpos = pos) {
        var c = lm[bits16(dat, pos) & lms], sym = c >> 4;
        pos += c & 15;
        if (pos > tbts) {
          if (noSt)
            err(0);
          break;
        }
        if (!c)
          err(2);
        if (sym < 256)
          buf[bt++] = sym;
        else if (sym == 256) {
          lpos = pos, lm = null;
          break;
        } else {
          var add = sym - 254;
          if (sym > 264) {
            var i = sym - 257, b = fleb[i];
            add = bits(dat, pos, (1 << b) - 1) + fl[i];
            pos += b;
          }
          var d = dm[bits16(dat, pos) & dms], dsym = d >> 4;
          if (!d)
            err(3);
          pos += d & 15;
          var dt = fd[dsym];
          if (dsym > 3) {
            var b = fdeb[dsym];
            dt += bits16(dat, pos) & (1 << b) - 1, pos += b;
          }
          if (pos > tbts) {
            if (noSt)
              err(0);
            break;
          }
          if (noBuf)
            cbuf(bt + 131072);
          var end = bt + add;
          if (bt < dt) {
            var shift = dl - dt, dend = Math.min(dt, end);
            if (shift + bt < 0)
              err(3);
            for (; bt < dend; ++bt)
              buf[bt] = dict[shift + bt];
          }
          for (; bt < end; bt += 4) {
            buf[bt] = buf[bt - dt];
            buf[bt + 1] = buf[bt + 1 - dt];
            buf[bt + 2] = buf[bt + 2 - dt];
            buf[bt + 3] = buf[bt + 3 - dt];
          }
          bt = end;
        }
      }
      st.l = lm, st.p = lpos, st.b = bt, st.f = final;
      if (lm)
        final = 1, st.m = lbt, st.d = dm, st.n = dbt;
    } while (!final);
    return bt == buf.length ? buf : slc(buf, 0, bt);
  };
  var et = /* @__PURE__ */ new u8(0);
  var b2 = function(d, b) {
    return d[b] | d[b + 1] << 8;
  };
  var b4 = function(d, b) {
    return (d[b] | d[b + 1] << 8 | d[b + 2] << 16 | d[b + 3] << 24) >>> 0;
  };
  var b8 = function(d, b) {
    return b4(d, b) + b4(d, b + 4) * 4294967296;
  };
  function inflateSync(data, opts) {
    return inflt(data, { i: 2 }, opts && opts.out, opts && opts.dictionary);
  }
  var td = typeof TextDecoder != "undefined" && /* @__PURE__ */ new TextDecoder();
  var tds = 0;
  try {
    td.decode(et, { stream: true });
    tds = 1;
  } catch (e) {
  }
  var dutf8 = function(d) {
    for (var r = "", i = 0; ; ) {
      var c = d[i++];
      var eb = (c > 127) + (c > 223) + (c > 239);
      if (i + eb > d.length)
        return { s: r, r: slc(d, i - 1) };
      if (!eb)
        r += String.fromCharCode(c);
      else if (eb == 3) {
        c = ((c & 15) << 18 | (d[i++] & 63) << 12 | (d[i++] & 63) << 6 | d[i++] & 63) - 65536, r += String.fromCharCode(55296 | c >> 10, 56320 | c & 1023);
      } else if (eb & 1)
        r += String.fromCharCode((c & 31) << 6 | d[i++] & 63);
      else
        r += String.fromCharCode((c & 15) << 12 | (d[i++] & 63) << 6 | d[i++] & 63);
    }
  };
  function strFromU8(dat, latin1) {
    if (latin1) {
      var r = "";
      for (var i = 0; i < dat.length; i += 16384)
        r += String.fromCharCode.apply(null, dat.subarray(i, i + 16384));
      return r;
    } else if (td) {
      return td.decode(dat);
    } else {
      var _a2 = dutf8(dat), s = _a2.s, r = _a2.r;
      if (r.length)
        err(8);
      return s;
    }
  }
  var slzh = function(d, b) {
    return b + 30 + b2(d, b + 26) + b2(d, b + 28);
  };
  var zh = function(d, b, z) {
    var fnl = b2(d, b + 28), fn = strFromU8(d.subarray(b + 46, b + 46 + fnl), !(b2(d, b + 8) & 2048)), es = b + 46 + fnl, bs = b4(d, b + 20);
    var _a2 = z && bs == 4294967295 ? z64e(d, es) : [bs, b4(d, b + 24), b4(d, b + 42)], sc = _a2[0], su = _a2[1], off = _a2[2];
    return [b2(d, b + 10), sc, su, fn, es + b2(d, b + 30) + b2(d, b + 32), off];
  };
  var z64e = function(d, b) {
    for (; b2(d, b) != 1; b += 4 + b2(d, b + 2))
      ;
    return [b8(d, b + 12), b8(d, b + 4), b8(d, b + 20)];
  };
  function unzipSync(data, opts) {
    var files = {};
    var e = data.length - 22;
    for (; b4(data, e) != 101010256; --e) {
      if (!e || data.length - e > 65558)
        err(13);
    }
    ;
    var c = b2(data, e + 8);
    if (!c)
      return {};
    var o = b4(data, e + 16);
    var z = o == 4294967295 || c == 65535;
    if (z) {
      var ze = b4(data, e - 12);
      z = b4(data, ze) == 101075792;
      if (z) {
        c = b4(data, ze + 32);
        o = b4(data, ze + 48);
      }
    }
    var fltr = opts && opts.filter;
    for (var i = 0; i < c; ++i) {
      var _a2 = zh(data, o, z), c_2 = _a2[0], sc = _a2[1], su = _a2[2], fn = _a2[3], no = _a2[4], off = _a2[5], b = slzh(data, off);
      o = no;
      if (!fltr || fltr({
        name: fn,
        size: sc,
        originalSize: su,
        compression: c_2
      })) {
        if (!c_2)
          files[fn] = slc(data, b, b + sc);
        else if (c_2 == 8)
          files[fn] = inflateSync(data.subarray(b, b + sc), { out: new u8(su) });
        else
          err(14, "unknown compression type " + c_2);
      }
    }
    return files;
  }

  // pkgs/base/src/upgrade.ts
  var import_fs6 = __require("fs");
  var import_fs_jetpack23 = __toESM(require_main());
  var import_path16 = __require("path");
  var upgradeHook = async (args2) => {
    if (args2.includes("upgrade")) {
      const backupDir = dir.root(".output/upgrade/backup");
      await (0, import_fs_jetpack23.removeAsync)(dir.root(".output/upgrade"));
      await (0, import_fs_jetpack23.dirAsync)(backupDir);
      console.log(`Upgrading Base Framework`);
      console.log(` > Downloading upgrade zip`);
      const downloadURI = `https://github.com/avolut/royal/archive/refs/heads/main.zip`;
      const res = await fetch(downloadURI);
      const ab = await res.arrayBuffer();
      console.log(` > Extracting: .output/upgrade/royal`);
      const uzi = unzipSync(new Uint8Array(ab));
      await (0, import_fs_jetpack23.dirAsync)(dir.root(".output/upgrade/royal-main"));
      await Promise.all(
        Object.entries(uzi).map(async ([filename, buf]) => {
          if (buf.length === 0) {
            await (0, import_fs_jetpack23.dirAsync)(dir.root(`.output/upgrade/${filename}`));
          } else {
            await (0, import_fs_jetpack23.writeAsync)(
              dir.root(`.output/upgrade/${filename}`),
              Buffer.from(buf)
            );
          }
        })
      );
      console.log(` > Backing up existing pkgs to: .output/upgrade/backup`);
      const root = dir.root("");
      for (const f of (0, import_fs6.readdirSync)(dir.root(""))) {
        if (f !== "app" && f !== ".output" && f !== ".husky" && f !== ".git") {
          if (await (0, import_fs_jetpack23.existsAsync)((0, import_path16.join)(root, `.output/upgrade/backup/${f}`))) {
            await (0, import_fs_jetpack23.moveAsync)(
              (0, import_path16.join)(root, f),
              (0, import_path16.join)(root, `.output/upgrade/backup/${f}`)
            );
          }
        }
      }
      console.log(` > Applying upgrade`);
      for (const f of (0, import_fs6.readdirSync)((0, import_path16.join)(root, ".output/upgrade/royal-main"))) {
        if (f !== "app" && f !== ".output" && f !== "." && f !== ".." && f !== ".husky" && f !== ".git") {
          await (0, import_fs_jetpack23.copyAsync)(
            (0, import_path16.join)(root, `.output/upgrade/royal-main/${f}`),
            (0, import_path16.join)(root, f),
            {
              overwrite: true
            }
          );
        }
      }
      (0, import_child_process4.spawnSync)("pnpm", ["i"], { cwd: dir.root(""), stdio: "inherit" });
      if (process.send) {
        process.send("exit");
      } else {
        process.exit();
      }
      process.exit(1);
      return true;
    }
  };

  // pkgs/base/src/vscode.ts
  init_export();
  var import_fs_jetpack24 = __toESM(require_main());
  var import_path17 = __require("path");
  var vscodeSettings = async () => {
    const vscodeFile = dir.path(".vscode/settings.json");
    const source = JSON.stringify(defaultVsSettings, null, 2);
    if (await (0, import_fs_jetpack24.existsAsync)(vscodeFile)) {
      if (await (0, import_fs_jetpack24.readAsync)(vscodeFile, "utf8") === source) {
        return;
      }
    }
    await (0, import_fs_jetpack24.dirAsync)((0, import_path17.dirname)(vscodeFile));
    await (0, import_fs_jetpack24.writeAsync)(vscodeFile, source);
  };
  var defaultVsSettings = {
    "typescript.preferences.importModuleSpecifier": "relative",
    "search.exclude": {
      "app/gen/**": true
    },
    "typescript.updateImportsOnFileMove.enabled": "always",
    "files.exclude": {
      "**/.git": true,
      "**/.svn": true,
      "**/.hg": true,
      "**/CVS": true,
      "**/.DS_Store": true,
      "**/Thumbs.db": true,
      "**/bun.lockb": true,
      "**/go.sum": true,
      ".output/.cache": true,
      ".devcontainer.json": true,
      ".hintrc": true,
      "pre-commit": true,
      "post-commit": true,
      ".node-version": true,
      "pkgs/base/main.js": true,
      "pkgs/base/main.js.map": true,
      "**/.parcelrc": true,
      "**/pnpm-lock.yaml": true,
      "**/.gitignore": true,
      "**/.npmrc": true,
      "**/.postcssrc": true,
      "**/pnpm-workspace.yaml": true,
      "**/.vscode": true,
      "**/build": true,
      "**/node_modules": true,
      "**/.htmlnanorc": true,
      "**/.parcel-cache": true,
      ".fleet": true,
      ".vscode": true,
      ".husky": true,
      "app/gen": true
    },
    "hide-files.files": []
  };

  // pkgs/base/src/watcher/new-service.ts
  init_export();
  var import_fs_jetpack25 = __toESM(require_main());
  var import_promises6 = __require("fs/promises");
  var import_path18 = __require("path");
  var watchNewService = () => {
    watcher.watch({
      dir: dir.root("app"),
      depth: 1,
      event: async (err2, changes) => {
        if (!err2) {
          for (const c of changes) {
            const name = (0, import_path18.basename)(c.path);
            if (name === "app.ts") {
              process.exit(99);
              return;
            }
            if (c.type === "delete") {
              console.log(`Removing service: ${source_default.red(name)}`);
              await (0, import_fs_jetpack25.removeAsync)(dir.root(`.output/app/${name}`));
              await serviceGen();
              process.exit(99);
            } else if (c.type === "create") {
              const s = await (0, import_promises6.stat)(c.path);
              if (s.isDirectory() && (await (0, import_promises6.readdir)(c.path)).length === 0) {
                console.log(`Scaffolding new service: ${source_default.blue(name)}`);
                let root = "pkgs/template/pkgs/service";
                if (name.startsWith("db")) {
                  root = "pkgs/template/pkgs/db";
                } else if (name.startsWith("srv")) {
                  root = "pkgs/template/pkgs/srv";
                }
                const files = await (0, import_promises6.readdir)(dir.root(root));
                for (const f of files) {
                  if (f !== "node_modules") {
                    const fpath = dir.root(`${root}/${f}`);
                    const s2 = await (0, import_promises6.stat)(fpath);
                    if (s2.isDirectory()) {
                      await (0, import_fs_jetpack25.copyAsync)(fpath, (0, import_path18.join)(c.path, f), {
                        overwrite: true
                      });
                    } else {
                      const src = await (0, import_fs_jetpack25.readAsync)(fpath, "utf8");
                      await (0, import_fs_jetpack25.writeAsync)(
                        (0, import_path18.join)(c.path, f),
                        (src || "").replace(/template_service/g, name)
                      );
                    }
                  }
                }
                await serviceGen();
                await pkg.install(dir.root(`app/${name}`), {
                  cwd: dir.root(`app/${name}`),
                  silent: true
                });
                process.exit(99);
              }
            }
          }
        }
      }
    });
  };

  // pkgs/base/src/main.ts
  var g3 = global;
  var args = process.argv.slice(2);
  var baseMain = async () => {
    process.removeAllListeners("warning");
    attachCleanUp();
    vscodeSettings();
    await pkg.install(dir.root(), {
      deep: { exclude: [dir.root(".output"), dir.root("pkgs/template")] }
    });
    if (await commitHook(args))
      return;
    if (await upgradeHook(args))
      return;
    if (args.includes("clean")) {
      console.log("Cleaning node_modules");
      const dirs = await scanDir([dir.root()]);
      await (0, import_fs_jetpack26.removeAsync)(dir.root(".output"));
      await Promise.all(
        dirs.map((e) => (0, import_fs_jetpack26.removeAsync)((0, import_path19.join)((0, import_path19.dirname)(e), "node_modules")))
      );
      await (0, import_fs_jetpack26.removeAsync)(dir.root("node_modules"));
      return;
    }
    console.log(`\u2500\u2500 ${(0, import_lodash6.default)(source_default.yellow(`BASE`) + " ", 47, "\u2500")}`);
    baseGlobal.parcels = /* @__PURE__ */ new Set();
    await createRPC("base", action, { isMain: true });
    if (args.includes("build") || args.includes("deploy") || args.includes("prod") || args.includes("staging")) {
      await (0, import_fs_jetpack26.removeAsync)(dir.root(`.output/app`));
      const app = await prepareApp();
      baseGlobal.app = app;
      baseGlobal.mode = "prod";
      if (args.includes("staging")) {
        baseGlobal.mode = "staging";
      }
      await buildMainApp(app);
      await Promise.all(app.serviceNames.map(async (e) => await prepareBuild(e)));
      await Promise.all(
        app.serviceNames.map(
          async (e) => await buildServiceMain(e, { watch: false })
        )
      );
      if (g3.afterBuild) {
        await g3.afterBuild();
      }
      await Promise.all(app.serviceNames.map(async (e) => await postRun(e)));
      await (0, import_fs_jetpack26.writeAsync)(dir.root(`.output/app/${baseGlobal.mode}`), "");
      console.log(`
Build done: ${source_default.green(`.output/app`)}`);
      process.exit(1);
    } else {
      baseGlobal.mode = "dev";
      await (0, import_fs_jetpack26.removeAsync)(dir.root(`.output/app/prod`));
      await (0, import_fs_jetpack26.removeAsync)(dir.root(`.output/app/staging`));
      connectRPC("root", {
        waitConnection: true
      }).then((e) => {
        if (process.send)
          process.send("base-restartable");
        baseGlobal.rpc = {
          service: e
        };
      });
      const app = await prepareApp();
      baseGlobal.app = app;
      watchNewService();
      await buildMainApp(app);
      await Promise.all(app.serviceNames.map(async (e) => await prepareBuild(e)));
      await Promise.all(
        app.serviceNames.map(
          async (e) => await buildServiceMain(e, { watch: true })
        )
      );
      if (g3.afterBuild) {
        await g3.afterBuild();
      }
      await runner.run({
        path: app.output,
        cwd: app.cwd
      });
      await Promise.all(app.serviceNames.map(async (e) => await postRun(e)));
      await new Promise(() => {
      });
    }
  };
  baseMain();
})();
/*! Bundled license information:

@noble/hashes/utils.js:
  (*! noble-hashes - MIT License (c) 2022 Paul Miller (paulmillr.com) *)
*/
//# sourceMappingURL=main.js.map
